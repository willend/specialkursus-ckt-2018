/* Automatically generated file. Do not edit. 
 * Format:     ANSI C source code
 * Creator:    McStas <http://www.mcstas.org>
 * Instrument: BIFROST.instr (BIFROST)
 * Date:       Mon Oct 01 14:32:15 2018
 * File:       BIFROST.c
 * Compile:    cc -o BIFROST.exe BIFROST.c 
 * CFLAGS=
 */


#define MCCODE_STRING "McStas 2.4.1 - Jun. 26, 2017"
#define FLAVOR "mcstas"
#define FLAVOR_UPPER "MCSTAS"
#define MC_USE_DEFAULT_MAIN
#define MC_TRACE_ENABLED
#define MC_EMBEDDED_RUNTIME

#line 1 "mccode-r.h"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas 2.4.1
* Version: $Revision$
*
* Runtime system header for McStas/McXtrace.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas/McXtrace version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCCODE_R_H
#define MCCODE_R_H "$Revision$"

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <time.h>
#include <float.h>
#include <inttypes.h>

/* If the runtime is embedded in the simulation program, some definitions can
   be made static. */

#ifdef MC_EMBEDDED_RUNTIME
#define mcstatic static
#else
#define mcstatic
#endif

#ifdef __dest_os
#if (__dest_os == __mac_os)
#define MAC
#endif
#endif

#ifdef __FreeBSD__
#define NEED_STAT_H
#endif

#if defined(__APPLE__) && defined(__GNUC__)
#define NEED_STAT_H
#endif

#ifdef NEED_STAT_H
#include <sys/stat.h>
#endif

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !WIN32 */
#endif /* MC_PATHSEP_C */



/* the version string is replaced when building distribution with mkdist */
#ifndef MCCODE_STRING
#define MCCODE_STRING "McStas 2.4.1 - Jun. 26, 2017"
#endif

#ifndef MCCODE_DATE
#define MCCODE_DATE "Jun. 26, 2017"
#endif

#ifndef MCCODE_VERSION
#define MCCODE_VERSION "2.4.1"
#endif

#ifndef MCCODE_NAME
#define MCCODE_NAME "McStas"
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE "neutron"
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV "MCSTAS"
#endif

#ifndef FLAVOR_UPPER
#define FLAVOR_UPPER MCCODE_NAME
#endif

#ifdef MC_PORTABLE
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#ifdef MAC
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (USE_MPI == 0)
#undef USE_MPI
#endif

#ifdef USE_MPI  /* default is to disable signals with MPI, as MPICH uses them to communicate */
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (NOSIGNALS == 0)
#undef NOSIGNALS
#endif

/* Note: the enum instr_formal_types definition MUST be kept
   synchronized with the one in mccode.h and with the
   instr_formal_type_names array in cogen.c. */
enum instr_formal_types
  {
    instr_type_double, instr_type_int, instr_type_string
  };
struct mcinputtable_struct { /* defines instrument parameters */
  char *name; /* name of parameter */
  void *par;  /* pointer to instrument parameter (variable) */
  enum instr_formal_types type;
  char *val;  /* default value */
};

typedef double MCNUM;
typedef struct {MCNUM x, y, z;} Coords;
typedef MCNUM Rotation[3][3];

/* the following variables are defined in the McStas generated C code
   but should be defined externally in case of independent library usage */
#ifndef DANSE
extern struct mcinputtable_struct mcinputtable[]; /* list of instrument parameters */
extern int    mcnumipar;                          /* number of instrument parameters */
extern char   mcinstrument_name[], mcinstrument_source[]; /* instrument name and filename */
extern char  *mcinstrument_exe;                           /* executable path = argv[0] or NULL */
extern MCNUM  mccomp_storein[]; /* 11 coords * number of components in instrument */
extern MCNUM  mcAbsorbProp[];
extern MCNUM  mcScattered;      /* number of SCATTER calls in current component */
extern MCNUM  mcRestore;        /* Flag to indicate if neutron needs to be restored */
#ifndef MC_ANCIENT_COMPATIBILITY
extern int mctraceenabled, mcdefaultmain;
#endif
#endif


/* Useful macros ============================================================ */

/* MPI stuff */

#ifdef USE_MPI
#include "mpi.h"

#ifdef OMPI_MPI_H  /* openmpi does not use signals: we may install our sighandler */
#undef NOSIGNALS
#endif

/*
 * MPI_MASTER(i):
 * execution of i only on master node
 */
#define MPI_MASTER(statement) { \
  if(mpi_node_rank == mpi_node_root)\
  { statement; } \
}

#ifndef MPI_REDUCE_BLOCKSIZE
#define MPI_REDUCE_BLOCKSIZE 1000
#endif

int mc_MPI_Sum(double* buf, long count);
int mc_MPI_Send(void *sbuf, long count, MPI_Datatype dtype, int dest);
int mc_MPI_Recv(void *rbuf, long count, MPI_Datatype dtype, int source);

/* MPI_Finalize exits gracefully and should be preferred to MPI_Abort */
#define exit(code) do {                                   \
    MPI_Finalize();                                       \
    exit(code);                                           \
  } while(0)

#else /* !USE_MPI */
#define MPI_MASTER(instr) instr
#endif /* USE_MPI */

#ifdef USE_MPI
static int mpi_node_count;
#endif

#ifdef USE_THREADS  /* user want threads */
#error Threading (USE_THREADS) support has been removed for very poor efficiency. Use MPI/SSH grid instead.
#endif


void   mcset_ncount(unsigned long long count);    /* wrapper to get mcncount */
unsigned long long int mcget_ncount(void);            /* wrapper to set mcncount */
unsigned long long mcget_run_num(void);           /* wrapper to get mcrun_num=0:mcncount */


/* Following part is only embedded when not redundant with mccode.h ========= */

#ifndef MCCODE_H

#ifndef NOSIGNALS
#include <signal.h>
#define SIG_MESSAGE(msg) strcpy(mcsig_message, msg);
#else
#define SIG_MESSAGE(msg)
#endif /* !NOSIGNALS */

/* Useful macros and constants ============================================== */

#ifndef FLT_MAX
#define FLT_MAX         3.40282347E+38F /* max decimal value of a "float" */
#endif

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif
#ifndef SQR
#define SQR(x) ( (x) * (x) )
#endif
#ifndef SIGN
#define SIGN(x) (((x)>0.0)?(1):(-1))
#endif

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
#  define PI 3.14159265358979323846
# endif
#endif

#define RAD2MIN  ((180*60)/PI)
#define MIN2RAD  (PI/(180*60))
#define DEG2RAD  (PI/180)
#define RAD2DEG  (180/PI)
#define FWHM2RMS 0.424660900144    /* Convert between full-width-half-max and */
#define RMS2FWHM 2.35482004503     /* root-mean-square (standard deviation) */
#define HBAR     1.05457168e-34    /* [Js] h bar Planck constant CODATA 2002 */
#define MNEUTRON 1.67492728e-27    /* [kg] mass of neutron CODATA 2002 */
#define GRAVITY  9.81              /* [m/s^2] gravitational acceleration */
#define NA       6.02214179e23     /* [#atoms/g .mole] Avogadro's number*/


/* wrapper to get absolute and relative position of comp */
/* mccomp_posa and mccomp_posr are defined in McStas generated C code */
#define POS_A_COMP_INDEX(index) \
    (mccomp_posa[index])
#define POS_R_COMP_INDEX(index) \
    (mccomp_posr[index])
/* number of SCATTER calls in current comp: mcScattered defined in generated C code */
#define SCATTERED mcScattered
/* Flag to indicate if neutron needs to be restored: mcRestore defined in generated C code */
#define RESTORE mcRestore


/* Retrieve component information from the kernel */
/* Name, position and orientation (both absolute and relative)  */
/* Any component: For "redundancy", see comment by KN */
#define tmp_name_comp(comp) #comp
#define NAME_COMP(comp) tmp_name_comp(comp)
#define tmp_pos_a_comp(comp) (mcposa ## comp)
#define POS_A_COMP(comp) tmp_pos_a_comp(comp)
#define tmp_pos_r_comp(comp) (mcposr ## comp)
#define POS_R_COMP(comp) tmp_pos_r_comp(comp)
#define tmp_rot_a_comp(comp) (mcrota ## comp)
#define ROT_A_COMP(comp) tmp_rot_a_comp(comp)
#define tmp_rot_r_comp(comp) (mcrotr ## comp)
#define ROT_R_COMP(comp) tmp_rot_r_comp(comp)

/* Current component name, index, position and orientation */
#define NAME_CURRENT_COMP  NAME_COMP(mccompcurname)
#define INDEX_CURRENT_COMP mccompcurindex
#define POS_A_CURRENT_COMP POS_A_COMP(mccompcurname)
#define POS_R_CURRENT_COMP POS_R_COMP(mccompcurname)
#define ROT_A_CURRENT_COMP ROT_A_COMP(mccompcurname)
#define ROT_R_CURRENT_COMP ROT_R_COMP(mccompcurname)

/* Note: The two-stage approach to MC_GETPAR is NOT redundant; without it,
* after #define C sample, MC_GETPAR(C,x) would refer to component C, not to
* component sample. Such are the joys of ANSI C.

* Anyway the usage of MCGETPAR requires that we use sometimes bare names...
*/
#define MC_GETPAR2(comp, par) (mcc ## comp ## _ ## par)
#define MC_GETPAR(comp, par) MC_GETPAR2(comp,par)

/* MCDISPLAY/trace and debugging message sent to stdout */
#ifdef MC_TRACE_ENABLED
#define DEBUG
#endif

#ifdef DEBUG
#define mcDEBUG_INSTR() if(!mcdotrace); else { printf("INSTRUMENT:\n"); printf("Instrument '%s' (%s)\n", mcinstrument_name, mcinstrument_source); }
#define mcDEBUG_COMPONENT(name,c,t) if(!mcdotrace); else {\
  printf("COMPONENT: \"%s\"\n" \
         "POS: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         name, c.x, c.y, c.z, t[0][0], t[0][1], t[0][2], \
         t[1][0], t[1][1], t[1][2], t[2][0], t[2][1], t[2][2]); \
  mcAccumulatedILength += coords_len(coords_sub(mcLastComp,c)); \
  printf("Component %30s AT (%g,%g,%g)    %g m from origin\n", name, c.x, c.y, c.z, mcAccumulatedILength); \
  mcLastComp=c;\
  }
#define mcDEBUG_INSTR_END() if(!mcdotrace); else printf("INSTRUMENT END:\n");
#define mcDEBUG_ENTER() if(!mcdotrace); else printf("ENTER:\n");
#define mcDEBUG_COMP(c) if(!mcdotrace); else printf("COMP: \"%s\"\n", c);
#define mcDEBUG_LEAVE() if(!mcdotrace); else printf("LEAVE:\n");
#define mcDEBUG_ABSORB() if(!mcdotrace); else printf("ABSORB:\n");
#else
#define mcDEBUG_INSTR()
#define mcDEBUG_COMPONENT(name,c,t)
#define mcDEBUG_INSTR_END()
#define mcDEBUG_ENTER()
#define mcDEBUG_COMP(c)
#define mcDEBUG_LEAVE()
#define mcDEBUG_ABSORB()
#endif

// mcDEBUG_STATE and mcDEBUG_SCATTER are defined by mcstas-r.h and mcxtrace-r.h



#ifdef TEST
#define test_printf printf
#else
#define test_printf while(0) printf
#endif

/* send MCDISPLAY message to stdout to show gemoetry */
void mcdis_magnify(char *what);
void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2);
void mcdis_dashed_linemcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n);
void mcdis_multiline(int count, ...);
void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height);
void mcdis_box(double x, double y, double z,
	       double width, double height, double length);
void mcdis_circle(char *plane, double x, double y, double z, double r);

/* selection of random number generator. default is MT */
#ifndef MC_RAND_ALG
#define MC_RAND_ALG 1
#endif

#if MC_RAND_ALG == 0
   /* Use system random() (not recommended). */
#  define MC_RAND_MAX RAND_MAX
#elif MC_RAND_ALG == 1
   /* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
#  define MC_RAND_MAX ((unsigned long)0xffffffff)
#  define random mt_random
#  define srandom mt_srandom
#elif MC_RAND_ALG == 2
   /* Algorithm used in McStas CVS-080208 and earlier (not recommended). */
#  define MC_RAND_MAX 0x7fffffff
#  define random mc_random
#  define srandom mc_srandom
#else
#  error "Bad value for random number generator choice."
#endif

typedef int mc_int32_t;
mc_int32_t mc_random(void);
void mc_srandom (unsigned int x);
unsigned long mt_random(void);
void mt_srandom (unsigned long x);

double rand01();
double randpm1();
double rand0max(double max);
double randminmax(double min, double max);

double randnorm(void);
double randtriangle(void);

#ifndef DANSE
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);
#endif

/* simple vector algebra ==================================================== */
#define vec_prod(x, y, z, x1, y1, z1, x2, y2, z2) \
	vec_prod_func(&x, &y, &z, x1, y1, z1, x2, y2, z2)
mcstatic inline void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1, double x2, double y2, double z2);

mcstatic inline double scalar_prod(
		double x1, double y1, double z1, double x2, double y2, double z2);

#define NORM(x,y,z) \
	norm_func(&x, &y, &z)
mcstatic inline void norm_func(double *x, double *y, double *z) {
	double temp = (*x * *x) + (*y * *y) + (*z * *z);
	if (temp != 0) {
		temp = sqrt(temp);
		*x /= temp;
		*y /= temp;
		*z /= temp;
	}
}
#define normal_vec(nx, ny, nz, x, y, z) \
    normal_vec_func(&(nx), &(ny), &(nz), x, y, z)
mcstatic inline void normal_vec_func(double *nx, double *ny, double *nz,
    double x, double y, double z);

/**
 * Rotate the vector vx,vy,vz psi radians around the vector ax,ay,az
 * and put the result in x,y,z.
 */
#define rotate(x, y, z, vx, vy, vz, phi, ax, ay, az) \
  do { \
    double mcrt_tmpx = (ax), mcrt_tmpy = (ay), mcrt_tmpz = (az); \
    double mcrt_vp, mcrt_vpx, mcrt_vpy, mcrt_vpz; \
    double mcrt_vnx, mcrt_vny, mcrt_vnz, mcrt_vn1x, mcrt_vn1y, mcrt_vn1z; \
    double mcrt_bx, mcrt_by, mcrt_bz; \
    double mcrt_cos, mcrt_sin; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vp = scalar_prod((vx), (vy), (vz), mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vpx = mcrt_vp*mcrt_tmpx; \
    mcrt_vpy = mcrt_vp*mcrt_tmpy; \
    mcrt_vpz = mcrt_vp*mcrt_tmpz; \
    mcrt_vnx = (vx) - mcrt_vpx; \
    mcrt_vny = (vy) - mcrt_vpy; \
    mcrt_vnz = (vz) - mcrt_vpz; \
    vec_prod(mcrt_bx, mcrt_by, mcrt_bz, \
             mcrt_tmpx, mcrt_tmpy, mcrt_tmpz, mcrt_vnx, mcrt_vny, mcrt_vnz); \
    mcrt_cos = cos((phi)); mcrt_sin = sin((phi)); \
    mcrt_vn1x = mcrt_vnx*mcrt_cos + mcrt_bx*mcrt_sin; \
    mcrt_vn1y = mcrt_vny*mcrt_cos + mcrt_by*mcrt_sin; \
    mcrt_vn1z = mcrt_vnz*mcrt_cos + mcrt_bz*mcrt_sin; \
    (x) = mcrt_vpx + mcrt_vn1x; \
    (y) = mcrt_vpy + mcrt_vn1y; \
    (z) = mcrt_vpz + mcrt_vn1z; \
  } while(0)

/**
 * Mirror (xyz) in the plane given by the point (rx,ry,rz) and normal (nx,ny,nz)
 *
 * TODO: This define is seemingly never used...
 */
#define mirror(x,y,z,rx,ry,rz,nx,ny,nz) \
  do { \
    double mcrt_tmpx= (nx), mcrt_tmpy = (ny), mcrt_tmpz = (nz); \
    double mcrt_tmpt; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_tmpt=scalar_prod((rx),(ry),(rz),mcrt_tmpx,mcrt_tmpy,mcrt_tmpz); \
    (x) = rx -2 * mcrt_tmpt*mcrt_rmpx; \
    (y) = ry -2 * mcrt_tmpt*mcrt_rmpy; \
    (z) = rz -2 * mcrt_tmpt*mcrt_rmpz; \
  } while (0)

Coords coords_set(MCNUM x, MCNUM y, MCNUM z);
Coords coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z);
Coords coords_add(Coords a, Coords b);
Coords coords_sub(Coords a, Coords b);
Coords coords_neg(Coords a);
Coords coords_scale(Coords b, double scale);
double coords_sp(Coords a, Coords b);
Coords coords_xp(Coords b, Coords c);
double coords_len(Coords a);
void   coords_print(Coords a);
mcstatic inline void coords_norm(Coords* c);

void rot_set_rotation(Rotation t, double phx, double phy, double phz);
int  rot_test_identity(Rotation t);
void rot_mul(Rotation t1, Rotation t2, Rotation t3);
void rot_copy(Rotation dest, Rotation src);
void rot_transpose(Rotation src, Rotation dst);
Coords rot_apply(Rotation t, Coords a);

void mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
    double *vx, double *vy, double *vz, double *sx, double *sy, double *sz);
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz);

double mcestimate_error(double N, double p1, double p2);
void mcreadparams(void);

/* this is now in mcstas-r.h and mcxtrace-r.h as the number of state parameters is no longer equal*/
/* void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);
*/
void mcgenstate(void);

/* trajectory/shape intersection routines */
int inside_rectangle(double, double, double, double);
int box_intersect(double *dt_in, double *dt_out, double x, double y, double z,
    double vx, double vy, double vz, double dx, double dy, double dz);
int cylinder_intersect(double *t0, double *t1, double x, double y, double z,
    double vx, double vy, double vz, double r, double h);
int sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r);
/* second order equation roots */
int solve_2nd_order(double *t1, double *t2,
    double A,  double B,  double C);

/* random vector generation to shape */
void randvec_target_circle(double *xo, double *yo, double *zo,
    double *solid_angle, double xi, double yi, double zi, double radius);
#define randvec_target_sphere randvec_target_circle
void randvec_target_rect_angular(double *xo, double *yo, double *zo,
    double *solid_angle,
               double xi, double yi, double zi, double height, double width, Rotation A);
#define randvec_target_rect(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)  randvec_target_rect_real(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,0,0,0,1)
void randvec_target_rect_real(double *xo, double *yo, double *zo,
    double *solid_angle,
	       double xi, double yi, double zi, double height, double width, Rotation A,
			 double lx, double ly, double lz, int order);

/* this is the main() */
int mccode_main(int argc, char *argv[]);


#endif /* !MCCODE_H */

#ifndef MCCODE_R_IO_H
#define MCCODE_R_IO_H "$Revision$"

#if (USE_NEXUS == 0)
#undef USE_NEXUS
#endif

#ifndef CHAR_BUF_LENGTH
#define CHAR_BUF_LENGTH 1024
#endif

/* I/O section part ========================================================= */

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */


/* main DETECTOR structure which stores most information to write to data files */
struct mcdetector_struct {
  char   filename[CHAR_BUF_LENGTH];   /* file name of monitor */
  char   position[CHAR_BUF_LENGTH];   /* position of detector component */
  char   component[CHAR_BUF_LENGTH];  /* component instance name */
  char   instrument[CHAR_BUF_LENGTH]; /* instrument name */
  char   type[CHAR_BUF_LENGTH];       /* data type, e.g. 0d, 1d, 2d, 3d */
  char   user[CHAR_BUF_LENGTH];       /* user name, e.g. HOME */
  char   date[CHAR_BUF_LENGTH];       /* date of simulation end/write time */
  char   title[CHAR_BUF_LENGTH];      /* title of detector */
  char   xlabel[CHAR_BUF_LENGTH];     /* X axis label */
  char   ylabel[CHAR_BUF_LENGTH];     /* Y axis label */
  char   zlabel[CHAR_BUF_LENGTH];     /* Z axis label */
  char   xvar[CHAR_BUF_LENGTH];       /* X variable name */
  char   yvar[CHAR_BUF_LENGTH];       /* Y variable name */
  char   zvar[CHAR_BUF_LENGTH];       /* Z variable name */
  char   ncount[CHAR_BUF_LENGTH];     /* number of events initially generated */
  char   limits[CHAR_BUF_LENGTH];     /* X Y Z limits, e.g. [xmin xmax ymin ymax zmin zmax] */
  char   variables[CHAR_BUF_LENGTH];  /* variables written into data block */
  char   statistics[CHAR_BUF_LENGTH]; /* center, mean and half width along axis */
  char   signal[CHAR_BUF_LENGTH];     /* min max and mean of signal (data block) */
  char   values[CHAR_BUF_LENGTH];     /* integrated values e.g. [I I_err N] */
  double xmin,xmax;                   /* min max of axes */
  double ymin,ymax;
  double zmin,zmax;
  double intensity;                   /* integrated values for data block */
  double error;
  double events;
  double min;                         /* statistics for data block */
  double max;
  double mean;
  double centerX;                     /* statistics for axes */
  double halfwidthX;
  double centerY;
  double halfwidthY;
  int    rank;                        /* dimensionaly of monitor, e.g. 0 1 2 3 */
  char   istransposed;                /* flag to transpose matrix for some formats */

  long   m,n,p;                       /* dimensions of data block and along axes */
  long   date_l;                      /* same as date, but in sec since 1970 */

  double *p0, *p1, *p2;               /* pointers to saved data, NULL when freed */
  char   format[CHAR_BUF_LENGTH];    /* format for file generation */
};

typedef struct mcdetector_struct MCDETECTOR;

static   char *mcdirname             = NULL;      /* name of output directory */
static   char *mcsiminfo_name        = "mccode";  /* default output sim file name */
char    *mcformat                    = NULL;      /* NULL (default) or a specific format */

/* file I/O definitions and function prototypes */

#ifndef MC_EMBEDDED_RUNTIME /* the mcstatic variables (from mccode-r.c) */
extern FILE * mcsiminfo_file;     /* handle to the output siminfo file */
extern int    mcgravitation;      /* flag to enable gravitation */
extern int    mcdotrace;          /* flag to print MCDISPLAY messages */
#else
mcstatic FILE *mcsiminfo_file        = NULL;
#endif

/* I/O function prototypes ================================================== */

/* output functions */
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2, char *c, Coords pos);
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
                  char *xvar, double x1, double x2, long n,
                  double *p0, double *p1, double *p2, char *f, char *c, Coords pos);
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2, long m,
                  long n, double *p0, double *p1, double *p2, char *f,
                  char *c, Coords pos);
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa);

/* wrappers to output functions, that automatically set NAME and POSITION */
#define DETECTOR_OUT(p0,p1,p2) mcdetector_out_0D(NAME_CURRENT_COMP,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_0D(t,p0,p1,p2) mcdetector_out_0D(t,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f) \
     mcdetector_out_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f) \
     mcdetector_out_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)

#ifdef USE_NEXUS
#include "napi.h"
NXhandle nxhandle;
#endif

#endif /* ndef MCCODE_R_IO_H */

#endif /* MCCODE_R_H */
/* End of file "mccode-r.h". */

#line 691 "BIFROST.c"

#line 1 "mcstas-r.h"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system header for McStas.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#define MCSTAS_R_H "$Revision$"

/* Following part is only embedded when not redundent with mcstas.h ========= */

#ifndef MCCODE_H

#define AA2MS    629.622368        /* Convert k[1/AA] to v[m/s] */
#define MS2AA    1.58825361e-3     /* Convert v[m/s] to k[1/AA] */
#define K2V      AA2MS
#define V2K      MS2AA
#define Q2V      AA2MS
#define V2Q      MS2AA
#define SE2V     437.393377        /* Convert sqrt(E)[meV] to v[m/s] */
#define VS2E     5.22703725e-6     /* Convert (v[m/s])**2 to E[meV] */

#define SCATTER do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0)
#define ABSORB do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0)

#define STORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcstore_neutron(mccomp_storein,index, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
#define RESTORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcrestore_neutron(mccomp_storein,index, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p);

#define MAGNET_ON \
  do { \
    mcMagnet = 1; \
  } while(0)

#define MAGNET_OFF \
  do { \
    mcMagnet = 0; \
  } while(0)

#define ALLOW_BACKPROP \
  do { \
    mcallowbackprop = 1; \
  } while(0)

#define DISALLOW_BACKPROP \
  do { \
    mcallowbackprop = 0; \
  } while(0)

#define PROP_MAGNET(dt) \
  do { \
  }while (0)
    /* change coordinates from local system to magnet system */
/*    Rotation rotLM, rotTemp; \
      Coords   posLM = coords_sub(POS_A_CURRENT_COMP, mcMagnetPos); \
      rot_transpose(ROT_A_CURRENT_COMP, rotTemp); \
      rot_mul(rotTemp, mcMagnetRot, rotLM); \
      mcMagnetPrecession(mcnlx, mcnly, mcnlz, mcnlt, mcnlvx, mcnlvy, mcnlvz, \
               &mcnlsx, &mcnlsy, &mcnlsz, dt, posLM, rotLM); \
      } while(0)
*/

#define mcPROP_DT(dt) \
  do { \
    if (mcMagnet && dt > 0) PROP_MAGNET(dt);\
    mcnlx += mcnlvx*(dt); \
    mcnly += mcnlvy*(dt); \
    mcnlz += mcnlvz*(dt); \
    mcnlt += (dt); \
    if (isnan(p) || isinf(p)) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
  } while(0)

/* ADD: E. Farhi, Aug 6th, 2001 PROP_GRAV_DT propagation with acceleration */
#define PROP_GRAV_DT(dt, Ax, Ay, Az) \
  do { \
    if(dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
    if (mcMagnet) printf("Spin precession gravity\n"); \
    mcnlx  += mcnlvx*(dt) + (Ax)*(dt)*(dt)/2; \
    mcnly  += mcnlvy*(dt) + (Ay)*(dt)*(dt)/2; \
    mcnlz  += mcnlvz*(dt) + (Az)*(dt)*(dt)/2; \
    mcnlvx += (Ax)*(dt); \
    mcnlvy += (Ay)*(dt); \
    mcnlvz += (Az)*(dt); \
    mcnlt  += (dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_DT(dt) \
  do { \
    if(dt < 0) { RESTORE=1; goto mcabsorbComp; }; \
    if (mcgravitation) { Coords mcLocG; double mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    PROP_GRAV_DT(dt, mc_gx, mc_gy, mc_gz); } \
    else mcPROP_DT(dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_Z0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gz/2, -mcnlvz, -mcnlz); \
    if (mc_ret && mc_dt>=0) {PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); mcnlz=0;}\
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Z0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_Z0 \
  do { \
    double mc_dt; \
    if(mcnlvz == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlz/mcnlvz; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlz = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_X0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gx/2, -mcnlvx, -mcnlx); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_X0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_X0 \
  do { \
    double mc_dt; \
    if(mcnlvx == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlx/mcnlvx; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlx = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_Y0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gy/2, -mcnlvy, -mcnly); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Y0; \
    DISALLOW_BACKPROP;\
  } while(0)


#define mcPROP_Y0 \
  do { \
    double mc_dt; \
    if(mcnlvy == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnly/mcnlvy; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnly = 0; \
    DISALLOW_BACKPROP; \
  } while(0)

/*moved from mccode-r.h*/
void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);

#ifdef DEBUG

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("STATE: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("SCATTER: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);

#else

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p)
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p)

#endif

#endif /* !MCCODE_H */

#endif /* MCSTAS_R_H */
/* End of file "mcstas-r.h". */

#line 924 "BIFROST.c"

#line 1 "mccode-r.c"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y/McXtrace X.Y
* Version: $Revision$
*
* Runtime system for McStas and McXtrace.
* Embedded within instrument in runtime mode.
* Contains SECTIONS:
*   MPI handling (sum, send, recv)
*   format definitions
*   I/O
*   mcdisplay support
*   random numbers
*   coordinates handling
*   vectors math (solve 2nd order, normals, randvec...)
*   parameter handling
*   signal and main handlers
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/


/** Include header files to avoid implicit declarations (not allowed on LLVM) */
#include <ctype.h>
#include <sys/types.h>

// UNIX specific headers (non-Windows)
#if defined(__unix__) || defined(__APPLE__)
#include <unistd.h>
#include <sys/stat.h>
#endif


#ifndef DANSE
#ifdef MC_ANCIENT_COMPATIBILITY
int mctraceenabled = 0;
int mcdefaultmain  = 0;
#endif
/* else defined directly in the McCode generated C code */

static   long mcseed                 = 0; /* seed for random generator */
static   long mcstartdate            = 0; /* start simulation time */
static   int  mcdisable_output_files = 0; /* --no-output-files */
mcstatic int  mcgravitation          = 0; /* use gravitation flag, for PROP macros */
int      mcMagnet                    = 0; /* magnet stack flag */
mcstatic int  mcdotrace              = 0; /* flag for --trace and messages for DISPLAY */
int      mcallowbackprop             = 0;         /* flag to enable negative/backprop */

/* Number of particle histories to simulate. */
#ifdef NEUTRONICS
mcstatic unsigned long long int mcncount             = 1;
mcstatic unsigned long long int mcrun_num            = 0;
#else
mcstatic unsigned long long int mcncount             = 1000000;
mcstatic unsigned long long int mcrun_num            = 0;
#endif /* NEUTRONICS */

#else
#include "mcstas-globals.h"
#endif /* !DANSE */

/* SECTION: MPI handling ==================================================== */

#ifdef USE_MPI
/* MPI rank */
static int mpi_node_rank;
static int mpi_node_root = 0;


/*******************************************************************************
* mc_MPI_Reduce: Gathers arrays from MPI nodes using Reduce function.
*******************************************************************************/
int mc_MPI_Sum(double *sbuf, long count)
{
  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to reduce */
  else {
    /* we must cut the buffer into blocks not exceeding the MPI max buffer size of 32000 */
    long   offset=0;
    double *rbuf=NULL;
    int    length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */
    int    i=0;
    rbuf = calloc(count, sizeof(double));
    if (!rbuf)
      exit(-fprintf(stderr, "Error: Out of memory %li (mc_MPI_Sum)\n", count*sizeof(double)));
    while (offset < count) {
      if (!length || offset+length > count-1) length=count-offset;
      else length=MPI_REDUCE_BLOCKSIZE;
      if (MPI_Allreduce((double*)(sbuf+offset), (double*)(rbuf+offset),
              length, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD) != MPI_SUCCESS)
        return MPI_ERR_COUNT;
      offset += length;
    }

    for (i=0; i<count; i++) sbuf[i] = rbuf[i];
    free(rbuf);
  }
  return MPI_SUCCESS;
} /* mc_MPI_Sum */

/*******************************************************************************
* mc_MPI_Send: Send array to MPI node by blocks to avoid buffer limit
*******************************************************************************/
int mc_MPI_Send(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int dest)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to send */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Send((void*)(sbuf+offset*dsize), length, dtype, dest, tag++, MPI_COMM_WORLD) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Send */

/*******************************************************************************
* mc_MPI_Recv: Receives arrays from MPI nodes by blocks to avoid buffer limit
*             the buffer must have been allocated previously.
*******************************************************************************/
int mc_MPI_Recv(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int source)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to recv */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Recv((void*)(sbuf+offset*dsize), length, dtype, source, tag++,
            MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Recv */

#endif /* USE_MPI */

/* SECTION: parameters handling ============================================= */

/* Instrument input parameter type handling. */
/*******************************************************************************
* mcparm_double: extract double value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_double(char *s, void *vptr)
{
  char *p;
  double *v = (double *)vptr;

  if (!s) { *v = 0; return(1); }
  *v = strtod(s, &p);
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_double: display parameter type double
*******************************************************************************/
static char *
mcparminfo_double(char *parmname)
{
  return "double";
}

/*******************************************************************************
* mcparmerror_double: display error message when failed extract double
*******************************************************************************/
static void
mcparmerror_double(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for floating point parameter %s (mcparmerror_double)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_double: convert double to string
*******************************************************************************/
static void
mcparmprinter_double(char *f, void *vptr)
{
  double *v = (double *)vptr;
  sprintf(f, "%g", *v);
}

/*******************************************************************************
* mcparm_int: extract int value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_int(char *s, void *vptr)
{
  char *p;
  int *v = (int *)vptr;
  long x;

  if (!s) { *v = 0; return(1); }
  *v = 0;
  x = strtol(s, &p, 10);
  if(x < INT_MIN || x > INT_MAX)
    return 0;                        /* Under/overflow */
  *v = x;
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_int: display parameter type int
*******************************************************************************/
static char *
mcparminfo_int(char *parmname)
{
  return "int";
}

/*******************************************************************************
* mcparmerror_int: display error message when failed extract int
*******************************************************************************/
static void
mcparmerror_int(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for integer parameter %s (mcparmerror_int)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_int: convert int to string
*******************************************************************************/
static void
mcparmprinter_int(char *f, void *vptr)
{
  int *v = (int *)vptr;
  sprintf(f, "%d", *v);
}

/*******************************************************************************
* mcparm_string: extract char* value from 's' into 'vptr' (copy)
*******************************************************************************/
static int
mcparm_string(char *s, void *vptr)
{
  char **v = (char **)vptr;
  if (!s) { *v = NULL; return(1); }
  *v = (char *)malloc(strlen(s) + 1);
  if(*v == NULL)
  {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcparm_string).\n", (long)strlen(s) + 1));
  }
  strcpy(*v, s);
  return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_string: display parameter type string
*******************************************************************************/
static char *
mcparminfo_string(char *parmname)
{
  return "string";
}

/*******************************************************************************
* mcparmerror_string: display error message when failed extract string
*******************************************************************************/
static void
mcparmerror_string(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for string parameter %s (mcparmerror_string)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_string: convert string to string (including esc chars)
*******************************************************************************/
static void
mcparmprinter_string(char *f, void *vptr)
{
  char **v = (char **)vptr;
  char *p;

  if (!*v) { *f='\0'; return; }
  strcpy(f, "");
  for(p = *v; *p != '\0'; p++)
  {
    switch(*p)
    {
      case '\n':
        strcat(f, "\\n");
        break;
      case '\r':
        strcat(f, "\\r");
        break;
      case '"':
        strcat(f, "\\\"");
        break;
      case '\\':
        strcat(f, "\\\\");
        break;
      default:
        strncat(f, p, 1);
    }
  }
  /* strcat(f, "\""); */
} /* mcparmprinter_string */

/* now we may define the parameter structure, using previous functions */
static struct
  {
    int (*getparm)(char *, void *);
    char * (*parminfo)(char *);
    void (*error)(char *, char *);
    void (*printer)(char *, void *);
} mcinputtypes[] = {
  {
    mcparm_double, mcparminfo_double, mcparmerror_double,
    mcparmprinter_double
  }, {
    mcparm_int, mcparminfo_int, mcparmerror_int,
    mcparmprinter_int
  }, {
    mcparm_string, mcparminfo_string, mcparmerror_string,
    mcparmprinter_string
  }
};

/*******************************************************************************
* mcestimate_error: compute sigma from N,p,p2 in Gaussian large numbers approx
*******************************************************************************/
double mcestimate_error(double N, double p1, double p2)
{
  double pmean, n1;
  if(N <= 1)
    return p1;
  pmean = p1 / N;
  n1 = N - 1;
  /* Note: underflow may cause p2 to become zero; the fabs() below guards
     against this. */
  return sqrt((N/n1)*fabs(p2 - pmean*pmean));
}

double (*mcestimate_error_p)
  (double V2, double psum, double p2sum)=mcestimate_error;

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */

#ifndef MCCODE_R_IO_C
#define MCCODE_R_IO_C "$Revision$"

/* SECTION: file i/o handling ================================================ */

#ifndef HAVE_STRCASESTR
// from msysgit: https://code.google.com/p/msysgit/source/browse/compat/strcasestr.c
char *strcasestr(const char *haystack, const char *needle)
{
  int nlen = strlen(needle);
  int hlen = strlen(haystack) - nlen + 1;
  int i;

  for (i = 0; i < hlen; i++) {
    int j;
    for (j = 0; j < nlen; j++) {
            unsigned char c1 = haystack[i+j];
            unsigned char c2 = needle[j];
            if (toupper(c1) != toupper(c2))
                    goto next;
    }
    return (char *) haystack + i;
  next:
    ;
  }
  return NULL;
}


#endif
#ifndef HAVE_STRCASECMP
int strcasecmp( const char *s1, const char *s2 )
{
  int c1, c2;
  do {
    c1 = tolower( (unsigned char) *s1++ );
    c2 = tolower( (unsigned char) *s2++ );
  } while (c1 == c2 && c1 != 0);
  return c2 > c1 ? -1 : c1 > c2;
}
#endif

/*******************************************************************************
* mcfull_file: allocates a full file name=mcdirname+file. Catenate extension if missing.
*******************************************************************************/
char *mcfull_file(char *name, char *ext)
{
  int   dirlen=0;
  char *mem   =NULL;

  dirlen = mcdirname ? strlen(mcdirname) : 0;
  mem = (char*)malloc(dirlen + strlen(name) + CHAR_BUF_LENGTH);
  if(!mem) {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcfull_file)\n", (long)(dirlen + strlen(name) + 256)));
  }
  strcpy(mem, "");

  /* prepend directory name to path if name does not contain a path */
  if (dirlen > 0 && !strchr(name, MC_PATHSEP_C)) {
    strcat(mem, mcdirname);
    strcat(mem, MC_PATHSEP_S);
  } /* dirlen */

  strcat(mem, name);
  if (!strchr(name, '.') && ext && strlen(ext))
  { /* add extension if not in file name already */
    strcat(mem, ".");
    strcat(mem, ext);
  }
  return(mem);
} /* mcfull_file */

/*******************************************************************************
* mcnew_file: opens a new file within mcdirname if non NULL
*             the file is opened in "a" (append, create if does not exist)
*             the extension 'ext' is added if the file name does not include one.
*             the last argument is set to 0 if file did not exist, else to 1.
*******************************************************************************/
FILE *mcnew_file(char *name, char *ext, int *exists)
{
  char *mem;
  FILE *file=NULL;

  if (!name || strlen(name) == 0 || mcdisable_output_files) return(NULL);
  
  mem  = mcfull_file(name, ext); /* create mcdirname/name.ext */
  
  /* check for existence */
  file = fopen(mem, "r"); /* for reading -> fails if does not exist */
  if (file) {
    fclose(file);
    *exists=1;
  } else
    *exists=0;
  
  /* open the file for writing/appending */
#ifdef USE_NEXUS
  if (mcformat && strcasestr(mcformat, "NeXus")) {
    /* NXhandle nxhandle is defined in the .h with USE_NEXUS */
    NXaccess mode = (*exists ? NXACC_CREATE5 | NXACC_RDWR : NXACC_CREATE5);
      
    if (NXopen(mem, mode, &nxhandle) != NX_OK)
      file = NULL;
    else
      file = (FILE*)&nxhandle; /* to make it non NULL */
  } else
#endif
    file = fopen(mem, "a+"); 
    
  if(!file)
    fprintf(stderr, "Warning: could not open output file '%s' for %s (mcnew_file)\n", 
      mem, *exists ? "append" : "create");
  free(mem);

  return file;
} /* mcnew_file */

/*******************************************************************************
* mcdetector_statistics: compute detector statistics, error bars, [x I I_err N] 1D
* RETURN:            updated detector structure
* Used by: mcdetector_import
*******************************************************************************/
MCDETECTOR mcdetector_statistics(
  MCDETECTOR detector)
{

  if (!detector.p1 || !detector.m || !detector.filename)
    return(detector);
  
  /* compute statistics and update MCDETECTOR structure ===================== */
  double sum_z  = 0, min_z  = 0, max_z  = 0;
  double fmon_x =0,  smon_x = 0, fmon_y =0, smon_y=0, mean_z=0;
  double Nsum=0, P2sum=0;

  double sum_xz = 0, sum_yz = 0, sum_x = 0, sum_y = 0, sum_x2z = 0, sum_y2z = 0;
  int    i,j;
  char   hasnan=0, hasinf=0;
  char   israw = ((char*)strcasestr(detector.format,"raw") != NULL);
  double *this_p1=NULL; /* new 1D McCode array [x I E N]. Freed after writing data */

  /* if McCode/PGPLOT and rank==1 we create a new m*4 data block=[x I E N] */
  if (detector.rank == 1 && strcasestr(detector.format,"McCode")) {
    this_p1 = (double *)calloc(detector.m*detector.n*detector.p*4, sizeof(double));
    if (!this_p1)
      exit(-fprintf(stderr, "Error: Out of memory creating %li 1D " MCCODE_STRING " data set for file '%s' (mcdetector_import)\n",
        detector.m*detector.n*detector.p*4*sizeof(double*), detector.filename));
  }

  max_z = min_z = detector.p1[0];
  
  /* compute sum and moments (not for lists) */
  if (!strcasestr(detector.format,"list") && detector.m)
  for(j = 0; j < detector.n*detector.p; j++)
  {
    for(i = 0; i < detector.m; i++)
    {
      double x,y,z;
      double N, E;
      long   index= !detector.istransposed ? i*detector.n*detector.p + j : i+j*detector.m;
      char   hasnaninf=0;

      if (detector.m) 
        x = detector.xmin + (i + 0.5)/detector.m*(detector.xmax - detector.xmin); 
      else x = 0;
      if (detector.n && detector.p) 
        y = detector.ymin + (j + 0.5)/detector.n/detector.p*(detector.ymax - detector.ymin); 
      else y = 0;
      z = detector.p1[index];
      N = detector.p0 ? detector.p0[index] : 1;
      E = detector.p2 ? detector.p2[index] : 0;
      if (detector.p2 && !israw) 
        detector.p2[index] = (*mcestimate_error_p)(detector.p0[index],detector.p1[index],detector.p2[index]); /* set sigma */
      
      if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
        /* fill-in 1D McCode array [x I E N] */
        this_p1[index*4]   = x;
        this_p1[index*4+1] = z;
        this_p1[index*4+2] = detector.p2 ? detector.p2[index] : 0;
        this_p1[index*4+3] = N;
      }
      
      if (isnan(z) || isnan(E) || isnan(N)) hasnaninf=hasnan=1;
      if (isinf(z) || isinf(E) || isinf(N)) hasnaninf=hasinf=1;

      /* compute stats integrals */
      if (!hasnaninf) {
        sum_xz += x*z;
        sum_yz += y*z;
        sum_x  += x;
        sum_y  += y;
        sum_z  += z;
        sum_x2z += x*x*z;
        sum_y2z += y*y*z;
        if (z > max_z) max_z = z;
        if (z < min_z) min_z = z;

        Nsum += N;
        P2sum += E;
      }

    }
  } /* for j */

  /* compute 1st and 2nd moments. For lists, sum_z=0 so this is skipped. */
  if (sum_z && detector.n*detector.m*detector.p)
  {
    fmon_x = sum_xz/sum_z;
    fmon_y = sum_yz/sum_z;
    smon_x = sum_x2z/sum_z-fmon_x*fmon_x; smon_x = smon_x > 0 ? sqrt(smon_x) : 0;
    smon_y = sum_y2z/sum_z-fmon_y*fmon_y; smon_y = smon_y > 0 ? sqrt(smon_y) : 0;
    mean_z = sum_z/detector.n/detector.m/detector.p;
  }
  /* store statistics into detector */
  detector.intensity = sum_z;
  detector.error     = Nsum ? (*mcestimate_error_p)(Nsum, sum_z, P2sum) : 0;
  detector.events    = Nsum;
  detector.min       = min_z;
  detector.max       = max_z;
  detector.mean      = mean_z;
  detector.centerX   = fmon_x;
  detector.halfwidthX= smon_x;
  detector.centerY   = fmon_y;
  detector.halfwidthY= smon_y;

  /* if McCode/PGPLOT and rank==1 replace p1 with new m*4 1D McCode and clear others */
  if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
    
    detector.p1 = this_p1;
    detector.n  = detector.m; detector.m  = 4;
    detector.p0 = detector.p2 = NULL;
    detector.istransposed = 1;
  }

  if (detector.n*detector.m*detector.p > 1)
    snprintf(detector.signal, CHAR_BUF_LENGTH, 
      "Min=%g; Max=%g; Mean=%g;", detector.min, detector.max, detector.mean);
  else
    strcpy(detector.signal, "None");
  snprintf(detector.values, CHAR_BUF_LENGTH,
    "%g %g %g", detector.intensity, detector.error, detector.events);

  switch (detector.rank) {
    case 1:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g;",
      detector.centerX, detector.halfwidthX); break;
    case 2:
    case 3:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g; Y0=%g; dY=%g;",
      detector.centerX, detector.halfwidthX, detector.centerY, detector.halfwidthY);
      break;
    default: strcpy(detector.statistics, "None");
  }
  
  if (hasnan)
    printf("WARNING: Nan detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  if (hasinf)
    printf("WARNING: Inf detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  
  return(detector);
  
} /* mcdetector_statistics */

/*******************************************************************************
* mcdetector_import: build detector structure, merge non-lists from MPI
*                    compute basic stat, write "Detector:" line
* RETURN:            detector structure. Invalid data if detector.p1 == NULL
*                    Invalid detector sets m=0 and filename=""
*                    Simulation data  sets m=0 and filename=mcsiminfo_name
* This function is equivalent to the old 'mcdetector_out', returning a structure
*******************************************************************************/
MCDETECTOR mcdetector_import(
  char *format,
  char *component, char *title,
  long m, long n,  long p,
  char *xlabel, char *ylabel, char *zlabel,
  char *xvar, char *yvar, char *zvar,
  double x1, double x2, double y1, double y2, double z1, double z2,
  char *filename,
  double *p0, double *p1, double *p2,
  Coords position)
{
  time_t t;       /* for detector.date */
  long   date_l;  /* date as a long number */
  char   istransposed=0;
  char   c[CHAR_BUF_LENGTH]; /* temp var for signal label */

  MCDETECTOR detector;

  /* build MCDETECTOR structure ============================================= */
  /* make sure we do not have NULL for char fields */

  /* these also apply to simfile */
  strncpy (detector.filename,  filename ? filename : "",        CHAR_BUF_LENGTH);
  strncpy (detector.format,    format   ? format   : "McCode" , CHAR_BUF_LENGTH);
  /* add extension if missing */
  if (strlen(detector.filename) && !strchr(detector.filename, '.'))
  { /* add extension if not in file name already */
    strcat(detector.filename, ".dat");
  }
  strncpy (detector.component, component ? component : MCCODE_STRING " component", CHAR_BUF_LENGTH);

  snprintf(detector.instrument, CHAR_BUF_LENGTH, "%s (%s)", mcinstrument_name, mcinstrument_source);
  snprintf(detector.user, CHAR_BUF_LENGTH,      "%s on %s",
        getenv("USER") ? getenv("USER") : MCCODE_NAME,
        getenv("HOST") ? getenv("HOST") : "localhost");
  time(&t);         /* get current write time */
  date_l = (long)t; /* same but as a long */
  snprintf(detector.date, CHAR_BUF_LENGTH, "%s", ctime(&t));
  if (strlen(detector.date))   detector.date[strlen(detector.date)-1] = '\0'; /* remove last \n in date */
  detector.date_l = date_l;

  if (!mcget_run_num() || mcget_run_num() >= mcget_ncount())
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%llu", mcget_ncount()
#ifdef USE_MPI
*mpi_node_count
#endif
  );
  else
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%g/%g", (double)mcget_run_num(), (double)mcget_ncount());

  detector.p0         = p0;
  detector.p1         = p1;
  detector.p2         = p2;

  /* handle transposition (not for NeXus) */
  if (!strcasestr(detector.format, "NeXus")) {
    if (m<0 || n<0 || p<0)             istransposed = !istransposed;
    if (strcasestr(detector.format, "transpose")) istransposed = !istransposed;
    if (istransposed) { /* do the swap once for all */
      long i=m; m=n; n=i;
    }
  }

  m=abs(m); n=abs(n); p=abs(p); /* make sure dimensions are positive */
  detector.istransposed = istransposed;

  /* determine detector rank (dimensionality) */
  if (!m || !n || !p || !p1) detector.rank = 4; /* invalid: exit with m=0 filename="" */
  else if (m*n*p == 1)       detector.rank = 0; /* 0D */
  else if (n == 1 || m == 1) detector.rank = 1; /* 1D */
  else if (p == 1)           detector.rank = 2; /* 2D */
  else                       detector.rank = 3; /* 3D */

  /* from rank, set type */
  switch (detector.rank) {
    case 0:  strcpy(detector.type,  "array_0d"); m=n=p=1; break;
    case 1:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_1d(%ld)", m*n*p); m *= n*p; n=p=1; break;
    case 2:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_2d(%ld, %ld)", m, n*p); n *= p; p=1; break;
    case 3:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_3d(%ld, %ld, %ld)", m, n, p); break;
    default: m=0; strcpy(detector.type, ""); strcpy(detector.filename, "");/* invalid */
  }

  detector.m    = m;
  detector.n    = n;
  detector.p    = p;

  /* these only apply to detector files ===================================== */

  snprintf(detector.position, CHAR_BUF_LENGTH, "%g %g %g", position.x, position.y, position.z);
  /* may also store actual detector orientation in the future */

  strncpy(detector.title,      title && strlen(title) ? title : component,       CHAR_BUF_LENGTH);
  strncpy(detector.xlabel,     xlabel && strlen(xlabel) ? xlabel : "X", CHAR_BUF_LENGTH); /* axis labels */
  strncpy(detector.ylabel,     ylabel && strlen(ylabel) ? ylabel : "Y", CHAR_BUF_LENGTH);
  strncpy(detector.zlabel,     zlabel && strlen(zlabel) ? zlabel : "Z", CHAR_BUF_LENGTH);
  strncpy(detector.xvar,       xvar && strlen(xvar) ? xvar :       "x", CHAR_BUF_LENGTH); /* axis variables */
  strncpy(detector.yvar,       yvar && strlen(yvar) ? yvar :       detector.xvar, CHAR_BUF_LENGTH);
  strncpy(detector.zvar,       zvar && strlen(zvar) ? zvar :       detector.yvar, CHAR_BUF_LENGTH);

  /* set "variables" as e.g. "I I_err N" */
  strcpy(c, "I ");
  if (strlen(detector.zvar))      strncpy(c, detector.zvar,32);
  else if (strlen(detector.yvar)) strncpy(c, detector.yvar,32);
  else if (strlen(detector.xvar)) strncpy(c, detector.xvar,32);

  if (detector.rank == 1)
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s %s_err N", detector.xvar, c, c);
  else
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s_err N", c, c);

  /* limits */
  detector.xmin = x1;
  detector.xmax = x2;
  detector.ymin = y1;
  detector.ymax = y2;
  detector.zmin = z1;
  detector.zmax = z2;
  if (abs(detector.rank) == 1)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g", x1, x2);
  else if (detector.rank == 2)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g", x1, x2, y1, y2);
  else
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g %g %g", x1, x2, y1, y2, z1, z2);

  /* if MPI and nodes_nb > 1: reduce data sets when using MPI =============== */
#ifdef USE_MPI
  if (!strcasestr(detector.format,"list") && mpi_node_count > 1 && m) {
    /* we save additive data: reduce everything into mpi_node_root */
    if (p0) mc_MPI_Sum(p0, m*n*p);
    if (p1) mc_MPI_Sum(p1, m*n*p);
    if (p2) mc_MPI_Sum(p2, m*n*p);
    if (!p0) {  /* additive signal must be then divided by the number of nodes */
      int i;
      for (i=0; i<m*n*p; i++) {
        p1[i] /= mpi_node_count;
        if (p2) p2[i] /= mpi_node_count;
      }
    }
  }
#endif /* USE_MPI */

  /* compute statistics, Nsum, intensity, Error bars */
  detector = mcdetector_statistics(detector);

#ifdef USE_MPI
  /* slaves are done */
  if(mpi_node_rank != mpi_node_root) {
    return detector;
  }
#endif

  /* output "Detector:" line ================================================ */
  /* when this is a detector written by a component (not the SAVE from instrument),
     not an event lists */
  if (!m) return(detector);
  if (!strcasestr(detector.format,"list")) {
    if (!strcmp(detector.component, mcinstrument_name)) {
      if (strlen(detector.filename))  /* we name it from its filename, or from its title */
        strncpy(c, detector.filename, CHAR_BUF_LENGTH);
      else
        snprintf(c, CHAR_BUF_LENGTH, "%s", mcinstrument_name);
    } else
      strncpy(c, detector.component, CHAR_BUF_LENGTH);  /* usual detectors written by components */

    printf("Detector: %s_I=%g %s_ERR=%g %s_N=%g",
           c, detector.intensity,
           c, detector.error,
           c, detector.events);
    printf(" \"%s\"\n", strlen(detector.filename) ? detector.filename : detector.component);
  }
  

  return(detector);
} /* mcdetector_import */

/* end MCDETECTOR import section ============================================ */

















/* ========================================================================== */

/*                               ASCII output                                 */
/*     The SIM file is YAML based, the data files have '#' headers            */

/* ========================================================================== */


/*******************************************************************************
* mcinfo_out: output instrument tags/info (only in SIM)
* Used in: mcsiminfo_init (ascii), mcinfo(stdout)
*******************************************************************************/
static void mcinfo_out(char *pre, FILE *f)
{
  char Parameters[CHAR_BUF_LENGTH] = "";
  int  i;

  if (!f || mcdisable_output_files) return;

  /* create parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++)
  {
    char ThisParam[CHAR_BUF_LENGTH];
    if (strlen(mcinputtable[i].name) > CHAR_BUF_LENGTH) break;
    snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
            (*mcinputtypes[mcinputtable[i].type].parminfo)
                (mcinputtable[i].name));
    strcat(Parameters, ThisParam);
    if (strlen(Parameters) >= CHAR_BUF_LENGTH-64) break;
  }

  /* output data ============================================================ */
  if (f != stdout)
    fprintf(f, "%sFile: %s%c%s\n",    pre, mcdirname, MC_PATHSEP_C, mcsiminfo_name);
  else
    fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);

  fprintf(f, "%sSource: %s\n",   pre, mcinstrument_source);
  fprintf(f, "%sParameters: %s\n",    pre, Parameters);
  
  fprintf(f, "%sTrace_enabled: %s\n", pre, mctraceenabled ? "yes" : "no");
  fprintf(f, "%sDefault_main: %s\n",  pre, mcdefaultmain ?  "yes" : "no");
  fprintf(f, "%sEmbedded_runtime: %s\n", pre, 
#ifdef MC_EMBEDDED_RUNTIME
         "yes"
#else
         "no"
#endif
         );

  fflush(f);
} /* mcinfo_out */

/*******************************************************************************
* mcruninfo_out: output simulation tags/info (both in SIM and data files)
* Used in: mcsiminfo_init (ascii case), mcdetector_out_xD_ascii
*******************************************************************************/
static void mcruninfo_out(char *pre, FILE *f)
{
  int i;
  char Parameters[CHAR_BUF_LENGTH];

  if (!f || mcdisable_output_files) return;

  fprintf(f, "%sFormat: %s%s\n",      pre, 
    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME,
    mcformat && strcasestr(mcformat,"McCode") ? " with text headers" : "");
  fprintf(f, "%sURL: %s\n",         pre, "http://www.mccode.org");
  fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);
  fprintf(f, "%sInstrument: %s\n", pre, mcinstrument_source);
  fprintf(f, "%sNcount: %llu\n",        pre, mcget_ncount());
  fprintf(f, "%sTrace: %s\n",       pre, mcdotrace ? "yes" : "no");
  fprintf(f, "%sGravitation: %s\n", pre, mcgravitation ? "yes" : "no");
  snprintf(Parameters, CHAR_BUF_LENGTH, "%ld", mcseed);
  fprintf(f, "%sSeed: %s\n",        pre, Parameters);
  fprintf(f, "%sDirectory: %s\n",        pre, mcdirname ? mcdirname : ".");
#ifdef USE_MPI
  if (mpi_node_count > 1)
    fprintf(f, "%sNodes: %i\n",        pre, mpi_node_count);
#endif

  /* output parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++) {
    if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
      if (mcinputtable[i].par == NULL)
        strncpy(Parameters, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
      else
        (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);

      fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
    }
  }
  fflush(f);
} /* mcruninfo_out */

/*******************************************************************************
* mcsiminfo_out:    wrapper to fprintf(mcsiminfo_file)
*******************************************************************************/
void mcsiminfo_out(char *format, ...)
{
  va_list ap;

  if(mcsiminfo_file && !mcdisable_output_files)
  {
    va_start(ap, format);
    vfprintf(mcsiminfo_file, format, ap);
    va_end(ap);
  }
} /* mcsiminfo_out */


/*******************************************************************************
* mcdatainfo_out: output detector header
*   mcdatainfo_out(prefix, file_handle, detector) writes info to data file
*******************************************************************************/
static void
mcdatainfo_out(char *pre, FILE *f, MCDETECTOR detector)
{
  if (!f || !detector.m || mcdisable_output_files) return;
  
  /* output data ============================================================ */
  fprintf(f, "%sDate: %s (%li)\n",       pre, detector.date, detector.date_l);
  fprintf(f, "%stype: %s\n",       pre, detector.type);
  fprintf(f, "%sSource: %s\n",     pre, detector.instrument);
  fprintf(f, "%scomponent: %s\n",  pre, detector.component);
  fprintf(f, "%sposition: %s\n",   pre, detector.position);

  fprintf(f, "%stitle: %s\n",      pre, detector.title);
  fprintf(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
             "%sNcount: %s\n" : 
             "%sratio: %s\n",  pre, detector.ncount);

  if (strlen(detector.filename)) {
    fprintf(f, "%sfilename: %s\n", pre, detector.filename);
  }

  fprintf(f, "%sstatistics: %s\n", pre, detector.statistics);
  fprintf(f, "%ssignal: %s\n",     pre, detector.signal);
  fprintf(f, "%svalues: %s\n",     pre, detector.values);

  if (detector.rank >= 1)
  {
    fprintf(f, "%sxvar: %s\n",     pre, detector.xvar);
    fprintf(f, "%syvar: %s\n",     pre, detector.yvar);
    fprintf(f, "%sxlabel: %s\n",   pre, detector.xlabel);
    fprintf(f, "%sylabel: %s\n",   pre, detector.ylabel);
    if (detector.rank > 1) {
      fprintf(f, "%szvar: %s\n",   pre, detector.zvar);
      fprintf(f, "%szlabel: %s\n", pre, detector.zlabel);
    }
  }

  fprintf(f, 
    abs(detector.rank)==1 ?
             "%sxlimits: %s\n" : 
             "%sxylimits: %s\n", pre, detector.limits);
  fprintf(f, "%svariables: %s\n", pre, 
    strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
    
  fflush(f);

} /* mcdatainfo_out */

/* mcdetector_out_array_ascii: output a single array to a file
 *   m: columns
 *   n: rows
 *   p: array
 *   f: file handle (already opened)
 */
static void mcdetector_out_array_ascii(long m, long n, double *p, FILE *f, char istransposed)
{
  if(f)
  {
    int i,j;
    for(j = 0; j < n; j++)
    {
      for(i = 0; i < m; i++)
      {
          fprintf(f, "%.10g ", p[!istransposed ? i*n + j : j*m+i]);
      }
      fprintf(f,"\n");
    }
  }
} /* mcdetector_out_array_ascii */

/*******************************************************************************
* mcdetector_out_0D_ascii: called by mcdetector_out_0D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_0D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  /* Write data set information to simulation description file. */
  MPI_MASTER(
    mcsiminfo_out("\nbegin data\n"); // detector.component
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.component, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* write I I_err N */
      fprintf(outfile, "%g %g %g\n", 
        detector.intensity, detector.error, detector.events);
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
} /* mcdetector_out_0D_ascii */

/*******************************************************************************
* mcdetector_out_1D_ascii: called by mcdetector_out_1D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_1D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;

  MPI_MASTER(
    /* Write data set information to simulation description file. */
    mcsiminfo_out("\nbegin data\n"); // detector.filename
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* output the 1D array columns */
      mcdetector_out_array_ascii(detector.m, detector.n, detector.p1, outfile, detector.istransposed);
      
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
  
}  /* mcdetector_out_1D_ascii */

/*******************************************************************************
* mcdetector_out_2D_ascii: called by mcdetector_out_2D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_2D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  MPI_MASTER(
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write header only if file has just been created (not appending) */
      if (!exists) {
        /* Write data set information to simulation description file. */
        mcsiminfo_out("\nbegin data\n"); // detector.filename
        mcdatainfo_out("  ", mcsiminfo_file, detector);
        mcsiminfo_out("end data\n");
      
        mcruninfo_out( "# ", outfile);
        mcdatainfo_out("# ", outfile,   detector);
        fprintf(outfile, "# Data [%s/%s] %s:\n", detector.component, detector.filename, detector.zvar);
      }
      mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
        outfile, detector.istransposed);
      if (detector.p2) {
        fprintf(outfile, "# Errors [%s/%s] %s_err:\n", detector.component, detector.filename, detector.zvar);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p2, 
          outfile, detector.istransposed);
      }
      if (detector.p0) {
        fprintf(outfile, "# Events [%s/%s] N:\n", detector.component, detector.filename);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p0, 
          outfile, detector.istransposed);
      }
      fclose(outfile);
      
      if (!exists) {
        if (strcasestr(detector.format, "list"))
          printf("Events:   \"%s\"\n",  
            strlen(detector.filename) ? detector.filename : detector.component);
      }
    } /* if outfile */
  ); /* MPI_MASTER */
#ifdef USE_MPI
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    int node_i=0;
    /* loop along MPI nodes to write sequentially */
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      /* MPI: slaves wait for the master to write its block, then append theirs */
      MPI_Barrier(MPI_COMM_WORLD);
      if (node_i != mpi_node_root && node_i == mpi_node_rank) {
        if(strlen(detector.filename) && !mcdisable_output_files)	/* Don't write if filename is NULL */
          outfile = mcnew_file(detector.filename, "dat", &exists);
        if (!exists)
          fprintf(stderr, "Warning: [MPI node %i] file '%s' does not exist yet, "
                          "MASTER should have opened it before.\n",
            mpi_node_rank, detector.filename);
        if(outfile) {
          mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
            outfile, detector.istransposed);
          fclose(outfile);
        }
      }
    }
  } /* if strcasestr list */
#endif
  return(detector);
} /* mcdetector_out_2D_ascii */

/*******************************************************************************
* strcpy_valid: makes a valid string for variable names.
*   copy 'original' into 'valid', replacing invalid characters by '_'
*   char arrays must be pre-allocated
*******************************************************************************/
static char *strcpy_valid(char *valid, char *original)
{
  long i;
  int  n=32; /* max length of valid names */

  if (original == NULL || !strlen(original)) return(NULL);

  if (n > strlen(original)) n = strlen(original);
  else original += strlen(original)-n;
  strncpy(valid, original, n);

  for (i=0; i < n; i++)
  {
    if ( (valid[i] > 122)
      || (valid[i] < 32)
      || (strchr("!\"#$%&'()*+,-.:;<=>?@[\\]^`/ \n\r\t", valid[i]) != NULL) )
    {
      if (i) valid[i] = '_'; else valid[i] = 'm';
    }
  }
  valid[i] = '\0';

  return(valid);
} /* strcpy_valid */

/* end ascii output section ================================================= */







#ifdef USE_NEXUS

/* ========================================================================== */

/*                               NeXus output                                 */

/* ========================================================================== */

#define nxprintf(...)    nxstr('d', __VA_ARGS__)
#define nxprintattr(...) nxstr('a', __VA_ARGS__)

/*******************************************************************************
* nxstr: output a tag=value data set (char) in NeXus/current group
*   when 'format' is larger that 1024 chars it is used as value for the 'tag'
*   else the value is assembled with format and following arguments.
*   type='d' -> data set
*        'a' -> attribute for current data set
*******************************************************************************/
static int nxstr(char type, NXhandle *f, char *tag, char *format, ...)
{
  va_list ap;
  char value[CHAR_BUF_LENGTH];
  int  i;
  int  ret=NX_OK;
  
  if (!tag || !format || !strlen(tag) || !strlen(format)) return(NX_OK);
  
  /* assemble the value string */
  if (strlen(format) < CHAR_BUF_LENGTH) {
    va_start(ap, format);
    ret = vsnprintf(value, CHAR_BUF_LENGTH, format, ap);
    va_end(ap);
  
    i = strlen(value);
  } else {
    i = strlen(format);
  }

  if (type == 'd') {
    /* open/put/close data set */
    if (NXmakedata (f, tag, NX_CHAR, 1, &i) != NX_OK) return(NX_ERROR);
    NXopendata (f, tag);
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputdata  (f, value);
    else
      ret = NXputdata  (f, format);
    NXclosedata(f);
  } else {
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputattr  (f, tag, value, strlen(value), NX_CHAR);
    else
      ret = NXputattr  (f, tag, format, strlen(format), NX_CHAR);
  }
  
  return(ret);
  
} /* nxstr */

/*******************************************************************************
* mcinfo_readfile: read a full file into a string buffer which is allocated
*   Think to free the buffer after use.
* Used in: mcinfo_out_nexus (nexus)
*******************************************************************************/
char *mcinfo_readfile(char *filename)
{
  FILE *f = fopen(filename, "r");
  if (!f) return(NULL);
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  rewind(f);
  char *string = malloc(fsize + 1);
  if (string) {
    int n = fread(string, fsize, 1, f);
    fclose(f);

    string[fsize] = 0;
  }
  return(string);
}

/*******************************************************************************
* mcinfo_out: output instrument/simulation groups in NeXus file
* Used in: mcsiminfo_init (nexus)
*******************************************************************************/
static void mcinfo_out_nexus(NXhandle f)
{
  FILE  *fid;     /* for intrument source code/C/IDF */
  char  *buffer=NULL;
  time_t t     =time(NULL); /* for date */
  char   entry0[CHAR_BUF_LENGTH];
  int    count=0;
  char   name[CHAR_BUF_LENGTH];
  char   class[CHAR_BUF_LENGTH];
  
  if (!f || mcdisable_output_files) return;
  
  /* write NeXus NXroot attributes */
  /* automatically added: file_name, HDF5_Version, file_time, NeXus_version */ 
  nxprintattr(f, "creator",   "%s generated with " MCCODE_STRING, mcinstrument_name);
  
  /* count the number of existing NXentry and create the next one */
  NXgetgroupinfo(f, &count, name, class);
  sprintf(entry0, "entry%i", count+1);

  /* create the main NXentry (mandatory in NeXus) */
  if (NXmakegroup(f, entry0, "NXentry") == NX_OK) 
  if (NXopengroup(f, entry0, "NXentry") == NX_OK) {
    
    nxprintf(nxhandle, "program_name", MCCODE_STRING);
    nxprintf(f, "start_time", ctime(&t));
    nxprintf(f, "title", "%s%s%s simulation generated by instrument %s", 
      mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name,
      mcinstrument_name);
    nxprintattr(f, "program_name", MCCODE_STRING);
    nxprintattr(f, "instrument",   mcinstrument_name);
    nxprintattr(f, "simulation",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);

    /* write NeXus instrument group */
    if (NXmakegroup(f, "instrument", "NXinstrument") == NX_OK)
    if (NXopengroup(f, "instrument", "NXinstrument") == NX_OK) {
      int   i;
      char *string=NULL;

      /* write NeXus parameters(types) data =================================== */
      string = (char*)malloc(CHAR_BUF_LENGTH);
      if (string) {
        strcpy(string, "");
        for(i = 0; i < mcnumipar; i++)
        {
          char ThisParam[CHAR_BUF_LENGTH];
          snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
                  (*mcinputtypes[mcinputtable[i].type].parminfo)
                      (mcinputtable[i].name));
          if (strlen(string) + strlen(ThisParam) < CHAR_BUF_LENGTH)
            strcat(string, ThisParam);
        }
        nxprintattr(f, "Parameters",    string);
        free(string);
      }
        
      nxprintattr(f, "name",          mcinstrument_name);
      nxprintf   (f, "name",          mcinstrument_name);
      nxprintattr(f, "Source",        mcinstrument_source);
      
      nxprintattr(f, "Trace_enabled", mctraceenabled ? "yes" : "no");
      nxprintattr(f, "Default_main",  mcdefaultmain ?  "yes" : "no");
      nxprintattr(f, "Embedded_runtime",  
  #ifdef MC_EMBEDDED_RUNTIME
           "yes"
  #else
           "no"
  #endif
           );
           
      /* add instrument source code when available */
      buffer = mcinfo_readfile(mcinstrument_source);
      if (buffer && strlen(buffer)) {
        long length=strlen(buffer);
        nxprintf (f, "description", buffer);
        NXopendata(f,"description");
        nxprintattr(f, "file_name", mcinstrument_source);
        nxprintattr(f, "file_size", "%li", length);
        nxprintattr(f, "MCCODE_STRING", MCCODE_STRING);
        NXclosedata(f);
        nxprintf (f,"instrument_source", "%s " MCCODE_NAME " " MCCODE_PARTICLE " Monte Carlo simulation", mcinstrument_name);
        free(buffer);
      } else
        nxprintf (f, "description", "File %s not found (instrument description %s is missing)", 
          mcinstrument_source, mcinstrument_name);
      
      /* add Mantid/IDF.xml when available */
      char *IDFfile=NULL;
      IDFfile = (char*)malloc(CHAR_BUF_LENGTH);
      sprintf(IDFfile,"%s%s",mcinstrument_source,".xml");
      buffer = mcinfo_readfile(IDFfile);
      if (buffer && strlen(buffer)) {
        NXmakegroup (nxhandle, "instrument_xml", "NXnote");
        NXopengroup (nxhandle, "instrument_xml", "NXnote");
        nxprintf(f, "data", buffer);
        nxprintf(f, "description", "IDF.xml file found with instrument %s", mcinstrument_source);
        nxprintf(f, "type", "text/xml");
        NXclosegroup(f); /* instrument_xml */
        free(buffer);
      }
      free(IDFfile);
      NXclosegroup(f); /* instrument */
    } /* NXinstrument */

    /* write NeXus simulation group */
    if (NXmakegroup(f, "simulation", "NXnote") == NX_OK)
    if (NXopengroup(f, "simulation", "NXnote") == NX_OK) {

      nxprintattr(f, "name",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);
      
      nxprintf   (f, "name",      "%s",     mcsiminfo_name);
      nxprintattr(f, "Format",    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME);
      nxprintattr(f, "URL",       "http://www.mccode.org");
      nxprintattr(f, "program",   MCCODE_STRING);
      nxprintattr(f, "Instrument",mcinstrument_source);
      nxprintattr(f, "Trace",     mcdotrace ?     "yes" : "no");
      nxprintattr(f, "Gravitation",mcgravitation ? "yes" : "no");
      nxprintattr(f, "Seed",      "%li", mcseed);
      nxprintattr(f, "Directory", mcdirname);
    #ifdef USE_MPI
      if (mpi_node_count > 1)
        nxprintf(f, "Nodes", "%i",        mpi_node_count);
    #endif
    
      /* output parameter string ================================================ */
      if (NXmakegroup(f, "Param", "NXparameters") == NX_OK)
      if (NXopengroup(f, "Param", "NXparameters") == NX_OK) {
        int i;
        char string[CHAR_BUF_LENGTH];
        for(i = 0; i < mcnumipar; i++) {
          if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
            if (mcinputtable[i].par == NULL)
              strncpy(string, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
            else
              (*mcinputtypes[mcinputtable[i].type].printer)(string, mcinputtable[i].par);

            nxprintf(f,  mcinputtable[i].name, "%s", string);
            nxprintattr(f, mcinputtable[i].name, string);
          }
        }
        NXclosegroup(f); /* Param */
      } /* NXparameters */
      
      NXclosegroup(f); /* simulation */
    } /* NXsimulation */
    
    /* create a group to hold all monitors */
    NXmakegroup(f, "data", "NXdetector");

    /* leave the NXentry opened (closed at exit) */
  } /* NXentry */
} /* mcinfo_out_nexus */

/*******************************************************************************
* mcdatainfo_out_nexus: output detector header
*   mcdatainfo_out_nexus(detector) create group and write info to NeXus data file
*   open data:NXdetector then filename:NXdata and write headers/attributes
*   requires: NXentry to be opened
*******************************************************************************/
static void
mcdatainfo_out_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  if (!f || !detector.m || mcdisable_output_files) return;
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* create and open the data group */
    /* this may fail when appending to list -> ignore/skip */
    NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
    
    if (NXmakegroup(f, data_name, "NXdata") == NX_OK)
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
    
      /* output metadata (as attributes) ======================================== */
      nxprintattr(f, "Date",       detector.date);
      nxprintattr(f, "type",       detector.type);
      nxprintattr(f, "Source",     detector.instrument);
      nxprintattr(f, "component",  detector.component);
      nxprintattr(f, "position",   detector.position);

      nxprintattr(f, "title",      detector.title);
      nxprintattr(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
                 "Ncount" : 
                 "ratio",  detector.ncount);

      if (strlen(detector.filename)) {
        nxprintattr(f, "filename", detector.filename);
      }

      nxprintattr(f, "statistics", detector.statistics);
      nxprintattr(f, "signal",     detector.signal);
      nxprintattr(f, "values",     detector.values);

      if (detector.rank >= 1)
      {
        nxprintattr(f, "xvar",     detector.xvar);
        nxprintattr(f, "yvar",     detector.yvar);
        nxprintattr(f, "xlabel",   detector.xlabel);
        nxprintattr(f, "ylabel",   detector.ylabel);
        if (detector.rank > 1) {
          nxprintattr(f, "zvar",   detector.zvar);
          nxprintattr(f, "zlabel", detector.zlabel);
        }
      }

      nxprintattr(f, abs(detector.rank)==1 ?
                 "xlimits" : 
                 "xylimits", detector.limits);
      nxprintattr(f, "variables", 
        strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
      nxprintf(f, "distance", detector.position);
      nxprintf(f, "acquisition_mode",
        strcasestr(detector.format, "list") ? "event" : "summed");
        
      NXclosegroup(f);
    } /* NXdata (filename) */
    NXMEnableErrorReporting();  /* re-enable NeXus error messages */
    NXclosegroup(f);
  } /* NXdetector (data) */
  
} /* mcdatainfo_out_nexus */

/*******************************************************************************
* mcdetector_out_axis_nexus: write detector axis into current NXdata
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_axis_nexus(NXhandle f, char *label, char *var, int rank, long length, double min, double max)
{
  if (!f || length <= 1 || mcdisable_output_files || max == min) return(NX_OK);
  else {
    double axis[length];
    char valid[32];
    int dim=(int)length;
    int i;
    int nprimary=1;
    /* create an axis from [min:max] */
    for(i = 0; i < length; i++)
      axis[i] = min+(max-min)*(i+0.5)/length;
    /* create the data set */
    strcpy_valid(valid, label);
    NXcompmakedata(f, valid, NX_FLOAT64, 1, &dim, NX_COMP_LZW, &dim);
    /* open it */
    if (NXopendata(f, valid) != NX_OK) {
      fprintf(stderr, "Warning: could not open axis rank %i '%s' (NeXus)\n",
        rank, valid);
      return(NX_ERROR);
    }
    /* put the axis and its attributes */
    NXputdata  (f, axis);
    nxprintattr(f, "long_name",  label);
    nxprintattr(f, "short_name", var);
    NXputattr  (f, "axis",       &rank,     1, NX_INT32);
    nxprintattr(f, "units",      var);
    NXputattr  (f, "primary",    &nprimary, 1, NX_INT32);
    NXclosedata(f);
    
    return(NX_OK);
  }
} /* mcdetector_out_axis_nexus */

/*******************************************************************************
* mcdetector_out_array_nexus: write detector array into current NXdata (1D,2D)
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_array_nexus(NXhandle f, char *part, double *data, MCDETECTOR detector)
{
  
  int dims[3]={detector.m,detector.n,detector.p};  /* number of elements to write */
  int signal=1;
  int exists=0;
  int current_dims[3]={0,0,0};
  int ret=NX_OK;
  
  if (!f || !data || !detector.m || mcdisable_output_files) return(NX_OK);
  
  /* when this is a list, we set 1st dimension to NX_UNLIMITED for creation */
  if (strcasestr(detector.format, "list")) dims[0] = NX_UNLIMITED;
  
  /* create the data set in NXdata group */
  NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
  /* NXcompmakedata fails with NX_UNLIMITED */
  if (strcasestr(detector.format, "list"))
    ret = NXmakedata(    f, part, NX_FLOAT64, detector.rank, dims);
  else
    ret = NXcompmakedata(f, part, NX_FLOAT64, detector.rank, dims, NX_COMP_LZW, dims);
  if (ret != NX_OK) {
    /* failed: data set already exists */
    int datatype=0;
    int rank=0;
    exists=1;
    /* inquire current size of data set (nb of events stored) */
    NXopendata(f, part);
    NXgetinfo(f, &rank, current_dims, &datatype);
    NXclosedata(f);
  }
  NXMEnableErrorReporting();  /* re-enable NeXus error messages */
  dims[0] = detector.m; /* restore actual dimension from data writing */
  
  /* open the data set */
  if (NXopendata(f, part) == NX_ERROR) {
    fprintf(stderr, "Warning: could not open DataSet %s '%s' (NeXus)\n",
      part, detector.title);
    return(NX_ERROR);
  }
  if (strcasestr(detector.format, "list")) {
    current_dims[1] = current_dims[2] = 0; /* set starting location for writing slab */
    NXputslab(f, data, current_dims, dims);
    if (!exists)
      printf("Events:   \"%s\"\n",  
        strlen(detector.filename) ? detector.filename : detector.component);
  } else {
    NXputdata (f, data);
  }
  
  if (strstr(part,"data") || strstr(part, "events")) {
    NXputattr(f, "signal", &signal, 1, NX_INT32);
    nxprintattr(f, "short_name", detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);
  }
  nxprintattr(f, "long_name", "%s '%s'", part, detector.title);
  NXclosedata(f);
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

/*******************************************************************************
* mcdetector_out_data_nexus: write detector axes+data into current NXdata
*   The data:NXdetector is opened, then filename:NXdata
*   requires: NXentry to be opened
*******************************************************************************/
int mcdetector_out_data_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  
  if (!f || !detector.m || mcdisable_output_files) return(NX_OK);
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* the NXdata group has been created in mcdatainfo_out_nexus */
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
  
      /* write axes, for histogram data sets, not for lists */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_axis_nexus(f, detector.xlabel, detector.xvar, 
          1, detector.m, detector.xmin, detector.xmax);
          
        mcdetector_out_axis_nexus(f, detector.ylabel, detector.yvar, 
          2, detector.n, detector.ymin, detector.ymax);
          
        mcdetector_out_axis_nexus(f, detector.zlabel, detector.zvar, 
          3, detector.p, detector.zmin, detector.zmax);

      } /* !list */
      
      /* write the actual data (appended if already exists) */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_array_nexus(f, "data", detector.p1, detector);
        mcdetector_out_array_nexus(f, "errors", detector.p2, detector);
        mcdetector_out_array_nexus(f, "ncount", detector.p0, detector);
      } else
        mcdetector_out_array_nexus(  f, "events", detector.p1, detector);
      
      NXclosegroup(f);
    } /* NXdata */
    NXclosegroup(f);
  } /* NXdetector */
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

#ifdef USE_MPI
/*******************************************************************************
* mcdetector_out_list_slaves: slaves send their list data to master which writes
*   requires: NXentry to be opened
* WARNING: this method has a flaw: it requires all nodes to flush the lists
*   the same number of times. In case one node is just below the buffer size
*   when finishing (e.g. monitor_nd), it may not trigger save but others may. 
*   Then the number of recv/send is not constant along nodes, and simulation stalls.  
*******************************************************************************/
MCDETECTOR mcdetector_out_list_slaves(MCDETECTOR detector)
{
  int     node_i=0;
  MPI_MASTER(
	     printf("\n** MPI master gathering slave node list data ** \n");
  );
  
  if (mpi_node_rank != mpi_node_root) {
    /* MPI slave: slaves send their data to master: 2 MPI_Send calls */
    /* m, n, p must be sent first, since all slaves do not have the same number of events */
    int mnp[3]={detector.m,detector.n,detector.p};

    if (mc_MPI_Send(mnp, 3, MPI_INT, mpi_node_root)!= MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send mnp list error (mcdetector_out_list_slaves)\n", mpi_node_rank);
    if (!detector.p1
     || mc_MPI_Send(detector.p1, mnp[0]*mnp[1]*mnp[2], MPI_DOUBLE, mpi_node_root) != MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send p1 list error: mnp=%i (mcdetector_out_list_slaves)\n", mpi_node_rank, abs(mnp[0]*mnp[1]*mnp[2]));
    /* slaves are done: sent mnp and p1 */
    return (detector);
  } /* end slaves */

  /* MPI master: receive data from slaves sequentially: 2 MPI_Recv calls */

  if (mpi_node_rank == mpi_node_root) {
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      double *this_p1=NULL;                               /* buffer to hold the list from slaves */
      int     mnp[3]={0,0,0};  /* size of this buffer */
      if (node_i != mpi_node_root) { /* get data from slaves */
	if (mc_MPI_Recv(mnp, 3, MPI_INT, node_i) != MPI_SUCCESS)
	  fprintf(stderr, "Warning: master from proc %i: "
		  "MPI_Recv mnp list error (mcdetector_write_data)\n", node_i);
	if (mnp[0]*mnp[1]*mnp[2]) {
	  this_p1 = (double *)calloc(mnp[0]*mnp[1]*mnp[2], sizeof(double));
	  if (!this_p1 || mc_MPI_Recv(this_p1, abs(mnp[0]*mnp[1]*mnp[2]), MPI_DOUBLE, node_i)!= MPI_SUCCESS)
	    fprintf(stderr, "Warning: master from proc %i: "
		    "MPI_Recv p1 list error: mnp=%i (mcdetector_write_data)\n", node_i, mnp[0]*mnp[1]*mnp[2]);
	  else {
	    printf(". MPI master writing data for slave node %i\n",node_i);
	    detector.p1 = this_p1;
	    detector.m  = mnp[0]; detector.n  = mnp[1]; detector.p  = mnp[2];
	    
	    mcdetector_out_data_nexus(nxhandle, detector);
	  }
	}
      } /* if not master */
    } /* for */
  MPI_MASTER(
	     printf("\n** Done ** \n");
  );   
  }
}
#endif

MCDETECTOR mcdetector_out_0D_nexus(MCDETECTOR detector)
{
  /* Write data set information to NeXus file. */
  MPI_MASTER(
    mcdatainfo_out_nexus(nxhandle, detector);
  );
  
  return(detector);
} /* mcdetector_out_0D_ascii */

MCDETECTOR mcdetector_out_1D_nexus(MCDETECTOR detector)
{
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  return(detector);
} /* mcdetector_out_1D_ascii */

MCDETECTOR mcdetector_out_2D_nexus(MCDETECTOR detector)
{
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  
#ifdef USE_MPI // and USE_NEXUS
  /* NeXus: slave nodes have master write their lists */
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    mcdetector_out_list_slaves(detector);
  }
#endif /* USE_MPI */

  return(detector);
} /* mcdetector_out_2D_nexus */

#endif /* USE_NEXUS*/








/* ========================================================================== */

/*                            Main input functions                            */
/*            DETECTOR_OUT_xD function calls -> ascii or NeXus                */

/* ========================================================================== */

/*******************************************************************************
* mcsiminfo_init:   open SIM and write header
*******************************************************************************/
FILE *mcsiminfo_init(FILE *f)
{
  int exists=0;
  int index;
  
  /* check format */      
  if (!mcformat || !strlen(mcformat) 
   || !strcasecmp(mcformat, "MCSTAS") || !strcasecmp(mcformat, "MCXTRACE") 
   || !strcasecmp(mcformat, "PGPLOT") || !strcasecmp(mcformat, "GNUPLOT") || !strcasecmp(mcformat, "MCCODE")
   || !strcasecmp(mcformat, "MATLAB")) {
    mcformat="McCode";
#ifdef USE_NEXUS
  } else if (strcasestr(mcformat, "NeXus")) {
    /* Do nothing */
#endif
  } else {
    fprintf(stderr,
	    "Warning: You have requested the output format %s which is unsupported by this binary. Resetting to standard %s format.\n",mcformat ,"McCode");
    mcformat="McCode";
  }
  
  /* open the SIM file if not defined yet */
  if (mcsiminfo_file || mcdisable_output_files) 
    return (mcsiminfo_file);
    
#ifdef USE_NEXUS
  /* only master writes NeXus header: calls NXopen(nxhandle) */
  if (mcformat && strcasestr(mcformat, "NeXus")) {
	  MPI_MASTER(
	  mcsiminfo_file = mcnew_file(mcsiminfo_name, "h5", &exists);
    if(!mcsiminfo_file)
      fprintf(stderr,
	      "Warning: could not open simulation description file '%s'\n",
	      mcsiminfo_name);
	  else
	    mcinfo_out_nexus(nxhandle);
	  );
    return(mcsiminfo_file); /* points to nxhandle */
  }
#endif
  
  /* write main description file (only MASTER) */
  MPI_MASTER(

  mcsiminfo_file = mcnew_file(mcsiminfo_name, "sim", &exists);
  if(!mcsiminfo_file)
    fprintf(stderr,
	    "Warning: could not open simulation description file '%s'\n",
	    mcsiminfo_name);
  else
  {
    /* write SIM header */
    time_t t=time(NULL);
    mcsiminfo_out("%s simulation description file for %s.\n", 
      MCCODE_NAME, mcinstrument_name);
    mcsiminfo_out("Date:    %s", ctime(&t)); /* includes \n */
    mcsiminfo_out("Program: %s\n\n", MCCODE_STRING);
    
    mcsiminfo_out("begin instrument: %s\n", mcinstrument_name);
    mcinfo_out(   "  ", mcsiminfo_file);
    mcsiminfo_out("end instrument\n");

    mcsiminfo_out("\nbegin simulation: %s\n", mcdirname);
    mcruninfo_out("  ", mcsiminfo_file);
    mcsiminfo_out("end simulation\n");

  }
  return (mcsiminfo_file);
  
  ); /* MPI_MASTER */
  
} /* mcsiminfo_init */

/*******************************************************************************
*   mcsiminfo_close:  close SIM
*******************************************************************************/
void mcsiminfo_close()
{
  MPI_MASTER(
  if(mcsiminfo_file && !mcdisable_output_files) {
#ifdef USE_NEXUS
    if (mcformat && strcasestr(mcformat, "NeXus")) {
      time_t t=time(NULL);
      nxprintf(nxhandle, "end_time", ctime(&t));
      nxprintf(nxhandle, "duration", "%li", (long)t-mcstartdate);
      NXclosegroup(nxhandle); /* NXentry */
      NXclose(&nxhandle);
    } else
#endif
      fclose(mcsiminfo_file);
    );
    mcsiminfo_file = NULL;
  }
} /* mcsiminfo_close */

/*******************************************************************************
* mcdetector_out_0D: wrapper for 0D (single value).
*   Output single detector/monitor data (p0, p1, p2).
*   Title is t, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2,
                         char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " data"),
    1, 1, 1,
    "I", "", "",
    "I", "", "",
    0, 0, 0, 0, 0, 0, "",
    &p0, &p1, &p2, posa); /* write Detector: line */

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_0D_nexus(detector));
  else
#endif
    return(mcdetector_out_0D_ascii(detector));
    
} /* mcdetector_out_0D */



/*******************************************************************************
* mcdetector_out_1D: wrapper for 1D.
*   Output 1d detector data (p0, p1, p2) for n bins linearly
*   distributed across the range x1..x2 (x1 is lower limit of first
*   bin, x2 is upper limit of last bin). Title is t, axis labels are xl
*   and yl. File name is f, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
        char *xvar, double x1, double x2,
        long n,
        double *p0, double *p1, double *p2, char *f,
        char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " 1D data"),
    n, 1, 1,
    xl, yl, (n > 1 ? "Signal per bin" : " Signal"),
    xvar, "(I,I_err)", "I",
    x1, x2, 0, 0, 0, 0, f,
    p0, p1, p2, posa); /* write Detector: line */
  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_1D_nexus(detector));
  else
#endif
    return(mcdetector_out_1D_ascii(detector));
  
} /* mcdetector_out_1D */

/*******************************************************************************
* mcdetector_out_2D: wrapper for 2D.
*   special case for list: master creates file first, then slaves append their blocks without header
*******************************************************************************/
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2,
                  long m, long n,
                  double *p0, double *p1, double *p2, char *f,
                  char *c, Coords posa)
{
  char xvar[CHAR_BUF_LENGTH];
  char yvar[CHAR_BUF_LENGTH];
  
  /* create short axes labels */
  if (xl && strlen(xl)) { strncpy(xvar, xl, CHAR_BUF_LENGTH); xvar[2]='\0'; }
  else strcpy(xvar, "x");
  if (yl && strlen(yl)) { strncpy(yvar, yl, CHAR_BUF_LENGTH); yvar[2]='\0'; }
  else strcpy(yvar, "y");

  MCDETECTOR detector;

  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  if (abs(m) == 1) {/* n>1 on Y, m==1 on X: 1D, no X axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      n, 1, 1,
      yl, "", "Signal per bin",
      yvar, "(I,Ierr)", "I",
      y1, y2, x1, x2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  } else if (abs(n)==1) {/* m>1 on X, n==1 on Y: 1D, no Y axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      m, 1, 1,
      xl, "", "Signal per bin",
      xvar, "(I,Ierr)", "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }else {
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 2D data"),
      m, n, 1,
      xl, yl, "Signal per bin",
      xvar, yvar, "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }

  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_2D_nexus(detector));
  else
#endif
    return(mcdetector_out_2D_ascii(detector));
  
} /* mcdetector_out_2D */

/*******************************************************************************
* mcdetector_out_list: wrapper for list output (calls out_2D with mcformat+"list").
*   m=number of events, n=size of each event
*******************************************************************************/
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa)
{
  char       format_new[CHAR_BUF_LENGTH];
  char      *format_org;
  MCDETECTOR detector;
  
  format_org = mcformat;
  strcpy(format_new, mcformat);
  strcat(format_new, " list");
  mcformat = format_new;

  detector = mcdetector_out_2D(t, xl, yl,
                  1,abs(m),1,abs(n),
                  m,n,
                  NULL, p1, NULL, f,
                  c, posa);
  
  mcformat = format_org;
  return(detector);
}

/*******************************************************************************
 * mcuse_dir: set data/sim storage directory and create it,
 * or exit with error if exists
 ******************************************************************************/
static void
mcuse_dir(char *dir)
{
  if (!dir || !strlen(dir)) return;
#ifdef MC_PORTABLE
  fprintf(stderr, "Error: "
          "Directory output cannot be used with portable simulation (mcuse_dir)\n");
  exit(1);
#else  /* !MC_PORTABLE */
  /* handle file://directory URL type */
  if (strncmp(dir, "file://", strlen("file://")))
    mcdirname = dir;
  else
    mcdirname = dir+strlen("file://");
  
  
  
  MPI_MASTER(
    if(mkdir(mcdirname, 0777)) {
#ifndef DANSE
      fprintf(stderr, "Error: unable to create directory '%s' (mcuse_dir)\n", dir);
      fprintf(stderr, "(Maybe the directory already exists?)\n");
#endif
#ifdef USE_MPI
    MPI_Abort(MPI_COMM_WORLD, -1);
#endif
    exit(-1);
    }
  ); /* MPI_MASTER */
  
  /* remove trailing PATHSEP (if any) */
  while (strlen(mcdirname) && mcdirname[strlen(mcdirname) - 1] == MC_PATHSEP_C)
    mcdirname[strlen(mcdirname) - 1]='\0';
#endif /* !MC_PORTABLE */
} /* mcuse_dir */

/*******************************************************************************
* mcinfo: display instrument simulation info to stdout and exit
*******************************************************************************/
static void
mcinfo(void)
{
  fprintf(stdout, "begin instrument: %s\n", mcinstrument_name);
  mcinfo_out("  ", stdout);
  fprintf(stdout, "end instrument\n");
  fprintf(stdout, "begin simulation: %s\n", mcdirname ? mcdirname : ".");
  mcruninfo_out("  ", stdout);
  fprintf(stdout, "end simulation\n");
  exit(0); /* includes MPI_Finalize in MPI mode */
} /* mcinfo */

#endif /* ndef MCCODE_R_IO_C */

/* end of the I/O section =================================================== */







/*******************************************************************************
* mcset_ncount: set total number of rays to generate
*******************************************************************************/
void mcset_ncount(unsigned long long int count)
{
  mcncount = count;
}

/* mcget_ncount: get total number of rays to generate */
unsigned long long int mcget_ncount(void)
{
  return mcncount;
}

/* mcget_run_num: get curent number of rays in TRACE */
unsigned long long int mcget_run_num(void)
{
  return mcrun_num;
}

/* mcsetn_arg: get ncount from a string argument */
static void
mcsetn_arg(char *arg)
{
  mcset_ncount((long long int) strtod(arg, NULL));
}

/* mcsetseed: set the random generator seed from a string argument */
static void
mcsetseed(char *arg)
{
  mcseed = atol(arg);
  if(mcseed) {
    srandom(mcseed);
  } else {
    fprintf(stderr, "Error: seed must not be zero (mcsetseed)\n");
    exit(1);
  }
}

/* Following part is only embedded when not redundent with mccode-r.h ========= */

#ifndef MCCODE_H

/* SECTION: MCDISPLAY support. =============================================== */

/*******************************************************************************
* Just output MCDISPLAY keywords to be caught by an external plotter client.
*******************************************************************************/

void mcdis_magnify(char *what){
  printf("MCDISPLAY: magnify('%s')\n", what);
}

void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2){
  printf("MCDISPLAY: multiline(2,%g,%g,%g,%g,%g,%g)\n",
         x1,y1,z1,x2,y2,z2);
}

void mcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n){
  int i;
  const double dx = (x2-x1)/(2*n+1);
  const double dy = (y2-y1)/(2*n+1);
  const double dz = (z2-z1)/(2*n+1);

  for(i = 0; i < n+1; i++)
    mcdis_line(x1 + 2*i*dx,     y1 + 2*i*dy,     z1 + 2*i*dz,
	       x1 + (2*i+1)*dx, y1 + (2*i+1)*dy, z1 + (2*i+1)*dz);
}

void mcdis_multiline(int count, ...){
  va_list ap;
  double x,y,z;

  printf("MCDISPLAY: multiline(%d", count);
  va_start(ap, count);
  while(count--)
    {
    x = va_arg(ap, double);
    y = va_arg(ap, double);
    z = va_arg(ap, double);
    printf(",%g,%g,%g", x, y, z);
    }
  va_end(ap);
  printf(")\n");
}

void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height){
  /* draws a rectangle in the plane           */
  /* x is ALWAYS width and y is ALWAYS height */
  if (strcmp("xy", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y - height/2, z,
		    x + width/2, y - height/2, z,
		    x + width/2, y + height/2, z,
		    x - width/2, y + height/2, z,
		    x - width/2, y - height/2, z);
  } else if (strcmp("xz", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y, z - height/2,
		    x + width/2, y, z - height/2,
		    x + width/2, y, z + height/2,
		    x - width/2, y, z + height/2,
		    x - width/2, y, z - height/2);
  } else if (strcmp("yz", plane)==0) {
    mcdis_multiline(5,
		    x, y - height/2, z - width/2,
		    x, y - height/2, z + width/2,
		    x, y + height/2, z + width/2,
		    x, y + height/2, z - width/2,
		    x, y - height/2, z - width/2);
  } else {

    fprintf(stderr, "Error: Definition of plane %s unknown\n", plane);
    exit(1);
  }
}

/*  draws a box with center at (x, y, z) and
    width (deltax), height (deltay), length (deltaz) */
void mcdis_box(double x, double y, double z,
	       double width, double height, double length){

  mcdis_rectangle("xy", x, y, z-length/2, width, height);
  mcdis_rectangle("xy", x, y, z+length/2, width, height);
  mcdis_line(x-width/2, y-height/2, z-length/2,
	     x-width/2, y-height/2, z+length/2);
  mcdis_line(x-width/2, y+height/2, z-length/2,
	     x-width/2, y+height/2, z+length/2);
  mcdis_line(x+width/2, y-height/2, z-length/2,
	     x+width/2, y-height/2, z+length/2);
  mcdis_line(x+width/2, y+height/2, z-length/2,
	     x+width/2, y+height/2, z+length/2);
}

void mcdis_circle(char *plane, double x, double y, double z, double r){
  printf("MCDISPLAY: circle('%s',%g,%g,%g,%g)\n", plane, x, y, z, r);
}

/* SECTION: coordinates handling ============================================ */

/*******************************************************************************
* Since we use a lot of geometric calculations using Cartesian coordinates,
* we collect some useful routines here. However, it is also permissible to
* work directly on the underlying struct coords whenever that is most
* convenient (that is, the type Coords is not abstract).
*
* Coordinates are also used to store rotation angles around x/y/z axis.
*
* Since coordinates are used much like a basic type (such as double), the
* structure itself is passed and returned, rather than a pointer.
*
* At compile-time, the values of the coordinates may be unknown (for example
* a motor position). Hence coordinates are general expressions and not simple
* numbers. For this we used the type Coords_exp which has three CExp
* fields. For runtime (or calculations possible at compile time), we use
* Coords which contains three double fields.
*******************************************************************************/

/* coords_set: Assign coordinates. */
Coords
coords_set(MCNUM x, MCNUM y, MCNUM z)
{
  Coords a;

  a.x = x;
  a.y = y;
  a.z = z;
  return a;
}

/* coords_get: get coordinates. Required when 'x','y','z' are #defined as ray pars */
Coords
coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z)
{
  *x = a.x;
  *y = a.y;
  *z = a.z;
  return a;
}

/* coords_add: Add two coordinates. */
Coords
coords_add(Coords a, Coords b)
{
  Coords c;

  c.x = a.x + b.x;
  c.y = a.y + b.y;
  c.z = a.z + b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_sub: Subtract two coordinates. */
Coords
coords_sub(Coords a, Coords b)
{
  Coords c;

  c.x = a.x - b.x;
  c.y = a.y - b.y;
  c.z = a.z - b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_neg: Negate coordinates. */
Coords
coords_neg(Coords a)
{
  Coords b;

  b.x = -a.x;
  b.y = -a.y;
  b.z = -a.z;
  return b;
}

/* coords_scale: Scale a vector. */
Coords coords_scale(Coords b, double scale) {
  Coords a;

  a.x = b.x*scale;
  a.y = b.y*scale;
  a.z = b.z*scale;
  return a;
}

/* coords_sp: Scalar product: a . b */
double coords_sp(Coords a, Coords b) {
  double value;

  value = a.x*b.x + a.y*b.y + a.z*b.z;
  return value;
}

/* coords_xp: Cross product: a = b x c. */
Coords coords_xp(Coords b, Coords c) {
  Coords a;

  a.x = b.y*c.z - c.y*b.z;
  a.y = b.z*c.x - c.z*b.x;
  a.z = b.x*c.y - c.x*b.y;
  return a;
}

/* coords_len: Gives length of coords set. */
double coords_len(Coords a) {
  return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

/* coords_mirror: Mirror a in plane (through the origin) defined by normal n*/
Coords coords_mirror(Coords a, Coords n) {
  double t = scalar_prod(n.x, n.y, n.z, n.x, n.y, n.z);
  Coords b;
  if (t!=1) {
    t = sqrt(t);
    n.x /= t;
    n.y /= t;
    n.z /= t;
  }
  t=scalar_prod(a.x, a.y, a.z, n.x, n.y, n.z);
  b.x = a.x-2*t*n.x;
  b.y = a.y-2*t*n.y;
  b.z = a.z-2*t*n.z;
  return b;
}

/* coords_print: Print out vector values. */
void coords_print(Coords a) {

  fprintf(stdout, "(%f, %f, %f)\n", a.x, a.y, a.z);
  return;
}

mcstatic inline void coords_norm(Coords* c) {
	double temp = coords_sp(*c,*c);

	// Skip if we will end dividing by zero
	if (temp == 0) return;

	temp = sqrt(temp);

	c->x /= temp;
	c->y /= temp;
	c->z /= temp;
}

/*******************************************************************************
* The Rotation type implements a rotation transformation of a coordinate
* system in the form of a double[3][3] matrix.
*
* Contrary to the Coords type in coords.c, rotations are passed by
* reference. Functions that yield new rotations do so by writing to an
* explicit result parameter; rotations are not returned from functions. The
* reason for this is that arrays cannot by returned from functions (though
* structures can; thus an alternative would have been to wrap the
* double[3][3] array up in a struct). Such are the ways of C programming.
*
* A rotation represents the tranformation of the coordinates of a vector when
* changing between coordinate systems that are rotated with respect to each
* other. For example, suppose that coordinate system Q is rotated 45 degrees
* around the Z axis with respect to coordinate system P. Let T be the
* rotation transformation representing a 45 degree rotation around Z. Then to
* get the coordinates of a vector r in system Q, apply T to the coordinates
* of r in P. If r=(1,0,0) in P, it will be (sqrt(1/2),-sqrt(1/2),0) in
* Q. Thus we should be careful when interpreting the sign of rotation angles:
* they represent the rotation of the coordinate systems, not of the
* coordinates (which has opposite sign).
*******************************************************************************/

/*******************************************************************************
* rot_set_rotation: Get transformation for rotation first phx around x axis,
* then phy around y, then phz around z.
*******************************************************************************/
void
rot_set_rotation(Rotation t, double phx, double phy, double phz)
{
  if ((phx == 0) && (phy == 0) && (phz == 0)) {
    t[0][0] = 1.0;
    t[0][1] = 0.0;
    t[0][2] = 0.0;
    t[1][0] = 0.0;
    t[1][1] = 1.0;
    t[1][2] = 0.0;
    t[2][0] = 0.0;
    t[2][1] = 0.0;
    t[2][2] = 1.0;
  } else {
    double cx = cos(phx);
    double sx = sin(phx);
    double cy = cos(phy);
    double sy = sin(phy);
    double cz = cos(phz);
    double sz = sin(phz);

    t[0][0] = cy*cz;
    t[0][1] = sx*sy*cz + cx*sz;
    t[0][2] = sx*sz - cx*sy*cz;
    t[1][0] = -cy*sz;
    t[1][1] = cx*cz - sx*sy*sz;
    t[1][2] = sx*cz + cx*sy*sz;
    t[2][0] = sy;
    t[2][1] = -sx*cy;
    t[2][2] = cx*cy;
  }
}

/*******************************************************************************
* rot_test_identity: Test if rotation is identity
*******************************************************************************/
int
rot_test_identity(Rotation t)
{
  return (t[0][0] + t[1][1] + t[2][2] == 3);
}

/*******************************************************************************
* rot_mul: Matrix multiplication of transformations (this corresponds to
* combining transformations). After rot_mul(T1, T2, T3), doing T3 is
* equal to doing first T2, then T1.
* Note that T3 must not alias (use the same array as) T1 or T2.
*******************************************************************************/
void
rot_mul(Rotation t1, Rotation t2, Rotation t3)
{
  if (rot_test_identity(t1)) {
    rot_copy(t3, t2);
  } else if (rot_test_identity(t2)) {
    rot_copy(t3, t1);
  } else {
    int i,j;
    for(i = 0; i < 3; i++)
      for(j = 0; j < 3; j++)
	t3[i][j] = t1[i][0]*t2[0][j] + t1[i][1]*t2[1][j] + t1[i][2]*t2[2][j];
  }
}

/*******************************************************************************
* rot_copy: Copy a rotation transformation (arrays cannot be assigned in C).
*******************************************************************************/
void
rot_copy(Rotation dest, Rotation src)
{
  int i,j;
  for(i = 0; i < 3; i++)
    for(j = 0; j < 3; j++)
      dest[i][j] = src[i][j];
}

/*******************************************************************************
* rot_transpose: Matrix transposition, which is inversion for Rotation matrices
*******************************************************************************/
void
rot_transpose(Rotation src, Rotation dst)
{
  dst[0][0] = src[0][0];
  dst[0][1] = src[1][0];
  dst[0][2] = src[2][0];
  dst[1][0] = src[0][1];
  dst[1][1] = src[1][1];
  dst[1][2] = src[2][1];
  dst[2][0] = src[0][2];
  dst[2][1] = src[1][2];
  dst[2][2] = src[2][2];
}

/*******************************************************************************
* rot_apply: returns t*a
*******************************************************************************/
Coords
rot_apply(Rotation t, Coords a)
{
  Coords b;
  if (rot_test_identity(t)) {
    return a;
  } else {
    b.x = t[0][0]*a.x + t[0][1]*a.y + t[0][2]*a.z;
    b.y = t[1][0]*a.x + t[1][1]*a.y + t[1][2]*a.z;
    b.z = t[2][0]*a.x + t[2][1]*a.y + t[2][2]*a.z;
    return b;
  }
}

/**
 * Pretty-printing of rotation matrices.
 */
void rot_print(Rotation rot) {
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[0][0], rot[0][1], rot[0][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[1][0], rot[1][1], rot[1][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n\n",
			rot[2][0], rot[2][1], rot[2][2]);
}

/**
 * Vector product: used by vec_prod (mccode-r.h). Use coords_xp for Coords.
 */
mcstatic inline void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
    *x = (y1)*(z2) - (y2)*(z1);
    *y = (z1)*(x2) - (z2)*(x1);
    *z = (x1)*(y2) - (x2)*(y1);
}

/**
 * Scalar product: use coords_sp for Coords.
 */
mcstatic inline double scalar_prod(
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
	return ((x1 * x2) + (y1 * y2) + (z1 * z2));
}

/*******************************************************************************
* mccoordschange: applies rotation to (x y z) and (vx vy vz) and Spin (sx,sy,sz)
*******************************************************************************/
void
mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *x;
  b.y = *y;
  b.z = *z;
  c = rot_apply(t, b);
  b = coords_add(c, a);
  *x = b.x;
  *y = b.y;
  *z = b.z;

  if ( (vz && vy  && vx) && (*vz != 0.0 || *vx != 0.0 || *vy != 0.0) ) mccoordschange_polarisation(t, vx, vy, vz);

  if ( (sz && sy  && sx) && (*sz != 0.0 || *sx != 0.0 || *sy != 0.0) ) mccoordschange_polarisation(t, sx, sy, sz);

}

/*******************************************************************************
* mccoordschange_polarisation: applies rotation to vector (sx sy sz)
*******************************************************************************/
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *sx;
  b.y = *sy;
  b.z = *sz;
  c = rot_apply(t, b);
  *sx = c.x;
  *sy = c.y;
  *sz = c.z;
}

/* SECTION: vector math  ==================================================== */

/* normal_vec_func: Compute normal vector to (x,y,z). */
mcstatic inline void normal_vec_func(double *nx, double *ny, double *nz,
                double x, double y, double z)
{
  double ax = fabs(x);
  double ay = fabs(y);
  double az = fabs(z);
  double l;
  if(x == 0 && y == 0 && z == 0)
  {
    *nx = 0;
    *ny = 0;
    *nz = 0;
    return;
  }
  if(ax < ay)
  {
    if(ax < az)
    {                           /* Use X axis */
      l = sqrt(z*z + y*y);
      *nx = 0;
      *ny = z/l;
      *nz = -y/l;
      return;
    }
  }
  else
  {
    if(ay < az)
    {                           /* Use Y axis */
      l = sqrt(z*z + x*x);
      *nx = z/l;
      *ny = 0;
      *nz = -x/l;
      return;
    }
  }
  /* Use Z axis */
  l = sqrt(y*y + x*x);
  *nx = y/l;
  *ny = -x/l;
  *nz = 0;
} /* normal_vec */

/*******************************************************************************
 * solve_2nd_order: second order equation solve: A*t^2 + B*t + C = 0
 * solve_2nd_order(&t1, NULL, A,B,C)
 *   returns 0 if no solution was found, or set 't1' to the smallest positive
 *   solution.
 * solve_2nd_order(&t1, &t2, A,B,C)
 *   same as with &t2=NULL, but also returns the second solution.
 * EXAMPLE usage for intersection of a trajectory with a plane in gravitation
 * field (gx,gy,gz):
 * The neutron starts at point r=(x,y,z) with velocityv=(vx vy vz). The plane
 * has a normal vector n=(nx,ny,nz) and contains the point W=(wx,wy,wz).
 * The problem consists in solving the 2nd order equation:
 *      1/2.n.g.t^2 + n.v.t + n.(r-W) = 0
 * so that A = 0.5 n.g; B = n.v; C = n.(r-W);
 * Without acceleration, t=-n.(r-W)/n.v
 ******************************************************************************/
int solve_2nd_order(double *t1, double *t2,
                  double A,  double B,  double C)
{
  int ret=0;

  if (!t1) return 0;
  *t1 = 0;
  if (t2) *t2=0;

  if (fabs(A) < 1E-10) /* approximate to linear equation: A ~ 0 */
  {
    if (B) {  *t1 = -C/B; ret=1; if (t2) *t2=*t1; }
    /* else no intersection: A=B=0 ret=0 */
  }
  else
  {
    double D;
    D = B*B - 4*A*C;
    if (D >= 0) /* Delta > 0: two solutions */
    {
      double sD, dt1, dt2;
      sD = sqrt(D);
      dt1 = (-B + sD)/2/A;
      dt2 = (-B - sD)/2/A;
      /* we identify very small values with zero */
      if (fabs(dt1) < 1e-10) dt1=0.0;
      if (fabs(dt2) < 1e-10) dt2=0.0;

      /* now we choose the smallest positive solution */
      if      (dt1<=0.0 && dt2>0.0) ret=2; /* dt2 positive */
      else if (dt2<=0.0 && dt1>0.0) ret=1; /* dt1 positive */
      else if (dt1> 0.0 && dt2>0.0)
      {  if (dt1 < dt2) ret=1; else ret=2; } /* all positive: min(dt1,dt2) */
      /* else two solutions are negative. ret=-1 */
      if (ret==1) { *t1 = dt1;  if (t2) *t2=dt2; }
      else        { *t1 = dt2;  if (t2) *t2=dt1; }
      ret=2;  /* found 2 solutions and t1 is the positive one */
    } /* else Delta <0: no intersection. ret=0 */
  }
  return(ret);
} /* solve_2nd_order */

/*******************************************************************************
 * randvec_target_circle: Choose random direction towards target at (x,y,z)
 * with given radius.
 * If radius is zero, choose random direction in full 4PI, no target.
 ******************************************************************************/
void
randvec_target_circle(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double radius)
{
  double l2, phi, theta, nx, ny, nz, xt, yt, zt, xu, yu, zu;

  if(radius == 0.0)
  {
    /* No target, choose uniformly a direction in full 4PI solid angle. */
    theta = acos (1 - rand0max(2));
    phi = rand0max(2 * PI);
    if(solid_angle)
      *solid_angle = 4*PI;
    nx = 1;
    ny = 0;
    nz = 0;
    yi = sqrt(xi*xi+yi*yi+zi*zi);
    zi = 0;
    xi = 0;
  }
  else
  {
    double costheta0;
    l2 = xi*xi + yi*yi + zi*zi; /* sqr Distance to target. */
    costheta0 = sqrt(l2/(radius*radius+l2));
    if (radius < 0) costheta0 *= -1;
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
        *solid_angle = 2*PI*(1 - costheta0);
    }

    /* Now choose point uniformly on circle surface within angle theta0 */
    theta = acos (1 - rand0max(1 - costheta0)); /* radius on circle */
    phi = rand0max(2 * PI); /* rotation on circle at given radius */
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around a
       perpendicular axis u=i x n and then angle phi around i. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, xu, yu, zu);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xi, yi, zi);
} /* randvec_target_circle */

/*******************************************************************************
 * randvec_target_rect_angular: Choose random direction towards target at
 * (xi,yi,zi) with given ANGULAR dimension height x width. height=phi_x=[0,PI],
 * width=phi_y=[0,2*PI] (radians)
 * If height or width is zero, choose random direction in full 4PI, no target.
 *******************************************************************************/
void
randvec_target_rect_angular(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double width, double height, Rotation A)
{
  double theta, phi, nx, ny, nz, xt, yt, zt, xu, yu, zu;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
      *solid_angle = 2*fabs(width*sin(height/2));
    }

    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Now choose point uniformly on the unit sphere segment with angle theta/phi */
    phi   = width*randpm1()/2.0;
    theta = asin(randpm1()*sin(height/2.0));
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around
       n, and then phi around u. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, nx, ny, nz);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xu,  yu,  zu);

  /* Go back to local coordinate system */
  tmp = coords_set(*xo, *yo, *zo);
  tmp = rot_apply(A, tmp);
  coords_get(tmp, &*xo, &*yo, &*zo);

} /* randvec_target_rect_angular */

/*******************************************************************************
 * randvec_target_rect_real: Choose random direction towards target at (xi,yi,zi)
 * with given dimension height x width (in meters !).
 *
 * Local emission coordinate is taken into account and corrected for 'order' times.
 * (See remarks posted to mcstas-users by George Apostolopoulus <gapost@ipta.demokritos.gr>)
 *
 * If height or width is zero, choose random direction in full 4PI, no target.
 *
 * Traditionally, this routine had the name randvec_target_rect - this is now a
 * a define (see mcstas-r.h) pointing here. If you use the old rouine, you are NOT
 * taking the local emmission coordinate into account.
*******************************************************************************/

void
randvec_target_rect_real(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi,
               double width, double height, Rotation A,
               double lx, double ly, double lz, int order)
{
  double dx, dy, dist, dist_p, nx, ny, nz, mx, my, mz, n_norm, m_norm;
  double cos_theta;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {

    /* Now choose point uniformly on rectangle within width x height */
    dx = width*randpm1()/2.0;
    dy = height*randpm1()/2.0;

    /* Determine distance to target plane*/
    dist = sqrt(xi*xi + yi*yi + zi*zi);
    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Determine vector normal to trajectory axis (z) and gravity [0 1 0] */
    vec_prod(nx, ny, nz, xi, yi, zi, 0, 1, 0);

    /* This now defines the x-axis, normalize: */
    n_norm=sqrt(nx*nx + ny*ny + nz*nz);
    nx = nx/n_norm;
    ny = ny/n_norm;
    nz = nz/n_norm;

    /* Now, determine our y-axis (vertical in many cases...) */
    vec_prod(mx, my, mz, xi, yi, zi, nx, ny, nz);
    m_norm=sqrt(mx*mx + my*my + mz*mz);
    mx = mx/m_norm;
    my = my/m_norm;
    mz = mz/m_norm;

    /* Our output, random vector can now be defined by linear combination: */

    *xo = xi + dx * nx + dy * mx;
    *yo = yi + dx * ny + dy * my;
    *zo = zi + dx * nz + dy * mz;

    /* Go back to local coordinate system */
    tmp = coords_set(*xo, *yo, *zo);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &*xo, &*yo, &*zo);

    /* Go back to local coordinate system */
    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    if (solid_angle) {
      /* Calculate vector from local point to remote random point */
      lx = *xo - lx;
      ly = *yo - ly;
      lz = *zo - lz;
      dist_p = sqrt(lx*lx + ly*ly + lz*lz);

      /* Adjust the 'solid angle' */
      /* 1/r^2 to the chosen point times cos(\theta) between the normal */
      /* vector of the target rectangle and direction vector of the chosen point. */
      cos_theta = (xi * lx + yi * ly + zi * lz) / (dist * dist_p);
      *solid_angle = width * height / (dist_p * dist_p);
      int counter;
      for (counter = 0; counter < order; counter++) {
	*solid_angle = *solid_angle * cos_theta;
      }
    }
  }
} /* randvec_target_rect_real */

/* SECTION: random numbers ================================================== */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * This is derived from the Berkeley source:
 *        @(#)random.c        5.5 (Berkeley) 7/6/88
 * It was reworked for the GNU C Library by Roland McGrath.
 * Rewritten to use reentrant functions by Ulrich Drepper, 1995.
 */

/*******************************************************************************
* Modified for McStas from glibc 2.0.7pre1 stdlib/random.c and
* stdlib/random_r.c.
*
* This way random() is more than four times faster compared to calling
* standard glibc random() on ix86 Linux, probably due to multithread support,
* ELF shared library overhead, etc. It also makes McStas generated
* simulations more portable (more likely to behave identically across
* platforms, important for parrallel computations).
*******************************************************************************/


#define        TYPE_3                3
#define        BREAK_3                128
#define        DEG_3                31
#define        SEP_3                3

static mc_int32_t randtbl[DEG_3 + 1] =
  {
    TYPE_3,

    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,
    1627687941, -179304937, -2073333483, 1780058412, -1989503057,
    -615974602, 344556628, 939512070, -1249116260, 1507946756,
    -812545463, 154635395, 1388815473, -1926676823, 525320961,
    -1009028674, 968117788, -123449607, 1284210865, 435012392,
    -2017506339, -911064859, -370259173, 1132637927, 1398500161,
    -205601318,
  };

static mc_int32_t *fptr = &randtbl[SEP_3 + 1];
static mc_int32_t *rptr = &randtbl[1];
static mc_int32_t *state = &randtbl[1];
#define rand_deg DEG_3
#define rand_sep SEP_3
static mc_int32_t *end_ptr = &randtbl[sizeof (randtbl) / sizeof (randtbl[0])];

mc_int32_t
mc_random (void)
{
  mc_int32_t result;

  *fptr += *rptr;
  /* Chucking least random bit.  */
  result = (*fptr >> 1) & 0x7fffffff;
  ++fptr;
  if (fptr >= end_ptr)
  {
    fptr = state;
    ++rptr;
  }
  else
  {
    ++rptr;
    if (rptr >= end_ptr)
      rptr = state;
  }
  return result;
}

void
mc_srandom (unsigned int x)
{
  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
  state[0] = x ? x : 1;
  {
    long int i;
    for (i = 1; i < rand_deg; ++i)
    {
      /* This does:
         state[i] = (16807 * state[i - 1]) % 2147483647;
         but avoids overflowing 31 bits.  */
      long int hi = state[i - 1] / 127773;
      long int lo = state[i - 1] % 127773;
      long int test = 16807 * lo - 2836 * hi;
      state[i] = test + (test < 0 ? 2147483647 : 0);
    }
    fptr = &state[rand_sep];
    rptr = &state[0];
    for (i = 0; i < 10 * rand_deg; ++i)
      random ();
  }
}

/* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
/* See http://www.math.keio.ac.jp/~matumoto/emt.html for original source. */


/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using mt_srandom(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.keio.ac.jp/matumoto/emt.html
   email: matumoto@math.keio.ac.jp
*/

#include <stdio.h>

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void mt_srandom(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] =
            (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
void init_by_array(unsigned long init_key[], unsigned long key_length)
{
    int i, j, k;
    mt_srandom(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long mt_random(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if mt_srandom() has not been called, */
            mt_srandom(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }

    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

#undef N
#undef M
#undef MATRIX_A
#undef UPPER_MASK
#undef LOWER_MASK

/* End of "Mersenne Twister". */

/* End of McCode random number routine. */

/* randnorm: generate a random number from normal law */
double
randnorm(void)
{
  static double v1, v2, s;
  static int phase = 0;
  double X, u1, u2;

  if(phase == 0)
  {
    do
    {
      u1 = rand01();
      u2 = rand01();
      v1 = 2*u1 - 1;
      v2 = 2*u2 - 1;
      s = v1*v1 + v2*v2;
    } while(s >= 1 || s == 0);

    X = v1*sqrt(-2*log(s)/s);
  }
  else
  {
    X = v2*sqrt(-2*log(s)/s);
  }

  phase = 1 - phase;
  return X;
}

/**
 * Generate a random number from -1 to 1 with triangle distribution
 */
double randtriangle(void) {
	double randnum = rand01();
	if (randnum>0.5) return(1-sqrt(2*(randnum-0.5)));
	else return(sqrt(2*randnum)-1);
}

/**
 * Random number between 0.0 and 1.0 (including?)
 */
double rand01() {
	double randnum;
	randnum = (double) random();
	randnum /= (double) MC_RAND_MAX + 1;
	return randnum;
}

/**
 * Return a random number between 1 and -1
 */
double randpm1() {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / 2;
	randnum -= 1;
	return randnum;
}

/**
 * Return a random number between 0 and max.
 */
double rand0max(double max) {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / max;
	return randnum;
}

/**
 * Return a random number between min and max.
 */
double randminmax(double min, double max) {
	return rand0max(max - min) + max;
}

/* SECTION: main and signal handlers ======================================== */

/*******************************************************************************
* mchelp: displays instrument executable help with possible options
*******************************************************************************/
static void
mchelp(char *pgmname)
{
  int i;

  fprintf(stderr, "%s (%s) instrument simulation, generated with " MCCODE_STRING " (" MCCODE_DATE ")\n", mcinstrument_name, mcinstrument_source);
  fprintf(stderr, "Usage: %s [options] [parm=value ...]\n", pgmname);
  fprintf(stderr,
"Options are:\n"
"  -s SEED   --seed=SEED      Set random seed (must be != 0)\n"
"  -n COUNT  --ncount=COUNT   Set number of " MCCODE_PARTICLE "s to simulate.\n"
"  -d DIR    --dir=DIR        Put all data files in directory DIR.\n"
"  -t        --trace          Enable trace of " MCCODE_PARTICLE "s through instrument.\n"
"  -g        --gravitation    Enable gravitation for all trajectories.\n"
"  --no-output-files          Do not write any data files.\n"
"  -h        --help           Show this help message.\n"
"  -i        --info           Detailed instrument information.\n"
"  --format=FORMAT            Output data files using FORMAT="
   FLAVOR_UPPER
#ifdef USE_NEXUS
   " NEXUS"
#endif
"\n\n"
);
#ifdef USE_MPI
  fprintf(stderr,
  "This instrument has been compiled with MPI support.\n  Use 'mpirun %s [options] [parm=value ...]'.\n", pgmname);
#endif
  if(mcnumipar > 0)
  {
    fprintf(stderr, "Instrument parameters are:\n");
    for(i = 0; i < mcnumipar; i++)
      if (mcinputtable[i].val && strlen(mcinputtable[i].val))
        fprintf(stderr, "  %-16s(%s) [default='%s']\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name),
        mcinputtable[i].val);
      else
        fprintf(stderr, "  %-16s(%s)\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name));
  }

#ifndef NOSIGNALS
  fprintf(stderr, "Known signals are: "
#ifdef SIGUSR1
  "USR1 (status) "
#endif
#ifdef SIGUSR2
  "USR2 (save) "
#endif
#ifdef SIGBREAK
  "BREAK (save) "
#endif
#ifdef SIGTERM
  "TERM (save and exit)"
#endif
  "\n");
#endif /* !NOSIGNALS */
} /* mchelp */


/* mcshowhelp: show help and exit with 0 */
static void
mcshowhelp(char *pgmname)
{
  mchelp(pgmname);
  exit(0);
}

/* mcusage: display usage when error in input arguments and exit with 1 */
static void
mcusage(char *pgmname)
{
  fprintf(stderr, "Error: incorrect command line arguments\n");
  mchelp(pgmname);
  exit(1);
}

/* mcenabletrace: enable trace/mcdisplay or error if requires recompile */
static void
mcenabletrace(void)
{
 if(mctraceenabled)
  mcdotrace = 1;
 else
 {
   fprintf(stderr,
           "Error: trace not enabled (mcenabletrace)\n"
           "Please re-run the " MCCODE_NAME " compiler "
                   "with the --trace option, or rerun the\n"
           "C compiler with the MC_TRACE_ENABLED macro defined.\n");
   exit(1);
 }
}

/*******************************************************************************
* mcreadparams: request parameters from the prompt (or use default)
*******************************************************************************/
void
mcreadparams(void)
{
  int i,j,status;
  static char buf[CHAR_BUF_LENGTH];
  char *p;
  int len;

  MPI_MASTER(printf("Instrument parameters for %s (%s)\n",
                    mcinstrument_name, mcinstrument_source));

  for(i = 0; mcinputtable[i].name != 0; i++)
  {
    do
    {
      MPI_MASTER(
                 if (mcinputtable[i].val && strlen(mcinputtable[i].val))
                   printf("Set value of instrument parameter %s (%s) [default='%s']:\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name), mcinputtable[i].val);
                 else
                   printf("Set value of instrument parameter %s (%s):\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name));
                 fflush(stdout);
                 );
#ifdef USE_MPI
      if(mpi_node_rank == mpi_node_root)
        {
          p = fgets(buf, CHAR_BUF_LENGTH, stdin);
          if(p == NULL)
            {
              fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
              exit(1);
            }
        }
      else
        p = buf;
      MPI_Bcast(buf, CHAR_BUF_LENGTH, MPI_CHAR, mpi_node_root, MPI_COMM_WORLD);
#else /* !USE_MPI */
      p = fgets(buf, CHAR_BUF_LENGTH, stdin);
      if(p == NULL)
        {
          fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
          exit(1);
        }
#endif /* USE_MPI */
      len = strlen(buf);
      if (!len || (len == 1 && (buf[0] == '\n' || buf[0] == '\r')))
      {
        if (mcinputtable[i].val && strlen(mcinputtable[i].val)) {
          strncpy(buf, mcinputtable[i].val, CHAR_BUF_LENGTH);  /* use default value */
          len = strlen(buf);
        }
      }
      for(j = 0; j < 2; j++)
      {
        if(len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
        {
          len--;
          buf[len] = '\0';
        }
      }

      status = (*mcinputtypes[mcinputtable[i].type].getparm)
                   (buf, mcinputtable[i].par);
      if(!status)
      {
        (*mcinputtypes[mcinputtable[i].type].error)(mcinputtable[i].name, buf);
        if (!mcinputtable[i].val || strlen(mcinputtable[i].val)) {
          fprintf(stderr, "       Change %s default value in instrument definition.\n", mcinputtable[i].name);
          exit(1);
        }
      }
    } while(!status);
  }
} /* mcreadparams */

/*******************************************************************************
* mcparseoptions: parse command line arguments (options, parameters)
*******************************************************************************/
void
mcparseoptions(int argc, char *argv[])
{
  int i, j;
  char *p;
  int paramset = 0, *paramsetarray;
  char *usedir=NULL;

  /* Add one to mcnumipar to avoid allocating zero size memory block. */
  paramsetarray = (int*)malloc((mcnumipar + 1)*sizeof(*paramsetarray));
  if(paramsetarray == NULL)
  {
    fprintf(stderr, "Error: insufficient memory (mcparseoptions)\n");
    exit(1);
  }
  for(j = 0; j < mcnumipar; j++)
    {
      paramsetarray[j] = 0;
      if (mcinputtable[j].val != NULL && strlen(mcinputtable[j].val))
      {
        int  status;
        char buf[CHAR_BUF_LENGTH];
        strncpy(buf, mcinputtable[j].val, CHAR_BUF_LENGTH);
        status = (*mcinputtypes[mcinputtable[j].type].getparm)
                   (buf, mcinputtable[j].par);
        if(!status) fprintf(stderr, "Invalid '%s' default value %s in instrument definition (mcparseoptions)\n", mcinputtable[j].name, buf);
        else paramsetarray[j] = 1;
      } else {
        (*mcinputtypes[mcinputtable[j].type].getparm)
          (NULL, mcinputtable[j].par);
        paramsetarray[j] = 0;
      }
    }
  for(i = 1; i < argc; i++)
  {
    if(!strcmp("-s", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("-s", argv[i], 2))
      mcsetseed(&argv[i][2]);
    else if(!strcmp("--seed", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("--seed=", argv[i], 7))
      mcsetseed(&argv[i][7]);
    else if(!strcmp("-n", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("-n", argv[i], 2))
      mcsetn_arg(&argv[i][2]);
    else if(!strcmp("--ncount", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("--ncount=", argv[i], 9))
      mcsetn_arg(&argv[i][9]);
    else if(!strcmp("-d", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];  /* will create directory after parsing all arguments (end of this function) */
    else if(!strncmp("-d", argv[i], 2))
      usedir=&argv[i][2];
    else if(!strcmp("--dir", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];
    else if(!strncmp("--dir=", argv[i], 6))
      usedir=&argv[i][6];
    else if(!strcmp("-h", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("--help", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("-i", argv[i])) {
      mcformat=FLAVOR_UPPER;
      mcinfo();
    }
    else if(!strcmp("--info", argv[i]))
      mcinfo();
    else if(!strcmp("-t", argv[i]))
      mcenabletrace();
    else if(!strcmp("--trace", argv[i]))
      mcenabletrace();
    else if(!strcmp("--gravitation", argv[i]))
      mcgravitation = 1;
    else if(!strcmp("-g", argv[i]))
      mcgravitation = 1;
    else if(!strncmp("--format=", argv[i], 9)) {
      mcformat=&argv[i][9];
    }
    else if(!strcmp("--format", argv[i]) && (i + 1) < argc) {
      mcformat=argv[++i];
    }
    else if(!strcmp("--no-output-files", argv[i]))
      mcdisable_output_files = 1;
    else if(argv[i][0] != '-' && (p = strchr(argv[i], '=')) != NULL)
    {
      *p++ = '\0';

      for(j = 0; j < mcnumipar; j++)
        if(!strcmp(mcinputtable[j].name, argv[i]))
        {
          int status;
          status = (*mcinputtypes[mcinputtable[j].type].getparm)(p,
                        mcinputtable[j].par);
          if(!status || !strlen(p))
          {
            (*mcinputtypes[mcinputtable[j].type].error)
              (mcinputtable[j].name, p);
            exit(1);
          }
          paramsetarray[j] = 1;
          paramset = 1;
          break;
        }
      if(j == mcnumipar)
      {                                /* Unrecognized parameter name */
        fprintf(stderr, "Error: unrecognized parameter %s (mcparseoptions)\n", argv[i]);
        exit(1);
      }
    }
    else if(argv[i][0] == '-') {
      fprintf(stderr, "Error: unrecognized option argument %s (mcparseoptions). Ignored.\n", argv[i++]);
    }
    else {
      fprintf(stderr, "Error: unrecognized argument %s (mcparseoptions). Aborting.\n", argv[i]);
      mcusage(argv[0]);
    }
  }
  if(!paramset)
    mcreadparams();                /* Prompt for parameters if not specified. */
  else
  {
    for(j = 0; j < mcnumipar; j++)
      if(!paramsetarray[j])
      {
        fprintf(stderr, "Error: Instrument parameter %s left unset (mcparseoptions)\n",
                mcinputtable[j].name);
        exit(1);
      }
  }
  free(paramsetarray);
#ifdef USE_MPI
  if (mcdotrace) mpi_node_count=1; /* disable threading when in trace mode */
#endif
  if (usedir && strlen(usedir)) mcuse_dir(usedir);
} /* mcparseoptions */

#ifndef NOSIGNALS
mcstatic char  mcsig_message[256];


/*******************************************************************************
* sighandler: signal handler that makes simulation stop, and save results
*******************************************************************************/
void sighandler(int sig)
{
  /* MOD: E. Farhi, Sep 20th 2001: give more info */
  time_t t1, t0;
#define SIG_SAVE 0
#define SIG_TERM 1
#define SIG_STAT 2
#define SIG_ABRT 3

  printf("\n# " MCCODE_STRING ": [pid %i] Signal %i detected", getpid(), sig);
#ifdef USE_MPI
  printf(" [proc %i]", mpi_node_rank);
#endif
#if defined(SIGUSR1) && defined(SIGUSR2) && defined(SIGKILL)
  if (!strcmp(mcsig_message, "sighandler") && (sig != SIGUSR1) && (sig != SIGUSR2))
  {
    printf("\n# Fatal : unrecoverable loop ! Suicide (naughty boy).\n");
    kill(0, SIGKILL); /* kill myself if error occurs within sighandler: loops */
  }
#endif
  switch (sig) {
#ifdef SIGINT
    case SIGINT : printf(" SIGINT (interrupt from terminal, Ctrl-C)"); sig = SIG_TERM; break;
#endif
#ifdef SIGILL
    case SIGILL  : printf(" SIGILL (Illegal instruction)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGFPE
    case SIGFPE  : printf(" SIGFPE (Math Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGSEGV
    case SIGSEGV : printf(" SIGSEGV (Mem Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGTERM
    case SIGTERM : printf(" SIGTERM (Termination)"); sig = SIG_TERM; break;
#endif
#ifdef SIGABRT
    case SIGABRT : printf(" SIGABRT (Abort)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGQUIT
    case SIGQUIT : printf(" SIGQUIT (Quit from terminal)"); sig = SIG_TERM; break;
#endif
#ifdef SIGTRAP
    case SIGTRAP : printf(" SIGTRAP (Trace trap)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGPIPE
    case SIGPIPE : printf(" SIGPIPE (Broken pipe)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGUSR1
    case SIGUSR1 : printf(" SIGUSR1 (Display info)"); sig = SIG_STAT; break;
#endif
#ifdef SIGUSR2
    case SIGUSR2 : printf(" SIGUSR2 (Save simulation)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGHUP
    case SIGHUP  : printf(" SIGHUP (Hangup/update)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGBUS
    case SIGBUS  : printf(" SIGBUS (Bus error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGURG
    case SIGURG  : printf(" SIGURG (Urgent socket condition)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGBREAK
    case SIGBREAK: printf(" SIGBREAK (Break signal, Ctrl-Break)"); sig = SIG_SAVE; break;
#endif
    default : printf(" (look at signal list for signification)"); sig = SIG_ABRT; break;
  }
  printf("\n");
  printf("# Simulation: %s (%s) \n", mcinstrument_name, mcinstrument_source);
  printf("# Breakpoint: %s ", mcsig_message);
  if (strstr(mcsig_message, "Save") && (sig == SIG_SAVE))
    sig = SIG_STAT;
  SIG_MESSAGE("sighandler");
  if (mcget_ncount() == 0)
    printf("(0 %%)\n" );
  else
  {
    printf("%.2f %% (%10.1f/%10.1f)\n", 100.0*mcget_run_num()/mcget_ncount(), 1.0*mcget_run_num(), 1.0*mcget_ncount());
  }
  t0 = (time_t)mcstartdate;
  t1 = time(NULL);
  printf("# Date:      %s", ctime(&t1));
  printf("# Started:   %s", ctime(&t0));

  if (sig == SIG_STAT)
  {
    printf("# " MCCODE_STRING ": Resuming simulation (continue)\n");
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_SAVE)
  {
    printf("# " MCCODE_STRING ": Saving data and resume simulation (continue)\n");
    mcsave(NULL);
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_TERM)
  {
    printf("# " MCCODE_STRING ": Finishing simulation (save results and exit)\n");
    mcfinally();
    exit(0);
  }
  else
  {
    fflush(stdout);
    perror("# Last I/O Error");
    printf("# " MCCODE_STRING ": Simulation stop (abort).\n");
// This portion of the signal handling only works on UNIX
#if defined(__unix__) || defined(__APPLE__)
    signal(sig, SIG_DFL); /* force to use default sighandler now */
    kill(getpid(), sig);  /* and trigger it with the current signal */
#endif
    exit(-1);
  }
#undef SIG_SAVE
#undef SIG_TERM
#undef SIG_STAT
#undef SIG_ABRT

} /* sighandler */
#endif /* !NOSIGNALS */

/*******************************************************************************
* mccode_main: McCode main() function.
*******************************************************************************/
int mccode_main(int argc, char *argv[])
{
/*  double run_num = 0; */
  time_t  t;
#ifdef USE_MPI
  char mpi_node_name[MPI_MAX_PROCESSOR_NAME];
  int  mpi_node_name_len;
#endif /* USE_MPI */

#ifdef MAC
  argc = ccommand(&argv);
#endif

#ifdef USE_MPI
  MPI_Init(&argc,&argv);
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_node_count); /* get number of nodes */
  MPI_Comm_rank(MPI_COMM_WORLD, &mpi_node_rank);
  MPI_Comm_set_name(MPI_COMM_WORLD, mcinstrument_name);
  MPI_Get_processor_name(mpi_node_name, &mpi_node_name_len);
#endif /* USE_MPI */

t = time(NULL);
mcseed = (long)t+(long)getpid();

#ifdef USE_MPI
/* *** print number of nodes *********************************************** */
  if (mpi_node_count > 1) {
    MPI_MASTER(
    printf("Simulation '%s' (%s): running on %i nodes (master is '%s', MPI version %i.%i).\n",
      mcinstrument_name, mcinstrument_source, mpi_node_count, mpi_node_name, MPI_VERSION, MPI_SUBVERSION);
    );
  }
#endif /* USE_MPI */
  
  mcstartdate = (long)t;  /* set start date before parsing options and creating sim file */

/* *** parse options ******************************************************* */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;
  mcinstrument_exe = argv[0]; /* store the executable path */
  /* read simulation parameters and options */
  mcparseoptions(argc, argv); /* sets output dir and format */
  
#ifdef USE_MPI
  if (mpi_node_count > 1) {
    /* share the same seed, then adapt random seed for each node */
    MPI_Bcast(&mcseed, 1, MPI_LONG, 0, MPI_COMM_WORLD); /* root sends its seed to slaves */
    mcseed += mpi_node_rank; /* make sure we use different seeds per node */
  }
#endif
  srandom(mcseed);

/* *** install sig handler, but only once !! after parameters parsing ******* */
#ifndef NOSIGNALS
#ifdef SIGQUIT
  if (signal( SIGQUIT ,sighandler) == SIG_IGN)
    signal( SIGQUIT,SIG_IGN);   /* quit (ASCII FS) */
#endif
#ifdef SIGABRT
  if (signal( SIGABRT ,sighandler) == SIG_IGN)
    signal( SIGABRT,SIG_IGN);   /* used by abort, replace SIGIOT in the future */
#endif
#ifdef SIGTERM
  if (signal( SIGTERM ,sighandler) == SIG_IGN)
    signal( SIGTERM,SIG_IGN);   /* software termination signal from kill */
#endif
#ifdef SIGUSR1
  if (signal( SIGUSR1 ,sighandler) == SIG_IGN)
    signal( SIGUSR1,SIG_IGN);   /* display simulation status */
#endif
#ifdef SIGUSR2
  if (signal( SIGUSR2 ,sighandler) == SIG_IGN)
    signal( SIGUSR2,SIG_IGN);
#endif
#ifdef SIGHUP
  if (signal( SIGHUP ,sighandler) == SIG_IGN)
    signal( SIGHUP,SIG_IGN);
#endif
#ifdef SIGILL
  if (signal( SIGILL ,sighandler) == SIG_IGN)
    signal( SIGILL,SIG_IGN);    /* illegal instruction (not reset when caught) */
#endif
#ifdef SIGFPE
  if (signal( SIGFPE ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* floating point exception */
#endif
#ifdef SIGBUS
  if (signal( SIGBUS ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* bus error */
#endif
#ifdef SIGSEGV
  if (signal( SIGSEGV ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);   /* segmentation violation */
#endif
#endif /* !NOSIGNALS */
  mcsiminfo_init(NULL); /* open SIM */
  SIG_MESSAGE("main (Init)");
  mcinit();
#ifndef NOSIGNALS
#ifdef SIGINT
  if (signal( SIGINT ,sighandler) == SIG_IGN)
    signal( SIGINT,SIG_IGN);    /* interrupt (rubout) only after INIT */
#endif
#endif /* !NOSIGNALS */

/* ================ main particle generation/propagation loop ================ */
#if defined (USE_MPI)
  /* sliced Ncount on each MPI node */
  mcncount = mpi_node_count > 1 ?
    floor(mcncount / mpi_node_count) :
    mcncount; /* number of rays per node */
#endif

/* main particle event loop */
while(mcrun_num < mcncount || mcrun_num < mcget_ncount())
  {
#ifndef NEUTRONICS
    mcgenstate();
#endif
    /* old init: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
    mcraytrace();
    mcrun_num++;
  }

#ifdef USE_MPI
 /* merge run_num from MPI nodes */
  if (mpi_node_count > 1) {
  double mcrun_num_double = (double)mcrun_num;
  mc_MPI_Sum(&mcrun_num_double, 1);
  mcrun_num = (unsigned long long)mcrun_num_double;
  }
#endif

/* save/finally executed by master node/thread */
  mcfinally();

#ifdef USE_MPI
  MPI_Finalize();
#endif /* USE_MPI */

  return 0;
} /* mccode_main */

#ifdef NEUTRONICS
/*Main neutronics function steers the McStas calls, initializes parameters etc */
/* Only called in case NEUTRONICS = TRUE */
void neutronics_main_(float *inx, float *iny, float *inz, float *invx, float *invy, float *invz, float *intime, float *insx, float *insy, float *insz, float *inw, float *outx, float *outy, float *outz, float *outvx, float *outvy, float *outvz, float *outtime, float *outsx, float *outsy, float *outsz, float *outwgt)
{

  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  /* External code governs iteration - McStas is iterated once per call to neutronics_main. I.e. below counter must be initiancated for each call to neutronics_main*/
  mcrun_num=0;

  time_t t;
  t = (time_t)mcstartdate;
  mcstartdate = t;  /* set start date before parsing options and creating sim file */
  mcinit();

  /* *** parse options *** */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;

  /* Set neutron state based on input from neutronics code */
  mcsetstate(*inx,*iny,*inz,*invx,*invy,*invz,*intime,*insx,*insy,*insz,*inw);

  /* main neutron event loop - runs only one iteration */

  //mcstas_raytrace(&mcncount); /* prior to McStas 1.12 */

  mcallowbackprop = 1; //avoid absorbtion from negative dt
  int argc=1;
  char *argv[0];
  int dummy = mccode_main(argc, argv);

  *outx =  mcnx;
  *outy =  mcny;
  *outz =  mcnz;
  *outvx =  mcnvx;
  *outvy =  mcnvy;
  *outvz =  mcnvz;
  *outtime =  mcnt;
  *outsx =  mcnsx;
  *outsy =  mcnsy;
  *outsz =  mcnsz;
  *outwgt =  mcnp;

  return;
} /* neutronics_main */

#endif /*NEUTRONICS*/

#endif /* !MCCODE_H */
/* End of file "mccode-r.c". */
/* End of file "mccode-r.c". */

#line 4856 "BIFROST.c"

#line 1 "mcstas-r.c"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system for McStas.
* Embedded within instrument in runtime mode.
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#include "mcstas-r.h"
#endif
#ifdef DANSE
#include "mcstas-globals.h"
#endif

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/

/*the magnet stack*/
#ifdef MC_POL_COMPAT
void (*mcMagnetPrecession) (double, double, double, double, double, double,
    double, double*, double*, double*, double, Coords, Rotation)=NULL;
Coords   mcMagnetPos;
Rotation mcMagnetRot;
double*  mcMagnetData                = NULL;
/* mcMagneticField(x, y, z, t, Bx, By, Bz) */
int (*mcMagneticField) (double, double, double, double,
    double*, double*, double*, void *) = NULL;
#endif

#ifndef MCSTAS_H

/*******************************************************************************
* mcstore_neutron: stores neutron coodinates into global array (per component)
*******************************************************************************/
void
mcstore_neutron(MCNUM *s, int index, double x, double y, double z,
               double vx, double vy, double vz, double t,
               double sx, double sy, double sz, double p)
{
    double *dptr = &s[11*index];
    *dptr++  = x;
    *dptr++  = y ;
    *dptr++  = z ;
    *dptr++  = vx;
    *dptr++  = vy;
    *dptr++  = vz;
    *dptr++  = t ;
    *dptr++  = sx;
    *dptr++  = sy;
    *dptr++  = sz;
    *dptr    = p ;
} /* mcstore_neutron */

/*******************************************************************************
* mcrestore_neutron: restores neutron coodinates from global array
*******************************************************************************/
void
mcrestore_neutron(MCNUM *s, int index, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *t,
               double *sx, double *sy, double *sz, double *p)
{
    double *dptr = &s[11*index];
    *x  =  *dptr++;
    *y  =  *dptr++;
    *z  =  *dptr++;
    *vx =  *dptr++;
    *vy =  *dptr++;
    *vz =  *dptr++;
    *t  =  *dptr++;
    *sx =  *dptr++;
    *sy =  *dptr++;
    *sz =  *dptr++;
    *p  =  *dptr;
} /* mcrestore_neutron */

/*******************************************************************************
* mcsetstate: transfer parameters into global McStas variables 
*******************************************************************************/
void
mcsetstate(double x, double y, double z, double vx, double vy, double vz,
           double t, double sx, double sy, double sz, double p)
{
  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  mcnx = x;
  mcny = y;
  mcnz = z;
  mcnvx = vx;
  mcnvy = vy;
  mcnvz = vz;
  mcnt = t;
  mcnsx = sx;
  mcnsy = sy;
  mcnsz = sz;
  mcnp = p;
} /* mcsetstate */

/*******************************************************************************
* mcgenstate: set default neutron parameters 
*******************************************************************************/
void
mcgenstate(void)
{
  mcsetstate(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  /* old initialisation: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
}

/* intersection routines ==================================================== */

/*******************************************************************************
* inside_rectangle: Check if (x,y) is inside rectangle (xwidth, yheight) 
* return 0 if outside and 1 if inside 
*******************************************************************************/
int inside_rectangle(double x, double y, double xwidth, double yheight)
{
  if (x>-xwidth/2 && x<xwidth/2 && y>-yheight/2 && y<yheight/2)
    return 1;
  else
    return 0;
}

/*******************************************************************************
 * box_intersect: compute time intersection with a box
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times dt_in and dt_out
 * This function written by Stine Nyborg, 1999. 
 *******************************************************************************/
int box_intersect(double *dt_in, double *dt_out,
                  double x, double y, double z,
                  double vx, double vy, double vz,
                  double dx, double dy, double dz)
{
  double x_in, y_in, z_in, tt, t[6], a, b;
  int i, count, s;

      /* Calculate intersection time for each of the six box surface planes
       *  If the box surface plane is not hit, the result is zero.*/

  if(vx != 0)
   {
    tt = -(dx/2 + x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[0] = tt;
    else
      t[0] = 0;

    tt = (dx/2 - x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[1] = tt;
    else
      t[1] = 0;
   }
  else
    t[0] = t[1] = 0;

  if(vy != 0)
   {
    tt = -(dy/2 + y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[2] = tt;
    else
      t[2] = 0;

    tt = (dy/2 - y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[3] = tt;
    else
      t[3] = 0;
   }
  else
    t[2] = t[3] = 0;

  if(vz != 0)
   {
    tt = -(dz/2 + z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[4] = tt;
    else
      t[4] = 0;

    tt = (dz/2 - z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[5] = tt;
    else
      t[5] = 0;
   }
  else
    t[4] = t[5] = 0;

  /* The intersection is evaluated and *dt_in and *dt_out are assigned */

  a = b = s = 0;
  count = 0;

  for( i = 0; i < 6; i = i + 1 )
    if( t[i] == 0 )
      s = s+1;
    else if( count == 0 )
    {
      a = t[i];
      count = 1;
    }
    else
    {
      b = t[i];
      count = 2;
    }

  if ( a == 0 && b == 0 )
    return 0;
  else if( a < b )
  {
    *dt_in = a;
    *dt_out = b;
    return 1;
  }
  else
  {
    *dt_in = b;
    *dt_out = a;
    return 1;
  }

} /* box_intersect */

/*******************************************************************************
 * cylinder_intersect: compute intersection with a cylinder
 * returns 0 when no intersection is found
 *      or 2/4/8/16 bits depending on intersection,
 *     and resulting times t0 and t1
 * Written by: EM,NB,ABA 4.2.98 
  *******************************************************************************/
int
cylinder_intersect(double *t0, double *t1, double x, double y, double z,
                   double vx, double vy, double vz, double r, double h)
{
  double D, t_in, t_out, y_in, y_out;
  int ret=1;

  D = (2*vx*x + 2*vz*z)*(2*vx*x + 2*vz*z)
    - 4*(vx*vx + vz*vz)*(x*x + z*z - r*r);

  if (D>=0)
  {
    if (vz*vz + vx*vx) {
      t_in  = (-(2*vz*z + 2*vx*x) - sqrt(D))/(2*(vz*vz + vx*vx));
      t_out = (-(2*vz*z + 2*vx*x) + sqrt(D))/(2*(vz*vz + vx*vx));
    } else if (vy) { /* trajectory parallel to cylinder axis */
      t_in = (-h/2-y)/vy;
      t_out = (h/2-y)/vy;
      if (t_in>t_out){
        double tmp=t_in;
        t_in=t_out;t_out=tmp;
      }
    } else return 0;
    y_in = vy*t_in + y;
    y_out =vy*t_out + y;

    if ( (y_in > h/2 && y_out > h/2) || (y_in < -h/2 && y_out < -h/2) )
      return 0;
    else
    {
      if (y_in > h/2)
        { t_in = ((h/2)-y)/vy; ret += 2; }
      else if (y_in < -h/2)
        { t_in = ((-h/2)-y)/vy; ret += 4; }
      if (y_out > h/2)
        { t_out = ((h/2)-y)/vy; ret += 8; }
      else if (y_out < -h/2)
        { t_out = ((-h/2)-y)/vy; ret += 16; }
    }
    *t0 = t_in;
    *t1 = t_out;
    return ret;
  }
  else
  {
    *t0 = *t1 = 0;
    return 0;
  }
} /* cylinder_intersect */


/*******************************************************************************
 * sphere_intersect: Calculate intersection between a line and a sphere.
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times t0 and t1 
 *******************************************************************************/
int
sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r)
{
  double A, B, C, D, v;

  v = sqrt(vx*vx + vy*vy + vz*vz);
  A = v*v;
  B = 2*(x*vx + y*vy + z*vz);
  C = x*x + y*y + z*z - r*r;
  D = B*B - 4*A*C;
  if(D < 0)
    return 0;
  D = sqrt(D);
  *t0 = (-B - D) / (2*A);
  *t1 = (-B + D) / (2*A);
  return 1;
} /* sphere_intersect */

/*******************************************************************************
 * plane_intersect: Calculate intersection between a plane and a line.
 * returns 0 when no intersection is found (i.e. line is parallel to the plane)
 * returns 1 or -1 when intersection time is positive and negative respectively
 *******************************************************************************/
int
plane_intersect(double *t, double x, double y, double z,
                 double vx, double vy, double vz, double nx, double ny, double nz, double wx, double wy, double wz)
{
  double s;
  if (fabs(s=scalar_prod(nx,ny,nz,vx,vy,vz))<FLT_EPSILON) return 0;
  *t = - scalar_prod(nx,ny,nz,x-wx,y-wy,z-wz)/s;
  if (*t<0) return -1;
  else return 1;
} /* plane_intersect */

#endif /* !MCSTAS_H */
/* End of file "mcstas-r.c". */

#line 5216 "BIFROST.c"
#ifdef MC_TRACE_ENABLED
int mctraceenabled = 1;
#else
int mctraceenabled = 0;
#endif
#define MCSTAS "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\"
int mcdefaultmain = 1;
char mcinstrument_name[] = "BIFROST";
char mcinstrument_source[] = "BIFROST.instr";
char *mcinstrument_exe=NULL; /* will be set to argv[0] in main */
int main(int argc, char *argv[]){return mccode_main(argc, argv);}
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);

/* Shared user declarations for all components 'Elliptic_guide_gravity'. */
#line 187 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
/*****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.h
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Depends on read_table-lib
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions.
*
* This library may be used directly as an external library. It has no dependency
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#define READ_TABLE_LIB_H "$Revision$"

#define READ_TABLE_STEPTOL  0.04 /* tolerancy for constant step approx */

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#ifdef MAC
#define MC_PATHSEP_C ':'
#define MC_PATHSEP_S ":"
#else  /* !MAC */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MC_PATHSEP_C */

#ifndef MCSTAS
#ifdef WIN32
#define MCSTAS "C:\\mcstas\\lib"
#else  /* !WIN32 */
#ifdef MAC
#define MCSTAS ":mcstas:lib" /* ToDo: What to put here? */
#else  /* !MAC */
#define MCSTAS "/usr/local/lib/mcstas"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MCSTAS */

#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

  typedef struct struct_table
  {
    char    filename[1024];
    long    filesize;
    char   *header;  /* text header, e.g. comments */
    double *data;    /* vector { x[0], y[0], ... x[n-1], y[n-1]... } */
    double  min_x;   /* min value of first column */
    double  max_x;   /* max value of first column */
    double  step_x;  /* minimal step value of first column */
    long    rows;    /* number of rows in matrix block */
    long    columns; /* number of columns in matrix block */

    long    begin;   /* start fseek index of block */
    long    end;     /* stop  fseek index of block */
    long    block_number;  /* block index. 0 is catenation of all */
    long    array_length;  /* number of elements in the t_Table array */
    char    monotonic;     /* true when 1st column/vector data is monotonic */
    char    constantstep;  /* true when 1st column/vector data has constant step */
    char    method[32];    /* interpolation method: nearest, linear */
  } t_Table;

typedef struct t_Read_table_file_item {
    int ref_count;
    t_Table *table_ref;
} t_Read_table_file_item;

typedef enum enum_Read_table_file_actions {STORE,FIND,GC}  t_Read_table_file_actions;

/* read_table-lib function prototypes */
/* ========================================================================= */

/* 'public' functions */
long     Table_Read              (t_Table *Table, char *File, long block_number);
long     Table_Read_Offset       (t_Table *Table, char *File, long block_number,
                                  long *offset, long max_lines);
long     Table_Read_Offset_Binary(t_Table *Table, char *File, char *Type,
                                  long *Offset, long Rows, long Columns);
long     Table_Rebin(t_Table *Table); /* rebin table with regular 1st column and interpolate all columns 2:end */
long     Table_Info (t_Table Table);
double   Table_Index(t_Table Table,   long i, long j); /* get indexed value */
double   Table_Value(t_Table Table, double X, long j); /* search X in 1st column and return interpolated value in j-column */
t_Table *Table_Read_Array(char *File, long *blocks);
void     Table_Free_Array(t_Table *Table);
long     Table_Info_Array(t_Table *Table);
int      Table_SetElement(t_Table *Table, long i, long j, double value);
long     Table_Init(t_Table *Table, long rows, long columns); /* create a Table */
double   Table_Value2d(t_Table Table, double X, double Y);    /* same as Table_Index with non-integer indices and 2d interpolation */
MCDETECTOR Table_Write(t_Table Table, char*file, char*xl, char*yl, 
           double x1, double x2, double y1, double y2); /* write Table to disk */
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier);
t_Table *Table_File_List_find(char *name, int block, int offset);
int Table_File_List_gc(t_Table *tab);
void *Table_File_List_store(t_Table *tab);

#define Table_ParseHeader(header, ...) \
  Table_ParseHeader_backend(header,__VA_ARGS__,NULL);

char **Table_ParseHeader_backend(char *header, ...);

/* private functions */
void Table_Free(t_Table *Table);
long Table_Read_Handle(t_Table *Table, FILE *fid, long block_number, long max_lines, char *name);
static void Table_Stat(t_Table *Table);
double Table_Interp1d(double x, double x1, double y1, double x2, double y2);
double Table_Interp1d_nearest(double x, double x1, double y1, double x2, double y2);
double Table_Interp2d(double x, double y, double x1, double y1, double x2, double y2,
double z11, double z12, double z21, double z22);

#endif

/* end of read_table-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas CVS_090504
* Version: $Revision: 5052 $
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#endif


/*******************************************************************************
 * void *Table_File_List_Handler(action, item, item_modifier)
 *   ACTION: handle file entries in the read_table-lib file list. If a file is read - it is supposed to be
 *   stored in a list such that we can avoid reading the same file many times.
 *   input  action: FIND, STORE, GC. check if file exists in the list, store an item in the list, or check if it can be garbage collected.
 *   input item: depends on the action.
 *    FIND)  item is a filename, and item_modifier is the block number
 *    STORE) item is the Table to store - item_modifier is ignored
 *    GC)    item is the Table to check. If it has a ref_count >1 then this is simply decremented.
 *   return  depends on the action
 *    FIND)  return a reference to a table+ref_count item if found - NULL otherwise. I.e. NULL means the file has not been read before and must be read again.
 *    STORE) return NULL always
 *    GC)    return NULL if no garbage collection is needed, return an adress to the t_Table which should be garbage collected. 0x1 is returned if
 *           the item is not found in the list
*******************************************************************************/
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier){

    /* logic here is Read_Table should include a call to FIND. If found the return value shoud just be used as
     * if the table had been read. If not found then read the table and STORE.
     * Table_Free should include a call to GC. If this returns non-NULL then we shoudl proceed with freeing the memory
     * associated with the table item - otherwise do nothing since there are more references that may need it.*/ 

    static t_Read_table_file_item read_table_file_list[1024];  
    static int read_table_file_count=0;

    t_Read_table_file_item *tr;
    switch(action){
        case FIND:
            /*interpret data item as a filename, if it is found return a pointer to the table and increment refcount.
             * if not found return the item itself*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                int i=*((int*) item_modifier);
                int j=*( ((int*) item_modifier)+1);
                if ( !strcmp(tr->table_ref->filename,(char *) item) &&
                        tr->table_ref->block_number==i && tr->table_ref->begin==j ){
                    tr->ref_count++;
                    return (void *) tr;
                }
                tr++;
            }
            return NULL;
        case STORE:
            /*find an available slot and store references to table there*/
            tr=&(read_table_file_list[read_table_file_count++]);
            tr->table_ref=(t_Table *)calloc(1,sizeof(t_Table));
            /*copy the contents of the table handle*/
            *(tr->table_ref)= *((t_Table *) item);
            tr->ref_count++;
            return NULL;
        case GC:
            /* Should this item be garbage collected (freed) - if so scratch the entry and return the address of the item - 
             * else decrement ref_count and return NULL.
             * A non-NULL return expects the item to actually be freed afterwards.*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                if ( tr->table_ref->data ==((t_Table *)item)->data && 
                        tr->table_ref->block_number == ((t_Table *)item)->block_number){
                    /*matching item found*/
                    if (tr->ref_count>1){
                        /*the item is found - no garbage collection needed*/
                        tr->ref_count--;
                        return NULL;
                    }else{
                        /* The item is found - move remaining list items up one slot,
                         * and return the table for garbage collection by caller*/
                        while (tr->table_ref!=NULL){
                            *tr=*(tr+1);
                            tr++;
                        }
                        read_table_file_count--;
                        return (t_Table *) item;
                    }
                }
                tr++;
            }
            return (void *)0x1 ;/*item not found*/ 
    } 

}

/* Access functions to the handler*/

/********************************************
 * t_Table *Table_File_List_find(char *name, int block, int offset)
 * input name: filename to search for in the file list
 * input block: data block in the file as each file may contain more than 1 data block.
 * return a ref. to a table if it is found (you may use this pointer and skip reading the file), NULL otherwise (i.e. go ahead and read the file)
*********************************************/
t_Table *Table_File_List_find(char *name, int block, int offset){
    int vars[2]={block,offset};
    t_Read_table_file_item *item = Table_File_List_Handler(FIND,name, vars);
    if (item == NULL){
        return NULL;
    }else{
        return item->table_ref;
    }
}
/********************************************
 * int Table_File_List_gc(t_Table *tab)
 * input tab: the table to check for references.
 * return 0: no garbage collection needed
 *        1: Table's data and header (at least) should be freed.
*********************************************/
int Table_File_List_gc(t_Table *tab){
    void *rval=Table_File_List_Handler(GC,tab,0);
    if (rval==NULL) return 0;
    else return 1;
}


/*****************************************************************************
 * void *Table_File_List_store(t_Table *tab)
 * input tab: pointer to table to store.
 * return None. 
*******************************************************************************/
void *Table_File_List_store(t_Table *tab){
    Table_File_List_Handler(STORE,tab,0);
}


/*******************************************************************************
* FILE *Open_File(char *name, char *Mode, char *path)
*   ACTION: search for a file and open it. Optionally return the opened path.
*   input   name:  file name from which table should be extracted
*           mode: "r", "w", "a" or any valid fopen mode
*           path:  NULL or a pointer to at least 1024 allocated chars
*   return  initialized file handle or NULL in case of error
*******************************************************************************/

  FILE *Open_File(char *File, const char *Mode, char *Path)
  {
    char path[1024];
    FILE *hfile = NULL;
    
    if (!File || File[0]=='\0')                     return(NULL);
    if (!strcmp(File,"NULL") || !strcmp(File,"0"))  return(NULL);
    
    /* search in current or full path */
    strncpy(path, File, 1024);
    hfile = fopen(path, Mode);
    if(!hfile)
    {
      char dir[1024];

      if (!hfile && mcinstrument_source && strlen(mcinstrument_source)) /* search in instrument source location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_source, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_source;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_source, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile && mcinstrument_exe && strlen(mcinstrument_exe)) /* search in PWD instrument executable location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_exe, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_exe;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_exe, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile) /* search in HOME or . */
      {
        strcpy(dir, getenv("HOME") ? getenv("HOME") : ".");
        snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MCSTAS/data */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "data", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MVCSTAS/contrib */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "contrib", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if(!hfile)
      {
        fprintf(stderr, "Error: Could not open input file '%s' (Open_File)\n", File);
        return (NULL);
      }
    }
    if (Path) strncpy(Path, path, 1024);
    return(hfile);
  } /* end Open_File */

/*******************************************************************************
* long Read_Table(t_Table *Table, char *name, int block_number)
*   ACTION: read a single Table from a text file
*   input   Table: pointer to a t_Table structure
*           name:  file name from which table should be extracted
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* File is opened, read and closed
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebinned with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read(t_Table *Table, char *File, long block_number)
  { /* reads all or a single data block from 'file' and returns a Table structure  */
    return(Table_Read_Offset(Table, File, block_number, NULL, 0));
  } /* end Table_Read */

/*******************************************************************************
* long Table_Read_Offset(t_Table *Table, char *name, int block_number, long *offset
*                        long max_rows)
*   ACTION: read a single Table from a text file, starting at offset
*     Same as Table_Read(..) except:
*   input   offset:    pointer to an offset (*offset should be 0 at start)
*           max_rows: max number of data rows to read from file (0 means all)
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset(t_Table *Table, char *File,
                         long block_number, long *offset,
                         long max_rows)
  { /* reads all/a data block in 'file' and returns a Table structure  */
    FILE *hfile;
    long  nelements=0;
    long  begin=0;
    long  filesize=0;
    char  name[1024];
    char  path[1024];
    struct stat stfile;

    /*Need to be able to store the pointer*/
    if (!Table) return(-1);
    
    //if (offset && *offset) snprintf(name, 1024, "%s@%li", File, *offset);
    //else                   
    strncpy(name, File, 1024);
    if(offset && *offset){
        begin=*offset;
    }
    /* Check if the table has already been read from file.
     * If so just reuse the table, if not (this is flagged by returning NULL
     * set up a new table and read the data into it */
    t_Table *tab_p= Table_File_List_find(name,block_number,begin);
    if ( tab_p!=NULL ){
        /*table was found in the Table_File_List*/
        printf("Reusing input file '%s' (Table_Read_Offset)\n", name);
        *Table=*tab_p;
        return Table->rows*Table->columns;
    }

    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read_Offset)\n", path);
      );
    }
    
    /* read file state */
    stat(path,&stfile); filesize = stfile.st_size;
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    
    Table_Init(Table, 0, 0);

    /* read file content and set the Table */
    nelements = Table_Read_Handle(Table, hfile, block_number, max_rows, name);
    Table->begin = begin;
    Table->end   = ftell(hfile);
    Table->filesize = (filesize>0 ? filesize : 0);
    Table_Stat(Table);
    
    Table_File_List_store(Table);

    if (offset) *offset=Table->end;
    fclose(hfile);
    return(nelements);

  } /* end Table_Read_Offset */

/*******************************************************************************
* long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
*                               long *offset, long rows, long columns)
*   ACTION: read a single Table from a binary file, starting at offset
*     Same as Table_Read_Offset(..) except that it handles binary files.
*   input   type: may be "float"/NULL or "double"
*           offset: pointer to an offset (*offset should be 0 at start)
*           rows   : number of rows (0 means read all)
*           columns: number of columns
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
                                long *offset, long rows, long columns)
  { /* reads all/a data block in binary 'file' and returns a Table structure  */
    long    nelements, sizeofelement;
    long    filesize;
    FILE   *hfile;
    char    path[1024];
    struct stat stfile;
    double *data;
    long    i;
    long    begin;

    if (!Table) return(-1);

    Table_Init(Table, 0, 0);
    
    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read, Binary)\n", path);
      );
    }
    
    /* read file state */
    stat(File,&stfile);
    filesize = stfile.st_size;
    Table->filesize=filesize;
    
    /* read file content */
    if (type && !strcmp(type,"double")) sizeofelement = sizeof(double);
    else  sizeofelement = sizeof(float);
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    if (rows && filesize > sizeofelement*columns*rows)
      nelements = columns*rows;
    else nelements = (long)(filesize/sizeofelement);
    if (!nelements || filesize <= *offset) return(0);
    data    = (double*)malloc(nelements*sizeofelement);
    if (!data) {
      fprintf(stderr,"Error: allocating %ld elements for %s file '%s'. Too big (Table_Read_Offset_Binary).\n", nelements, type, File);
      exit(-1);
    }
    nelements = fread(data, sizeofelement, nelements, hfile);

    if (!data || !nelements)
    {
      fprintf(stderr,"Error: reading %ld elements from %s file '%s' (Table_Read_Offset_Binary)\n", nelements, type, File);
      exit(-1);
    }
    Table->begin   = begin;
    Table->end     = ftell(hfile);
    if (offset) *offset=Table->end;
    fclose(hfile);
    data = (double*)realloc(data, (double)nelements*sizeofelement);
    /* copy file data into Table */
    if (type && !strcmp(type,"double")) Table->data = data;
    else {
      float  *s;
      double *dataf;
      s     = (float*)data;
      dataf = (double*)malloc(sizeof(double)*nelements);
      for (i=0; i<nelements; i++)
        dataf[i]=s[i];
      free(data);
      Table->data = dataf;
    }
    strncpy(Table->filename, File, 1024);
    Table->rows    = nelements/columns;
    Table->columns = columns;
    Table->array_length = 1;
    Table->block_number = 1;

    Table_Stat(Table);

    return(nelements);
  } /* end Table_Read_Offset_Binary */

/*******************************************************************************
* long Table_Read_Handle(t_Table *Table, FILE *fid, int block_number, long max_rows, char *name)
*   ACTION: read a single Table from a text file handle (private)
*   input   Table:pointer to a t_Table structure
*           fid:  pointer to FILE handle
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*           max_rows: if non 0, only reads that number of lines
*   return  initialized single Table t_Table structure containing data, header, ...
*           modified Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebined with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read_Handle(t_Table *Table, FILE *hfile,
                         long block_number, long max_rows, char *name)
  { /* reads all/a data block from 'file' handle and returns a Table structure  */
    double *Data;
    char *Header              = NULL;
    long  malloc_size         = CHAR_BUF_LENGTH;
    long  malloc_size_h       = 4096;
    long  Rows = 0,   Columns = 0;
    long  count_in_array      = 0;
    long  count_in_header     = 0;
    long  block_Current_index = 0;
    char  flag_End_row_loop   = 0;

    if (!Table) return(-1);
    Table_Init(Table, 0, 0);
    if (name && name[0]!='\0') strncpy(Table->filename, name, 1024);

    if(!hfile) {
       fprintf(stderr, "Error: File handle is NULL (Table_Read_Handle).\n");
       return (-1);
    }
    Header = (char*)  calloc(malloc_size_h, sizeof(char));
    Data   = (double*)calloc(malloc_size,   sizeof(double));
    if ((Header == NULL) || (Data == NULL)) {
       fprintf(stderr, "Error: Could not allocate Table and Header (Table_Read_Handle).\n");
       return (-1);
    }

    int flag_In_array = 0;
    do { /* while (!flag_End_row_loop) */
      char  line[1024*CHAR_BUF_LENGTH];
      long  back_pos=0;   /* ftell start of line */

      back_pos = ftell(hfile);
      if (fgets(line, 1024*CHAR_BUF_LENGTH, hfile) != NULL) { /* analyse line */
        /* first skip blank and tabulation characters */
        int i = strspn(line, " \t");

        /* handle comments: stored in header */
        if (NULL != strchr("#%;/", line[i]))
        { /* line is a comment */
          count_in_header += strlen(line);
          if (count_in_header >= malloc_size_h) {
            /* if succeed and in array : add (and realloc if necessary) */
            malloc_size_h = count_in_header+4096;
            Header        = (char*)realloc(Header, malloc_size_h*sizeof(char));
          }
          strncat(Header, line, 4096);
          flag_In_array=0;
          /* exit line and file if passed desired block */
          if (block_number > 0 && block_number == block_Current_index) {
            flag_End_row_loop = 1;
          }

          /* Continue with next line */
          continue;
        }

        /* get the number of columns splitting line with strtok */
        char  *lexeme;
        char  flag_End_Line = 0;
        long  block_Num_Columns = 0;
        const char seps[] = " ,;\t\n\r";

        lexeme = strtok(line, seps);
        while (!flag_End_Line) {
          if ((lexeme != NULL) && (lexeme[0] != '\0')) {
            /* reading line: the token is not empty */
            double X;
            int    count=1;
            /* test if we have 'NaN','Inf' */
            if (!strncasecmp(lexeme,"NaN",3))
              X = 0;
            else if (!strncasecmp(lexeme,"Inf",3) || !strncasecmp(lexeme,"+Inf",4))
              X = FLT_MAX;
            else if (!strncasecmp(lexeme,"-Inf",4))
              X = -FLT_MAX;
            else
              count = sscanf(lexeme,"%lg",&X);
            if (count == 1) {
              /* reading line: the token is a number in the line */
              if (!flag_In_array) {
                /* reading num: not already in a block: starts a new data block */
                block_Current_index++;
                flag_In_array    = 1;
                block_Num_Columns= 0;
                if (block_number > 0) {
                  /* initialise a new data block */
                  Rows = 0;
                  count_in_array = 0;
                } /* else append */
              }
              /* reading num: all blocks or selected block */
              if (flag_In_array && (block_number == 0 ||
                  block_number == block_Current_index)) {
                /* starting block: already the desired number of rows ? */
                if (block_Num_Columns == 0 &&
                    max_rows > 0 && Rows >= max_rows) {
                  flag_End_Line      = 1;
                  flag_End_row_loop  = 1;
                  flag_In_array      = 0;
                  /* reposition to begining of line (ignore line) */
                  fseek(hfile, back_pos, SEEK_SET);
                } else { /* store into data array */
                  if (count_in_array >= malloc_size) {
                    /* realloc data buffer if necessary */
                    malloc_size = count_in_array+CHAR_BUF_LENGTH;
                    Data = (double*) realloc(Data, malloc_size*sizeof(double));
                    if (Data == NULL) {
                      fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Handle).\n",
                              malloc_size*sizeof(double));
                      return (-1);
                    }
                  }
                  if (0 == block_Num_Columns) Rows++;
                  Data[count_in_array] = X;
                  count_in_array++;
                  block_Num_Columns++;
                }
              } /* reading num: end if flag_In_array */
            } /* end reading num: end if sscanf lexeme -> numerical */
            else {
              /* reading line: the token is not numerical in that line. end block */
              if (block_Current_index == block_number) {
                flag_End_Line = 1;
                flag_End_row_loop = 1;
              } else {
                flag_In_array = 0;
                flag_End_Line = 1;
              }
            }
          }
          else {
            /* no more tokens in line */
            flag_End_Line = 1;
            if (block_Num_Columns > 0) Columns = block_Num_Columns;
          }

          // parse next token
          lexeme = strtok(NULL, seps);

        } /* while (!flag_End_Line) */
      } /* end: if fgets */
      else flag_End_row_loop = 1; /* else fgets : end of file */

    } while (!flag_End_row_loop); /* end while flag_End_row_loop */

    Table->block_number = block_number;
    Table->array_length = 1;

    // shrink header to actual size (plus terminating 0-byte)
    if (count_in_header) {
      Header = (char*)realloc(Header, count_in_header*sizeof(char) + 1);
    }
    Table->header = Header;

    if (count_in_array*Rows*Columns == 0)
    {
      Table->rows         = 0;
      Table->columns      = 0;
      free(Data);
      return (0);
    }
    if (Rows * Columns != count_in_array)
    {
      fprintf(stderr, "Warning: Read_Table :%s %s Data has %li values that should be %li x %li\n",
        (Table->filename ? Table->filename : ""),
        (!block_number ? " catenated" : ""),
        count_in_array, Rows, Columns);
      Columns = count_in_array; Rows = 1;
    }
    Data     = (double*)realloc(Data, count_in_array*sizeof(double));
    Table->data         = Data;
    Table->rows         = Rows;
    Table->columns      = Columns;

    return (count_in_array);

  } /* end Table_Read_Handle */

/*******************************************************************************
* long Table_Rebin(t_Table *Table)
*   ACTION: rebin a single Table, sorting 1st column in ascending order
*   input   Table: single table containing data.
*                  The data block is reallocated in this process
*   return  updated Table with increasing, evenly spaced first column (index 0)
*           number of data elements (-1: error, 0:empty data)
*******************************************************************************/
  long Table_Rebin(t_Table *Table)
  {
    double new_step=0;
    long   i;
    /* performs linear interpolation on X axis (0-th column) */

    if (!Table) return(-1);
    if (!Table->data 
    || Table->rows*Table->columns == 0 || !Table->step_x)
      return(0);
    Table_Stat(Table); /* recompute statitstics and minimal step */
    new_step = Table->step_x; /* minimal step in 1st column */

    if (!(Table->constantstep)) /* not already evenly spaced */
    {
      long Length_Table;
      double *New_Table;

      Length_Table = ceil(fabs(Table->max_x - Table->min_x)/new_step)+1;
      New_Table    = (double*)malloc(Length_Table*Table->columns*sizeof(double));

      for (i=0; i < Length_Table; i++)
      {
        long   j;
        double X;
        X = Table->min_x + i*new_step;
        New_Table[i*Table->columns] = X;
        for (j=1; j < Table->columns; j++)
          New_Table[i*Table->columns+j]
                = Table_Value(*Table, X, j);
      } /* end for i */

      Table->rows = Length_Table;
      Table->step_x = new_step;
      Table->max_x = Table->min_x + (Length_Table-1)*new_step; 
      /*max might not be the same anymore
       * Use Length_Table -1 since the first and laset rows are the limits of the defined interval.*/
      free(Table->data);
      Table->data = New_Table;
      Table->constantstep=1;
    } /* end else (!constantstep) */
    return (Table->rows*Table->columns);
  } /* end Table_Rebin */

/*******************************************************************************
* double Table_Index(t_Table Table, long i, long j)
*   ACTION: read an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*   return  Value = data[i][j]
* Returns Value from the i-th row, j-th column of Table
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif

double Table_Index(t_Table Table, long i, long j)
{
  long AbsIndex;

  if (Table.rows == 1 || Table.columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table.columns*Table.rows - 1);
    i = 0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table.rows - 1);
    j = MIN(MAX(0, j), Table.columns - 1);
  }

  /* handle vectors specifically */
  AbsIndex = i*(Table.columns)+j;

  if (Table.data != NULL)
    return (Table.data[AbsIndex]);
  else
    return 0;
} /* end Table_Index */

/*******************************************************************************
* void Table_SetElement(t_Table *Table, long i, long j, double value)
*   ACTION: set an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*           value = data[i][j]
* Returns 0 in case of error
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/
int Table_SetElement(t_Table *Table, long i, long j,
                     double value)
{
  long AbsIndex;

  if (Table->rows == 1 || Table->columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table->columns*Table->rows - 1); i=0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table->rows - 1);
    j = MIN(MAX(0, j), Table->columns - 1);
  }

  AbsIndex = i*(Table->columns)+j;
  if (Table->data != NULL) {
    Table->data[AbsIndex] = value;
    return 1;
  }

  return 0;
} /* end Table_SetElement */

/*******************************************************************************
* double Table_Value(t_Table Table, double X, long j)
*   ACTION: read column [j] of a single Table at row which 1st column is X
*   input   Table: table containing data.
*           X : data value in the first column (index 0)
*           j : index of column from which is extracted the Value (0:Columns-1)
*   return  Value = data[index for X][j] with linear interpolation
* Returns Value from the j-th column of Table corresponding to the
* X value for the 1st column (index 0)
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
double Table_Value(t_Table Table, double X, long j)
{
  long   Index = -1;
  double X1=0, Y1=0, X2=0, Y2=0;
  double ret=0;

  if (X > Table.max_x) return Table_Index(Table,Table.rows-1  ,j);
  if (X < Table.min_x) return Table_Index(Table,0  ,j);

  // Use constant-time lookup when possible
  if(Table.constantstep) {
    Index = (long)floor(
              (X - Table.min_x) / (Table.max_x - Table.min_x) * (Table.rows-1));
    X1 = Table_Index(Table,Index  ,0);
    X2 = Table_Index(Table,Index+1,0);
  }
  // Use binary search on large, monotonic tables
  else if(Table.monotonic && Table.rows > 100) {
    long left = Table.min_x;
    long right = Table.max_x;

    while (!((X1 <= X) && (X < X2)) && (right - left > 1)) {
      Index = (left + right) / 2;

      X1 = Table_Index(Table, Index-1, 0);
      X2 = Table_Index(Table, Index,   0);

      if (X < X1) {
        right = Index;
      } else {
        left  = Index;
      }
    }
  }

  // Fall back to linear search, if no-one else has set X1, X2 correctly
  if (!((X1 <= X) && (X < X2))) {
    /* look for index surrounding X in the table -> Index */
    for (Index=1; Index < Table.rows-1; Index++) {
        X1 = Table_Index(Table, Index-1,0);
        X2 = Table_Index(Table, Index  ,0);
        if ((X1 <= X) && (X < X2)) break;
      } /* end for Index */
  }

  Y1 = Table_Index(Table,Index-1,j);
  Y2 = Table_Index(Table,Index  ,j);

  if (!strcmp(Table.method,"linear")) {
    ret = Table_Interp1d(X, X1,Y1, X2,Y2);
  }
  else if (!strcmp(Table.method,"nearest")) {
    ret = Table_Interp1d_nearest(X, X1,Y1, X2,Y2);
  }

  return ret;
} /* end Table_Value */

/*******************************************************************************
* double Table_Value2d(t_Table Table, double X, double Y)
*   ACTION: read element [X,Y] of a matrix Table
*   input   Table: table containing data.
*           X : row index, may be non integer
*           Y : column index, may be non integer
*   return  Value = data[index X][index Y] with bi-linear interpolation
* Returns Value for the indices [X,Y]
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
  double Table_Value2d(t_Table Table, double X, double Y)
  {
    long   x1,x2,y1,y2;
    double z11,z12,z21,z22;
    double ret=0;

    x1 = (long)floor(X);
    y1 = (long)floor(Y);

    if (x1 > Table.rows-1 || x1 < 0) {
      x2 = x1;
    } else {
      x2 = x1 + 1;
    }

    if (y1 > Table.columns-1 || y1 < 0) {
      y2 = y1;
    } else {
      y2 = y1 + 1;
    }

    z11 = Table_Index(Table, x1, y1);

    if (y2 != y1) z12=Table_Index(Table, x1, y2); else z12 = z11;
    if (x2 != x1) z21=Table_Index(Table, x2, y1); else z21 = z11;
    if (y2 != y1) z22=Table_Index(Table, x2, y2); else z22 = z21;

    if (!strcmp(Table.method,"linear"))
      ret = Table_Interp2d(X,Y, x1,y1,x2,y2, z11,z12,z21,z22);
    else {
      if (fabs(X-x1) < fabs(X-x2)) {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z11; else ret = z12;
      } else {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z21; else ret = z22;
      }
    }
    return ret;
  } /* end Table_Value2d */


/*******************************************************************************
* void Table_Free(t_Table *Table)
*   ACTION: free a single Table
*   return: empty Table
*******************************************************************************/
  void Table_Free(t_Table *Table)
  {
    if( !Table_File_List_gc(Table) ){
       return;
    } 
    if (!Table) return;
    if (Table->data   != NULL) free(Table->data);
    if (Table->header != NULL) free(Table->header);
    Table->data   = NULL;
    Table->header = NULL;
  } /* end Table_Free */

/******************************************************************************
* void Table_Info(t_Table Table)
*    ACTION: print informations about a single Table
*******************************************************************************/
  long Table_Info(t_Table Table)
  {
    char buffer[256];
    long ret=0;

    if (!Table.block_number) strcpy(buffer, "catenated");
    else sprintf(buffer, "block %li", Table.block_number);
    printf("Table from file '%s' (%s)",
      Table.filename ? Table.filename : "", buffer);
    if ((Table.data != NULL) && (Table.rows*Table.columns))
    {
      printf(" is %li x %li ", Table.rows, Table.columns);
      if (Table.rows*Table.columns > 1)
        printf("(x=%g:%g)", Table.min_x, Table.max_x);
      else printf("(x=%g) ", Table.min_x);
      ret = Table.rows*Table.columns;
      if (Table.monotonic)    printf(", monotonic");
      if (Table.constantstep) printf(", constant step");
      printf(". interpolation: %s\n", Table.method);
    }
    else printf(" is empty.\n");

    if (Table.header && strlen(Table.header)) {
      char *header;
      int  i;
      header = malloc(80);
      if (!header) return(ret);
      for (i=0; i<80; header[i++]=0);
      strncpy(header, Table.header, 75);
      if (strlen(Table.header) > 75) {
        strcat( header, " ...");
      }
      for (i=0; i<strlen(header); i++)
        if (header[i] == '\n' || header[i] == '\r') header[i] = ';';
      printf("  '%s'\n", header);
      free(header);
    }

    return(ret);
  } /* end Table_Info */

/******************************************************************************
* long Table_Init(t_Table *Table, m, n)
*   ACTION: initialise a Table to empty m by n table
*   return: empty Table
******************************************************************************/
long Table_Init(t_Table *Table, long rows, long columns)
{
  double *data=NULL;
  long   i;

  if (!Table) return(0);

  Table->header  = NULL;
  Table->filename[0]= '\0';
  Table->filesize= 0;
  Table->min_x   = 0;
  Table->max_x   = 0;
  Table->step_x  = 0;
  Table->block_number = 0;
  Table->array_length = 0;
  Table->monotonic    = 0;
  Table->constantstep = 0;
  Table->begin   = 0;
  Table->end     = 0;
  strcpy(Table->method,"linear");

  if (rows*columns >= 1) {
    data    = (double*)malloc(rows*columns*sizeof(double));
    if (data) for (i=0; i < rows*columns; data[i++]=0);
    else {
      fprintf(stderr,"Error: allocating %ld double elements."
                     "Too big (Table_Init).\n", rows*columns);
      rows = columns = 0;
    }
  }
  Table->rows    = (rows >= 1 ? rows : 0);
  Table->columns = (columns >= 1 ? columns : 0);
  Table->data    = data;
  return(Table->rows*Table->columns);
} /* end Table_Init */

/******************************************************************************
* long Table_Write(t_Table Table, char *file, x1,x2, y1,y2)
*   ACTION: write a Table to disk (ascii).
*     when x1=x2=0 or y1=y2=0, the table default limits are used.
*   return: 0=all is fine, non-0: error
*******************************************************************************/
MCDETECTOR Table_Write(t_Table Table, char *file, char *xl, char *yl, 
  double x1, double x2, double y1, double y2)
{
  long    i =0;
  MCDETECTOR detector;

  if ((Table.data == NULL) && (Table.rows*Table.columns)) {
    detector.m = 0;
    return(detector); /* Table is empty - nothing to do */
  }
  if (!x1 && !x2) {
    x1 = Table.min_x;
    x2 = Table.max_x;
  }
  if (!y1 && !y2) {
    y1 = 1;
    y2 = Table.columns;
  }

  /* transfer content of the Table into a 2D detector */
  Coords coords = { 0, 0, 0};

  if (Table.rows == 1 || Table.columns == 1) {
    detector = mcdetector_out_1D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      "x", x1, x2,
                      Table.rows * Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  } else {
    detector = mcdetector_out_2D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      x1, x2, y1, y2,
                      Table.rows, Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  }
  return(detector);
}

/******************************************************************************
* void Table_Stat(t_Table *Table)
*   ACTION: computes min/max/mean step of 1st column for a single table (private)
*   return: updated Table
*******************************************************************************/
  static void Table_Stat(t_Table *Table)
  {
    long   i;
    double max_x, min_x;
    double row=1;
    char   monotonic=1;
    char   constantstep=1;
    double step=0;
    long n;

    if (!Table) return;
    if (!Table->rows || !Table->columns) return;
    if (Table->rows == 1) row=0; // single row
    max_x = -FLT_MAX;
    min_x =  FLT_MAX;
    n     = (row ? Table->rows : Table->columns);
    /* get min and max of first column/vector */
    for (i=0; i < n; i++)
    {
      double X;
      X = (row ? Table_Index(*Table,i  ,0)
                               : Table_Index(*Table,0, i));
      if (X < min_x) min_x = X;
      if (X > max_x) max_x = X;
    } /* for */
    
    /* test for monotonicity and constant step if the table is an XY or single vector */
    if (n > 1) {
      /* mean step */
      step = (max_x - min_x)/(n-1);
      /* now test if table is monotonic on first column, and get minimal step size */
      for (i=0; i < n-1; i++) {
        double X, diff;;
        X    = (row ? Table_Index(*Table,i  ,0)
                    : Table_Index(*Table,0,  i));
        diff = (row ? Table_Index(*Table,i+1,0)
                    : Table_Index(*Table,0,  i+1)) - X;
        if (diff && fabs(diff) < fabs(step)) step = diff;
        /* change sign ? */
        if ((max_x - min_x)*diff < 0 && monotonic)
          monotonic = 0;
      } /* end for */
      
      /* now test if steps are constant within READ_TABLE_STEPTOL */
      if(!step){
        /*means there's a disconitnuity -> not constantstep*/
        constantstep=0;
      }else if (monotonic) {
        for (i=0; i < n-1; i++) {
          double X, diff;
          X    = (row ? Table_Index(*Table,i  ,0)
              : Table_Index(*Table,0,  i));
          diff = (row ? Table_Index(*Table,i+1,0)
              : Table_Index(*Table,0,  i+1)) - X;
          if ( fabs(step)*(1+READ_TABLE_STEPTOL) < fabs(diff) ||
                fabs(diff) < fabs(step)*(1-READ_TABLE_STEPTOL) )
          { constantstep = 0; break; }
        }
      }

    }
    Table->step_x= step;
    Table->max_x = max_x;
    Table->min_x = min_x;
    Table->monotonic = monotonic;
    Table->constantstep = constantstep;
  } /* end Table_Stat */

/******************************************************************************
* t_Table *Table_Read_Array(char *File, long *blocks)
*   ACTION: read as many data blocks as available, iteratively from file
*   return: initialized t_Table array, last element is an empty Table.
*           the number of extracted blocks in non NULL pointer *blocks
*******************************************************************************/
  t_Table *Table_Read_Array(char *File, long *blocks)
  {
    t_Table *Table_Array=NULL;
    long offset=0;
    long block_number=0;
    long allocated=256;
    long nelements=1;

    /* fisrt allocate an initial empty t_Table array */
    Table_Array = (t_Table *)malloc(allocated*sizeof(t_Table));
    if (!Table_Array) {
      fprintf(stderr, "Error: Can not allocate memory %li (Table_Read_Array).\n",
         allocated*sizeof(t_Table));
      *blocks = 0;
      return (NULL);
    }

    while (nelements > 0)
    {
      t_Table Table;

      /* if ok, set t_Table block number else exit loop */
      block_number++;
      Table.block_number = block_number;
      
      /* access file at offset and get following block. Block number is from the set offset
       * hence the hardcoded 1 - i.e. the next block counted from offset.*/
      nelements = Table_Read_Offset(&Table, File, 1, &offset,0);
      /* if t_Table array is not long enough, expand and realocate */
      if (block_number >= allocated-1) {
        allocated += 256;
        Table_Array = (t_Table *)realloc(Table_Array,
           allocated*sizeof(t_Table));
        if (!Table_Array) {
          fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Array).\n",
              allocated*sizeof(t_Table));
          *blocks = 0;
          return (NULL);
        }
      }
      /* store it into t_Table array */
      //snprintf(Table.filename, 1024, "%s#%li", File, block_number-1);
      Table_Array[block_number-1] = Table;
      /* continues until we find an empty block */
    }
    /* send back number of extracted blocks */
    if (blocks) *blocks = block_number-1;

    /* now store total number of elements in Table array */
    for (offset=0; offset < block_number;
      Table_Array[offset++].array_length = block_number-1);

    return(Table_Array);
  } /* end Table_Read_Array */
/*******************************************************************************
* void Table_Free_Array(t_Table *Table)
*   ACTION: free a Table array
*******************************************************************************/
  void Table_Free_Array(t_Table *Table)
  {
    long index=0;
    if (!Table) return;
    while (Table[index].data || Table[index].header){
            Table_Free(&Table[index]);
            index++;
    }
    free(Table);
  } /* end Table_Free_Array */

/******************************************************************************
* long Table_Info_Array(t_Table *Table)
*    ACTION: print informations about a Table array
*    return: number of elements in the Table array
*******************************************************************************/
  long Table_Info_Array(t_Table *Table)
  {
    long index=0;

    if (!Table) return(-1);
    while (index < Table[index].array_length
       && (Table[index].data || Table[index].header)
       && (Table[index].rows*Table[index].columns) ) {
      Table_Info(Table[index]);
      index++;
    }
    printf("This Table array contains %li elements\n", index);
    return(index);
  } /* end Table_Info_Array */

/******************************************************************************
* char **Table_ParseHeader(char *header, symbol1, symbol2, ..., NULL)
*    ACTION: search for char* symbols in header and return their value or NULL
*            the search is not case sensitive.
*            Last argument MUST be NULL
*    return: array of char* with line following each symbol, or NULL if not found
*******************************************************************************/
#ifndef MyNL_ARGMAX
#define MyNL_ARGMAX 50
#endif

char **Table_ParseHeader_backend(char *header, ...){
  va_list ap;
  char exit_flag=0;
  int counter   =0;
  char **ret    =NULL;
  if (!header || header[0]=='\0') return(NULL);

  ret = (char**)calloc(MyNL_ARGMAX, sizeof(char*));
  if (!ret) {
    printf("Table_ParseHeader: Cannot allocate %i values array for Parser (Table_ParseHeader).\n",
      MyNL_ARGMAX);
    return(NULL);
  }
  for (counter=0; counter < MyNL_ARGMAX; ret[counter++] = NULL);
  counter=0;

  va_start(ap, header);
  while(!exit_flag && counter < MyNL_ARGMAX-1)
  {
    char *arg_char=NULL;
    char *pos     =NULL;
    /* get variable argument value as a char */
    arg_char = va_arg(ap, char *);
    if (!arg_char || arg_char[0]=='\0'){
      exit_flag = 1; break;
    }
    /* search for the symbol in the header */
    pos = (char*)strcasestr(header, arg_char);
    if (pos) {
      char *eol_pos;
      eol_pos = strchr(pos+strlen(arg_char), '\n');
      if (!eol_pos)
        eol_pos = strchr(pos+strlen(arg_char), '\r');
      if (!eol_pos)
        eol_pos = pos+strlen(pos)-1;
      ret[counter] = (char*)malloc(eol_pos - pos);
      if (!ret[counter]) {
        printf("Table_ParseHeader: Cannot allocate value[%i] array for Parser searching for %s (Table_ParseHeader).\n",
          counter, arg_char);
        exit_flag = 1; break;
      }
      strncpy(ret[counter], pos+strlen(arg_char), eol_pos - pos - strlen(arg_char));
      ret[counter][eol_pos - pos - strlen(arg_char)]='\0';
    }
    counter++;
  }
  va_end(ap);
  return(ret);
} /* Table_ParseHeader */

/******************************************************************************
* double Table_Interp1d(x, x1, y1, x2, y2)
*    ACTION: interpolates linearly at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d(double x,
  double x1, double y1,
  double x2, double y2)
{
  double slope;
  if (x2 == x1) return (y1+y2)/2;
  if (y1 == y2) return  y1;
  slope = (y2 - y1)/(x2 - x1);
  return y1+slope*(x - x1);
} /* Table_Interp1d */

/******************************************************************************
* double Table_Interp1d_nearest(x, x1, y1, x2, y2)
*    ACTION: table lookup with nearest method at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d_nearest(double x,
  double x1, double y1,
  double x2, double y2)
{
  if (fabs(x-x1) < fabs(x-x2)) return (y1);
  else return(y2);
} /* Table_Interp1d_nearest */

/******************************************************************************
* double Table_Interp2d(x,y, x1,y1, x2,y2, z11,z12,z21,z22)
*    ACTION: interpolates bi-linearly at (x,y) between z1=f(x1,y1) and z2=f(x2,y2)
*    return: z=f(x,y) value
*    x,y |   x1   x2
*    ----------------
*     y1 |   z11  z21
*     y2 |   z12  z22
*******************************************************************************/
double Table_Interp2d(double x, double y,
  double x1, double y1,
  double x2, double y2,
  double z11, double z12, double z21, double z22)
{
  double ratio_x, ratio_y;
  if (x2 == x1) return Table_Interp1d(y, y1,z11, y2,z12);
  if (y1 == y2) return Table_Interp1d(x, x1,z11, x2,z21);

  ratio_y = (y - y1)/(y2 - y1);
  ratio_x = (x - x1)/(x2 - x1);
  return (1-ratio_x)*(1-ratio_y)*z11 + ratio_x*(1-ratio_y)*z21
    + ratio_x*ratio_y*z22         + (1-ratio_x)*ratio_y*z12;
} /* Table_Interp2d */

/* end of read_table-lib.c */


#ifndef REF_LIB_H
#define REF_LIB_H "$Revision$"

void StdReflecFunc(double, double*, double*);
void TableReflecFunc(double, t_Table*, double*);

#endif

/* end of ref-lib.h */
/****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.c
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Variable names have prefix 'mc_ref_' for 'McStas Reflection' 
* to avoid conflicts
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/

#ifndef REF_LIB_H
#include "ref-lib.h"
#endif

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#include "read_table-lib.c"
#endif

/****************************************************************************
* void StdReflecFunc(double q, double *par, double *r)
* 
* The McStas standard analytic parametrization of the reflectivity.
* The parameters are:
* R0:      [1]    Low-angle reflectivity
* Qc:      [AA-1] Critical scattering vector
* alpha:   [AA]   Slope of reflectivity
* m:       [1]    m-value of material. Zero means completely absorbing.
* W:       [AA-1] Width of supermirror cut-off
*****************************************************************************/
void StdReflecFunc(double mc_pol_q, double *mc_pol_par, double *mc_pol_r) {
    double R0    = mc_pol_par[0];
    double Qc    = mc_pol_par[1];
    double alpha = mc_pol_par[2];
    double m     = mc_pol_par[3];
    double W     = mc_pol_par[4];
    double beta  = 0;
    mc_pol_q     = fabs(mc_pol_q);
    double arg;
        
    /* Simpler parametrization from Henrik Jacobsen uses these values that depend on m only.
       double m_value=m*0.9853+0.1978;
       double W=-0.0002*m_value+0.0022;
       double alpha=0.2304*m_value+5.0944;
       double beta=-7.6251*m_value+68.1137; 
       If W and alpha are set to 0, use Henrik's approach for estimating these parameters
       and apply the formulation:
       arg = R0*0.5*(1-tanh(arg))*(1-alpha*(q-Qc)+beta*(q-Qc)*(q-Qc));
    */  
    if (W==0 && alpha==0) {
      m=m*0.9853+0.1978;
      W=-0.0002*m+0.0022;
      alpha=0.2304*m+5.0944;
      beta=-7.6251*m+68.1137;
      if (m<=3) {
	alpha=m;
	beta=0;
      }
    }
    
    arg = W > 0 ? (mc_pol_q - m*Qc)/W : 11;

    if (arg > 10 || m <= 0 || Qc <=0 || R0 <= 0) {
      *mc_pol_r = 0;
      return;
    }
    
    if (m < 1) { Qc *= m; m=1; }
    
    if(mc_pol_q <= Qc) {      
      *mc_pol_r = R0;
      return;
    }
    
    
    *mc_pol_r = R0*0.5*(1 - tanh(arg))*(1 - alpha*(mc_pol_q - Qc) + beta*(mc_pol_q - Qc)*(mc_pol_q - Qc));
    
    return;
  }

/****************************************************************************
* void TableReflecFunc(double q, t_Table *par, double *r) {
* 
* Looks up the reflectivity in a table using the routines in read_table-lib.
*****************************************************************************/
void TableReflecFunc(double mc_pol_q, t_Table *mc_pol_par, double *mc_pol_r) {
    
  *mc_pol_r = Table_Value(*mc_pol_par, mc_pol_q, 1);
  if(*mc_pol_r>1)
    *mc_pol_r = 1;
  return;
}

/* end of ref-lib.c */


///////////////////////////////////////////////////////////////////////////
/////////////// local structs and enums
///////////////////////////////////////////////////////////////////////////

/**
Sides of the guide
*/
enum Side {RightSide,TopSide,LeftSide,BottomSide,None};

/**
The type of the collision is set in the collision function
and decide the functions called in trace()
	Reflex (TODO change this name) calls the reflection function
	Absorb calls the built in ABSORB funtion.
	LeaveGuide calls break and end the calculations in this component
	EnterGuide does nothing
*/
enum CollisionType {Reflex,Absorb,LeaveGuide,EnterGuide};

/**
	The Mirror type sets the CollisionType of particles colliding on the mirror
*/
enum MirrorType {MirrorTypeReflection,MirrorTypeTransparent,MirrorTypeabsorption};

// enum IntersectionType {Reflex,Absorb,Transparent,Leave,Enter};

/**
	Collision between guide and the particle
	contain infomation on the time to the next collision,
	which side of the guide it is on and whether this part of the guide
	is a perfect or approximated ellipse.
*/
struct Intersection
{
	double delta_time_to_next_collision; 
	enum Side side;	// A number from 0 to 4 (4 being an error warning)
	int ApproxOn;
	enum CollisionType collisionType;
};

/**
	Static Guide information (SGI)
	contain information on the guide, the ellipses and the mirrors on all sides
*/
struct SGI
{
	// guide infomation
	double Length;
	double entranceHorizontalWidth, entranceVerticalWidth;	
	double exitHorizontalWidth, exitVerticalWidth;	

	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	// mirror infomation
	double R0Arr[4]; 
	double QcArr[4]; 
	double alphaArr[4]; 
	double mArr[4]; 
	double WArr[4];

	// mirror type
	enum MirrorType InnerSide[4];
	enum MirrorType OuterSide[4];

	// selene
	int EnclosingBoxOn;
    double xArray[8];
    double yArray[8];
    double zArray[8];

    // segmentation
    int numberOfSegments;
    int enableSegments;
    double *mValuesright;
	double *mValuesleft;
	double *mValuestop;
	double *mValuesbottom;
    double *segLength;

    int verboseSetting;
};


///////////////////////////////////////////////////////////////////////////
/////////////// Error Handling Functions
///////////////////////////////////////////////////////////////////////////

/**
	If a user input is less than zero and hence doesn't allow for a well
	define geomtric of the guide or physical values for mirrors
	@param var is the input varible there the error occurred [text]
*/
int guide_elliptical_illegalInputLessThanZero(char var[],int verbose){
	if (verbose)
		printf("The user defined variable %s in %s has an illegal value"
				" less than zero\n",var,"Elliptic_guide_gravity");
	return 1;
}

/**
	The first focal point is in and the second is out.
	If -in-out > L then they would change position as the 
	first and second focal points. This is 
	@param in,out is the input varible there the error occurred [text]
*/
int guide_elliptical_illegalInputFocalPointsHyperbola(
			char in[],char out[],
			double inValue,double outValue, int verbose){
	if (verbose){
		printf("The user defined length of the guide, length \
				and the focal points %s and %s does not result \
				in an well defined ellipse. swap the focal points \
				or increase L, %s or %s to fix this problem\n",
				in,out,in,out);
		printf("The mininum length of the should be around %e\n",
				inValue+outValue+0.000001);
	}
	return 1;
}

/**
	Gives a warning if a part of the code is called that 
	should not be accessible if the algoritmes are working correctly
	Most likely errors are floating points and ill-defined cases
*/
void guide_elliptical_callCriticalWarning(char func[],int verbose){
	if (verbose)
		printf("A CRITICAL WARNING has been called inside %s by function %s." 
			"This is most likely due to a programming error \
			inside the component. \n",
			"Elliptic_guide_gravity",func);
	}

///////////////////////////////////////////////////////////////////////////
/////////////// Collision handling functions
///////////////////////////////////////////////////////////////////////////

int guide_elliptical_getMirrorTypeFromInput(char * input,int verbose){
	int type = -1;
	char* r1 = "reflection"; char* r2 = "reflect"; char* r3 = "r";
	char* a1 = "absorption"; char* a2 = "absorb"; char* a3 = "a";
	char* t1 = "transparant";char* t2 = "trans"; char* t3 = "t";
	if (strcmp (input, r1) == 0
	||  strcmp (input, r2) == 0 
	||  strcmp (input, r3) == 0)
		type = MirrorTypeReflection;
	if (strcmp (input, a1) == 0
	||  strcmp (input, a2) == 0 
	||  strcmp (input, a3) == 0)
		type = MirrorTypeabsorption;
	if (strcmp (input, t1) == 0
	||  strcmp (input, t2) == 0 
	||  strcmp (input, t3) == 0)
		type = MirrorTypeTransparent;
	if ( type == -1 && verbose)
		printf( "Following string is not a valid type of a mirror: %s,"
				"use reflection,absorption or transparant. \n" ,input);

	return type;
	}

///////////////////////////////////////////////////////////////////////////
/////////////// Collision functions
///////////////////////////////////////////////////////////////////////////	

/**
	Find the intersection between the neutron and the ellipse using newton method.
	As there is up to 4 solution to this problem, and only the 
	smallest positive root is the physical solution. Using the tuning points 
	it is possible to look the only the potential roots to speed up calculations.

	@param coef; A pointer to the array holding the coeffecients 
			for the 4th order polynomial.
	@param startPosition, The default starting point for newton method. [s]
	@param limit; A point after all the roots of the polynial. [s]
	@param solution A pointer which will hold the physical solution 
			if this function return true.
	@return; return 1 if the physical solution is found. [boolean] 
*/

double guide_elliptical_foverdf(double *coefficients,double currentPoint){
	double numerator= coefficients[0]*currentPoint*currentPoint*currentPoint*currentPoint
					+ coefficients[1]*currentPoint*currentPoint*currentPoint
					+ coefficients[2]*currentPoint*currentPoint
					+ coefficients[3]*currentPoint
					+ coefficients[4];
	double denominator=4*coefficients[0]*currentPoint*currentPoint*currentPoint
					+ 3*coefficients[1]*currentPoint*currentPoint
					+ 2*coefficients[2]*currentPoint
					+ coefficients[3];
	return numerator/denominator;
}

int guide_elliptical_newtonRapsonsMethod4thOrder(
		double *coefficients,double *solution,double startingPoint,
		double tolerance,double max_iterations){

	double numerator;
	double denominator;
	double t_previous;
	double t = startingPoint;
	int iteration = 0;

	do {
		t_previous = t;
		t = t_previous - guide_elliptical_foverdf(coefficients,t);
		iteration++;
	} while( fabs(t-t_previous) > tolerance && iteration < max_iterations );
	if( iteration == max_iterations ) { return 0; }
	else 			{ *solution = t;	return 1; }
}



int guide_elliptical_findNeutronEllipseIntersection(
				double *coef,double startPosition,
				double limit,double *solution){

	// in the case of no gravity
	if(coef[0] == 0 & coef[1] == 0){
		double t1=0;
		double t2=0;
		int boolean = solve_2nd_order(&t1,&t2,coef[2],coef[3],coef[4]);

		if ( t1 > startPosition ){ *solution = t1; }
		if ( t2 > startPosition ){ *solution = t2; }
		return boolean;
	}

	double tol = 1e-15;
	double max_iter = 1e3;
	double turningP1,turningP2;
	
	double sp = startPosition;
	int inside;
	if ( coef[0]*sp*sp*sp*sp
		+coef[1]*sp*sp*sp
		+coef[2]*sp*sp
		+coef[3]*sp
		+coef[4] < 0)
		 inside = 1;
	else inside = 0;

	int boolean = solve_2nd_order(
						&turningP1,&turningP2,
						12*coef[0],6*coef[1],2*coef[2]);

	double t1=0,t2=0;
	double ss=100;

	if( inside ){
		if(boolean) guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t1,turningP1,tol,max_iter);
		guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t2,limit,tol,max_iter);
	}
	else{
		if(boolean) guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t1,turningP2,tol,max_iter);
		guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t2,startPosition,tol,max_iter);
	}

	if (ss > t1 && t1 > 1e-15)	ss = t1;
	if (ss > t2 && t2 > 1e-15)	ss = t2;
	*solution = ss;
	
	return 1;
}


int guide_elliptical_handleGuideIntersection(
		double x, double y, double z,
		double vx,double vy,double vz,
		double Gx,double Gy,double Gz,
		struct SGI *guideInfo,
		struct Intersection *currentCollision){
	//
	double horExS = 1/( guideInfo->ellipseMinorAxis[RightSide]
					   *guideInfo->ellipseMinorAxis[RightSide]);
	double horEzS = 1/( guideInfo->ellipseMajorAxis[RightSide]
				 	   *guideInfo->ellipseMajorAxis[RightSide]);
	double hordiffx = x-guideInfo->ellipseMinorOffset[RightSide]; 
	double hordiffz = z-guideInfo->ellipseMajorOffset[RightSide]; 

	double horAlpha = ( Gx*Gx*horExS + Gz*Gz*horEzS )/4;
	double horBeta  = ( Gx*vx*horExS + Gz*vz*horEzS );
	double horGamma = horExS*vx*vx + horEzS*vz*vz 
					 + horExS*Gx*hordiffx + horEzS*Gz*hordiffz; 
	double horDelta = 2*horExS*vx*hordiffx + 2*horEzS*vz*hordiffz;
	double horEpsilon = horExS*hordiffx*hordiffx + horEzS*hordiffz*hordiffz - 1; 

	double horCoefficients[5] = {horAlpha,horBeta,horGamma,horDelta,horEpsilon};

	double verEyS = 1/( guideInfo->ellipseMinorAxis[TopSide]
					   *guideInfo->ellipseMinorAxis[TopSide]);
	double verEzS = 1/( guideInfo->ellipseMajorAxis[TopSide]
				 	   *guideInfo->ellipseMajorAxis[TopSide]);
	double verdiffy = y-guideInfo->ellipseMinorOffset[TopSide];
	double verdiffz = z-guideInfo->ellipseMajorOffset[TopSide];

	double verAlpha = ( Gy*Gy*verEyS + Gz*Gz*verEzS )/4;
	double verBeta  = ( Gy*vy*verEyS + Gz*vz*verEzS );
	double verGamma = verEyS*vy*vy + verEzS*vz*vz 
					+ verEyS*Gy*verdiffy + verEzS*Gz*verdiffz;
	double verDelta = 2*verEyS*vy*verdiffy + 2*verEzS*vz*verdiffz;
	double verEpsilon = verEyS*verdiffy*verdiffy + verEzS*verdiffz*verdiffz - 1;

	double verCoefficients[5] = {verAlpha,verBeta,verGamma,verDelta,verEpsilon};


	double upperlimit;
	double startingPoint = 1e-15;

	int boolean;
	// Horizontal
	double solutionH = 0;
	solve_2nd_order(
			&upperlimit,NULL,
			-0.5*Gz,-vz,2*guideInfo->ellipseMajorAxis[RightSide]-z);
	int booleanH = guide_elliptical_findNeutronEllipseIntersection(
						horCoefficients,startingPoint,upperlimit,&solutionH);
	// Vertical
	double solutionV = 0;
	solve_2nd_order(
			&upperlimit,NULL,
			-0.5*Gz,-vz,2*guideInfo->ellipseMajorAxis[TopSide]-z);
	int booleanV = guide_elliptical_findNeutronEllipseIntersection(
						verCoefficients,startingPoint,upperlimit,&solutionV);

	if (solutionH <= 0)
			currentCollision->delta_time_to_next_collision = solutionV;
	else if (solutionV <= 0)
			currentCollision->delta_time_to_next_collision = solutionH;
	else if (fabs(solutionH - solutionV) < 1e-12) return 0;
	else if (solutionH < solutionV){
		currentCollision->delta_time_to_next_collision = solutionH; 
		boolean = booleanH; 
		}
	else{
		currentCollision->delta_time_to_next_collision = solutionV; 
		boolean = booleanV; 
		}

	double tside = currentCollision->delta_time_to_next_collision;
	double xside = x + vx*tside + 0.5*Gx*tside*tside;
	double yside = y + vy*tside + 0.5*Gy*tside*tside;
	double zside = z + vz*tside + 0.5*Gz*tside*tside;

	double xfactor =
		2*sqrt(1 - ( (zside-guideInfo->ellipseMajorOffset[RightSide])
					*(zside-guideInfo->ellipseMajorOffset[RightSide]) 
					)/(guideInfo->ellipseMajorAxis[RightSide] 
					*guideInfo->ellipseMajorAxis[RightSide] ) 
		)*guideInfo->ellipseMinorAxis[RightSide];

	double yfactor =
		2*sqrt(1 - ( (zside-guideInfo->ellipseMajorOffset[BottomSide])
					*(zside-guideInfo->ellipseMajorOffset[BottomSide]) 
					)/(guideInfo->ellipseMajorAxis[BottomSide] 
					*guideInfo->ellipseMajorAxis[BottomSide] )
		)*guideInfo->ellipseMinorAxis[BottomSide];

	xside = xside/xfactor;
	yside = yside/yfactor;
	if( fabs(yside) >= fabs(xside) ){
		if(y > 0)	currentCollision->side = TopSide;
		else 		currentCollision->side = BottomSide;
	}
	else{
		if(x < 0)	currentCollision->side = RightSide;
		else 		currentCollision->side = LeftSide;
	}
	if (tside < 1e-15) printf("low time is: %e\n",tside);

	return boolean;
}

/**
	Check if the neutron is within the guide using the sign 
	of the crossproduct between the two points,
	on each of the enclosing box surface and neutrons position.    
	
	@param x,y,z; position of the neutron. [m]
	@param guideInfo; pointer to the guide infomation holding structure.
	@return; return 1 if the neutron is inside the guide [boolean] 
*/

/*
int guide_elliptical_InsideEnclosingBox(double x,double y,double z,struct SGI *guideInfo){
	int guide_elliptical_IsPointInVolume(
			double *x,double *y,double *z,
			double px,double py,double pz){
		int guide_elliptical_WhichSide( 	double p1x,double p1y,double p1z,
						double p2x,double p2y,double p2z,
						double p3x,double p3y,double p3z,
						double px ,double py ,double pz ){
			
			double v1x = p1x - p2x, v1y = p1y-p2y, v1z = p1z-p2z;
			double v2x = p3x - p2x, v2y = p3y-p2y, v2z = p3z-p2z;
			double v3x = v2y*v1z-v2z*v1y; 
			double v3y = v2z*v1x-v2x*v1z;
			double v3z = v2x*v1y-v2y*v1x;

			return 0 >= v3x*(px-p1x)+v3y*(py-p1y)+v3z*(pz-p1z); 
		}

		if(	//front
			guide_elliptical_WhichSide(x[3],y[3],z[3],x[2],y[2],z[2],x[1],y[1],z[1],px,py,pz) &&
			guide_elliptical_WhichSide(x[1],y[1],z[1],x[0],y[0],z[0],x[3],y[3],z[3],px,py,pz) &&
			//back
			guide_elliptical_WhichSide(x[5],y[5],z[5],x[6],y[6],z[6],x[7],y[7],z[7],px,py,pz) &&
			guide_elliptical_WhichSide(x[7],y[7],z[7],x[4],y[4],z[4],x[5],y[5],z[5],px,py,pz) &&
			//right
			guide_elliptical_WhichSide(x[7],y[7],z[7],x[3],y[3],z[3],x[0],y[0],z[0],px,py,pz) &&
			guide_elliptical_WhichSide(x[0],y[0],z[0],x[4],y[4],z[4],x[7],y[7],z[7],px,py,pz) &&
			//left
			guide_elliptical_WhichSide(x[1],y[1],z[1],x[2],y[2],z[2],x[6],y[6],z[6],px,py,pz) &&
			guide_elliptical_WhichSide(x[6],y[6],z[6],x[5],y[5],z[5],x[1],y[1],z[1],px,py,pz) &&
			//top
			guide_elliptical_WhichSide(x[0],y[0],z[0],x[1],y[1],z[1],x[5],y[5],z[5],px,py,pz) &&
			guide_elliptical_WhichSide(x[5],y[5],z[5],x[4],y[4],z[4],x[0],y[0],z[0],px,py,pz) &&
			//bottom
			guide_elliptical_WhichSide(x[6],y[6],z[6],x[2],y[2],z[2],x[3],y[3],z[3],px,py,pz) &&
			guide_elliptical_WhichSide(x[3],y[3],z[3],x[7],y[7],z[7],x[6],y[6],z[6],px,py,pz) )
			 	return 1;
		else 	return 0;
	}
	return guide_elliptical_IsPointInVolume(
				guideInfo->xArray,guideInfo->yArray,guideInfo->zArray,x,y,z);
}
*/


///////////////////////////////////////////////////////////////////////////
/////////////// reflection functions
///////////////////////////////////////////////////////////////////////////
		

/**
	Calculate the new velocity vector for the particle colliding on 
	the inner side of the elliptic mirror and returns the loss-factor (TODO)
	
	@param pos_V0,pos_W0 Is the 2d position vector of the particle, 
			assumed to be a point on the ellipse. [m]
	@param pvel_V0,pvel_W0 Is the 2d velocity vector of the particle. [m/s]
	@param ellipse_V_axis_squared,ellipse_W_axis_squared
			are the axes of the ellipse. [m]
	@param ellipse_V_offset,ellipse_W_offset Is the 2d vector difference 
			between the ellipse coordinate system (center of the ellipse) 
			and the guide coordinate system [m]
	@param R0, Mvalue, Qc, W, Alpha #TODO 
		slaa beskrivelse af disse variabler i andre dokumenter 
		og hold dig til standarden.
	@return the new wieght of the package
*/
double guide_elliptical_ReflectionOnEllipticSurface(
			double pos_V,double pos_W,
			double *pvel_V,double *pvel_W,
			double ellipse_V_axis,double ellipse_W_axis,
			double ellipse_V_offset,double ellipse_W_offset,
			double R0, double Qc, double alpha, double Mvalue, double W)
{

	// Turns the velocity vector (vel_V0,vel_W0) into a local value
	double vel_V = *pvel_V;
	double vel_W = *pvel_W;

	// Galilean transformation of the particles start position 
	// to the ellipse coordinate system
	pos_V=pos_V-ellipse_V_offset;
	pos_W=pos_W-ellipse_W_offset;

	/*  
	*   If we reflect the velocity vector in the normal 
	*	to the ellipse in the point of intersection
	*   The resulting vector will be -f2, do to conservation of momentum.
	*   this result in the following equation
	*   f2 = -f1 + 2(f1 dot nhat)nhat
	*   which is equal to f2 = f1 - 2(f1 dot n)n/nlength^2
	*/
	
	// The normal vector to the point of intersection
	double normVec_V = - pos_W*ellipse_V_axis/ellipse_W_axis;
	double normVec_W =   pos_V*ellipse_W_axis/ellipse_V_axis;

	double normVec_length_squared = normVec_V*normVec_V + normVec_W*normVec_W;

	// Dot product of (vel_V0,vel_W0) and the normal vector
	double Vel_dot_NV = vel_V*normVec_V+vel_W*normVec_W;

	// Calculate f2
	double vel_V_2 = -vel_V + 2*Vel_dot_NV*normVec_V/normVec_length_squared;
	double vel_W_2 = -vel_W + 2*Vel_dot_NV*normVec_W/normVec_length_squared;

	// Apply the new velocity vector to the particle globally
	*pvel_V=vel_V_2;
	*pvel_W=vel_W_2;

	// Calculate q and the weighting of the neutron package
	// q=f1-f2
	double delta_vel_V = vel_V-vel_V_2;
	double delta_vel_W = vel_W-vel_W_2;
	double q = V2Q*sqrt( delta_vel_V*delta_vel_V+delta_vel_W*delta_vel_W );

	// Calculate the loss of neutrons due to the reflection
	double mirrorPar[] = {R0, Qc, alpha, Mvalue, W};
	double weight = 1.0;
	StdReflecFunc(q, mirrorPar, &weight);

	return weight;
}

/**
	Use the found side of Intersection to call guide_elliptical_ReflectionOnEllipticSurface with
	the parameters of that side.
*/
double guide_elliptical_handleReflection(double x0, double y0, double z0,
				double *vx_p,double *vy_p,double *vz_p,
				struct SGI *sgi,
				struct Intersection *cc)
{

    if(!sgi->enableSegments){
		if(cc->side == RightSide || cc->side == LeftSide)
			return guide_elliptical_ReflectionOnEllipticSurface(x0,z0,vx_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mArr[cc->side],
					sgi->WArr[cc->side]
					);
		if(cc->side == TopSide || cc->side == BottomSide)
			return guide_elliptical_ReflectionOnEllipticSurface(y0,z0,vy_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mArr[cc->side],
					sgi->WArr[cc->side]
					);
    }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < sgi->numberOfSegments; i++){
    		combinedLength = combinedLength + sgi->segLength[i];
    		if(z0 < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(cc->side == RightSide)
			return guide_elliptical_ReflectionOnEllipticSurface(x0,z0,vx_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuesright[currentSegment],
					sgi->WArr[cc->side] );
		if(cc->side == LeftSide)
			return guide_elliptical_ReflectionOnEllipticSurface(x0,z0,vx_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuesleft[currentSegment],
					sgi->WArr[cc->side] );
		if(cc->side == TopSide)
			return guide_elliptical_ReflectionOnEllipticSurface(y0,z0,vy_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuestop[currentSegment],
					sgi->WArr[cc->side] );
		if(cc->side == BottomSide)
			return guide_elliptical_ReflectionOnEllipticSurface(y0,z0,vy_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuesbottom[currentSegment],
					sgi->WArr[cc->side] );
    }
	return 0;
}

///////////////////////////////////////////////////////////////////////////
/////////////// End of functions
/////////////////////////////////////////////////////////////////////////// 
#line 7422 "BIFROST.c"

/* Shared user declarations for all components 'Guide_gravity'. */
#line 124 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"

#ifndef Gravity_guide_Version
#define Gravity_guide_Version "$Revision$"

#ifndef PROP_GRAV_DT
#error McStas : You need PROP_GRAV_DT (McStas >= 1.4.3) to run this component
#endif

/*
* G:       (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gx:      (m/s^2) Gravitation acceleration along x axis [0]
* Gy:      (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gz:      (m/s^2) Gravitation acceleration along z axis [0]
* mh:      (1)    m-value of material for left/right vert. mirrors
* mv:      (1)    m-value of material for top/bottom horz. mirrors
* mx:      (1)    m-value of material for left/right vert. mirrors
* my:      (1)    m-value of material for top/bottom horz. mirrors
*/

  typedef struct Gravity_guide_Vars
  {
    double gx;
    double gy;
    double gz;
    double nx[6], ny[6], nz[6];
    double wx[6], wy[6], wz[6];
    double A[6], norm_n2[6], norm_n[6];
    long   N_reflection[7];
    double w1c, h1c;
    double w2c, h2c;
    double M[5];
    double Alpha[5];
    double nzC[5], norm_n2xy[5], Axy[5];
    double wav_lr, wav_tb, wav_z;
    double chamfer_z, chamfer_lr, chamfer_tb;
    char   compcurname[256];
    double fc_freq, fc_phase;
    double warnings;
  } Gravity_guide_Vars_type;

  void Gravity_guide_Init(Gravity_guide_Vars_type *aVars,
    MCNUM a_w1, MCNUM a_h1, MCNUM a_w2, MCNUM a_h2, MCNUM a_l, MCNUM a_R0,
    MCNUM a_Qc, MCNUM a_alpha, MCNUM a_m, MCNUM a_W, MCNUM a_nslit, MCNUM a_d,
    MCNUM a_Gx, MCNUM a_Gy, MCNUM a_Gz,
    MCNUM a_mleft, MCNUM a_mright, MCNUM a_mtop, MCNUM a_mbottom, MCNUM a_nhslit,
    MCNUM a_wavy_lr, MCNUM a_wavy_tb, MCNUM a_wavy_z, MCNUM a_wavy,
    MCNUM a_chamfers_z, MCNUM a_chamfers_lr, MCNUM a_chamfers_tb, MCNUM a_chamfers,
    MCNUM a_nu, MCNUM a_phase, MCNUM a_aleft, MCNUM a_aright, MCNUM a_atop, MCNUM a_abottom)
  {
    int i;

    for (i=0; i<7; aVars->N_reflection[i++] = 0);
    for (i=0; i<5; aVars->M[i++] = 0);
    for (i=0; i<5; aVars->Alpha[i++] = 0);

    aVars->gx = a_Gx; /* The gravitation vector in the current component axis system */
    aVars->gy = a_Gy;
    aVars->gz = a_Gz;
    aVars->warnings=0;

    if (a_nslit <= 0 || a_nhslit <= 0) { fprintf(stderr,"%s: Fatal: no channel in this guide (nhslit or nslit=0).\n", aVars->compcurname); exit(-1); }
    if (a_d < 0) { fprintf(stderr,"%s: Fatal: subdividing walls have negative thickness in this guide (d<0).\n", aVars->compcurname); exit(-1); }
    aVars->w1c = (a_w1 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->w2c = (a_w2 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->h1c = (a_h1 - (a_nhslit-1)*a_d)/(double)a_nhslit;
    aVars->h2c = (a_h2 - (a_nhslit-1)*a_d)/(double)a_nhslit;

    for (i=0; i <= 4;   aVars->M[i++]=a_m);
    for (i=0; i <= 4;   aVars->Alpha[i++]=a_alpha);
    if (a_mleft   >= 0) aVars->M[1] =a_mleft  ;
    if (a_mright  >= 0) aVars->M[2] =a_mright ;
    if (a_mtop    >= 0) aVars->M[3] =a_mtop   ;
    if (a_mbottom >= 0) aVars->M[4] =a_mbottom;
    if (a_aleft   >= 0) aVars->Alpha[1] =a_aleft  ;
    if (a_aright  >= 0) aVars->Alpha[2] =a_aright ;
    if (a_atop    >= 0) aVars->Alpha[3] =a_atop   ;
    if (a_abottom >= 0) aVars->Alpha[4] =a_abottom;

    /* n: normal vectors to surfaces */
    aVars->nx[1] =  a_l; aVars->ny[1] =  0;   aVars->nz[1] =  0.5*(aVars->w2c-aVars->w1c);  /* 1:+X left       */
    aVars->nx[2] = -a_l; aVars->ny[2] =  0;   aVars->nz[2] = -aVars->nz[1];             /* 2:-X right      */
    aVars->nx[3] =  0;   aVars->ny[3] =  a_l; aVars->nz[3] =  0.5*(aVars->h2c-aVars->h1c);  /* 3:+Y top        */
    aVars->nx[4] =  0;   aVars->ny[4] = -a_l; aVars->nz[4] = -aVars->nz[3];             /* 4:-Y bottom     */
    aVars->nx[5] =  0;   aVars->ny[5] =  0;   aVars->nz[5] =  a_l;                      /* 5:+Z exit       */
    aVars->nx[0] =  0;   aVars->ny[0] =  0;   aVars->nz[0] = -a_l;                      /* 0:Z0 input      */
    /* w: a point on these surfaces */
    aVars->wx[1] = +(aVars->w1c)/2; aVars->wy[1] =  0;              aVars->wz[1] = 0;   /* 1:+X left       */
    aVars->wx[2] = -(aVars->w1c)/2; aVars->wy[2] =  0;              aVars->wz[2] = 0;   /* 2:-X right      */
    aVars->wx[3] =  0;              aVars->wy[3] = +(aVars->h1c)/2; aVars->wz[3] = 0;   /* 3:+Y top        */
    aVars->wx[4] =  0;              aVars->wy[4] = -(aVars->h1c)/2; aVars->wz[4] = 0;   /* 4:-Y bottom     */
    aVars->wx[5] =  0;              aVars->wy[5] =  0;              aVars->wz[5] = a_l; /* 5:+Z exit       */
    aVars->wx[0] =  0;              aVars->wy[0] =  0;              aVars->wz[0] = 0;   /* 0:Z0 input      */

    for (i=0; i <= 5; i++)
    {
      aVars->A[i] = scalar_prod(aVars->nx[i], aVars->ny[i], aVars->nz[i], aVars->gx, aVars->gy, aVars->gz)/2;
      aVars->norm_n2[i] = aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i] + aVars->nz[i]*aVars->nz[i];
      if (aVars->norm_n2[i] <= 0)
        { fprintf(stderr,"%s: Fatal: normal vector norm %i is null/negative ! check guide dimensions.\n", aVars->compcurname, i); exit(-1); } /* should never occur */
      else
        aVars->norm_n[i] = sqrt(aVars->norm_n2[i]);
    }
    /* partial computations for l/r/t/b sides, to save computing time */
    for (i=1; i <= 4; i++)
    { /* stores nz that changes in case non box element (focus/defocus) */
      aVars->nzC[i]      =  aVars->nz[i]; /* partial xy terms */
      aVars->norm_n2xy[i]=  aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i];
      aVars->Axy[i]      = (aVars->nx[i]*aVars->gx    + aVars->ny[i]*aVars->gy)/2;
    }
    /* handle waviness init */
    if (a_wavy && (!a_wavy_tb && !a_wavy_lr && !a_wavy_z))
    { aVars->wav_tb=aVars->wav_lr=aVars->wav_z=a_wavy; }
    else
    { aVars->wav_tb=a_wavy_tb; aVars->wav_lr=a_wavy_lr; aVars->wav_z=a_wavy_z; }
    aVars->wav_tb *= DEG2RAD/(sqrt(8*log(2)));   /* Convert from deg FWHM to rad Gaussian sigma */
    aVars->wav_lr *= DEG2RAD/(sqrt(8*log(2)));
    aVars->wav_z  *= DEG2RAD/(sqrt(8*log(2)));
    /* handle chamfers init */
    if (a_chamfers && (!a_chamfers_z && !a_chamfers_lr && !a_chamfers_tb))
    { aVars->chamfer_z=aVars->chamfer_lr=aVars->chamfer_tb=a_chamfers; }
    else
    {
      aVars->chamfer_z=a_chamfers_z;
      aVars->chamfer_lr=a_chamfers_lr;
      aVars->chamfer_tb=a_chamfers_tb;
    }

    aVars->fc_freq  = a_nu;
    aVars->fc_phase = a_phase;
  }

  int Gravity_guide_Trace(double *dt,
        Gravity_guide_Vars_type *aVars,
        double cx, double cy, double cz,
        double cvx, double cvy, double cvz,
        double cxnum, double cxk, double cynum, double cyk,
        double *cnx, double *cny,double *cnz)
  {
    double B, C;
    int    ret=0;
    int    side=0;
    double n1;
    double dt0, dt_min=0;
    int    i;
    double loc_num, loc_nslit;
    int    i_slope=3;

    /* look if there is a previous intersection with guide sides */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 5=+Z side: n=(0, 0, -l) ; W = (0, 0, l) (at z=l, guide exit)*/
    B = aVars->nz[5]*cvz; C = aVars->nz[5]*(cz - aVars->wz[5]);
    ret = solve_2nd_order(&dt0, NULL, aVars->A[5], B, C);
    if (ret && dt0>1e-10) { dt_min = dt0; side=5; }

    loc_num = cynum; loc_nslit = cyk;
    for (i=4; i>0; i--)
    {
      if (i == 2) { i_slope=1; loc_num = cxnum; loc_nslit = cxk; }

      if (aVars->nzC[i_slope] != 0) {
        n1 = loc_nslit - 2*(loc_num);  /* slope of l/r/u/d sides depends on the channel ! */
        loc_num++; /* use partial computations to alter nz and A */
        aVars->nz[i]= aVars->nzC[i]*n1;
        aVars->A[i] = aVars->Axy[i] + aVars->nz[i]*aVars->gz/2;
      }
      if (i < 3)
      {      B = aVars->nx[i]*cvx + aVars->nz[i]*cvz; C = aVars->nx[i]*(cx-aVars->wx[i]) + aVars->nz[i]*cz; }
      else { B = aVars->ny[i]*cvy + aVars->nz[i]*cvz; C = aVars->ny[i]*(cy-aVars->wy[i]) + aVars->nz[i]*cz; }
      ret = solve_2nd_order(&dt0, NULL, aVars->A[i], B, C);
      if (ret && dt0>1e-10 && (dt0<dt_min || !dt_min))
      { dt_min = dt0; side=i;
        if (aVars->nzC[i] != 0)
        { aVars->norm_n2[i] = aVars->norm_n2xy[i] + aVars->nz[i]*aVars->nz[i];
          aVars->norm_n[i]  = sqrt(aVars->norm_n2[i]); }
      }
     }

    *dt = dt_min;
    /* handles waviness: rotate n vector */
    if (side > 0 && side < 5 && (aVars->wav_z || aVars->wav_lr || aVars->wav_tb))
    {
      double nt_x, nt_y, nt_z;  /* transverse vector */
      double nn_x, nn_y, nn_z;  /* normal vector (tmp) */
      double phi;
      /* normal vector n_z = [ 0,0,1], n_t = n x n_z; */
      vec_prod(nt_x,nt_y,nt_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], 0,0,1);
      /* rotate n with angle wavy_z around n_t -> nn */
      if (aVars->wav_z) {
        phi = aVars->wav_z;
        rotate(nn_x,nn_y,nn_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], aVars->wav_z*randnorm(), nt_x,nt_y,nt_z);
      } else { nn_x=aVars->nx[side]; nn_y=aVars->ny[side]; nn_z=aVars->nz[side]; }
      /* rotate n with angle wavy_{x|y} around n_z -> nt */
      phi = (side <=2) ? aVars->wav_lr : aVars->wav_tb;
      if (phi) {
        rotate(nt_x,nt_y,nt_z, nn_x,nn_y,nn_z, phi*randnorm(), 0,0,1);
      } else { nt_x=nn_x; nt_y=nn_y; nt_z=nn_z; }
      *cnx=nt_x; *cny=nt_y; *cnz=nt_z;
    } else
    { *cnx=aVars->nx[side]; *cny=aVars->ny[side]; *cnz=aVars->nz[side]; }
    return (side);
  }



#endif
#line 7631 "BIFROST.c"

/* Shared user declarations for all components 'Virtual_output'. */
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\Virtual_output.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H

#define MONITOR_ND_LIB_H "$Revision$"
#define MONnD_COORD_NMAX  30  /* max number of variables to record */

  typedef struct MonitornD_Defines
  {
    int COORD_NONE  ;
    int COORD_X     ;
    int COORD_Y     ;
    int COORD_Z     ;
    int COORD_RADIUS; 
    int COORD_VX    ;
    int COORD_VY    ;
    int COORD_VZ    ;
    int COORD_V     ;
    int COORD_T     ;
    int COORD_P     ;
    int COORD_SX    ;
    int COORD_SY    ;
    int COORD_SZ    ;
    int COORD_KX    ;
    int COORD_KY    ;
    int COORD_KZ    ;
    int COORD_K     ;
    int COORD_ENERGY;
    int COORD_LAMBDA;
    int COORD_KXY   ;
    int COORD_KYZ   ;
    int COORD_KXZ   ;
    int COORD_VXY   ;
    int COORD_VYZ   ;
    int COORD_VXZ   ;
    int COORD_HDIV  ;
    int COORD_VDIV  ;
    int COORD_ANGLE ;
    int COORD_NCOUNT;
    int COORD_THETA ;
    int COORD_PHI   ;
    int COORD_USER1 ;
    int COORD_USER2 ;
    int COORD_USER3 ;
    int COORD_XY    ;
    int COORD_XZ    ;
    int COORD_YZ    ;
    int COORD_PIXELID;

    /* token modifiers */
    int COORD_VAR   ; /* next token should be a variable or normal option */
    int COORD_MIN   ; /* next token is a min value */
    int COORD_MAX   ; /* next token is a max value */
    int COORD_DIM   ; /* next token is a bin value */
    int COORD_FIL   ; /* next token is a filename */
    int COORD_EVNT  ; /* next token is a buffer size value */
    int COORD_3HE   ; /* next token is a 3He pressure value */
    int COORD_LOG   ; /* next variable will be in log scale */
    int COORD_ABS   ; /* next variable will be in abs scale */
    int COORD_SIGNAL; /* next variable will be the signal var */
    int COORD_AUTO  ; /* set auto limits */

    char TOKEN_DEL[32]; /* token separators */

    char SHAPE_SQUARE; /* shape of the monitor */
    char SHAPE_DISK  ;
    char SHAPE_SPHERE;
    char SHAPE_CYLIND;
    char SHAPE_BANANA; /* cylinder without top/bottom, on restricted angular area */
    char SHAPE_BOX   ;
    char SHAPE_PREVIOUS;
    char SHAPE_OFF;

  } MonitornD_Defines_type;

  typedef struct MonitornD_Variables
  {
    double area;
    double Sphere_Radius     ;
    double Cylinder_Height   ;
    char   Flag_With_Borders ;   /* 2 means xy borders too */
    char   Flag_List         ;   /* 1 store 1 buffer, 2 is list all, 3 list all+append */
    char   Flag_Multiple     ;   /* 1 when n1D, 0 for 2D */
    char   Flag_Verbose      ;
    int    Flag_Shape        ;
    char   Flag_Auto_Limits  ;   /* get limits from first Buffer */
    char   Flag_Absorb       ;   /* monitor is also a slit */
    char   Flag_per_cm2      ;   /* flux is per cm2 */
    char   Flag_log          ;   /* log10 of the flux */
    char   Flag_parallel     ;   /* set neutron state back after detection (parallel components) */
    char   Flag_Binary_List  ;
    char   Flag_capture      ;   /* lambda monitor with lambda/lambda(2200m/s = 1.7985 Angs) weightening */
    int    Flag_signal       ;   /* 0:monitor p, else monitor a mean value */
    int    Flag_mantid       ;   /* 0:normal monitor, else do mantid-event specifics */
    int    Flag_OFF          ;   /* Flag to indicate external geometry from OFF file */
    unsigned long OFF_polyidx;   /* When intersection is done externally by off_intersect, this gives the 
				    polygon number, i.e. pixel index */

    unsigned long Coord_Number      ;   /* total number of variables to monitor, plus intensity (0) */
    unsigned long Coord_NumberNoPixel;  /* same but without counting PixelID */
    unsigned long Buffer_Block      ;   /* Buffer size for list or auto limits */
    unsigned long Neutron_Counter   ;   /* event counter, simulation total counts is mcget_ncount() */
    unsigned long Buffer_Counter    ;   /* index in Buffer size (for realloc) */
    unsigned long Buffer_Size       ;
    int    Coord_Type[MONnD_COORD_NMAX];      /* type of variable */
    char   Coord_Label[MONnD_COORD_NMAX][30]; /* label of variable */
    char   Coord_Var[MONnD_COORD_NMAX][30];   /* short id of variable */
    long   Coord_Bin[MONnD_COORD_NMAX];       /* bins of variable array */
    long   Coord_BinProd[MONnD_COORD_NMAX];   /* product of bins of variable array */
    double Coord_Min[MONnD_COORD_NMAX];
    double Coord_Max[MONnD_COORD_NMAX];
    char   Monitor_Label[MONnD_COORD_NMAX*30];/* Label for monitor */
    char   Mon_File[128];                     /* output file name */

    double cx,cy,cz;
    double cvx, cvy, cvz;
    double ckx, cky, ckz;
    double csx, csy, csz;
    double cEx, cEy, cEz;
    double cs1, cs2, ct, cphi, cp;
    double He3_pressure;
    char   Flag_UsePreMonitor    ;   /* use a previously stored neutron parameter set */
    char   UserName1[128];
    char   UserName2[128];
    char   UserName3[128];
    double UserVariable1;
    double UserVariable2;
    double UserVariable3;
    char   option[CHAR_BUF_LENGTH];

    long long int Nsum;
    double psum, p2sum;
    double **Mon2D_N;
    double **Mon2D_p;
    double **Mon2D_p2;
    double *Mon2D_Buffer;
    unsigned long PixelID;

    double mxmin,mxmax,mymin,mymax,mzmin,mzmax;
    double mean_dx, mean_dy, min_x, min_y, max_x, max_y, mean_p;

    char   compcurname[128];
    Coords compcurpos;

  } MonitornD_Variables_type;

/* monitor_nd-lib function prototypes */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *, MonitornD_Variables_type *, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, int);
double Monitor_nD_Trace(MonitornD_Defines_type *, MonitornD_Variables_type *);
MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_Finally(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_McDisplay(MonitornD_Defines_type *,
 MonitornD_Variables_type *);

#define MONND_DECLARE(monname) \
  struct MonitornD_Variables *mcmonnd ## monname;
#define MONND_USER_TITLE(monname, num, title) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    strcpy(mcmonnd ## monname->UserName ## num, title); }
#define MONND_USER_VALUE(monname, num, value) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    mcmonnd ## monname->UserVariable ## num = (value); }

#endif

/* end of monitor_nd-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H
#error McStas : please import this library with %include "monitor_nd-lib"
#endif

/* ========================================================================= */
/* Monitor_nD_Init: this routine is used to parse options                    */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars,
  MCNUM xwidth,
  MCNUM yheight,
  MCNUM zdepth,
  MCNUM xmin,
  MCNUM xmax,
  MCNUM ymin,
  MCNUM ymax,
  MCNUM zmin,
  MCNUM zmax,
  int offflag)
  {
    long carg = 1;
    char *option_copy, *token;
    char Flag_New_token = 1;
    char Flag_End       = 1;
    char Flag_All       = 0;
    char Flag_No        = 0;
    char Flag_abs       = 0;
    int  Flag_auto      = 0;  /* -1: all, 1: the current variable */
    int  Set_Vars_Coord_Type;
    char Set_Vars_Coord_Label[64];
    char Set_Vars_Coord_Var[64];
    char Short_Label[MONnD_COORD_NMAX][64];
    int  Set_Coord_Mode;
    long i=0, j=0;
    double lmin, lmax, XY=0;
    long t;


    t = (long)time(NULL);

/* initialize DEFS */
/* Variables to monitor */
    DEFS->COORD_NONE   =0;
    DEFS->COORD_X      =1;
    DEFS->COORD_Y      =2;
    DEFS->COORD_Z      =3;
    DEFS->COORD_RADIUS =19;
    DEFS->COORD_VX     =4;
    DEFS->COORD_VY     =5;
    DEFS->COORD_VZ     =6;
    DEFS->COORD_V      =16;
    DEFS->COORD_T      =7;
    DEFS->COORD_P      =8;
    DEFS->COORD_SX     =9;
    DEFS->COORD_SY     =10;
    DEFS->COORD_SZ     =11;
    DEFS->COORD_KX     =12;
    DEFS->COORD_KY     =13;
    DEFS->COORD_KZ     =14;
    DEFS->COORD_K      =15;
    DEFS->COORD_ENERGY =17;
    DEFS->COORD_LAMBDA =18;
    DEFS->COORD_HDIV   =20;
    DEFS->COORD_VDIV   =21;
    DEFS->COORD_ANGLE  =22;
    DEFS->COORD_NCOUNT =23;
    DEFS->COORD_THETA  =24;
    DEFS->COORD_PHI    =25;
    DEFS->COORD_USER1  =26;
    DEFS->COORD_USER2  =27;
    DEFS->COORD_USER3  =28;
    DEFS->COORD_XY     =37;
    DEFS->COORD_YZ     =31;
    DEFS->COORD_XZ     =32;
    DEFS->COORD_VXY    =30;
    DEFS->COORD_VYZ    =34;
    DEFS->COORD_VXZ    =36;
    DEFS->COORD_KXY    =29;
    DEFS->COORD_KYZ    =33;
    DEFS->COORD_KXZ    =35;
    DEFS->COORD_PIXELID=38;

/* token modifiers */
    DEFS->COORD_VAR    =0;    /* next token should be a variable or normal option */
    DEFS->COORD_MIN    =1;    /* next token is a min value */
    DEFS->COORD_MAX    =2;    /* next token is a max value */
    DEFS->COORD_DIM    =3;    /* next token is a bin value */
    DEFS->COORD_FIL    =4;    /* next token is a filename */
    DEFS->COORD_EVNT   =5;    /* next token is a buffer size value */
    DEFS->COORD_3HE    =6;    /* next token is a 3He pressure value */
    DEFS->COORD_LOG    =64;   /* next variable will be in log scale */
    DEFS->COORD_ABS    =128;  /* next variable will be in abs scale */
    DEFS->COORD_SIGNAL =256;  /* next variable will be the signal var */
    DEFS->COORD_AUTO   =512;  /* set auto limits */

    strcpy(DEFS->TOKEN_DEL, " =,;[](){}:");  /* token separators */

    DEFS->SHAPE_SQUARE =0;    /* shape of the monitor */
    DEFS->SHAPE_DISK   =1;
    DEFS->SHAPE_SPHERE =2;
    DEFS->SHAPE_CYLIND =3;
    DEFS->SHAPE_BANANA =4;
    DEFS->SHAPE_BOX    =5;
    DEFS->SHAPE_PREVIOUS=6;
    DEFS->SHAPE_OFF=7;

    Vars->Sphere_Radius     = 0;
    Vars->Cylinder_Height   = 0;
    Vars->Flag_With_Borders = 0;   /* 2 means xy borders too */
    Vars->Flag_List         = 0;   /* 1=store 1 buffer, 2=list all, 3=re-use buffer */
    Vars->Flag_Multiple     = 0;   /* 1 when n1D, 0 for 2D */
    Vars->Flag_Verbose      = 0;
    Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    Vars->Flag_Auto_Limits  = 0;   /* get limits from first Buffer */
    Vars->Flag_Absorb       = 0;   /* monitor is also a slit */
    Vars->Flag_per_cm2      = 0;   /* flux is per cm2 */
    Vars->Flag_log          = 0;   /* log10 of the flux */
    Vars->Flag_parallel     = 0;   /* set neutron state back after detection (parallel components) */
    Vars->Flag_Binary_List  = 0;   /* save list as a binary file (smaller) */
    Vars->Coord_Number      = 0;   /* total number of variables to monitor, plus intensity (0) */
    Vars->Coord_NumberNoPixel=0;   /* same but without counting PixelID */
    Vars->Buffer_Block      = 10000;     /* Buffer size for list or auto limits */
    Vars->Neutron_Counter   = 0;   /* event counter, simulation total counts is mcget_ncount() */
    Vars->Buffer_Counter    = 0;   /* index in Buffer size (for realloc) */
    Vars->Buffer_Size       = 0;
    Vars->UserVariable1     = 0;
    Vars->UserVariable2     = 0;
    Vars->He3_pressure      = 0;
    Vars->Flag_capture      = 0;
    Vars->Flag_signal       = DEFS->COORD_P;
    Vars->Flag_mantid       = 0;
    Vars->Flag_OFF          = offflag;
    Vars->OFF_polyidx       = -1;
    Vars->mean_dx=Vars->mean_dy=0;
    Vars->min_x = Vars->max_x  =0;
    Vars->min_y = Vars->max_y  =0;

    Set_Vars_Coord_Type = DEFS->COORD_NONE;
    Set_Coord_Mode = DEFS->COORD_VAR;

    /* handle size parameters */
    /* normal use is with xwidth, yheight, zdepth */
    /* if xmin,xmax,ymin,ymax,zmin,zmax are non 0, use them */
    if (fabs(xmin-xmax) == 0)
      { Vars->mxmin = -fabs(xwidth)/2; Vars->mxmax = fabs(xwidth)/2; }
    else
      { if (xmin < xmax) {Vars->mxmin = xmin; Vars->mxmax = xmax;}
        else {Vars->mxmin = xmax; Vars->mxmax = xmin;}
      }
    if (fabs(ymin-ymax) == 0)
      { Vars->mymin = -fabs(yheight)/2; Vars->mymax = fabs(yheight)/2; }
    else
      { if (ymin < ymax) {Vars->mymin = ymin; Vars->mymax = ymax;}
        else {Vars->mymin = ymax; Vars->mymax = ymin;}
      }
    if (fabs(zmin-zmax) == 0)
      { Vars->mzmin = -fabs(zdepth)/2; Vars->mzmax = fabs(zdepth)/2; }
    else
      { if (zmin < zmax) {Vars->mzmin = zmin; Vars->mzmax = zmax; }
        else {Vars->mzmin = zmax; Vars->mzmax = zmin; }
      }

    if (fabs(Vars->mzmax-Vars->mzmin) == 0)
      Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    else
      Vars->Flag_Shape        = DEFS->SHAPE_BOX;

    if (Vars->Flag_OFF) {
      Vars->Flag_Shape        = DEFS->SHAPE_OFF;
    }
    
    /* parse option string */

    option_copy = (char*)malloc(strlen(Vars->option)+1);
    if (option_copy == NULL)
    {
      fprintf(stderr,"Monitor_nD: %s cannot allocate 'options' copy (%li). Fatal.\n", Vars->compcurname, (long)strlen(Vars->option));
      exit(-1);
    }

    if (strlen(Vars->option))
    {
      Flag_End = 0;
      strcpy(option_copy, Vars->option);
    }

    if (strstr(Vars->option, "cm2") || strstr(Vars->option, "cm^2")) Vars->Flag_per_cm2 = 1;

    if (strstr(Vars->option, "binary") || strstr(Vars->option, "float"))
      Vars->Flag_Binary_List  = 1;
    if (strstr(Vars->option, "double"))
      Vars->Flag_Binary_List  = 2;

    strcpy(Vars->Coord_Label[0],"Intensity");
    strncpy(Vars->Coord_Var[0],"p",30);
    Vars->Coord_Type[0] = DEFS->COORD_P;
    Vars->Coord_Bin[0] = 1;
    Vars->Coord_Min[0] = 0;
    Vars->Coord_Max[0] = FLT_MAX;

    /* default file name is comp_name+dateID */
    sprintf(Vars->Mon_File, "%s_%li", Vars->compcurname, t);

    carg = 1;
    while((Flag_End == 0) && (carg < 128))
    {

      if (Flag_New_token) /* retain previous token or get a new one */
      {
        if (carg == 1) token=(char *)strtok(option_copy,DEFS->TOKEN_DEL);
        else token=(char *)strtok(NULL,DEFS->TOKEN_DEL);
        if (token == NULL) Flag_End=1;
      }
      Flag_New_token = 1;
      if ((token != NULL) && (strlen(token) != 0))
      {
        char iskeyword=0; /* left at 0 when variables are processed, 1 for modifiers */
        int  old_Mode;
        /* change token to lower case */
        for (i=0; i<strlen(token); i++) token[i]=tolower(token[i]);
        /* first handle option values from preceeding keyword token detected */
        old_Mode = Set_Coord_Mode;
        if (Set_Coord_Mode == DEFS->COORD_MAX)  /* max=%i */
        {
          if (!Flag_All)
            Vars->Coord_Max[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Max[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_MIN)  /* min=%i */
        {
          if (!Flag_All)
            Vars->Coord_Min[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Min[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_MAX;
        }
        if (Set_Coord_Mode == DEFS->COORD_DIM)  /* bins=%i */
        {
          if (!Flag_All)
            Vars->Coord_Bin[Vars->Coord_Number] = atoi(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Bin[i++] = atoi(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_FIL)  /* file=%s */
        {
          if (!Flag_No) strncpy(Vars->Mon_File,token,128);
          else { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1;}
          Set_Coord_Mode = DEFS->COORD_VAR;
        }
        if (Set_Coord_Mode == DEFS->COORD_EVNT) /* list=%i */
        {
          if (!strcmp(token, "all") || Flag_All) Vars->Flag_List = 2;
          else { i = (long)ceil(atof(token)); if (i) Vars->Buffer_Block = i;
            Vars->Flag_List = 1; }
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_3HE)  /* pressure=%g */
        {
            Vars->He3_pressure = atof(token);
            Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }

        /* now look for general option keywords */
        if (!strcmp(token, "borders"))  {Vars->Flag_With_Borders = 1; iskeyword=1; }
        if (!strcmp(token, "verbose"))  {Vars->Flag_Verbose      = 1; iskeyword=1; }
        if (!strcmp(token, "log"))      {Vars->Flag_log          = 1; iskeyword=1; }
        if (!strcmp(token, "abs"))      {Flag_abs                = 1; iskeyword=1; }
        if (!strcmp(token, "multiple")) {Vars->Flag_Multiple     = 1; iskeyword=1; }
        if (!strcmp(token, "list") || !strcmp(token, "events")) {
          Vars->Flag_List = 1; Set_Coord_Mode = DEFS->COORD_EVNT;  }
        if (!strcmp(token, "limits") || !strcmp(token, "min"))
          Set_Coord_Mode = DEFS->COORD_MIN;
        if (!strcmp(token, "slit") || !strcmp(token, "absorb")) {
          Vars->Flag_Absorb = 1;  iskeyword=1; }
        if (!strcmp(token, "max"))  Set_Coord_Mode = DEFS->COORD_MAX;
        if (!strcmp(token, "bins") || !strcmp(token, "dim")) Set_Coord_Mode = DEFS->COORD_DIM;
        if (!strcmp(token, "file") || !strcmp(token, "filename")) {
          Set_Coord_Mode = DEFS->COORD_FIL;
          if (Flag_No) { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1; }
        }
        if (!strcmp(token, "unactivate")) {
          Flag_End = 1; Vars->Coord_Number = 0; iskeyword=1; }
        if (!strcmp(token, "all"))    { Flag_All = 1;  iskeyword=1; }
        if (!strcmp(token, "sphere")) { Vars->Flag_Shape = DEFS->SHAPE_SPHERE; iskeyword=1; }
        if (!strcmp(token, "cylinder")) { Vars->Flag_Shape = DEFS->SHAPE_CYLIND; iskeyword=1; }
        if (!strcmp(token, "banana")) { Vars->Flag_Shape = DEFS->SHAPE_BANANA; iskeyword=1; }
        if (!strcmp(token, "square")) { Vars->Flag_Shape = DEFS->SHAPE_SQUARE; iskeyword=1; }
        if (!strcmp(token, "disk"))   { Vars->Flag_Shape = DEFS->SHAPE_DISK; iskeyword=1; }
        if (!strcmp(token, "box"))     { Vars->Flag_Shape = DEFS->SHAPE_BOX; iskeyword=1; }
        if (!strcmp(token, "previous")) { Vars->Flag_Shape = DEFS->SHAPE_PREVIOUS; iskeyword=1; }
        if (!strcmp(token, "parallel")){ Vars->Flag_parallel = 1; iskeyword=1; }
        if (!strcmp(token, "capture")) { Vars->Flag_capture = 1; iskeyword=1; }
        if (!strcmp(token, "auto") && (Flag_auto != -1)) {
          Vars->Flag_Auto_Limits = 1;
          if (Flag_All) Flag_auto = -1;
          else          Flag_auto = 1;
          iskeyword=1; Flag_All=0; }
        if (!strcmp(token, "premonitor")) {
          Vars->Flag_UsePreMonitor = 1; iskeyword=1; }
        if (!strcmp(token, "3He_pressure") || !strcmp(token, "pressure")) {
          Vars->He3_pressure = 3; iskeyword=1; }
        if (!strcmp(token, "no") || !strcmp(token, "not")) { Flag_No = 1;  iskeyword=1; }
        if (!strcmp(token, "signal")) Set_Coord_Mode = DEFS->COORD_SIGNAL;
        if (!strcmp(token, "mantid")) { Vars->Flag_mantid = 1; iskeyword=1; }

        /* Mode has changed: this was a keyword or value  ? */
        if (Set_Coord_Mode != old_Mode) iskeyword=1;

        /* now look for variable names to monitor */
        Set_Vars_Coord_Type = DEFS->COORD_NONE; lmin = 0; lmax = 0;

        if (!strcmp(token, "x"))
          { Set_Vars_Coord_Type = DEFS->COORD_X; strcpy(Set_Vars_Coord_Label,"x [m]"); strcpy(Set_Vars_Coord_Var,"x");
          lmin = Vars->mxmin; lmax = Vars->mxmax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mxmin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mxmax;}
        if (!strcmp(token, "y"))
          { Set_Vars_Coord_Type = DEFS->COORD_Y; strcpy(Set_Vars_Coord_Label,"y [m]"); strcpy(Set_Vars_Coord_Var,"y");
          lmin = Vars->mymin; lmax = Vars->mymax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mymin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mymax;}
        if (!strcmp(token, "z"))
          { Set_Vars_Coord_Type = DEFS->COORD_Z; strcpy(Set_Vars_Coord_Label,"z [m]"); strcpy(Set_Vars_Coord_Var,"z"); lmin = Vars->mzmin; lmax = Vars->mzmax; }
        if (!strcmp(token, "k") || !strcmp(token, "wavevector"))
          { Set_Vars_Coord_Type = DEFS->COORD_K; strcpy(Set_Vars_Coord_Label,"|k| [Angs-1]"); strcpy(Set_Vars_Coord_Var,"k"); lmin = 0; lmax = 10; }
        if (!strcmp(token, "v"))
          { Set_Vars_Coord_Type = DEFS->COORD_V; strcpy(Set_Vars_Coord_Label,"Velocity [m/s]"); strcpy(Set_Vars_Coord_Var,"v"); lmin = 0; lmax = 10000; }
        if (!strcmp(token, "t") || !strcmp(token, "time") || !strcmp(token, "tof"))
          { Set_Vars_Coord_Type = DEFS->COORD_T; strcpy(Set_Vars_Coord_Label,"TOF [s]"); strcpy(Set_Vars_Coord_Var,"t"); lmin = 0; lmax = .1; }
        if ((!strcmp(token, "p") || !strcmp(token, "i") || !strcmp(token, "intensity") || !strcmp(token, "flux")))
          { Set_Vars_Coord_Type = DEFS->COORD_P;
            strcpy(Set_Vars_Coord_Label,"Intensity");
            strncat(Set_Vars_Coord_Label, " [n/s", 30);
            if (Vars->Flag_per_cm2) strncat(Set_Vars_Coord_Label, "/cm2", 30);
            if (XY > 1 && Vars->Coord_Number)
              strncat(Set_Vars_Coord_Label, "/bin", 30);
            strncat(Set_Vars_Coord_Label, "]", 30);
            strcpy(Set_Vars_Coord_Var,"I");
            lmin = 0; lmax = FLT_MAX;
            if (Flag_auto>0) Flag_auto=0;
          }

        if (!strcmp(token, "vx"))
          { Set_Vars_Coord_Type = DEFS->COORD_VX; strcpy(Set_Vars_Coord_Label,"vx [m/s]"); strcpy(Set_Vars_Coord_Var,"vx"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VY; strcpy(Set_Vars_Coord_Label,"vy [m/s]"); strcpy(Set_Vars_Coord_Var,"vy"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VZ; strcpy(Set_Vars_Coord_Label,"vz [m/s]"); strcpy(Set_Vars_Coord_Var,"vz"); lmin = -10000; lmax = 10000; }
        if (!strcmp(token, "kx"))
          { Set_Vars_Coord_Type = DEFS->COORD_KX; strcpy(Set_Vars_Coord_Label,"kx [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "ky"))
          { Set_Vars_Coord_Type = DEFS->COORD_KY; strcpy(Set_Vars_Coord_Label,"ky [Angs-1]"); strcpy(Set_Vars_Coord_Var,"ky"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "kz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KZ; strcpy(Set_Vars_Coord_Label,"kz [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kz"); lmin = -10; lmax = 10; }
        if (!strcmp(token, "sx"))
          { Set_Vars_Coord_Type = DEFS->COORD_SX; strcpy(Set_Vars_Coord_Label,"sx [1]"); strcpy(Set_Vars_Coord_Var,"sx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sy"))
          { Set_Vars_Coord_Type = DEFS->COORD_SY; strcpy(Set_Vars_Coord_Label,"sy [1]"); strcpy(Set_Vars_Coord_Var,"sy"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sz"))
          { Set_Vars_Coord_Type = DEFS->COORD_SZ; strcpy(Set_Vars_Coord_Label,"sz [1]"); strcpy(Set_Vars_Coord_Var,"sz"); lmin = -1; lmax = 1; }

        if (!strcmp(token, "energy") || !strcmp(token, "omega") || !strcmp(token, "e"))
          { Set_Vars_Coord_Type = DEFS->COORD_ENERGY; strcpy(Set_Vars_Coord_Label,"Energy [meV]"); strcpy(Set_Vars_Coord_Var,"E"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "lambda") || !strcmp(token, "wavelength") || !strcmp(token, "l"))
          { Set_Vars_Coord_Type = DEFS->COORD_LAMBDA; strcpy(Set_Vars_Coord_Label,"Wavelength [Angs]"); strcpy(Set_Vars_Coord_Var,"L"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "radius") || !strcmp(token, "r"))
          { Set_Vars_Coord_Type = DEFS->COORD_RADIUS; strcpy(Set_Vars_Coord_Label,"Radius [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xy"))
          { Set_Vars_Coord_Type = DEFS->COORD_XY; strcpy(Set_Vars_Coord_Label,"Radius (xy) [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "yz"))
          { Set_Vars_Coord_Type = DEFS->COORD_YZ; strcpy(Set_Vars_Coord_Label,"Radius (yz) [m]"); strcpy(Set_Vars_Coord_Var,"yz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xz"))
          { Set_Vars_Coord_Type = DEFS->COORD_XZ; strcpy(Set_Vars_Coord_Label,"Radius (xz) [m]"); strcpy(Set_Vars_Coord_Var,"xz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "vxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXY; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xy) [m]"); strcpy(Set_Vars_Coord_Var,"Vxy"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXY; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xy) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxy"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VYZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (yz) [m]"); strcpy(Set_Vars_Coord_Var,"Vyz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KYZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (yz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kyz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xz) [m]"); strcpy(Set_Vars_Coord_Var,"Vxz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "angle") || !strcmp(token, "a"))
          { Set_Vars_Coord_Type = DEFS->COORD_ANGLE; strcpy(Set_Vars_Coord_Label,"Angle [deg]"); strcpy(Set_Vars_Coord_Var,"A"); lmin = -50; lmax = 50; }
        if (!strcmp(token, "hdiv")|| !strcmp(token, "divergence") || !strcmp(token, "xdiv") || !strcmp(token, "hd") || !strcmp(token, "dx"))
          { Set_Vars_Coord_Type = DEFS->COORD_HDIV; strcpy(Set_Vars_Coord_Label,"Hor. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"hd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "vdiv") || !strcmp(token, "ydiv") || !strcmp(token, "vd") || !strcmp(token, "dy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VDIV; strcpy(Set_Vars_Coord_Label,"Vert. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"vd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "theta") || !strcmp(token, "longitude") || !strcmp(token, "th"))
          { Set_Vars_Coord_Type = DEFS->COORD_THETA; strcpy(Set_Vars_Coord_Label,"Longitude [deg]"); strcpy(Set_Vars_Coord_Var,"th"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "phi") || !strcmp(token, "lattitude") || !strcmp(token, "ph"))
          { Set_Vars_Coord_Type = DEFS->COORD_PHI; strcpy(Set_Vars_Coord_Label,"Lattitude [deg]"); strcpy(Set_Vars_Coord_Var,"ph"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "ncounts") || !strcmp(token, "n") || !strcmp(token, "neutron"))
          { Set_Vars_Coord_Type = DEFS->COORD_NCOUNT; strcpy(Set_Vars_Coord_Label,"Neutron ID [1]"); strcpy(Set_Vars_Coord_Var,"n"); lmin = 0; lmax = mcget_ncount(); if (Flag_auto>0) Flag_auto=0; }
        if (!strcmp(token, "id") || !strcmp(token, "pixel"))
          { Set_Vars_Coord_Type = DEFS->COORD_PIXELID; 
            strcpy(Set_Vars_Coord_Label,"Pixel ID [1]"); 
            strcpy(Set_Vars_Coord_Var,"id"); lmin = 0; lmax = FLT_MAX; 
            if (Flag_auto>0) Flag_auto=0;
            Vars->Flag_List = 1; }
        if (!strcmp(token, "user") || !strcmp(token, "user1") || !strcmp(token, "u1"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER1; strncpy(Set_Vars_Coord_Label,Vars->UserName1,30); strcpy(Set_Vars_Coord_Var,"U1"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user2") || !strcmp(token, "u2"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER2; strncpy(Set_Vars_Coord_Label,Vars->UserName2,30); strcpy(Set_Vars_Coord_Var,"U2"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user3") || !strcmp(token, "u3"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER3; strncpy(Set_Vars_Coord_Label,Vars->UserName3,30); strcpy(Set_Vars_Coord_Var,"U3"); lmin = -1e10; lmax = 1e10; }

        /* now stores variable keywords detected, if any */
        if (Set_Vars_Coord_Type != DEFS->COORD_NONE)
        {
          int Coord_Number = Vars->Coord_Number;
          if (Vars->Flag_log) { Set_Vars_Coord_Type |= DEFS->COORD_LOG; Vars->Flag_log = 0; }
          if (Flag_abs) { Set_Vars_Coord_Type |= DEFS->COORD_ABS; Flag_abs = 0; }
          if (Flag_auto != 0) { Set_Vars_Coord_Type |= DEFS->COORD_AUTO; 
            if (Flag_auto > 0) Flag_auto = 0; }
          if (Set_Coord_Mode == DEFS->COORD_SIGNAL)
          {
            Coord_Number = 0;
            Vars->Flag_signal = Set_Vars_Coord_Type;
          }
          else
          {
            if (Coord_Number < MONnD_COORD_NMAX)
            { Coord_Number++;
              Vars->Coord_Number = Coord_Number; 
              if (Set_Vars_Coord_Type != DEFS->COORD_PIXELID)
                Vars->Coord_NumberNoPixel++;
            }
            else if (Vars->Flag_Verbose) printf("Monitor_nD: %s reached max number of variables (%i).\n", Vars->compcurname, MONnD_COORD_NMAX);
          }
          Vars->Coord_Type[Coord_Number] = Set_Vars_Coord_Type;
          strncpy(Vars->Coord_Label[Coord_Number], Set_Vars_Coord_Label,30);
          strncpy(Vars->Coord_Var[Coord_Number], Set_Vars_Coord_Var,30);
          if (lmin > lmax) { XY = lmin; lmin=lmax; lmax = XY; }
          Vars->Coord_Min[Coord_Number] = lmin;
          Vars->Coord_Max[Coord_Number] = lmax;
          if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT || Set_Vars_Coord_Type == DEFS->COORD_PIXELID || Set_Vars_Coord_Type == DEFS->COORD_SIGNAL)
            Vars->Coord_Bin[Coord_Number] = 1;
          else
            Vars->Coord_Bin[Coord_Number] = 20;
          Set_Coord_Mode = DEFS->COORD_VAR;
          Flag_All = 0;
          Flag_No  = 0;
        } else {
          /* no variable name could be read from options */
          if (!iskeyword) {
            if (strcmp(token, "cm2") && strcmp(token, "incoming")
             && strcmp(token, "outgoing") && strcmp(token, "cm2")
             && strcmp(token, "cm^2") && strcmp(token, "float")
             && strcmp(token, "double") && strcmp(token, "binary")
             && strcmp(token, "steradian") && Vars->Flag_Verbose)
              printf("Monitor_nD: %s: unknown '%s' keyword in 'options'. Ignoring.\n", Vars->compcurname, token);
          }
        }
      carg++;
      } /* end if token */
    } /* end while carg */
    free(option_copy);
    if (carg == 128) printf("Monitor_nD: %s reached max number of tokens (%i). Skipping.\n", Vars->compcurname, 128);

    if ((Vars->Flag_Shape == DEFS->SHAPE_BOX) && (fabs(Vars->mzmax - Vars->mzmin) == 0)) Vars->Flag_Shape = DEFS->SHAPE_SQUARE;

    if (Vars->Flag_log == 1) Vars->Coord_Type[0] |= DEFS->COORD_LOG;
    if (Vars->Coord_Number == 0)
    { Vars->Flag_Auto_Limits=0; Vars->Flag_Multiple=0; Vars->Flag_List=0; }

    /* now setting Monitor Name from variable labels */
    strcpy(Vars->Monitor_Label,"");
    XY = 1; /* will contain total bin number */
    for (i = 0; i <= Vars->Coord_Number; i++)
    {
      if (Flag_auto != 0) Vars->Coord_Type[i] |= DEFS->COORD_AUTO;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if ((Set_Vars_Coord_Type == DEFS->COORD_X)
       || (Set_Vars_Coord_Type == DEFS->COORD_Y)
       || (Set_Vars_Coord_Type == DEFS->COORD_Z))
       strcpy(Short_Label[i],"Position");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_THETA)
       || (Set_Vars_Coord_Type == DEFS->COORD_PHI)
       || (Set_Vars_Coord_Type == DEFS->COORD_ANGLE))
       strcpy(Short_Label[i],"Angle");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_XY)
       || (Set_Vars_Coord_Type == DEFS->COORD_XZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_YZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_RADIUS))
       strcpy(Short_Label[i],"Radius");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_VX)
       || (Set_Vars_Coord_Type == DEFS->COORD_VY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_V)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXZ))
       strcpy(Short_Label[i],"Velocity");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_KX)
       || (Set_Vars_Coord_Type == DEFS->COORD_KY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_K))
       strcpy(Short_Label[i],"Wavevector");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_SX)
       || (Set_Vars_Coord_Type == DEFS->COORD_SY)
       || (Set_Vars_Coord_Type == DEFS->COORD_SZ))
       strcpy(Short_Label[i],"Spin");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_HDIV)
       || (Set_Vars_Coord_Type == DEFS->COORD_VDIV))
       strcpy(Short_Label[i],"Divergence");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY)
       strcpy(Short_Label[i],"Energy");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA)
       strcpy(Short_Label[i],"Wavelength");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT)
       strcpy(Short_Label[i],"Neutron_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID)
       strcpy(Short_Label[i],"Pixel_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_T)
          strcpy(Short_Label[i],"Time_Of_Flight");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_P)
          strcpy(Short_Label[i],"Intensity");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER1)
          strncpy(Short_Label[i],Vars->UserName1,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER2)
          strncpy(Short_Label[i],Vars->UserName2,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER3)
          strncpy(Short_Label[i],Vars->UserName3,30);
      else
          strcpy(Short_Label[i],"Unknown");

      if (Vars->Coord_Type[i] & DEFS->COORD_ABS)
      { strcat(Vars->Coord_Label[i]," (abs)"); }

      if (Vars->Coord_Type[i] & DEFS->COORD_LOG)
      { strcat(Vars->Coord_Label[i]," (log)"); }

      strcat(Vars->Monitor_Label, " ");
      strcat(Vars->Monitor_Label, Short_Label[i]);
      XY *= Vars->Coord_Bin[i];

    } /* end for Short_Label */

    if ((Vars->Coord_Type[0] & (DEFS->COORD_LOG-1)) == DEFS->COORD_P) {
      strncat(Vars->Coord_Label[0], " [n/s", 30);
      if (Vars->Flag_per_cm2) strncat(Vars->Coord_Label[0], "/cm2", 30);

      if (XY > 1 && Vars->Coord_Number)
        strncat(Vars->Coord_Label[0], "/bin", 30);
      strncat(Vars->Coord_Label[0], "]", 30);
    }

    /* update label 'signal per bin' if more than 1 bin */
    if (XY > 1 && Vars->Coord_Number) {
      if (Vars->Flag_capture)
        printf("Monitor_nD: %s: Using capture flux weightening on %ld bins.\n"
               "WARNING     Use binned data with caution, and prefer monitor integral value (I,Ierr).\n", Vars->compcurname, (long)XY);
    }

    strcat(Vars->Monitor_Label, " Monitor");
    if (Vars->Flag_Shape == DEFS->SHAPE_SQUARE) strcat(Vars->Monitor_Label, " (Square)");
    if (Vars->Flag_Shape == DEFS->SHAPE_DISK)   strcat(Vars->Monitor_Label, " (Disk)");
    if (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) strcat(Vars->Monitor_Label, " (Sphere)");
    if (Vars->Flag_Shape == DEFS->SHAPE_CYLIND) strcat(Vars->Monitor_Label, " (Cylinder)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BANANA) strcat(Vars->Monitor_Label, " (Banana)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BOX)    strcat(Vars->Monitor_Label, " (Box)");
    if (Vars->Flag_Shape == DEFS->SHAPE_PREVIOUS) strcat(Vars->Monitor_Label, " (on PREVIOUS)");
    if (Vars->Flag_Shape == DEFS->SHAPE_OFF) strcat(Vars->Monitor_Label, " (OFF geometry)");
    if ((Vars->Flag_Shape == DEFS->SHAPE_CYLIND) || (Vars->Flag_Shape == DEFS->SHAPE_BANANA) || (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) || (Vars->Flag_Shape == DEFS->SHAPE_BOX))
    {
      if (strstr(Vars->option, "incoming"))
      {
        Vars->Flag_Shape = abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [in]");
      }
      else /* if strstr(Vars->option, "outgoing")) */
      {
        Vars->Flag_Shape = -abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [out]");
      }
    }
    if (Vars->Flag_UsePreMonitor == 1)
    {
        strcat(Vars->Monitor_Label, " at ");
        strncat(Vars->Monitor_Label, Vars->UserName1,30);
    }
    if (Vars->Flag_log == 1) strcat(Vars->Monitor_Label, " [log] ");

    /* now allocate memory to store variables in TRACE */

    /* Vars->Coord_Number  0   : intensity or signal
     * Vars->Coord_Number  1:n : detector variables */

    if ((Vars->Coord_NumberNoPixel != 2) && !Vars->Flag_Multiple && !Vars->Flag_List)
    { Vars->Flag_Multiple = 1; /* default is n1D */
      if (Vars->Coord_Number != Vars->Coord_NumberNoPixel) Vars->Flag_List = 1; }

    /* list and auto limits case : Vars->Flag_List or Vars->Flag_Auto_Limits
     * -> Buffer to flush and suppress after Vars->Flag_Auto_Limits
     */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      Vars->Mon2D_Buffer = (double *)malloc((Vars->Coord_Number+1)*Vars->Buffer_Block*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
      { printf("Monitor_nD: %s cannot allocate Vars->Mon2D_Buffer (%li). No list and auto limits.\n", Vars->compcurname, Vars->Buffer_Block*(Vars->Coord_Number+1)*sizeof(double)); Vars->Flag_List = 0; Vars->Flag_Auto_Limits = 0; }
      else
      {
        for (i=0; i < (Vars->Coord_Number+1)*Vars->Buffer_Block; Vars->Mon2D_Buffer[i++] = (double)0);
      }
      Vars->Buffer_Size = Vars->Buffer_Block;
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_NumberNoPixel)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, (Vars->Coord_Number)*sizeof(double *)); exit(-1); }
      for (i= 1; i <= Vars->Coord_Number; i++)
      {
        Vars->Mon2D_N[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p2[i-1] = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[i], i, (Vars->Coord_Bin[i])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[i]; j++ )
          { Vars->Mon2D_N[i-1][j] = (double)0; Vars->Mon2D_p[i-1][j] = (double)0; Vars->Mon2D_p2[i-1][j] = (double)0; }
        }
      }
    }
    else /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], (Vars->Coord_Bin[1])*sizeof(double *)); exit(-1); }
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        Vars->Mon2D_N[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p2[i] = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], i, (Vars->Coord_Bin[2])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[2]; j++ )
          { Vars->Mon2D_N[i][j] = (double)0; Vars->Mon2D_p[i][j] = (double)0; Vars->Mon2D_p2[i][j] = (double)0; }
        }
      }
    }
    else {
      Vars->Mon2D_N = Vars->Mon2D_p = Vars->Mon2D_p2 = NULL;
    }
      /* no Mon2D allocated for
       * (Vars->Coord_Number != 2) && !Vars->Flag_Multiple && Vars->Flag_List */

    Vars->psum  = 0;
    Vars->p2sum = 0;
    Vars->Nsum  = 0;

    Vars->area  = fabs(Vars->mxmax - Vars->mxmin)*fabs(Vars->mymax - Vars->mymin)*1E4; /* in cm**2 for square and box shapes */
    Vars->Sphere_Radius = fabs(Vars->mxmax - Vars->mxmin)/2;
    if ((abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    {
      Vars->area = PI*Vars->Sphere_Radius*Vars->Sphere_Radius*1E4; /* disk shapes */
    }


    if (Vars->area == 0 && abs(Vars->Flag_Shape) != DEFS->SHAPE_PREVIOUS ) {
      if (abs(Vars->Flag_Shape) != DEFS->SHAPE_OFF) {  
	Vars->Coord_Number = 0;
      }
    }
    if (Vars->Coord_Number == 0 && Vars->Flag_Verbose)
      printf("Monitor_nD: %s is unactivated (0D)\n", Vars->compcurname);
    Vars->Cylinder_Height = fabs(Vars->mymax - Vars->mymin);

    if (Vars->Flag_Verbose)
    {
      printf("Monitor_nD: %s is a %s.\n", Vars->compcurname, Vars->Monitor_Label);
      printf("Monitor_nD: version %s with options=%s\n", MONITOR_ND_LIB_H, Vars->option);
    }
    
    /* compute the product of bin dimensions for PixelID */
    Vars->Coord_BinProd[0]=1;
    for (i = 1; i <= Vars->Coord_Number; i++)
      Vars->Coord_BinProd[i]=Vars->Coord_Bin[i]*Vars->Coord_BinProd[i-1];
  } /* end Monitor_nD_Init */

/* ========================================================================= */
/* Monitor_nD_Trace: this routine is used to monitor one propagating neutron */
/* ========================================================================= */

double Monitor_nD_Trace(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
{

  double  XY=0, pp=0;
  long    i =0, j =0;
  double  Coord[MONnD_COORD_NMAX];
  long    Coord_Index[MONnD_COORD_NMAX];
  char    While_End   =0;
  long    While_Buffer=0;
  char    Set_Vars_Coord_Type = DEFS->COORD_NONE;
  
  /* the logic below depends mainly on:
       Flag_List:        1=store 1 buffer, 2=list all, 3=re-use buffer 
       Flag_Auto_Limits: 0 (no auto limits/list), 1 (store events into Buffer), 2 (re-emit store events)
   */

  /* Vars->Flag_Auto_Limits=1: buffer full, we read the Buffer, and determine min and max bounds */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 1) && (Vars->Coord_Number > 0))
  {
    /* auto limits case : get limits in Buffer for each variable */
          /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
    if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
    for (i = 1; i <= Vars->Coord_Number; i++)
    {
      if (Vars->Coord_Type[i] & DEFS->COORD_AUTO)
      {
        Vars->Coord_Min[i] =  FLT_MAX;
        Vars->Coord_Max[i] = -FLT_MAX;
        for (j = 0; j < Vars->Buffer_Counter; j++)
        {
          XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
          if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
          if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
        }
        if  (Vars->Flag_Verbose)  
          printf("  %s: min=%g max=%g\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i]);
      }
    }
    Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step (read Buffer and generate new events to store in histograms) */
  } /* end if Flag_Auto_Limits == 1 */

  /* manage realloc for 'list all' if Buffer size exceeded: flush Buffer to file */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List >= 2))
  {
    if (Vars->Buffer_Size >= 1000000 || Vars->Flag_List == 3)
    { /* save current (possibly append) and re-use Buffer */
      Monitor_nD_Save(DEFS, Vars);
      Vars->Flag_List = 3;
      Vars->Buffer_Block = Vars->Buffer_Size;
      Vars->Buffer_Counter  = 0;
      Vars->Neutron_Counter = 0;
    }
    else
    {
      Vars->Mon2D_Buffer  = (double *)realloc(Vars->Mon2D_Buffer, (Vars->Coord_Number+1)*(Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
            { printf("Monitor_nD: %s cannot reallocate Vars->Mon2D_Buffer[%li] (%li). Skipping.\n", Vars->compcurname, i, (Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double)); Vars->Flag_List = 1; }
      else { Vars->Buffer_Counter = 0; Vars->Buffer_Size = Vars->Neutron_Counter+Vars->Buffer_Block; }
    }
  } /* end if Buffer realloc */

  while (!While_End)
  { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) or passing neutron */
    char    outsidebounds=0;
    if ((Vars->Flag_Auto_Limits == 2) && (Vars->Coord_Number > 0))
    { /* Vars->Flag_Auto_Limits == 2: read back from Buffer (Buffer is filled or auto limits have been computed) */
      if (While_Buffer < Vars->Buffer_Block)
      {
        /* first while loop (While_Buffer) */
        /* auto limits case : scan Buffer within limits and store in Mon2D */
        Coord[0] = pp = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

        for (i = 1; i <= Vars->Coord_Number; i++)
        {
          /* scanning variables in Buffer */
          if (Vars->Coord_Bin[i] <= 1) continue;
          XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);

          Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
          if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
          else        Coord_Index[i] = 0;
          if (Vars->Flag_With_Borders)
          {
            if (Coord_Index[i] < 0)                   Coord_Index[i] = 0;
            if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
          }
        } /* end for */
        
        /* update the PixelID, we compute it from the previous variables index */
        if (Vars->Coord_NumberNoPixel < Vars->Coord_Number) /* there is a Pixel variable */
        for (i = 1; i <= Vars->Coord_Number; i++) {
          char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
          if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
            char flag_outside=0;
            Coord_Index[i] = Coord[i] = 0;
            for (j= 1; j < i; j++) {
              /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
              if (Vars->Coord_Bin[j] == 1) continue; 
              if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                flag_outside=1;
                Coord[i] = 0;
                break;
              }
              Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
            }
            if (!flag_outside) {
              Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
            }
          } /* end if PixelID */
        }
        While_Buffer++;
      } /* end if in Buffer */
      else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
      {
        Vars->Flag_Auto_Limits = 0;
        if (!Vars->Flag_List) /* free Buffer not needed anymore (no list to output) */
        { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, p2) */
          free(Vars->Mon2D_Buffer); Vars->Mon2D_Buffer = NULL;
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
      }
    } /* if Vars->Flag_Auto_Limits == 2 */
    
    if (Vars->Flag_Auto_Limits != 2 || !Vars->Coord_Number) /* Vars->Flag_Auto_Limits == 0 (no auto limits/list) or 1 (store events into Buffer) */
    {
      /* automatically compute area and steradian solid angle when in AUTO mode */
      /* compute the steradian solid angle incoming on the monitor */
      double v;
      v=sqrt(Vars->cvx*Vars->cvx
            +Vars->cvy*Vars->cvy
            +Vars->cvz*Vars->cvz);
      if (Vars->min_x > Vars->cx) Vars->min_x = Vars->cx;
      if (Vars->max_x < Vars->cx) Vars->max_x = Vars->cx;
      if (Vars->min_y > Vars->cy) Vars->min_y = Vars->cy;
      if (Vars->max_y < Vars->cy) Vars->max_y = Vars->cy;
      Vars->mean_p  += Vars->cp;
      if (v) {
        Vars->mean_dx += Vars->cp*fabs(Vars->cvx/v);
        Vars->mean_dy += Vars->cp*fabs(Vars->cvy/v);
      }

      for (i = 0; i <= Vars->Coord_Number; i++)
      { /* handle current neutron : last while */
        XY = 0;
        Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
        /* get values for variables to monitor */
        if (Set_Vars_Coord_Type == DEFS->COORD_X) XY = Vars->cx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Y) XY = Vars->cy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Z) XY = Vars->cz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VX) XY = Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VY) XY = Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VZ) XY = Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KX) XY = V2K*Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KY) XY = V2K*Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KZ) XY = V2K*Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SX) XY = Vars->csx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SY) XY = Vars->csy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SZ) XY = Vars->csz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_T) XY = Vars->ct;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_P) XY = Vars->cp;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_HDIV) XY = RAD2DEG*atan2(Vars->cvx,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VDIV) XY = RAD2DEG*atan2(Vars->cvy,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_V) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XY)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy)*(Vars->cx > 0 ? 1 : -1);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_YZ) XY = sqrt(Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XZ)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXY) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXZ) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VYZ) XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_K) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXY) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXZ) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KYZ) { XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY) { XY = Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz;  XY *= VS2E; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; if (XY != 0) XY = 2*PI/XY; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT) XY = Vars->Neutron_Counter;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
        {  XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
           if (Vars->cvz != 0)
                XY = RAD2DEG*atan2(XY,Vars->cvz)*(Vars->cx > 0 ? 1 : -1);
           else XY = 0;
        }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_THETA)  { if (Vars->cz != 0) XY = RAD2DEG*atan2(Vars->cx,Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PHI) { if (Vars->cz != 0) XY = RAD2DEG*asin(Vars->cy/Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER1) XY = Vars->UserVariable1;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER2) XY = Vars->UserVariable2;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER3) XY = Vars->UserVariable3;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID && !Vars->Flag_Auto_Limits) {
          /* compute the PixelID from previous coordinates 
             the PixelID is the product of Coord_Index[i] in the detector geometry 
             pixelID = sum( Coord_Index[j]*prod(Vars->Coord_Bin[1:(j-1)]) )
             
             this does not apply when we store events in the buffer as Coord_Index
             is not set. Then the pixelID will be re-computed during SAVE.
          */
          char flag_outside=0;
          for (j= 1; j < i; j++) {
            /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
            if (Vars->Coord_Bin[j] <= 1) continue; 
            if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) { 
              flag_outside=1; XY=0; break;
            }
            XY += Coord_Index[j]*Vars->Coord_BinProd[j-1];
          }
	  if (Vars->Flag_mantid && Vars->Flag_OFF && Vars->OFF_polyidx >=0) XY=Vars->OFF_polyidx;
          if (!flag_outside) XY += Vars->Coord_Min[i];
        }
        
        /* handle 'abs' and 'log' keywords */
        if (Vars->Coord_Type[i] & DEFS->COORD_ABS) XY=fabs(XY);

        if (Vars->Coord_Type[i] & DEFS->COORD_LOG) /* compute log of variable if requested */
        {  if (XY > 0) XY = log(XY)/log(10);
           else        XY = -100; }

        Coord[i] = XY; Coord_Index[i] = 0;
        if (i == 0) { pp = XY; Coord_Index[i] = 0; }
        else {
        /* check bounds for variables which have no automatic limits */
          if ((!Vars->Flag_Auto_Limits || !(Vars->Coord_Type[i] & DEFS->COORD_AUTO)) && Vars->Coord_Bin[i]>1)
          { /* compute index in histograms for each variable to monitor */
            XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
            if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
            if (Vars->Flag_With_Borders)
            {
              if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              if (Coord_Index[i] < 0) Coord_Index[i] = 0;
            }
            if (0 > Coord_Index[i] || Coord_Index[i] >= Vars->Coord_Bin[i])
              outsidebounds=1;
          } /* else will get Index later from Buffer when Flag_Auto_Limits == 2 */
        }
        
      } /* end for i */
      While_End = 1;
    }/* end else if Vars->Flag_Auto_Limits == 2 */
    
    /* ====================================================================== */
    /* store n1d/2d neutron from Buffer (Auto_Limits == 2) or current neutron in while */
    if (Vars->Flag_Auto_Limits != 1) /* not when storing auto limits Buffer */
    {
      /* apply per cm2 */
      if (Vars->Flag_per_cm2 && Vars->area != 0)
        pp /= Vars->area;

      /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
      if ( Vars->Coord_NumberNoPixel == 2 && !Vars->Flag_Multiple && !outsidebounds)
      { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
        
        i = Coord_Index[1];
        j = Coord_Index[2];
        if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
        {
          if (Vars->Mon2D_N) { 
            Vars->Mon2D_N[i][j]++;
            Vars->Mon2D_p[i][j] += pp;
            Vars->Mon2D_p2[i][j] += pp*pp;
          }
        } else {
          outsidebounds=1; 
          if (Vars->Flag_Absorb) pp=0;
        }
      } else if (!outsidebounds) {
        /* 1D and n1D case : Vars->Flag_Multiple */
        /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          
        for (i= 1; i <= Vars->Coord_Number; i++) {
          j = Coord_Index[i];
          if (j >= 0 && j < Vars->Coord_Bin[i]) {
            if  (Vars->Flag_Multiple && Vars->Mon2D_N) {
              Vars->Mon2D_N[i-1][j]++;
              Vars->Mon2D_p[i-1][j]  += pp;
              Vars->Mon2D_p2[i-1][j] += pp*pp;
            } 
          } else { 
            outsidebounds=1; 
            if (Vars->Flag_Absorb) { pp=0; break; }
          }
        }
      }
    } /* end (Vars->Flag_Auto_Limits != 1) */
    
    if (Vars->Flag_Auto_Limits != 2 && !outsidebounds) /* not when reading auto limits Buffer */
    { /* now store Coord into Buffer (no index needed) if necessary (list or auto limits) */
      if ((Vars->Buffer_Counter < Vars->Buffer_Block) && ((Vars->Flag_List) || (Vars->Flag_Auto_Limits == 1)))
      {
          
        for (i = 0; i <= Vars->Coord_Number; i++)
        {
          Vars->Mon2D_Buffer[i + Vars->Neutron_Counter*(Vars->Coord_Number+1)] = Coord[i];
        }
        Vars->Buffer_Counter++;
        if (Vars->Flag_Verbose && (Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List == 1)) 
          printf("Monitor_nD: %s %li neutrons stored in List.\n", Vars->compcurname, Vars->Buffer_Counter);
      }
      Vars->Neutron_Counter++;
    } /* end (Vars->Flag_Auto_Limits != 2) */
    
  } /* end while */
  Vars->Nsum++;
  Vars->psum  += pp;
  Vars->p2sum += pp*pp;
  
  return pp;
} /* end Monitor_nD_Trace */

/* ========================================================================= */
/* Monitor_nD_Save: this routine is used to save data files                  */
/* ========================================================================= */

MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
  {
    char   *fname;
    long    i,j;
    double *p0m = NULL;
    double *p1m = NULL;
    double *p2m = NULL;
    char    Coord_X_Label[CHAR_BUF_LENGTH];
    double  min1d, max1d;
    double  min2d, max2d;
    long    bin1d, bin2d;
    char    While_End = 0;
    long    While_Buffer = 0;
    double  XY=0, pp=0;
    double  Coord[MONnD_COORD_NMAX];
    long    Coord_Index[MONnD_COORD_NMAX];
    char    label[CHAR_BUF_LENGTH];
    double  ratio;

    MCDETECTOR detector;

    ratio = 100.0*mcget_run_num()/mcget_ncount();
    if (Vars->Flag_Verbose && Vars->Flag_per_cm2) {
      printf("Monitor_nD: %s: active flat detector area is %g [cm^2], total area is %g [cm^2]\n",
        Vars->compcurname, (Vars->max_x-Vars->min_x)
                          *(Vars->max_y-Vars->min_y)*1E4, Vars->area);
      printf("Monitor_nD: %s: beam solid angle is %g [st] (%g x %g [deg^2])\n",
        Vars->compcurname,
        2*fabs(2*atan(Vars->mean_dx/Vars->mean_p)
         *sin(2*atan(Vars->mean_dy/Vars->mean_p)/2)),
        atan(Vars->mean_dx/Vars->mean_p)*RAD2DEG,
        atan(Vars->mean_dy/Vars->mean_p)*RAD2DEG);
    }

    /* check Buffer flush when end of simulation reached */
    if ((Vars->Buffer_Counter <= Vars->Buffer_Block) && Vars->Flag_Auto_Limits && Vars->Mon2D_Buffer && Vars->Buffer_Counter)
    {
      /* Get Auto Limits */
      if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);

      for (i = 1; i <= Vars->Coord_Number; i++)
      {
        if ((Vars->Coord_Type[i] & DEFS->COORD_AUTO) && Vars->Coord_Bin[i] > 1)
        {
          Vars->Coord_Min[i] = FLT_MAX;
          Vars->Coord_Max[i] = -FLT_MAX;
          for (j = 0; j < Vars->Buffer_Counter; j++)
          {
            XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
            if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
            if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
          }
          if  (Vars->Flag_Verbose)  
            printf("  %s: min=%g max=%g in %li bins\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i], Vars->Coord_Bin[i]);
        }
      }
      Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step */
      Vars->Buffer_Block = Vars->Buffer_Counter;

      while (!While_End)
      { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) */
        /* simulation ended before Buffer was filled. Limits have to be computed, and stored events must be sent into histograms */
        
        if (While_Buffer < Vars->Buffer_Block)
        {
          /* first while loops (While_Buffer) */
          Coord[0] = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

          /* auto limits case : scan Buffer within limits and store in Mon2D */
          for (i = 1; i <= Vars->Coord_Number; i++)
          {
            /* scanning variables in Buffer */
            if (Vars->Coord_Bin[i] <= 1) Coord_Index[i] = 0;
            else {
              XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
              Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
              if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
              else Coord_Index[i] = 0;
              if (Vars->Flag_With_Borders)
              {
                if (Coord_Index[i] < 0) Coord_Index[i] = 0;
                if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              }
            }
          } /* end for */

          /* update the PixelID, we compute it from the previous variables index */
          for (i = 1; i <= Vars->Coord_Number; i++) {
            char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
            if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
              char outsidebounds=0;
              Coord_Index[i] = Coord[i] = 0;
              for (j= 1; j < i; j++) {
                /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
                if (Vars->Coord_Bin[j] == 1) continue; 
                if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                  outsidebounds=1;
                  Coord[i] = 0;
                  break;
                }
                Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
              }
              if (!outsidebounds) {
                Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
              }
            } /* end if PixelID */
          }
          While_Buffer++;
        } /* end if in Buffer */
        else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
        {
          Vars->Flag_Auto_Limits = 0;
          While_End = 1;
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
        }

        /* store n1d/2d section from Buffer */

        pp = Coord[0];
        /* apply per cm2 or per st */
        if (Vars->Flag_per_cm2 && Vars->area      != 0)
          pp /= Vars->area;
        
        /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
        if (!Vars->Flag_Multiple && Vars->Coord_NumberNoPixel == 2)
        { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
          i = Coord_Index[1];
          j = Coord_Index[2];
          if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
          {
            if (Vars->Mon2D_N) {
              Vars->Mon2D_N[i][j]++;
              Vars->Mon2D_p[i][j] += pp;
              Vars->Mon2D_p2[i][j] += pp*pp;
            }
          } else if (Vars->Flag_Absorb) pp=0;
        }
        else
        /* 1D and n1D case : Vars->Flag_Multiple */
        { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          for (i= 1; i <= Vars->Coord_Number; i++)
          {
            j = Coord_Index[i];
            if (j >= 0 && j < Vars->Coord_Bin[i])
            {
              if (Vars->Flag_Multiple && Vars->Mon2D_N) {
                Vars->Mon2D_N[i-1][j]++;
                Vars->Mon2D_p[i-1][j] += pp;
                Vars->Mon2D_p2[i-1][j] += pp*pp;
              }
            } else if (Vars->Flag_Absorb) {
              pp=0; break;
            }
          }
        } /* end store 2D/1D */
        
      } /* end while */
    } /* end Force Get Limits */

    /* write output files (sent to file as p[i*n + j] vectors) */
    if (Vars->Coord_Number == 0)
    {
      double Nsum;
      double psum, p2sum;
      Nsum = Vars->Nsum;
      psum = Vars->psum;
      p2sum= Vars->p2sum;
      if (Vars->Flag_signal != DEFS->COORD_P && Nsum > 0)
      { psum /=Nsum; p2sum /= Nsum*Nsum; }
      /* DETECTOR_OUT_0D(Vars->Monitor_Label, Vars->Nsum, Vars->psum, Vars->p2sum); */
      detector = mcdetector_out_0D(Vars->Monitor_Label, Nsum, psum, p2sum, Vars->compcurname, Vars->compcurpos);
    }
    else
    if (strlen(Vars->Mon_File) > 0)
    {
      fname = (char*)malloc(strlen(Vars->Mon_File)+10*Vars->Coord_Number);
      if (Vars->Flag_List && Vars->Mon2D_Buffer) /* List: DETECTOR_OUT_2D */
      {
       
        if (Vars->Flag_List >= 2) Vars->Buffer_Size = Vars->Neutron_Counter;
        if (Vars->Buffer_Size >= Vars->Neutron_Counter)
          Vars->Buffer_Size = Vars->Neutron_Counter;
        strcpy(fname,Vars->Mon_File);
        if (strchr(Vars->Mon_File,'.') == NULL) strcat(fname, "_list");

        strcpy(Coord_X_Label,"");
        for (i= 0; i <= Vars->Coord_Number; i++)
        {
          strcat(Coord_X_Label, Vars->Coord_Var[i]);
          strcat(Coord_X_Label, " ");
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i]); }
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s List (%lix%li).\n", Vars->compcurname, fname,bin2d,bin1d);

        /* handle the type of list output */
        strcpy(label, Vars->Monitor_Label);
        
        detector = mcdetector_out_list(
              label, "List of neutron events", Coord_X_Label,
              -Vars->Buffer_Size, Vars->Coord_Number+1,
              Vars->Mon2D_Buffer,
              fname, Vars->compcurname, Vars->compcurpos);
      }
      if (Vars->Flag_Multiple) /* n1D: DETECTOR_OUT_1D */
      {
        for (i= 0; i < Vars->Coord_Number; i++)
        {

          strcpy(fname,Vars->Mon_File);
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i+1]); }
          sprintf(Coord_X_Label, "%s monitor", Vars->Coord_Label[i+1]);
          strcpy(label, Coord_X_Label);
          if (Vars->Coord_Bin[i+1] > 0) { /* 1D monitor */
            if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 1D (%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[i+1]);
            min1d = Vars->Coord_Min[i+1];
            max1d = Vars->Coord_Max[i+1];
            if (min1d == max1d) max1d = min1d+1e-6;
            p1m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            p2m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            if (p2m == NULL) /* use Raw Buffer line output */
            {
              if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for output. Using raw data.\n", Vars->compcurname);
              if (p1m != NULL) free(p1m);
              detector = mcdetector_out_1D(
              label,
              Vars->Coord_Label[i+1],
              Vars->Coord_Label[0],
              Vars->Coord_Var[i+1],
              min1d, max1d,
              Vars->Coord_Bin[i+1],
              Vars->Mon2D_N[i],Vars->Mon2D_p[i],Vars->Mon2D_p2[i],
              fname, Vars->compcurname, Vars->compcurpos);
            } /* if (p2m == NULL) */
            else
            {
              if (Vars->Flag_log != 0)
              {
                XY = FLT_MAX;
                for (j=0; j < Vars->Coord_Bin[i+1]; j++) /* search min of signal */
                  if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j] > 0)) XY = Vars->Mon2D_p[i][j];
                if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
              } /* if */

              for (j=0; j < Vars->Coord_Bin[i+1]; j++)
              {
                p1m[j] = Vars->Mon2D_p[i][j];
                p2m[j] = Vars->Mon2D_p2[i][j];
                if (Vars->Flag_signal != DEFS->COORD_P && Vars->Mon2D_N[i][j] > 0)
                { /* normalize mean signal to the number of events */
                  p1m[j] /= Vars->Mon2D_N[i][j];
                  p2m[j] /= Vars->Mon2D_N[i][j]*Vars->Mon2D_N[i][j];
                }
                if (Vars->Flag_log != 0)
                {
                  if ((p1m[j] > 0) && (p2m[j] > 0))
                  {
                    p2m[j] /= p1m[j]*p1m[j];
                    p1m[j] = log(p1m[j])/log(10);
                  }
                  else
                  {
                    p1m[j] = XY;
                    p2m[j] = 0;
                  }
                }
              } /* for */
              detector = mcdetector_out_1D(
                label,
                Vars->Coord_Label[i+1],
                Vars->Coord_Label[0],
                Vars->Coord_Var[i+1],
                min1d, max1d,
                Vars->Coord_Bin[i+1],
                Vars->Mon2D_N[i],p1m,p2m,
                fname, Vars->compcurname, Vars->compcurpos);

            } /* else */
            /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
            if (p1m != NULL) free(p1m); p1m=NULL;
            if (p2m != NULL) free(p2m); p2m=NULL;
            */
          } else { /* 0d monitor */
            detector = mcdetector_out_0D(label, Vars->Mon2D_p[i][0], Vars->Mon2D_p2[i][0], Vars->Mon2D_N[i][0], Vars->compcurname, Vars->compcurpos);
          }


        } /* for */
      } /* if 1D */
      else
      if (Vars->Coord_NumberNoPixel == 2)  /* 2D: DETECTOR_OUT_2D */
      {
        strcpy(fname,Vars->Mon_File);

        p0m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p1m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p2m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        if (p2m == NULL)
        {
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for 2D array (%li). Skipping.\n", Vars->compcurname, 3*Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          */
        }
        else
        {
          if (Vars->Flag_log != 0)
          {
            XY = FLT_MAX;
            for (i= 0; i < Vars->Coord_Bin[1]; i++)
              for (j= 0; j < Vars->Coord_Bin[2]; j++) /* search min of signal */
                if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j]>0)) XY = Vars->Mon2D_p[i][j];
            if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
          }
          for (i= 0; i < Vars->Coord_Bin[1]; i++)
          {
            for (j= 0; j < Vars->Coord_Bin[2]; j++)
            {
              long index;
              index = j + i*Vars->Coord_Bin[2];
              p0m[index] = Vars->Mon2D_N[i][j];
              p1m[index] = Vars->Mon2D_p[i][j];
              p2m[index] = Vars->Mon2D_p2[i][j];
              if (Vars->Flag_signal != DEFS->COORD_P && p0m[index] > 0)
              {
                  p1m[index] /= p0m[index];
                  p2m[index] /= p0m[index]*p0m[index];
              }

              if (Vars->Flag_log != 0)
              {
                if ((p1m[index] > 0) && (p2m[index] > 0))
                {
                  p2m[index] /= (p1m[index]*p1m[index]);
                  p1m[index] = log(p1m[index])/log(10);

                }
                else
                {
                  p1m[index] = XY;
                  p2m[index] = 0;
                }
              }
            }
          }
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[1]);
              strcat(fname, "_"); strcat(fname, Vars->Coord_Var[2]); }
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 2D (%lix%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[1], Vars->Coord_Bin[2]);

          min1d = Vars->Coord_Min[1];
          max1d = Vars->Coord_Max[1];
          if (min1d == max1d) max1d = min1d+1e-6;
          min2d = Vars->Coord_Min[2];
          max2d = Vars->Coord_Max[2];
          if (min2d == max2d) max2d = min2d+1e-6;
          strcpy(label, Vars->Monitor_Label);
          if (Vars->Coord_Bin[1]*Vars->Coord_Bin[2] > 1
           && Vars->Flag_signal == DEFS->COORD_P)
            strcat(label, " per bin");

          detector = mcdetector_out_2D(
            label,
            Vars->Coord_Label[1],
            Vars->Coord_Label[2],
            min1d, max1d,
            min2d, max2d,
            Vars->Coord_Bin[1],
            Vars->Coord_Bin[2],
            p0m,p1m,p2m,
            fname, Vars->compcurname, Vars->compcurpos);

          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          if (p2m != NULL) free(p2m);
          */
        }
      }
      free(fname);
    }
    return(detector);
  } /* end Monitor_nD_Save */

/* ========================================================================= */
/* Monitor_nD_Finally: this routine is used to free memory                   */
/* ========================================================================= */

void Monitor_nD_Finally(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    int i;

    /* Now Free memory Mon2D.. */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      if (Vars->Mon2D_Buffer != NULL) free(Vars->Mon2D_Buffer);
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_Number)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      for (i= 0; i < Vars->Coord_Number; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }


    /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }
  } /* end Monitor_nD_Finally */

/* ========================================================================= */
/* Monitor_nD_McDisplay: this routine is used to display component           */
/* ========================================================================= */

void Monitor_nD_McDisplay(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    double radius, h;
    double xmin;
    double xmax;
    double ymin;
    double ymax;
    double zmin;
    double zmax;
    int    i;
    double hdiv_min=-180, hdiv_max=180, vdiv_min=-90, vdiv_max=90;
    char   restricted = 0;

    radius = Vars->Sphere_Radius;
    h = Vars->Cylinder_Height;
    xmin = Vars->mxmin;
    xmax = Vars->mxmax;
    ymin = Vars->mymin;
    ymax = Vars->mymax;
    zmin = Vars->mzmin;
    zmax = Vars->mzmax;

    /* determine if there are angular limits set at start (no auto) in coord_types
     * cylinder/banana: look for hdiv
     * sphere: look for angle, radius (->atan2(val,radius)), hdiv, vdiv
     * this activates a 'restricted' flag, to draw a region as blades on cylinder/sphere
     */
    for (i= 0; i <= Vars->Coord_Number; i++)
    {
      int Set_Vars_Coord_Type;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if (Set_Vars_Coord_Type == DEFS->COORD_HDIV || Set_Vars_Coord_Type == DEFS->COORD_THETA)
      { hdiv_min = Vars->Coord_Min[i]; hdiv_max = Vars->Coord_Max[i]; restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_VDIV || Set_Vars_Coord_Type == DEFS->COORD_PHI)
      { vdiv_min = Vars->Coord_Min[i]; vdiv_max = Vars->Coord_Max[i];restricted = 1;  }
      else if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
      { hdiv_min = vdiv_min = Vars->Coord_Min[i];
        hdiv_max = vdiv_max = Vars->Coord_Max[i];
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
      { double angle;
        angle = RAD2DEG*atan2(Vars->Coord_Max[i], radius);
        hdiv_min = vdiv_min = angle;
        hdiv_max = vdiv_max = angle;
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_Y && abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)
      {
        vdiv_min = atan2(ymin,radius)*RAD2DEG;
        vdiv_max = atan2(ymax,radius)*RAD2DEG;
        restricted = 1;
      }
    }
    /* full sphere */
    if ((!restricted && (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    || abs(Vars->Flag_Shape) == DEFS->SHAPE_PREVIOUS)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
      mcdis_circle("xz",0,0,0,radius);
      mcdis_circle("yz",0,0,0,radius);
    }
    /* banana/cylinder/sphere portion */
    else
    if (restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)))
    {
      int NH=24, NV=24;
      int ih, iv;
      double width, height;
      int issphere;
      issphere = (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE);
      width = (hdiv_max-hdiv_min)/NH;
      if (!issphere) NV=1; /* cylinder has vertical axis */
      else height= (vdiv_max-vdiv_min)/NV;
      
      /* check width and height of elements (sphere) to make sure the nb
         of plates remains limited */
      if (width < 10  && NH > 1) { width = 10;  NH=(hdiv_max-hdiv_min)/width; }
      if (height < 10 && NV > 1) { height = 10; NV=(vdiv_max-vdiv_min)/height; }
      
      mcdis_magnify("xyz");
      for(ih = 0; ih < NH; ih++)
        for(iv = 0; iv < NV; iv++)
        {
          double theta0, phi0, theta1, phi1;          /* angles in spherical coordinates */
          double x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3; /* vertices at plate edges */
          phi0 = (hdiv_min+ width*ih-90)*DEG2RAD;        /* in xz plane */
          phi1 = (hdiv_min+ width*(ih+1)-90)*DEG2RAD;
          if (issphere)
          {
            theta0= (vdiv_min+height* iv + 90)   *DEG2RAD; /* in vertical plane */
            theta1= (vdiv_min+height*(iv+1) + 90)*DEG2RAD;
            if (y0 < ymin) y0=ymin; 
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin; 
            if (y1 > ymax) y1=ymax;
            
            y0 = -radius*cos(theta0);            /* z with Z vertical */
            y1 = -radius*cos(theta1);
            if (y0 < ymin) y0=ymin;
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin;
            if (y1 > ymax) y1=ymax;
          } else {
            y0 = ymin;
            y1 = ymax;
            theta0=theta1=90*DEG2RAD;
          }

          x0 = radius*sin(theta0)*cos(phi0); /* x with Z vertical */
          z0 =-radius*sin(theta0)*sin(phi0); /* y with Z vertical */
          x1 = radius*sin(theta1)*cos(phi0); 
          z1 =-radius*sin(theta1)*sin(phi0);
          x2 = radius*sin(theta1)*cos(phi1); 
          z2 =-radius*sin(theta1)*sin(phi1);
          x3 = radius*sin(theta0)*cos(phi1); 
          z3 =-radius*sin(theta0)*sin(phi1);
          y2 = y1; y3 = y0;

          mcdis_multiline(5,
            x0,y0,z0,
            x1,y1,z1,
            x2,y2,z2,
            x3,y3,z3,
            x0,y0,z0);
        }
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dt, dy;
	dt = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_BANANA_DET:  %g, %g, %g, %g, %g, %li, %li, %g\n", radius, 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]); 
      }
    }
    /* disk (circle) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
    }
    /* rectangle (square) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_SQUARE)
    {
      mcdis_magnify("xy");
      mcdis_multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
      
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dx, dy;
	dx = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_RECTANGULAR_DET:  %g, %g, %g, %g, %li, %li, %g\n", 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]);
      }
    }
    /* full cylinder/banana */
    else
    if (!restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)))
    {
      mcdis_magnify("xyz");
      mcdis_circle("xz", 0,  h/2.0, 0, radius);
      mcdis_circle("xz", 0, -h/2.0, 0, radius);
      mcdis_line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
      mcdis_line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
      mcdis_line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
      mcdis_line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
    }
    else
    /* box */
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_BOX)
    {
      mcdis_magnify("xyz");
      mcdis_multiline(5, xmin, ymin, zmin,
                   xmax, ymin, zmin,
                   xmax, ymax, zmin,
                   xmin, ymax, zmin,
                   xmin, ymin, zmin);
      mcdis_multiline(5, xmin, ymin, zmax,
                   xmax, ymin, zmax,
                   xmax, ymax, zmax,
                   xmin, ymax, zmax,
                   xmin, ymin, zmax);
      mcdis_line(xmin, ymin, zmin, xmin, ymin, zmax);
      mcdis_line(xmax, ymin, zmin, xmax, ymin, zmax);
      mcdis_line(xmin, ymax, zmin, xmin, ymax, zmax);
      mcdis_line(xmax, ymax, zmin, xmax, ymax, zmax);
    }
  } /* end Monitor_nD_McDisplay */

/* end of monitor_nd-lib.c */

#line 9558 "BIFROST.c"

/* Shared user declarations for all components 'V_sample'. */
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\obsolete\\V_sample.comp"
struct StructVarsV
{
double  sigma_a; /* Absorption cross section per atom (barns) */
    double  sigma_i; /* Incoherent scattering cross section per atom (barns) */
    double  rho;     /* Density of atoms (AA-3) */
    double  my_s;
    double  my_a_v;
    int     shapetyp;    /* 0 double well cylynder, 1 box,  3 sphere */
    double  distance;    /* when non zero, gives rect target distance */
    double  aw,ah;       /* rectangular angular dimensions */
    double  xw,yh;       /* rectangular metrical dimensions */
    double  tx,ty,tz;    /* target coords */
  };
#line 9575 "BIFROST.c"

/* Shared user declarations for all components 'Monochromator_curved'. */
#line 109 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
#ifndef GAUSS
/* Define these arrays only once for all instances. */
/* Values for Gauss quadrature. Taken from Brice Carnahan, H. A. Luther and
James O Wilkes, "Applied numerical methods", Wiley, 1969, page 103.
This reference is available from the Copenhagen UB2 library */
double Gauss_X[] = {-0.987992518020485, -0.937273392400706, -0.848206583410427,
-0.724417731360170, -0.570972172608539, -0.394151347077563,
-0.201194093997435, 0, 0.201194093997435,
0.394151347077563, 0.570972172608539, 0.724417731360170,
0.848206583410427, 0.937273392400706, 0.987992518020485};
double Gauss_W[] = {0.030753241996117, 0.070366047488108, 0.107159220467172,
0.139570677926154, 0.166269205816994, 0.186161000115562,
0.198431485327111, 0.202578241925561, 0.198431485327111,
0.186161000115562, 0.166269205816994, 0.139570677926154,
0.107159220467172, 0.070366047488108, 0.030753241996117};


#define GAUSS(x,mean,rms) \
  (exp(-((x)-(mean))*((x)-(mean))/(2*(rms)*(rms)))/(sqrt(2*PI)*(rms)))
#endif


#line 9601 "BIFROST.c"

/* Instrument parameters. */
MCNUM mcipWaveMin;
MCNUM mcipWaveMax;
MCNUM mcippin_holeY;
MCNUM mcippin_holeX;
MCNUM mcipE_0;
MCNUM mcipL_0;
MCNUM mcipchopPulseOpening;
MCNUM mcipchopPulseFrequencyOrder;
MCNUM mcipsampleSizeX;
MCNUM mcipsampleSizeY;
MCNUM mcipchopBWPos;
MCNUM mcipDivSlit0_width;
MCNUM mcipDivSlit1_width;
MCNUM mcipDivSlit2_width;
MCNUM mcipDivSlit3_width;
MCNUM mcipBWopen;
MCNUM mcipFOCopen1;
MCNUM mcipFOCopen2;
MCNUM mcipNpulse;
MCNUM mcipPscOff;
MCNUM mcipdiscD;
MCNUM mcipmonigap_length;
int mcipprint;
MCNUM mcipmakeVirtualSource;
int mcipprintMValues;
MCNUM mcipOMA;
MCNUM mcipTTA;
MCNUM mcipphi;
MCNUM mcipdphi;

#define mcNUMIPAR 29
int mcnumipar = 29;
struct mcinputtable_struct mcinputtable[mcNUMIPAR+1] = {
  "WaveMin", &mcipWaveMin, instr_type_double, "0.1", 
  "WaveMax", &mcipWaveMax, instr_type_double, "99.5", 
  "pin_holeY", &mcippin_holeY, instr_type_double, "0.088", 
  "pin_holeX", &mcippin_holeX, instr_type_double, "0.03", 
  "E_0", &mcipE_0, instr_type_double, "4.0", 
  "L_0", &mcipL_0, instr_type_double, "0", 
  "chopPulseOpening", &mcipchopPulseOpening, instr_type_double, "0.004", 
  "chopPulseFrequencyOrder", &mcipchopPulseFrequencyOrder, instr_type_double, "14", 
  "sampleSizeX", &mcipsampleSizeX, instr_type_double, "0.010", 
  "sampleSizeY", &mcipsampleSizeY, instr_type_double, "0.010", 
  "chopBWPos", &mcipchopBWPos, instr_type_double, "78", 
  "DivSlit0_width", &mcipDivSlit0_width, instr_type_double, "0.1", 
  "DivSlit1_width", &mcipDivSlit1_width, instr_type_double, "0.1", 
  "DivSlit2_width", &mcipDivSlit2_width, instr_type_double, "0.1", 
  "DivSlit3_width", &mcipDivSlit3_width, instr_type_double, "0.1", 
  "BWopen", &mcipBWopen, instr_type_double, "172.33", 
  "FOCopen1", &mcipFOCopen1, instr_type_double, "37.79", 
  "FOCopen2", &mcipFOCopen2, instr_type_double, "51.63", 
  "Npulse", &mcipNpulse, instr_type_double, "1", 
  "PscOff", &mcipPscOff, instr_type_double, "0.0306", 
  "discD", &mcipdiscD, instr_type_double, "0.04", 
  "monigap_length", &mcipmonigap_length, instr_type_double, "0.02", 
  "print", &mcipprint, instr_type_int, "0", 
  "makeVirtualSource", &mcipmakeVirtualSource, instr_type_double, "0", 
  "printMValues", &mcipprintMValues, instr_type_int, "0", 
  "OMA", &mcipOMA, instr_type_double, "37.072", 
  "TTA", &mcipTTA, instr_type_double, "74.144", 
  "phi", &mcipphi, instr_type_double, "37", 
  "dphi", &mcipdphi, instr_type_double, "0.5", 
  NULL, NULL, instr_type_double, ""
};

/* User declarations from instrument definition. */
#define mccompcurname  BIFROST
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaBIFROST coords_set(0,0,0)
#define WaveMin mcipWaveMin
#define WaveMax mcipWaveMax
#define pin_holeY mcippin_holeY
#define pin_holeX mcippin_holeX
#define E_0 mcipE_0
#define L_0 mcipL_0
#define chopPulseOpening mcipchopPulseOpening
#define chopPulseFrequencyOrder mcipchopPulseFrequencyOrder
#define sampleSizeX mcipsampleSizeX
#define sampleSizeY mcipsampleSizeY
#define chopBWPos mcipchopBWPos
#define DivSlit0_width mcipDivSlit0_width
#define DivSlit1_width mcipDivSlit1_width
#define DivSlit2_width mcipDivSlit2_width
#define DivSlit3_width mcipDivSlit3_width
#define BWopen mcipBWopen
#define FOCopen1 mcipFOCopen1
#define FOCopen2 mcipFOCopen2
#define Npulse mcipNpulse
#define PscOff mcipPscOff
#define discD mcipdiscD
#define monigap_length mcipmonigap_length
#define print mcipprint
#define makeVirtualSource mcipmakeVirtualSource
#define printMValues mcipprintMValues
#define OMA mcipOMA
#define TTA mcipTTA
#define phi mcipphi
#define dphi mcipdphi
#line 35 "BIFROST.instr"
// M-value and element length arrays
double elementLength6S[150];
double mValues6verticalS[150];
double mValues6horizontalS[150];
double elementLength3S[150];
double mValues3verticalS[150];
double mValues3horizontalS[150];
double elementLength1S[150];
double mValues1verticalS[150];
double mValues1horizontalS[150];

double x_div;
double y_div;
int flag;
double u = 1e-5;

/*************************************** Chopper Variables  *******************************************/

double lambda_0; double lambda_1;
double v_0; double v_1;
double InstLength;
double chopPulseOffset;  double chopPulsePhaseOffset;  double chopPulseDist; double chopPulseOpen; 
double chopPulse2PhaseOffset;
double chopFrameOverlap1Offset;   double chopFrameOverlap1PhaseOffset; //double chopFrameOverlap1Pos; 
double chopFrameOverlap1Open;
double chopFrameOverlap2Offset;   double chopFrameOverlap2PhaseOffset; //double chopFrameOverlap2Pos; 
double chopFrameOverlap2Open;
double chopBWOffset;   double chopBWPhaseOffset; //double chopBWPos; 
double chopBWOpen;
double t_samp_center; double t_samp_0; double t_samp_1;
double chopBW_t0; double  chopBW_t1;

double PulseHighFluxOffset;
double WavelengthBand;
double ModPulseLengthHighF;
double chopPulsePossibleOpening;


/////  Martin's cutting parameters:
double sample_dist = 0.5;
double startXposition_straight = 49.303484;


double length5 = 17.995800;
//double benderStartXposition =6.380700;
double benderStartXposition =24.376254 ;

// straiht:
double length2 = 90.0;

// Focus ellipse:
double length1 = 22.114200;
double Linx1 = 24.364542;
double Loutx1 = 2.250342;
double Liny1 = 23.034433;
double Louty1 = 0.920233;
double alpha1 = 3.1;
double Qc1 = 0.021700;
double R01 = 0.990000;
double smallaxis_y1 = 0.090000/2;
double smallaxis_x1 = 0.060000/2;



double elementLength1_part_1[50]; 
double mValues1vertical_part_1[50]; 
double mValues1horizontal_part_1[50];
double elementLength1_part_2[5]; 
double mValues1vertical_part_2[5]; 
double mValues1horizontal_part_2[5];
double elementLength1_part_3[5]; 
double mValues1vertical_part_3[5]; 
double mValues1horizontal_part_3[5];
double elementLength1_part_4[5]; 
double mValues1vertical_part_4[5]; 
double mValues1horizontal_part_4[5];

int counter = 0;

double chopper_coordinate_offset = 4.439;


double curve_rot = 0; // has to be either 180 or -180. Determines curve to left or right

double chopFrameOverlap1Pos;
double chopFrameOverlap2Pos;

// These parameters are no longer safe to change
double DivSlit0Gap=0.02; // Hole in guide required for Divergence slit nr 0 (at the end of guide)
double DivSlit1Gap=0.02; // Hole in guide required for Divergence slit nr 1
double DivSlit2Gap=0.02; // Hole in guide required for Divergence slit nr 2
double DivSlit3Gap=0.02; // Hole in guide required for Divergence slit nr 3

double DivSlit1Pos=1.0814;  // Position of Divergence Slit nr 1
double DivSlit2Pos=1.661; // Position of Divergence Slit nr 2
double DivSlit3Pos=2.961; // Position of Divergence Slit nr 3
// Old divJaw pos:
//double DivSlit1Pos=1.191;  // Position of Divergence Slit nr 1
//double DivSlit2Pos=1.661; // Position of Divergence Slit nr 2
//double DivSlit3Pos=2.961; // Position of Divergence Slit nr 3
double chopGap=0.04;
double BW_chopGap=0.04;
double chopFrameOverlap1Pos= 8.530;    // Distance from moderator to first frame owerlap chopper
double chopFrameOverlap2Pos= 14.973;    // Distance from moderator to second frame owerlap chopper

double benderAngle = 0.01886551; // Mads numbers = 0.0183513513514;

double DM         = 3.355;   /* Monochromator d-spacing in Angs */
double wi		  = 0.01; 	/* Monochromator width*/


int i;  
#line 9816 "BIFROST.c"
#undef dphi
#undef phi
#undef TTA
#undef OMA
#undef printMValues
#undef makeVirtualSource
#undef print
#undef monigap_length
#undef discD
#undef PscOff
#undef Npulse
#undef FOCopen2
#undef FOCopen1
#undef BWopen
#undef DivSlit3_width
#undef DivSlit2_width
#undef DivSlit1_width
#undef DivSlit0_width
#undef chopBWPos
#undef sampleSizeY
#undef sampleSizeX
#undef chopPulseFrequencyOrder
#undef chopPulseOpening
#undef L_0
#undef E_0
#undef pin_holeX
#undef pin_holeY
#undef WaveMax
#undef WaveMin
#undef mcposaBIFROST
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname

/* neutron state table at each component input (local coords) */
/* [x, y, z, vx, vy, vz, t, sx, sy, sz, p] */
MCNUM mccomp_storein[11*127];
/* Components position table (absolute and relative coords) */
Coords mccomp_posa[127];
Coords mccomp_posr[127];
/* Counter for each comp to check for inactive ones */
MCNUM  mcNCounter[127];
MCNUM  mcPCounter[127];
MCNUM  mcP2Counter[127];
#define mcNUMCOMP 126 /* number of components */
/* Counter for PROP ABSORB */
MCNUM  mcAbsorbProp[127];
/* Flag true when previous component acted on the neutron (SCATTER) */
MCNUM mcScattered=0;
/* Flag true when neutron should be restored (RESTORE) */
MCNUM mcRestore=0;
/* Declarations of component definition and setting parameters. */

/* Setting parameters for component 'Origin' [1]. */
char mccOrigin_profile[16384];
MCNUM mccOrigin_percent;
MCNUM mccOrigin_flag_save;
MCNUM mccOrigin_minutes;

/* Setting parameters for component 'ESS_source' [2]. */
char mccESS_source_sector[16384];
int mccESS_source_beamline;
MCNUM mccESS_source_yheight;
MCNUM mccESS_source_cold_frac;
int mccESS_source_target_index;
MCNUM mccESS_source_dist;
MCNUM mccESS_source_focus_xw;
MCNUM mccESS_source_focus_yh;
MCNUM mccESS_source_c_performance;
MCNUM mccESS_source_t_performance;
MCNUM mccESS_source_Lmin;
MCNUM mccESS_source_Lmax;
MCNUM mccESS_source_tmax_multiplier;
int mccESS_source_n_pulses;
MCNUM mccESS_source_acc_power;
MCNUM mccESS_source_tfocus_dist;
MCNUM mccESS_source_tfocus_time;
MCNUM mccESS_source_tfocus_width;

/* Definition parameters for component 'NBOA' [4]. */
#define mccNBOA_mvaluesright mValues6horizontalS
#define mccNBOA_mvaluesleft mValues6horizontalS
#define mccNBOA_mvaluestop mValues6verticalS
#define mccNBOA_mvaluesbottom mValues6verticalS
#define mccNBOA_seglength elementLength6S
/* Setting parameters for component 'NBOA' [4]. */
MCNUM mccNBOA_l;
MCNUM mccNBOA_xwidth;
MCNUM mccNBOA_yheight;
MCNUM mccNBOA_linxw;
MCNUM mccNBOA_loutxw;
MCNUM mccNBOA_linyh;
MCNUM mccNBOA_loutyh;
MCNUM mccNBOA_majorAxisxw;
MCNUM mccNBOA_minorAxisxw;
MCNUM mccNBOA_majorAxisyh;
MCNUM mccNBOA_minorAxisyh;
MCNUM mccNBOA_majorAxisoffsetxw;
MCNUM mccNBOA_majorAxisoffsetyh;
char mccNBOA_dimensionsAt[16384];
char mccNBOA_option[16384];
MCNUM mccNBOA_R0;
MCNUM mccNBOA_Qc;
MCNUM mccNBOA_alpha;
MCNUM mccNBOA_m;
MCNUM mccNBOA_W;
MCNUM mccNBOA_alpharight;
MCNUM mccNBOA_mright;
MCNUM mccNBOA_alphaleft;
MCNUM mccNBOA_mleft;
MCNUM mccNBOA_alphatop;
MCNUM mccNBOA_mtop;
MCNUM mccNBOA_alphabottom;
MCNUM mccNBOA_mbottom;
char mccNBOA_verbose[16384];
MCNUM mccNBOA_enableGravity;
MCNUM mccNBOA_curvature;

/* Definition parameters for component 'L_monBeforePSC1' [6]. */
#define mccL_monBeforePSC1_nL 100
/* Setting parameters for component 'L_monBeforePSC1' [6]. */
char mccL_monBeforePSC1_filename[16384];
MCNUM mccL_monBeforePSC1_xmin;
MCNUM mccL_monBeforePSC1_xmax;
MCNUM mccL_monBeforePSC1_ymin;
MCNUM mccL_monBeforePSC1_ymax;
MCNUM mccL_monBeforePSC1_xwidth;
MCNUM mccL_monBeforePSC1_yheight;
MCNUM mccL_monBeforePSC1_Lmin;
MCNUM mccL_monBeforePSC1_Lmax;
MCNUM mccL_monBeforePSC1_restore_neutron;

/* Definition parameters for component 'ToFBeforerPSC1' [7]. */
#define mccToFBeforerPSC1_nt 1000
/* Setting parameters for component 'ToFBeforerPSC1' [7]. */
char mccToFBeforerPSC1_filename[16384];
MCNUM mccToFBeforerPSC1_xmin;
MCNUM mccToFBeforerPSC1_xmax;
MCNUM mccToFBeforerPSC1_ymin;
MCNUM mccToFBeforerPSC1_ymax;
MCNUM mccToFBeforerPSC1_xwidth;
MCNUM mccToFBeforerPSC1_yheight;
MCNUM mccToFBeforerPSC1_tmin;
MCNUM mccToFBeforerPSC1_tmax;
MCNUM mccToFBeforerPSC1_dt;
MCNUM mccToFBeforerPSC1_restore_neutron;

/* Definition parameters for component 'PSD_beforePulseShapping1' [8]. */
#define mccPSD_beforePulseShapping1_nx 100
#define mccPSD_beforePulseShapping1_ny 100
/* Setting parameters for component 'PSD_beforePulseShapping1' [8]. */
char mccPSD_beforePulseShapping1_filename[16384];
MCNUM mccPSD_beforePulseShapping1_xmin;
MCNUM mccPSD_beforePulseShapping1_xmax;
MCNUM mccPSD_beforePulseShapping1_ymin;
MCNUM mccPSD_beforePulseShapping1_ymax;
MCNUM mccPSD_beforePulseShapping1_xwidth;
MCNUM mccPSD_beforePulseShapping1_yheight;
MCNUM mccPSD_beforePulseShapping1_restore_neutron;

/* Definition parameters for component 'TofLambdaBeforePSC' [9]. */
#define mccTofLambdaBeforePSC_nL 100
#define mccTofLambdaBeforePSC_nt 100
#define mccTofLambdaBeforePSC_tmin 0
#define mccTofLambdaBeforePSC_tmax 2e4
/* Setting parameters for component 'TofLambdaBeforePSC' [9]. */
char mccTofLambdaBeforePSC_filename[16384];
MCNUM mccTofLambdaBeforePSC_xmin;
MCNUM mccTofLambdaBeforePSC_xmax;
MCNUM mccTofLambdaBeforePSC_ymin;
MCNUM mccTofLambdaBeforePSC_ymax;
MCNUM mccTofLambdaBeforePSC_xwidth;
MCNUM mccTofLambdaBeforePSC_yheight;
MCNUM mccTofLambdaBeforePSC_Lmin;
MCNUM mccTofLambdaBeforePSC_Lmax;
MCNUM mccTofLambdaBeforePSC_restore_neutron;

/* Setting parameters for component 'PulseShapingChopper' [10]. */
MCNUM mccPulseShapingChopper_theta_0;
MCNUM mccPulseShapingChopper_radius;
MCNUM mccPulseShapingChopper_yheight;
MCNUM mccPulseShapingChopper_nu;
MCNUM mccPulseShapingChopper_nslit;
MCNUM mccPulseShapingChopper_jitter;
MCNUM mccPulseShapingChopper_delay;
MCNUM mccPulseShapingChopper_isfirst;
MCNUM mccPulseShapingChopper_n_pulse;
MCNUM mccPulseShapingChopper_abs_out;
MCNUM mccPulseShapingChopper_phase;
MCNUM mccPulseShapingChopper_xwidth;
MCNUM mccPulseShapingChopper_verbose;

/* Definition parameters for component 'PSD_AfterPulseShapping1' [11]. */
#define mccPSD_AfterPulseShapping1_nx 100
#define mccPSD_AfterPulseShapping1_ny 100
/* Setting parameters for component 'PSD_AfterPulseShapping1' [11]. */
char mccPSD_AfterPulseShapping1_filename[16384];
MCNUM mccPSD_AfterPulseShapping1_xmin;
MCNUM mccPSD_AfterPulseShapping1_xmax;
MCNUM mccPSD_AfterPulseShapping1_ymin;
MCNUM mccPSD_AfterPulseShapping1_ymax;
MCNUM mccPSD_AfterPulseShapping1_xwidth;
MCNUM mccPSD_AfterPulseShapping1_yheight;
MCNUM mccPSD_AfterPulseShapping1_restore_neutron;

/* Definition parameters for component 'ToFInsidePSC' [12]. */
#define mccToFInsidePSC_nt 1000
/* Setting parameters for component 'ToFInsidePSC' [12]. */
char mccToFInsidePSC_filename[16384];
MCNUM mccToFInsidePSC_xmin;
MCNUM mccToFInsidePSC_xmax;
MCNUM mccToFInsidePSC_ymin;
MCNUM mccToFInsidePSC_ymax;
MCNUM mccToFInsidePSC_xwidth;
MCNUM mccToFInsidePSC_yheight;
MCNUM mccToFInsidePSC_tmin;
MCNUM mccToFInsidePSC_tmax;
MCNUM mccToFInsidePSC_dt;
MCNUM mccToFInsidePSC_restore_neutron;

/* Setting parameters for component 'PulseShapingChopper2' [13]. */
MCNUM mccPulseShapingChopper2_theta_0;
MCNUM mccPulseShapingChopper2_radius;
MCNUM mccPulseShapingChopper2_yheight;
MCNUM mccPulseShapingChopper2_nu;
MCNUM mccPulseShapingChopper2_nslit;
MCNUM mccPulseShapingChopper2_jitter;
MCNUM mccPulseShapingChopper2_delay;
MCNUM mccPulseShapingChopper2_isfirst;
MCNUM mccPulseShapingChopper2_n_pulse;
MCNUM mccPulseShapingChopper2_abs_out;
MCNUM mccPulseShapingChopper2_phase;
MCNUM mccPulseShapingChopper2_xwidth;
MCNUM mccPulseShapingChopper2_verbose;

/* Definition parameters for component 'TofLambdaAfterPSC2' [14]. */
#define mccTofLambdaAfterPSC2_nL 100
#define mccTofLambdaAfterPSC2_nt 100
#define mccTofLambdaAfterPSC2_tmin 0
#define mccTofLambdaAfterPSC2_tmax 2e4
/* Setting parameters for component 'TofLambdaAfterPSC2' [14]. */
char mccTofLambdaAfterPSC2_filename[16384];
MCNUM mccTofLambdaAfterPSC2_xmin;
MCNUM mccTofLambdaAfterPSC2_xmax;
MCNUM mccTofLambdaAfterPSC2_ymin;
MCNUM mccTofLambdaAfterPSC2_ymax;
MCNUM mccTofLambdaAfterPSC2_xwidth;
MCNUM mccTofLambdaAfterPSC2_yheight;
MCNUM mccTofLambdaAfterPSC2_Lmin;
MCNUM mccTofLambdaAfterPSC2_Lmax;
MCNUM mccTofLambdaAfterPSC2_restore_neutron;

/* Definition parameters for component 'PSD_AfterPSC2' [15]. */
#define mccPSD_AfterPSC2_nx 100
#define mccPSD_AfterPSC2_ny 100
/* Setting parameters for component 'PSD_AfterPSC2' [15]. */
char mccPSD_AfterPSC2_filename[16384];
MCNUM mccPSD_AfterPSC2_xmin;
MCNUM mccPSD_AfterPSC2_xmax;
MCNUM mccPSD_AfterPSC2_ymin;
MCNUM mccPSD_AfterPSC2_ymax;
MCNUM mccPSD_AfterPSC2_xwidth;
MCNUM mccPSD_AfterPSC2_yheight;
MCNUM mccPSD_AfterPSC2_restore_neutron;

/* Definition parameters for component 'ToFAfterPSC2' [16]. */
#define mccToFAfterPSC2_nt 1000
/* Setting parameters for component 'ToFAfterPSC2' [16]. */
char mccToFAfterPSC2_filename[16384];
MCNUM mccToFAfterPSC2_xmin;
MCNUM mccToFAfterPSC2_xmax;
MCNUM mccToFAfterPSC2_ymin;
MCNUM mccToFAfterPSC2_ymax;
MCNUM mccToFAfterPSC2_xwidth;
MCNUM mccToFAfterPSC2_yheight;
MCNUM mccToFAfterPSC2_tmin;
MCNUM mccToFAfterPSC2_tmax;
MCNUM mccToFAfterPSC2_dt;
MCNUM mccToFAfterPSC2_restore_neutron;

/* Definition parameters for component 'L_monAfterPSC2' [17]. */
#define mccL_monAfterPSC2_nL 100
/* Setting parameters for component 'L_monAfterPSC2' [17]. */
char mccL_monAfterPSC2_filename[16384];
MCNUM mccL_monAfterPSC2_xmin;
MCNUM mccL_monAfterPSC2_xmax;
MCNUM mccL_monAfterPSC2_ymin;
MCNUM mccL_monAfterPSC2_ymax;
MCNUM mccL_monAfterPSC2_xwidth;
MCNUM mccL_monAfterPSC2_yheight;
MCNUM mccL_monAfterPSC2_Lmin;
MCNUM mccL_monAfterPSC2_Lmax;
MCNUM mccL_monAfterPSC2_restore_neutron;

/* Setting parameters for component 'curved_guide_1_0' [19]. */
MCNUM mcccurved_guide_1_0_w1;
MCNUM mcccurved_guide_1_0_h1;
MCNUM mcccurved_guide_1_0_w2;
MCNUM mcccurved_guide_1_0_h2;
MCNUM mcccurved_guide_1_0_l;
MCNUM mcccurved_guide_1_0_R0;
MCNUM mcccurved_guide_1_0_Qc;
MCNUM mcccurved_guide_1_0_alpha;
MCNUM mcccurved_guide_1_0_m;
MCNUM mcccurved_guide_1_0_W;
MCNUM mcccurved_guide_1_0_nslit;
MCNUM mcccurved_guide_1_0_d;
MCNUM mcccurved_guide_1_0_mleft;
MCNUM mcccurved_guide_1_0_mright;
MCNUM mcccurved_guide_1_0_mtop;
MCNUM mcccurved_guide_1_0_mbottom;
MCNUM mcccurved_guide_1_0_nhslit;
MCNUM mcccurved_guide_1_0_G;
MCNUM mcccurved_guide_1_0_aleft;
MCNUM mcccurved_guide_1_0_aright;
MCNUM mcccurved_guide_1_0_atop;
MCNUM mcccurved_guide_1_0_abottom;
MCNUM mcccurved_guide_1_0_wavy;
MCNUM mcccurved_guide_1_0_wavy_z;
MCNUM mcccurved_guide_1_0_wavy_tb;
MCNUM mcccurved_guide_1_0_wavy_lr;
MCNUM mcccurved_guide_1_0_chamfers;
MCNUM mcccurved_guide_1_0_chamfers_z;
MCNUM mcccurved_guide_1_0_chamfers_lr;
MCNUM mcccurved_guide_1_0_chamfers_tb;
MCNUM mcccurved_guide_1_0_nelements;
MCNUM mcccurved_guide_1_0_nu;
MCNUM mcccurved_guide_1_0_phase;
char mcccurved_guide_1_0_reflect[16384];

/* Setting parameters for component 'curved_guide_2_0' [20]. */
MCNUM mcccurved_guide_2_0_w1;
MCNUM mcccurved_guide_2_0_h1;
MCNUM mcccurved_guide_2_0_w2;
MCNUM mcccurved_guide_2_0_h2;
MCNUM mcccurved_guide_2_0_l;
MCNUM mcccurved_guide_2_0_R0;
MCNUM mcccurved_guide_2_0_Qc;
MCNUM mcccurved_guide_2_0_alpha;
MCNUM mcccurved_guide_2_0_m;
MCNUM mcccurved_guide_2_0_W;
MCNUM mcccurved_guide_2_0_nslit;
MCNUM mcccurved_guide_2_0_d;
MCNUM mcccurved_guide_2_0_mleft;
MCNUM mcccurved_guide_2_0_mright;
MCNUM mcccurved_guide_2_0_mtop;
MCNUM mcccurved_guide_2_0_mbottom;
MCNUM mcccurved_guide_2_0_nhslit;
MCNUM mcccurved_guide_2_0_G;
MCNUM mcccurved_guide_2_0_aleft;
MCNUM mcccurved_guide_2_0_aright;
MCNUM mcccurved_guide_2_0_atop;
MCNUM mcccurved_guide_2_0_abottom;
MCNUM mcccurved_guide_2_0_wavy;
MCNUM mcccurved_guide_2_0_wavy_z;
MCNUM mcccurved_guide_2_0_wavy_tb;
MCNUM mcccurved_guide_2_0_wavy_lr;
MCNUM mcccurved_guide_2_0_chamfers;
MCNUM mcccurved_guide_2_0_chamfers_z;
MCNUM mcccurved_guide_2_0_chamfers_lr;
MCNUM mcccurved_guide_2_0_chamfers_tb;
MCNUM mcccurved_guide_2_0_nelements;
MCNUM mcccurved_guide_2_0_nu;
MCNUM mcccurved_guide_2_0_phase;
char mcccurved_guide_2_0_reflect[16384];

/* Setting parameters for component 'curved_guide_3_0' [21]. */
MCNUM mcccurved_guide_3_0_w1;
MCNUM mcccurved_guide_3_0_h1;
MCNUM mcccurved_guide_3_0_w2;
MCNUM mcccurved_guide_3_0_h2;
MCNUM mcccurved_guide_3_0_l;
MCNUM mcccurved_guide_3_0_R0;
MCNUM mcccurved_guide_3_0_Qc;
MCNUM mcccurved_guide_3_0_alpha;
MCNUM mcccurved_guide_3_0_m;
MCNUM mcccurved_guide_3_0_W;
MCNUM mcccurved_guide_3_0_nslit;
MCNUM mcccurved_guide_3_0_d;
MCNUM mcccurved_guide_3_0_mleft;
MCNUM mcccurved_guide_3_0_mright;
MCNUM mcccurved_guide_3_0_mtop;
MCNUM mcccurved_guide_3_0_mbottom;
MCNUM mcccurved_guide_3_0_nhslit;
MCNUM mcccurved_guide_3_0_G;
MCNUM mcccurved_guide_3_0_aleft;
MCNUM mcccurved_guide_3_0_aright;
MCNUM mcccurved_guide_3_0_atop;
MCNUM mcccurved_guide_3_0_abottom;
MCNUM mcccurved_guide_3_0_wavy;
MCNUM mcccurved_guide_3_0_wavy_z;
MCNUM mcccurved_guide_3_0_wavy_tb;
MCNUM mcccurved_guide_3_0_wavy_lr;
MCNUM mcccurved_guide_3_0_chamfers;
MCNUM mcccurved_guide_3_0_chamfers_z;
MCNUM mcccurved_guide_3_0_chamfers_lr;
MCNUM mcccurved_guide_3_0_chamfers_tb;
MCNUM mcccurved_guide_3_0_nelements;
MCNUM mcccurved_guide_3_0_nu;
MCNUM mcccurved_guide_3_0_phase;
char mcccurved_guide_3_0_reflect[16384];

/* Setting parameters for component 'curved_guide_4_0' [22]. */
MCNUM mcccurved_guide_4_0_w1;
MCNUM mcccurved_guide_4_0_h1;
MCNUM mcccurved_guide_4_0_w2;
MCNUM mcccurved_guide_4_0_h2;
MCNUM mcccurved_guide_4_0_l;
MCNUM mcccurved_guide_4_0_R0;
MCNUM mcccurved_guide_4_0_Qc;
MCNUM mcccurved_guide_4_0_alpha;
MCNUM mcccurved_guide_4_0_m;
MCNUM mcccurved_guide_4_0_W;
MCNUM mcccurved_guide_4_0_nslit;
MCNUM mcccurved_guide_4_0_d;
MCNUM mcccurved_guide_4_0_mleft;
MCNUM mcccurved_guide_4_0_mright;
MCNUM mcccurved_guide_4_0_mtop;
MCNUM mcccurved_guide_4_0_mbottom;
MCNUM mcccurved_guide_4_0_nhslit;
MCNUM mcccurved_guide_4_0_G;
MCNUM mcccurved_guide_4_0_aleft;
MCNUM mcccurved_guide_4_0_aright;
MCNUM mcccurved_guide_4_0_atop;
MCNUM mcccurved_guide_4_0_abottom;
MCNUM mcccurved_guide_4_0_wavy;
MCNUM mcccurved_guide_4_0_wavy_z;
MCNUM mcccurved_guide_4_0_wavy_tb;
MCNUM mcccurved_guide_4_0_wavy_lr;
MCNUM mcccurved_guide_4_0_chamfers;
MCNUM mcccurved_guide_4_0_chamfers_z;
MCNUM mcccurved_guide_4_0_chamfers_lr;
MCNUM mcccurved_guide_4_0_chamfers_tb;
MCNUM mcccurved_guide_4_0_nelements;
MCNUM mcccurved_guide_4_0_nu;
MCNUM mcccurved_guide_4_0_phase;
char mcccurved_guide_4_0_reflect[16384];

/* Setting parameters for component 'curved_guide_5_beforeChopper' [23]. */
MCNUM mcccurved_guide_5_beforeChopper_w1;
MCNUM mcccurved_guide_5_beforeChopper_h1;
MCNUM mcccurved_guide_5_beforeChopper_w2;
MCNUM mcccurved_guide_5_beforeChopper_h2;
MCNUM mcccurved_guide_5_beforeChopper_l;
MCNUM mcccurved_guide_5_beforeChopper_R0;
MCNUM mcccurved_guide_5_beforeChopper_Qc;
MCNUM mcccurved_guide_5_beforeChopper_alpha;
MCNUM mcccurved_guide_5_beforeChopper_m;
MCNUM mcccurved_guide_5_beforeChopper_W;
MCNUM mcccurved_guide_5_beforeChopper_nslit;
MCNUM mcccurved_guide_5_beforeChopper_d;
MCNUM mcccurved_guide_5_beforeChopper_mleft;
MCNUM mcccurved_guide_5_beforeChopper_mright;
MCNUM mcccurved_guide_5_beforeChopper_mtop;
MCNUM mcccurved_guide_5_beforeChopper_mbottom;
MCNUM mcccurved_guide_5_beforeChopper_nhslit;
MCNUM mcccurved_guide_5_beforeChopper_G;
MCNUM mcccurved_guide_5_beforeChopper_aleft;
MCNUM mcccurved_guide_5_beforeChopper_aright;
MCNUM mcccurved_guide_5_beforeChopper_atop;
MCNUM mcccurved_guide_5_beforeChopper_abottom;
MCNUM mcccurved_guide_5_beforeChopper_wavy;
MCNUM mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM mcccurved_guide_5_beforeChopper_chamfers;
MCNUM mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM mcccurved_guide_5_beforeChopper_nelements;
MCNUM mcccurved_guide_5_beforeChopper_nu;
MCNUM mcccurved_guide_5_beforeChopper_phase;
char mcccurved_guide_5_beforeChopper_reflect[16384];

/* Definition parameters for component 'L_monBeforeFOC1' [24]. */
#define mccL_monBeforeFOC1_nL 100
/* Setting parameters for component 'L_monBeforeFOC1' [24]. */
char mccL_monBeforeFOC1_filename[16384];
MCNUM mccL_monBeforeFOC1_xmin;
MCNUM mccL_monBeforeFOC1_xmax;
MCNUM mccL_monBeforeFOC1_ymin;
MCNUM mccL_monBeforeFOC1_ymax;
MCNUM mccL_monBeforeFOC1_xwidth;
MCNUM mccL_monBeforeFOC1_yheight;
MCNUM mccL_monBeforeFOC1_Lmin;
MCNUM mccL_monBeforeFOC1_Lmax;
MCNUM mccL_monBeforeFOC1_restore_neutron;

/* Definition parameters for component 'ToFBeforeFOC1' [25]. */
#define mccToFBeforeFOC1_nt 1000
/* Setting parameters for component 'ToFBeforeFOC1' [25]. */
char mccToFBeforeFOC1_filename[16384];
MCNUM mccToFBeforeFOC1_xmin;
MCNUM mccToFBeforeFOC1_xmax;
MCNUM mccToFBeforeFOC1_ymin;
MCNUM mccToFBeforeFOC1_ymax;
MCNUM mccToFBeforeFOC1_xwidth;
MCNUM mccToFBeforeFOC1_yheight;
MCNUM mccToFBeforeFOC1_tmin;
MCNUM mccToFBeforeFOC1_tmax;
MCNUM mccToFBeforeFOC1_dt;
MCNUM mccToFBeforeFOC1_restore_neutron;

/* Definition parameters for component 'PSD_beforeFOC1' [26]. */
#define mccPSD_beforeFOC1_nx 100
#define mccPSD_beforeFOC1_ny 100
/* Setting parameters for component 'PSD_beforeFOC1' [26]. */
char mccPSD_beforeFOC1_filename[16384];
MCNUM mccPSD_beforeFOC1_xmin;
MCNUM mccPSD_beforeFOC1_xmax;
MCNUM mccPSD_beforeFOC1_ymin;
MCNUM mccPSD_beforeFOC1_ymax;
MCNUM mccPSD_beforeFOC1_xwidth;
MCNUM mccPSD_beforeFOC1_yheight;
MCNUM mccPSD_beforeFOC1_restore_neutron;

/* Setting parameters for component 'FOC1' [27]. */
MCNUM mccFOC1_theta_0;
MCNUM mccFOC1_radius;
MCNUM mccFOC1_yheight;
MCNUM mccFOC1_nu;
MCNUM mccFOC1_nslit;
MCNUM mccFOC1_jitter;
MCNUM mccFOC1_delay;
MCNUM mccFOC1_isfirst;
MCNUM mccFOC1_n_pulse;
MCNUM mccFOC1_abs_out;
MCNUM mccFOC1_phase;
MCNUM mccFOC1_xwidth;
MCNUM mccFOC1_verbose;

/* Definition parameters for component 'PSD_afterFOC1' [28]. */
#define mccPSD_afterFOC1_nx 100
#define mccPSD_afterFOC1_ny 100
/* Setting parameters for component 'PSD_afterFOC1' [28]. */
char mccPSD_afterFOC1_filename[16384];
MCNUM mccPSD_afterFOC1_xmin;
MCNUM mccPSD_afterFOC1_xmax;
MCNUM mccPSD_afterFOC1_ymin;
MCNUM mccPSD_afterFOC1_ymax;
MCNUM mccPSD_afterFOC1_xwidth;
MCNUM mccPSD_afterFOC1_yheight;
MCNUM mccPSD_afterFOC1_restore_neutron;

/* Definition parameters for component 'ToFAfterFOC1' [29]. */
#define mccToFAfterFOC1_nt 1000
/* Setting parameters for component 'ToFAfterFOC1' [29]. */
char mccToFAfterFOC1_filename[16384];
MCNUM mccToFAfterFOC1_xmin;
MCNUM mccToFAfterFOC1_xmax;
MCNUM mccToFAfterFOC1_ymin;
MCNUM mccToFAfterFOC1_ymax;
MCNUM mccToFAfterFOC1_xwidth;
MCNUM mccToFAfterFOC1_yheight;
MCNUM mccToFAfterFOC1_tmin;
MCNUM mccToFAfterFOC1_tmax;
MCNUM mccToFAfterFOC1_dt;
MCNUM mccToFAfterFOC1_restore_neutron;

/* Definition parameters for component 'L_monAfterFOC1' [30]. */
#define mccL_monAfterFOC1_nL 100
/* Setting parameters for component 'L_monAfterFOC1' [30]. */
char mccL_monAfterFOC1_filename[16384];
MCNUM mccL_monAfterFOC1_xmin;
MCNUM mccL_monAfterFOC1_xmax;
MCNUM mccL_monAfterFOC1_ymin;
MCNUM mccL_monAfterFOC1_ymax;
MCNUM mccL_monAfterFOC1_xwidth;
MCNUM mccL_monAfterFOC1_yheight;
MCNUM mccL_monAfterFOC1_Lmin;
MCNUM mccL_monAfterFOC1_Lmax;
MCNUM mccL_monAfterFOC1_restore_neutron;

/* Setting parameters for component 'curved_guide_5_afterChopper' [31]. */
MCNUM mcccurved_guide_5_afterChopper_w1;
MCNUM mcccurved_guide_5_afterChopper_h1;
MCNUM mcccurved_guide_5_afterChopper_w2;
MCNUM mcccurved_guide_5_afterChopper_h2;
MCNUM mcccurved_guide_5_afterChopper_l;
MCNUM mcccurved_guide_5_afterChopper_R0;
MCNUM mcccurved_guide_5_afterChopper_Qc;
MCNUM mcccurved_guide_5_afterChopper_alpha;
MCNUM mcccurved_guide_5_afterChopper_m;
MCNUM mcccurved_guide_5_afterChopper_W;
MCNUM mcccurved_guide_5_afterChopper_nslit;
MCNUM mcccurved_guide_5_afterChopper_d;
MCNUM mcccurved_guide_5_afterChopper_mleft;
MCNUM mcccurved_guide_5_afterChopper_mright;
MCNUM mcccurved_guide_5_afterChopper_mtop;
MCNUM mcccurved_guide_5_afterChopper_mbottom;
MCNUM mcccurved_guide_5_afterChopper_nhslit;
MCNUM mcccurved_guide_5_afterChopper_G;
MCNUM mcccurved_guide_5_afterChopper_aleft;
MCNUM mcccurved_guide_5_afterChopper_aright;
MCNUM mcccurved_guide_5_afterChopper_atop;
MCNUM mcccurved_guide_5_afterChopper_abottom;
MCNUM mcccurved_guide_5_afterChopper_wavy;
MCNUM mcccurved_guide_5_afterChopper_wavy_z;
MCNUM mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM mcccurved_guide_5_afterChopper_chamfers;
MCNUM mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM mcccurved_guide_5_afterChopper_nelements;
MCNUM mcccurved_guide_5_afterChopper_nu;
MCNUM mcccurved_guide_5_afterChopper_phase;
char mcccurved_guide_5_afterChopper_reflect[16384];

/* Setting parameters for component 'curved_guide_6_0' [32]. */
MCNUM mcccurved_guide_6_0_w1;
MCNUM mcccurved_guide_6_0_h1;
MCNUM mcccurved_guide_6_0_w2;
MCNUM mcccurved_guide_6_0_h2;
MCNUM mcccurved_guide_6_0_l;
MCNUM mcccurved_guide_6_0_R0;
MCNUM mcccurved_guide_6_0_Qc;
MCNUM mcccurved_guide_6_0_alpha;
MCNUM mcccurved_guide_6_0_m;
MCNUM mcccurved_guide_6_0_W;
MCNUM mcccurved_guide_6_0_nslit;
MCNUM mcccurved_guide_6_0_d;
MCNUM mcccurved_guide_6_0_mleft;
MCNUM mcccurved_guide_6_0_mright;
MCNUM mcccurved_guide_6_0_mtop;
MCNUM mcccurved_guide_6_0_mbottom;
MCNUM mcccurved_guide_6_0_nhslit;
MCNUM mcccurved_guide_6_0_G;
MCNUM mcccurved_guide_6_0_aleft;
MCNUM mcccurved_guide_6_0_aright;
MCNUM mcccurved_guide_6_0_atop;
MCNUM mcccurved_guide_6_0_abottom;
MCNUM mcccurved_guide_6_0_wavy;
MCNUM mcccurved_guide_6_0_wavy_z;
MCNUM mcccurved_guide_6_0_wavy_tb;
MCNUM mcccurved_guide_6_0_wavy_lr;
MCNUM mcccurved_guide_6_0_chamfers;
MCNUM mcccurved_guide_6_0_chamfers_z;
MCNUM mcccurved_guide_6_0_chamfers_lr;
MCNUM mcccurved_guide_6_0_chamfers_tb;
MCNUM mcccurved_guide_6_0_nelements;
MCNUM mcccurved_guide_6_0_nu;
MCNUM mcccurved_guide_6_0_phase;
char mcccurved_guide_6_0_reflect[16384];

/* Setting parameters for component 'curved_guide_7_0' [33]. */
MCNUM mcccurved_guide_7_0_w1;
MCNUM mcccurved_guide_7_0_h1;
MCNUM mcccurved_guide_7_0_w2;
MCNUM mcccurved_guide_7_0_h2;
MCNUM mcccurved_guide_7_0_l;
MCNUM mcccurved_guide_7_0_R0;
MCNUM mcccurved_guide_7_0_Qc;
MCNUM mcccurved_guide_7_0_alpha;
MCNUM mcccurved_guide_7_0_m;
MCNUM mcccurved_guide_7_0_W;
MCNUM mcccurved_guide_7_0_nslit;
MCNUM mcccurved_guide_7_0_d;
MCNUM mcccurved_guide_7_0_mleft;
MCNUM mcccurved_guide_7_0_mright;
MCNUM mcccurved_guide_7_0_mtop;
MCNUM mcccurved_guide_7_0_mbottom;
MCNUM mcccurved_guide_7_0_nhslit;
MCNUM mcccurved_guide_7_0_G;
MCNUM mcccurved_guide_7_0_aleft;
MCNUM mcccurved_guide_7_0_aright;
MCNUM mcccurved_guide_7_0_atop;
MCNUM mcccurved_guide_7_0_abottom;
MCNUM mcccurved_guide_7_0_wavy;
MCNUM mcccurved_guide_7_0_wavy_z;
MCNUM mcccurved_guide_7_0_wavy_tb;
MCNUM mcccurved_guide_7_0_wavy_lr;
MCNUM mcccurved_guide_7_0_chamfers;
MCNUM mcccurved_guide_7_0_chamfers_z;
MCNUM mcccurved_guide_7_0_chamfers_lr;
MCNUM mcccurved_guide_7_0_chamfers_tb;
MCNUM mcccurved_guide_7_0_nelements;
MCNUM mcccurved_guide_7_0_nu;
MCNUM mcccurved_guide_7_0_phase;
char mcccurved_guide_7_0_reflect[16384];

/* Setting parameters for component 'curved_guide_8_0' [34]. */
MCNUM mcccurved_guide_8_0_w1;
MCNUM mcccurved_guide_8_0_h1;
MCNUM mcccurved_guide_8_0_w2;
MCNUM mcccurved_guide_8_0_h2;
MCNUM mcccurved_guide_8_0_l;
MCNUM mcccurved_guide_8_0_R0;
MCNUM mcccurved_guide_8_0_Qc;
MCNUM mcccurved_guide_8_0_alpha;
MCNUM mcccurved_guide_8_0_m;
MCNUM mcccurved_guide_8_0_W;
MCNUM mcccurved_guide_8_0_nslit;
MCNUM mcccurved_guide_8_0_d;
MCNUM mcccurved_guide_8_0_mleft;
MCNUM mcccurved_guide_8_0_mright;
MCNUM mcccurved_guide_8_0_mtop;
MCNUM mcccurved_guide_8_0_mbottom;
MCNUM mcccurved_guide_8_0_nhslit;
MCNUM mcccurved_guide_8_0_G;
MCNUM mcccurved_guide_8_0_aleft;
MCNUM mcccurved_guide_8_0_aright;
MCNUM mcccurved_guide_8_0_atop;
MCNUM mcccurved_guide_8_0_abottom;
MCNUM mcccurved_guide_8_0_wavy;
MCNUM mcccurved_guide_8_0_wavy_z;
MCNUM mcccurved_guide_8_0_wavy_tb;
MCNUM mcccurved_guide_8_0_wavy_lr;
MCNUM mcccurved_guide_8_0_chamfers;
MCNUM mcccurved_guide_8_0_chamfers_z;
MCNUM mcccurved_guide_8_0_chamfers_lr;
MCNUM mcccurved_guide_8_0_chamfers_tb;
MCNUM mcccurved_guide_8_0_nelements;
MCNUM mcccurved_guide_8_0_nu;
MCNUM mcccurved_guide_8_0_phase;
char mcccurved_guide_8_0_reflect[16384];

/* Setting parameters for component 'curved_guide_9_0' [35]. */
MCNUM mcccurved_guide_9_0_w1;
MCNUM mcccurved_guide_9_0_h1;
MCNUM mcccurved_guide_9_0_w2;
MCNUM mcccurved_guide_9_0_h2;
MCNUM mcccurved_guide_9_0_l;
MCNUM mcccurved_guide_9_0_R0;
MCNUM mcccurved_guide_9_0_Qc;
MCNUM mcccurved_guide_9_0_alpha;
MCNUM mcccurved_guide_9_0_m;
MCNUM mcccurved_guide_9_0_W;
MCNUM mcccurved_guide_9_0_nslit;
MCNUM mcccurved_guide_9_0_d;
MCNUM mcccurved_guide_9_0_mleft;
MCNUM mcccurved_guide_9_0_mright;
MCNUM mcccurved_guide_9_0_mtop;
MCNUM mcccurved_guide_9_0_mbottom;
MCNUM mcccurved_guide_9_0_nhslit;
MCNUM mcccurved_guide_9_0_G;
MCNUM mcccurved_guide_9_0_aleft;
MCNUM mcccurved_guide_9_0_aright;
MCNUM mcccurved_guide_9_0_atop;
MCNUM mcccurved_guide_9_0_abottom;
MCNUM mcccurved_guide_9_0_wavy;
MCNUM mcccurved_guide_9_0_wavy_z;
MCNUM mcccurved_guide_9_0_wavy_tb;
MCNUM mcccurved_guide_9_0_wavy_lr;
MCNUM mcccurved_guide_9_0_chamfers;
MCNUM mcccurved_guide_9_0_chamfers_z;
MCNUM mcccurved_guide_9_0_chamfers_lr;
MCNUM mcccurved_guide_9_0_chamfers_tb;
MCNUM mcccurved_guide_9_0_nelements;
MCNUM mcccurved_guide_9_0_nu;
MCNUM mcccurved_guide_9_0_phase;
char mcccurved_guide_9_0_reflect[16384];

/* Setting parameters for component 'curved_guide_10_0' [36]. */
MCNUM mcccurved_guide_10_0_w1;
MCNUM mcccurved_guide_10_0_h1;
MCNUM mcccurved_guide_10_0_w2;
MCNUM mcccurved_guide_10_0_h2;
MCNUM mcccurved_guide_10_0_l;
MCNUM mcccurved_guide_10_0_R0;
MCNUM mcccurved_guide_10_0_Qc;
MCNUM mcccurved_guide_10_0_alpha;
MCNUM mcccurved_guide_10_0_m;
MCNUM mcccurved_guide_10_0_W;
MCNUM mcccurved_guide_10_0_nslit;
MCNUM mcccurved_guide_10_0_d;
MCNUM mcccurved_guide_10_0_mleft;
MCNUM mcccurved_guide_10_0_mright;
MCNUM mcccurved_guide_10_0_mtop;
MCNUM mcccurved_guide_10_0_mbottom;
MCNUM mcccurved_guide_10_0_nhslit;
MCNUM mcccurved_guide_10_0_G;
MCNUM mcccurved_guide_10_0_aleft;
MCNUM mcccurved_guide_10_0_aright;
MCNUM mcccurved_guide_10_0_atop;
MCNUM mcccurved_guide_10_0_abottom;
MCNUM mcccurved_guide_10_0_wavy;
MCNUM mcccurved_guide_10_0_wavy_z;
MCNUM mcccurved_guide_10_0_wavy_tb;
MCNUM mcccurved_guide_10_0_wavy_lr;
MCNUM mcccurved_guide_10_0_chamfers;
MCNUM mcccurved_guide_10_0_chamfers_z;
MCNUM mcccurved_guide_10_0_chamfers_lr;
MCNUM mcccurved_guide_10_0_chamfers_tb;
MCNUM mcccurved_guide_10_0_nelements;
MCNUM mcccurved_guide_10_0_nu;
MCNUM mcccurved_guide_10_0_phase;
char mcccurved_guide_10_0_reflect[16384];

/* Setting parameters for component 'curved_guide_11_0' [37]. */
MCNUM mcccurved_guide_11_0_w1;
MCNUM mcccurved_guide_11_0_h1;
MCNUM mcccurved_guide_11_0_w2;
MCNUM mcccurved_guide_11_0_h2;
MCNUM mcccurved_guide_11_0_l;
MCNUM mcccurved_guide_11_0_R0;
MCNUM mcccurved_guide_11_0_Qc;
MCNUM mcccurved_guide_11_0_alpha;
MCNUM mcccurved_guide_11_0_m;
MCNUM mcccurved_guide_11_0_W;
MCNUM mcccurved_guide_11_0_nslit;
MCNUM mcccurved_guide_11_0_d;
MCNUM mcccurved_guide_11_0_mleft;
MCNUM mcccurved_guide_11_0_mright;
MCNUM mcccurved_guide_11_0_mtop;
MCNUM mcccurved_guide_11_0_mbottom;
MCNUM mcccurved_guide_11_0_nhslit;
MCNUM mcccurved_guide_11_0_G;
MCNUM mcccurved_guide_11_0_aleft;
MCNUM mcccurved_guide_11_0_aright;
MCNUM mcccurved_guide_11_0_atop;
MCNUM mcccurved_guide_11_0_abottom;
MCNUM mcccurved_guide_11_0_wavy;
MCNUM mcccurved_guide_11_0_wavy_z;
MCNUM mcccurved_guide_11_0_wavy_tb;
MCNUM mcccurved_guide_11_0_wavy_lr;
MCNUM mcccurved_guide_11_0_chamfers;
MCNUM mcccurved_guide_11_0_chamfers_z;
MCNUM mcccurved_guide_11_0_chamfers_lr;
MCNUM mcccurved_guide_11_0_chamfers_tb;
MCNUM mcccurved_guide_11_0_nelements;
MCNUM mcccurved_guide_11_0_nu;
MCNUM mcccurved_guide_11_0_phase;
char mcccurved_guide_11_0_reflect[16384];

/* Setting parameters for component 'curved_guide_12_0' [38]. */
MCNUM mcccurved_guide_12_0_w1;
MCNUM mcccurved_guide_12_0_h1;
MCNUM mcccurved_guide_12_0_w2;
MCNUM mcccurved_guide_12_0_h2;
MCNUM mcccurved_guide_12_0_l;
MCNUM mcccurved_guide_12_0_R0;
MCNUM mcccurved_guide_12_0_Qc;
MCNUM mcccurved_guide_12_0_alpha;
MCNUM mcccurved_guide_12_0_m;
MCNUM mcccurved_guide_12_0_W;
MCNUM mcccurved_guide_12_0_nslit;
MCNUM mcccurved_guide_12_0_d;
MCNUM mcccurved_guide_12_0_mleft;
MCNUM mcccurved_guide_12_0_mright;
MCNUM mcccurved_guide_12_0_mtop;
MCNUM mcccurved_guide_12_0_mbottom;
MCNUM mcccurved_guide_12_0_nhslit;
MCNUM mcccurved_guide_12_0_G;
MCNUM mcccurved_guide_12_0_aleft;
MCNUM mcccurved_guide_12_0_aright;
MCNUM mcccurved_guide_12_0_atop;
MCNUM mcccurved_guide_12_0_abottom;
MCNUM mcccurved_guide_12_0_wavy;
MCNUM mcccurved_guide_12_0_wavy_z;
MCNUM mcccurved_guide_12_0_wavy_tb;
MCNUM mcccurved_guide_12_0_wavy_lr;
MCNUM mcccurved_guide_12_0_chamfers;
MCNUM mcccurved_guide_12_0_chamfers_z;
MCNUM mcccurved_guide_12_0_chamfers_lr;
MCNUM mcccurved_guide_12_0_chamfers_tb;
MCNUM mcccurved_guide_12_0_nelements;
MCNUM mcccurved_guide_12_0_nu;
MCNUM mcccurved_guide_12_0_phase;
char mcccurved_guide_12_0_reflect[16384];

/* Setting parameters for component 'curved_guide_13_0' [39]. */
MCNUM mcccurved_guide_13_0_w1;
MCNUM mcccurved_guide_13_0_h1;
MCNUM mcccurved_guide_13_0_w2;
MCNUM mcccurved_guide_13_0_h2;
MCNUM mcccurved_guide_13_0_l;
MCNUM mcccurved_guide_13_0_R0;
MCNUM mcccurved_guide_13_0_Qc;
MCNUM mcccurved_guide_13_0_alpha;
MCNUM mcccurved_guide_13_0_m;
MCNUM mcccurved_guide_13_0_W;
MCNUM mcccurved_guide_13_0_nslit;
MCNUM mcccurved_guide_13_0_d;
MCNUM mcccurved_guide_13_0_mleft;
MCNUM mcccurved_guide_13_0_mright;
MCNUM mcccurved_guide_13_0_mtop;
MCNUM mcccurved_guide_13_0_mbottom;
MCNUM mcccurved_guide_13_0_nhslit;
MCNUM mcccurved_guide_13_0_G;
MCNUM mcccurved_guide_13_0_aleft;
MCNUM mcccurved_guide_13_0_aright;
MCNUM mcccurved_guide_13_0_atop;
MCNUM mcccurved_guide_13_0_abottom;
MCNUM mcccurved_guide_13_0_wavy;
MCNUM mcccurved_guide_13_0_wavy_z;
MCNUM mcccurved_guide_13_0_wavy_tb;
MCNUM mcccurved_guide_13_0_wavy_lr;
MCNUM mcccurved_guide_13_0_chamfers;
MCNUM mcccurved_guide_13_0_chamfers_z;
MCNUM mcccurved_guide_13_0_chamfers_lr;
MCNUM mcccurved_guide_13_0_chamfers_tb;
MCNUM mcccurved_guide_13_0_nelements;
MCNUM mcccurved_guide_13_0_nu;
MCNUM mcccurved_guide_13_0_phase;
char mcccurved_guide_13_0_reflect[16384];

/* Setting parameters for component 'curved_guide_14_0' [40]. */
MCNUM mcccurved_guide_14_0_w1;
MCNUM mcccurved_guide_14_0_h1;
MCNUM mcccurved_guide_14_0_w2;
MCNUM mcccurved_guide_14_0_h2;
MCNUM mcccurved_guide_14_0_l;
MCNUM mcccurved_guide_14_0_R0;
MCNUM mcccurved_guide_14_0_Qc;
MCNUM mcccurved_guide_14_0_alpha;
MCNUM mcccurved_guide_14_0_m;
MCNUM mcccurved_guide_14_0_W;
MCNUM mcccurved_guide_14_0_nslit;
MCNUM mcccurved_guide_14_0_d;
MCNUM mcccurved_guide_14_0_mleft;
MCNUM mcccurved_guide_14_0_mright;
MCNUM mcccurved_guide_14_0_mtop;
MCNUM mcccurved_guide_14_0_mbottom;
MCNUM mcccurved_guide_14_0_nhslit;
MCNUM mcccurved_guide_14_0_G;
MCNUM mcccurved_guide_14_0_aleft;
MCNUM mcccurved_guide_14_0_aright;
MCNUM mcccurved_guide_14_0_atop;
MCNUM mcccurved_guide_14_0_abottom;
MCNUM mcccurved_guide_14_0_wavy;
MCNUM mcccurved_guide_14_0_wavy_z;
MCNUM mcccurved_guide_14_0_wavy_tb;
MCNUM mcccurved_guide_14_0_wavy_lr;
MCNUM mcccurved_guide_14_0_chamfers;
MCNUM mcccurved_guide_14_0_chamfers_z;
MCNUM mcccurved_guide_14_0_chamfers_lr;
MCNUM mcccurved_guide_14_0_chamfers_tb;
MCNUM mcccurved_guide_14_0_nelements;
MCNUM mcccurved_guide_14_0_nu;
MCNUM mcccurved_guide_14_0_phase;
char mcccurved_guide_14_0_reflect[16384];

/* Setting parameters for component 'curved_guide_15_0' [41]. */
MCNUM mcccurved_guide_15_0_w1;
MCNUM mcccurved_guide_15_0_h1;
MCNUM mcccurved_guide_15_0_w2;
MCNUM mcccurved_guide_15_0_h2;
MCNUM mcccurved_guide_15_0_l;
MCNUM mcccurved_guide_15_0_R0;
MCNUM mcccurved_guide_15_0_Qc;
MCNUM mcccurved_guide_15_0_alpha;
MCNUM mcccurved_guide_15_0_m;
MCNUM mcccurved_guide_15_0_W;
MCNUM mcccurved_guide_15_0_nslit;
MCNUM mcccurved_guide_15_0_d;
MCNUM mcccurved_guide_15_0_mleft;
MCNUM mcccurved_guide_15_0_mright;
MCNUM mcccurved_guide_15_0_mtop;
MCNUM mcccurved_guide_15_0_mbottom;
MCNUM mcccurved_guide_15_0_nhslit;
MCNUM mcccurved_guide_15_0_G;
MCNUM mcccurved_guide_15_0_aleft;
MCNUM mcccurved_guide_15_0_aright;
MCNUM mcccurved_guide_15_0_atop;
MCNUM mcccurved_guide_15_0_abottom;
MCNUM mcccurved_guide_15_0_wavy;
MCNUM mcccurved_guide_15_0_wavy_z;
MCNUM mcccurved_guide_15_0_wavy_tb;
MCNUM mcccurved_guide_15_0_wavy_lr;
MCNUM mcccurved_guide_15_0_chamfers;
MCNUM mcccurved_guide_15_0_chamfers_z;
MCNUM mcccurved_guide_15_0_chamfers_lr;
MCNUM mcccurved_guide_15_0_chamfers_tb;
MCNUM mcccurved_guide_15_0_nelements;
MCNUM mcccurved_guide_15_0_nu;
MCNUM mcccurved_guide_15_0_phase;
char mcccurved_guide_15_0_reflect[16384];

/* Setting parameters for component 'curved_guide_16_0' [42]. */
MCNUM mcccurved_guide_16_0_w1;
MCNUM mcccurved_guide_16_0_h1;
MCNUM mcccurved_guide_16_0_w2;
MCNUM mcccurved_guide_16_0_h2;
MCNUM mcccurved_guide_16_0_l;
MCNUM mcccurved_guide_16_0_R0;
MCNUM mcccurved_guide_16_0_Qc;
MCNUM mcccurved_guide_16_0_alpha;
MCNUM mcccurved_guide_16_0_m;
MCNUM mcccurved_guide_16_0_W;
MCNUM mcccurved_guide_16_0_nslit;
MCNUM mcccurved_guide_16_0_d;
MCNUM mcccurved_guide_16_0_mleft;
MCNUM mcccurved_guide_16_0_mright;
MCNUM mcccurved_guide_16_0_mtop;
MCNUM mcccurved_guide_16_0_mbottom;
MCNUM mcccurved_guide_16_0_nhslit;
MCNUM mcccurved_guide_16_0_G;
MCNUM mcccurved_guide_16_0_aleft;
MCNUM mcccurved_guide_16_0_aright;
MCNUM mcccurved_guide_16_0_atop;
MCNUM mcccurved_guide_16_0_abottom;
MCNUM mcccurved_guide_16_0_wavy;
MCNUM mcccurved_guide_16_0_wavy_z;
MCNUM mcccurved_guide_16_0_wavy_tb;
MCNUM mcccurved_guide_16_0_wavy_lr;
MCNUM mcccurved_guide_16_0_chamfers;
MCNUM mcccurved_guide_16_0_chamfers_z;
MCNUM mcccurved_guide_16_0_chamfers_lr;
MCNUM mcccurved_guide_16_0_chamfers_tb;
MCNUM mcccurved_guide_16_0_nelements;
MCNUM mcccurved_guide_16_0_nu;
MCNUM mcccurved_guide_16_0_phase;
char mcccurved_guide_16_0_reflect[16384];

/* Setting parameters for component 'curved_guide_17_0' [43]. */
MCNUM mcccurved_guide_17_0_w1;
MCNUM mcccurved_guide_17_0_h1;
MCNUM mcccurved_guide_17_0_w2;
MCNUM mcccurved_guide_17_0_h2;
MCNUM mcccurved_guide_17_0_l;
MCNUM mcccurved_guide_17_0_R0;
MCNUM mcccurved_guide_17_0_Qc;
MCNUM mcccurved_guide_17_0_alpha;
MCNUM mcccurved_guide_17_0_m;
MCNUM mcccurved_guide_17_0_W;
MCNUM mcccurved_guide_17_0_nslit;
MCNUM mcccurved_guide_17_0_d;
MCNUM mcccurved_guide_17_0_mleft;
MCNUM mcccurved_guide_17_0_mright;
MCNUM mcccurved_guide_17_0_mtop;
MCNUM mcccurved_guide_17_0_mbottom;
MCNUM mcccurved_guide_17_0_nhslit;
MCNUM mcccurved_guide_17_0_G;
MCNUM mcccurved_guide_17_0_aleft;
MCNUM mcccurved_guide_17_0_aright;
MCNUM mcccurved_guide_17_0_atop;
MCNUM mcccurved_guide_17_0_abottom;
MCNUM mcccurved_guide_17_0_wavy;
MCNUM mcccurved_guide_17_0_wavy_z;
MCNUM mcccurved_guide_17_0_wavy_tb;
MCNUM mcccurved_guide_17_0_wavy_lr;
MCNUM mcccurved_guide_17_0_chamfers;
MCNUM mcccurved_guide_17_0_chamfers_z;
MCNUM mcccurved_guide_17_0_chamfers_lr;
MCNUM mcccurved_guide_17_0_chamfers_tb;
MCNUM mcccurved_guide_17_0_nelements;
MCNUM mcccurved_guide_17_0_nu;
MCNUM mcccurved_guide_17_0_phase;
char mcccurved_guide_17_0_reflect[16384];

/* Setting parameters for component 'curved_guide_18_beforeChopper' [44]. */
MCNUM mcccurved_guide_18_beforeChopper_w1;
MCNUM mcccurved_guide_18_beforeChopper_h1;
MCNUM mcccurved_guide_18_beforeChopper_w2;
MCNUM mcccurved_guide_18_beforeChopper_h2;
MCNUM mcccurved_guide_18_beforeChopper_l;
MCNUM mcccurved_guide_18_beforeChopper_R0;
MCNUM mcccurved_guide_18_beforeChopper_Qc;
MCNUM mcccurved_guide_18_beforeChopper_alpha;
MCNUM mcccurved_guide_18_beforeChopper_m;
MCNUM mcccurved_guide_18_beforeChopper_W;
MCNUM mcccurved_guide_18_beforeChopper_nslit;
MCNUM mcccurved_guide_18_beforeChopper_d;
MCNUM mcccurved_guide_18_beforeChopper_mleft;
MCNUM mcccurved_guide_18_beforeChopper_mright;
MCNUM mcccurved_guide_18_beforeChopper_mtop;
MCNUM mcccurved_guide_18_beforeChopper_mbottom;
MCNUM mcccurved_guide_18_beforeChopper_nhslit;
MCNUM mcccurved_guide_18_beforeChopper_G;
MCNUM mcccurved_guide_18_beforeChopper_aleft;
MCNUM mcccurved_guide_18_beforeChopper_aright;
MCNUM mcccurved_guide_18_beforeChopper_atop;
MCNUM mcccurved_guide_18_beforeChopper_abottom;
MCNUM mcccurved_guide_18_beforeChopper_wavy;
MCNUM mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM mcccurved_guide_18_beforeChopper_chamfers;
MCNUM mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM mcccurved_guide_18_beforeChopper_nelements;
MCNUM mcccurved_guide_18_beforeChopper_nu;
MCNUM mcccurved_guide_18_beforeChopper_phase;
char mcccurved_guide_18_beforeChopper_reflect[16384];

/* Definition parameters for component 'L_monBeforeFOC2' [45]. */
#define mccL_monBeforeFOC2_nL 100
/* Setting parameters for component 'L_monBeforeFOC2' [45]. */
char mccL_monBeforeFOC2_filename[16384];
MCNUM mccL_monBeforeFOC2_xmin;
MCNUM mccL_monBeforeFOC2_xmax;
MCNUM mccL_monBeforeFOC2_ymin;
MCNUM mccL_monBeforeFOC2_ymax;
MCNUM mccL_monBeforeFOC2_xwidth;
MCNUM mccL_monBeforeFOC2_yheight;
MCNUM mccL_monBeforeFOC2_Lmin;
MCNUM mccL_monBeforeFOC2_Lmax;
MCNUM mccL_monBeforeFOC2_restore_neutron;

/* Definition parameters for component 'ToFBeforeFOC2' [46]. */
#define mccToFBeforeFOC2_nt 1000
/* Setting parameters for component 'ToFBeforeFOC2' [46]. */
char mccToFBeforeFOC2_filename[16384];
MCNUM mccToFBeforeFOC2_xmin;
MCNUM mccToFBeforeFOC2_xmax;
MCNUM mccToFBeforeFOC2_ymin;
MCNUM mccToFBeforeFOC2_ymax;
MCNUM mccToFBeforeFOC2_xwidth;
MCNUM mccToFBeforeFOC2_yheight;
MCNUM mccToFBeforeFOC2_tmin;
MCNUM mccToFBeforeFOC2_tmax;
MCNUM mccToFBeforeFOC2_dt;
MCNUM mccToFBeforeFOC2_restore_neutron;

/* Definition parameters for component 'PSD_beforeFOC2' [47]. */
#define mccPSD_beforeFOC2_nx 100
#define mccPSD_beforeFOC2_ny 100
/* Setting parameters for component 'PSD_beforeFOC2' [47]. */
char mccPSD_beforeFOC2_filename[16384];
MCNUM mccPSD_beforeFOC2_xmin;
MCNUM mccPSD_beforeFOC2_xmax;
MCNUM mccPSD_beforeFOC2_ymin;
MCNUM mccPSD_beforeFOC2_ymax;
MCNUM mccPSD_beforeFOC2_xwidth;
MCNUM mccPSD_beforeFOC2_yheight;
MCNUM mccPSD_beforeFOC2_restore_neutron;

/* Setting parameters for component 'FOC2' [48]. */
MCNUM mccFOC2_theta_0;
MCNUM mccFOC2_radius;
MCNUM mccFOC2_yheight;
MCNUM mccFOC2_nu;
MCNUM mccFOC2_nslit;
MCNUM mccFOC2_jitter;
MCNUM mccFOC2_delay;
MCNUM mccFOC2_isfirst;
MCNUM mccFOC2_n_pulse;
MCNUM mccFOC2_abs_out;
MCNUM mccFOC2_phase;
MCNUM mccFOC2_xwidth;
MCNUM mccFOC2_verbose;

/* Definition parameters for component 'PSD_afterFOC2' [49]. */
#define mccPSD_afterFOC2_nx 100
#define mccPSD_afterFOC2_ny 100
/* Setting parameters for component 'PSD_afterFOC2' [49]. */
char mccPSD_afterFOC2_filename[16384];
MCNUM mccPSD_afterFOC2_xmin;
MCNUM mccPSD_afterFOC2_xmax;
MCNUM mccPSD_afterFOC2_ymin;
MCNUM mccPSD_afterFOC2_ymax;
MCNUM mccPSD_afterFOC2_xwidth;
MCNUM mccPSD_afterFOC2_yheight;
MCNUM mccPSD_afterFOC2_restore_neutron;

/* Definition parameters for component 'ToFAfterFOC2' [50]. */
#define mccToFAfterFOC2_nt 1000
/* Setting parameters for component 'ToFAfterFOC2' [50]. */
char mccToFAfterFOC2_filename[16384];
MCNUM mccToFAfterFOC2_xmin;
MCNUM mccToFAfterFOC2_xmax;
MCNUM mccToFAfterFOC2_ymin;
MCNUM mccToFAfterFOC2_ymax;
MCNUM mccToFAfterFOC2_xwidth;
MCNUM mccToFAfterFOC2_yheight;
MCNUM mccToFAfterFOC2_tmin;
MCNUM mccToFAfterFOC2_tmax;
MCNUM mccToFAfterFOC2_dt;
MCNUM mccToFAfterFOC2_restore_neutron;

/* Definition parameters for component 'L_monAfterFOC2' [51]. */
#define mccL_monAfterFOC2_nL 100
/* Setting parameters for component 'L_monAfterFOC2' [51]. */
char mccL_monAfterFOC2_filename[16384];
MCNUM mccL_monAfterFOC2_xmin;
MCNUM mccL_monAfterFOC2_xmax;
MCNUM mccL_monAfterFOC2_ymin;
MCNUM mccL_monAfterFOC2_ymax;
MCNUM mccL_monAfterFOC2_xwidth;
MCNUM mccL_monAfterFOC2_yheight;
MCNUM mccL_monAfterFOC2_Lmin;
MCNUM mccL_monAfterFOC2_Lmax;
MCNUM mccL_monAfterFOC2_restore_neutron;

/* Setting parameters for component 'curved_guide_18_afterChopper' [52]. */
MCNUM mcccurved_guide_18_afterChopper_w1;
MCNUM mcccurved_guide_18_afterChopper_h1;
MCNUM mcccurved_guide_18_afterChopper_w2;
MCNUM mcccurved_guide_18_afterChopper_h2;
MCNUM mcccurved_guide_18_afterChopper_l;
MCNUM mcccurved_guide_18_afterChopper_R0;
MCNUM mcccurved_guide_18_afterChopper_Qc;
MCNUM mcccurved_guide_18_afterChopper_alpha;
MCNUM mcccurved_guide_18_afterChopper_m;
MCNUM mcccurved_guide_18_afterChopper_W;
MCNUM mcccurved_guide_18_afterChopper_nslit;
MCNUM mcccurved_guide_18_afterChopper_d;
MCNUM mcccurved_guide_18_afterChopper_mleft;
MCNUM mcccurved_guide_18_afterChopper_mright;
MCNUM mcccurved_guide_18_afterChopper_mtop;
MCNUM mcccurved_guide_18_afterChopper_mbottom;
MCNUM mcccurved_guide_18_afterChopper_nhslit;
MCNUM mcccurved_guide_18_afterChopper_G;
MCNUM mcccurved_guide_18_afterChopper_aleft;
MCNUM mcccurved_guide_18_afterChopper_aright;
MCNUM mcccurved_guide_18_afterChopper_atop;
MCNUM mcccurved_guide_18_afterChopper_abottom;
MCNUM mcccurved_guide_18_afterChopper_wavy;
MCNUM mcccurved_guide_18_afterChopper_wavy_z;
MCNUM mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM mcccurved_guide_18_afterChopper_chamfers;
MCNUM mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM mcccurved_guide_18_afterChopper_nelements;
MCNUM mcccurved_guide_18_afterChopper_nu;
MCNUM mcccurved_guide_18_afterChopper_phase;
char mcccurved_guide_18_afterChopper_reflect[16384];

/* Setting parameters for component 'curved_guide_19_0' [53]. */
MCNUM mcccurved_guide_19_0_w1;
MCNUM mcccurved_guide_19_0_h1;
MCNUM mcccurved_guide_19_0_w2;
MCNUM mcccurved_guide_19_0_h2;
MCNUM mcccurved_guide_19_0_l;
MCNUM mcccurved_guide_19_0_R0;
MCNUM mcccurved_guide_19_0_Qc;
MCNUM mcccurved_guide_19_0_alpha;
MCNUM mcccurved_guide_19_0_m;
MCNUM mcccurved_guide_19_0_W;
MCNUM mcccurved_guide_19_0_nslit;
MCNUM mcccurved_guide_19_0_d;
MCNUM mcccurved_guide_19_0_mleft;
MCNUM mcccurved_guide_19_0_mright;
MCNUM mcccurved_guide_19_0_mtop;
MCNUM mcccurved_guide_19_0_mbottom;
MCNUM mcccurved_guide_19_0_nhslit;
MCNUM mcccurved_guide_19_0_G;
MCNUM mcccurved_guide_19_0_aleft;
MCNUM mcccurved_guide_19_0_aright;
MCNUM mcccurved_guide_19_0_atop;
MCNUM mcccurved_guide_19_0_abottom;
MCNUM mcccurved_guide_19_0_wavy;
MCNUM mcccurved_guide_19_0_wavy_z;
MCNUM mcccurved_guide_19_0_wavy_tb;
MCNUM mcccurved_guide_19_0_wavy_lr;
MCNUM mcccurved_guide_19_0_chamfers;
MCNUM mcccurved_guide_19_0_chamfers_z;
MCNUM mcccurved_guide_19_0_chamfers_lr;
MCNUM mcccurved_guide_19_0_chamfers_tb;
MCNUM mcccurved_guide_19_0_nelements;
MCNUM mcccurved_guide_19_0_nu;
MCNUM mcccurved_guide_19_0_phase;
char mcccurved_guide_19_0_reflect[16384];

/* Setting parameters for component 'curved_guide_20_0' [54]. */
MCNUM mcccurved_guide_20_0_w1;
MCNUM mcccurved_guide_20_0_h1;
MCNUM mcccurved_guide_20_0_w2;
MCNUM mcccurved_guide_20_0_h2;
MCNUM mcccurved_guide_20_0_l;
MCNUM mcccurved_guide_20_0_R0;
MCNUM mcccurved_guide_20_0_Qc;
MCNUM mcccurved_guide_20_0_alpha;
MCNUM mcccurved_guide_20_0_m;
MCNUM mcccurved_guide_20_0_W;
MCNUM mcccurved_guide_20_0_nslit;
MCNUM mcccurved_guide_20_0_d;
MCNUM mcccurved_guide_20_0_mleft;
MCNUM mcccurved_guide_20_0_mright;
MCNUM mcccurved_guide_20_0_mtop;
MCNUM mcccurved_guide_20_0_mbottom;
MCNUM mcccurved_guide_20_0_nhslit;
MCNUM mcccurved_guide_20_0_G;
MCNUM mcccurved_guide_20_0_aleft;
MCNUM mcccurved_guide_20_0_aright;
MCNUM mcccurved_guide_20_0_atop;
MCNUM mcccurved_guide_20_0_abottom;
MCNUM mcccurved_guide_20_0_wavy;
MCNUM mcccurved_guide_20_0_wavy_z;
MCNUM mcccurved_guide_20_0_wavy_tb;
MCNUM mcccurved_guide_20_0_wavy_lr;
MCNUM mcccurved_guide_20_0_chamfers;
MCNUM mcccurved_guide_20_0_chamfers_z;
MCNUM mcccurved_guide_20_0_chamfers_lr;
MCNUM mcccurved_guide_20_0_chamfers_tb;
MCNUM mcccurved_guide_20_0_nelements;
MCNUM mcccurved_guide_20_0_nu;
MCNUM mcccurved_guide_20_0_phase;
char mcccurved_guide_20_0_reflect[16384];

/* Setting parameters for component 'curved_guide_21_0' [55]. */
MCNUM mcccurved_guide_21_0_w1;
MCNUM mcccurved_guide_21_0_h1;
MCNUM mcccurved_guide_21_0_w2;
MCNUM mcccurved_guide_21_0_h2;
MCNUM mcccurved_guide_21_0_l;
MCNUM mcccurved_guide_21_0_R0;
MCNUM mcccurved_guide_21_0_Qc;
MCNUM mcccurved_guide_21_0_alpha;
MCNUM mcccurved_guide_21_0_m;
MCNUM mcccurved_guide_21_0_W;
MCNUM mcccurved_guide_21_0_nslit;
MCNUM mcccurved_guide_21_0_d;
MCNUM mcccurved_guide_21_0_mleft;
MCNUM mcccurved_guide_21_0_mright;
MCNUM mcccurved_guide_21_0_mtop;
MCNUM mcccurved_guide_21_0_mbottom;
MCNUM mcccurved_guide_21_0_nhslit;
MCNUM mcccurved_guide_21_0_G;
MCNUM mcccurved_guide_21_0_aleft;
MCNUM mcccurved_guide_21_0_aright;
MCNUM mcccurved_guide_21_0_atop;
MCNUM mcccurved_guide_21_0_abottom;
MCNUM mcccurved_guide_21_0_wavy;
MCNUM mcccurved_guide_21_0_wavy_z;
MCNUM mcccurved_guide_21_0_wavy_tb;
MCNUM mcccurved_guide_21_0_wavy_lr;
MCNUM mcccurved_guide_21_0_chamfers;
MCNUM mcccurved_guide_21_0_chamfers_z;
MCNUM mcccurved_guide_21_0_chamfers_lr;
MCNUM mcccurved_guide_21_0_chamfers_tb;
MCNUM mcccurved_guide_21_0_nelements;
MCNUM mcccurved_guide_21_0_nu;
MCNUM mcccurved_guide_21_0_phase;
char mcccurved_guide_21_0_reflect[16384];

/* Setting parameters for component 'curved_guide_22_0' [56]. */
MCNUM mcccurved_guide_22_0_w1;
MCNUM mcccurved_guide_22_0_h1;
MCNUM mcccurved_guide_22_0_w2;
MCNUM mcccurved_guide_22_0_h2;
MCNUM mcccurved_guide_22_0_l;
MCNUM mcccurved_guide_22_0_R0;
MCNUM mcccurved_guide_22_0_Qc;
MCNUM mcccurved_guide_22_0_alpha;
MCNUM mcccurved_guide_22_0_m;
MCNUM mcccurved_guide_22_0_W;
MCNUM mcccurved_guide_22_0_nslit;
MCNUM mcccurved_guide_22_0_d;
MCNUM mcccurved_guide_22_0_mleft;
MCNUM mcccurved_guide_22_0_mright;
MCNUM mcccurved_guide_22_0_mtop;
MCNUM mcccurved_guide_22_0_mbottom;
MCNUM mcccurved_guide_22_0_nhslit;
MCNUM mcccurved_guide_22_0_G;
MCNUM mcccurved_guide_22_0_aleft;
MCNUM mcccurved_guide_22_0_aright;
MCNUM mcccurved_guide_22_0_atop;
MCNUM mcccurved_guide_22_0_abottom;
MCNUM mcccurved_guide_22_0_wavy;
MCNUM mcccurved_guide_22_0_wavy_z;
MCNUM mcccurved_guide_22_0_wavy_tb;
MCNUM mcccurved_guide_22_0_wavy_lr;
MCNUM mcccurved_guide_22_0_chamfers;
MCNUM mcccurved_guide_22_0_chamfers_z;
MCNUM mcccurved_guide_22_0_chamfers_lr;
MCNUM mcccurved_guide_22_0_chamfers_tb;
MCNUM mcccurved_guide_22_0_nelements;
MCNUM mcccurved_guide_22_0_nu;
MCNUM mcccurved_guide_22_0_phase;
char mcccurved_guide_22_0_reflect[16384];

/* Setting parameters for component 'curved_guide_23_0' [57]. */
MCNUM mcccurved_guide_23_0_w1;
MCNUM mcccurved_guide_23_0_h1;
MCNUM mcccurved_guide_23_0_w2;
MCNUM mcccurved_guide_23_0_h2;
MCNUM mcccurved_guide_23_0_l;
MCNUM mcccurved_guide_23_0_R0;
MCNUM mcccurved_guide_23_0_Qc;
MCNUM mcccurved_guide_23_0_alpha;
MCNUM mcccurved_guide_23_0_m;
MCNUM mcccurved_guide_23_0_W;
MCNUM mcccurved_guide_23_0_nslit;
MCNUM mcccurved_guide_23_0_d;
MCNUM mcccurved_guide_23_0_mleft;
MCNUM mcccurved_guide_23_0_mright;
MCNUM mcccurved_guide_23_0_mtop;
MCNUM mcccurved_guide_23_0_mbottom;
MCNUM mcccurved_guide_23_0_nhslit;
MCNUM mcccurved_guide_23_0_G;
MCNUM mcccurved_guide_23_0_aleft;
MCNUM mcccurved_guide_23_0_aright;
MCNUM mcccurved_guide_23_0_atop;
MCNUM mcccurved_guide_23_0_abottom;
MCNUM mcccurved_guide_23_0_wavy;
MCNUM mcccurved_guide_23_0_wavy_z;
MCNUM mcccurved_guide_23_0_wavy_tb;
MCNUM mcccurved_guide_23_0_wavy_lr;
MCNUM mcccurved_guide_23_0_chamfers;
MCNUM mcccurved_guide_23_0_chamfers_z;
MCNUM mcccurved_guide_23_0_chamfers_lr;
MCNUM mcccurved_guide_23_0_chamfers_tb;
MCNUM mcccurved_guide_23_0_nelements;
MCNUM mcccurved_guide_23_0_nu;
MCNUM mcccurved_guide_23_0_phase;
char mcccurved_guide_23_0_reflect[16384];

/* Setting parameters for component 'curved_guide_24_0' [58]. */
MCNUM mcccurved_guide_24_0_w1;
MCNUM mcccurved_guide_24_0_h1;
MCNUM mcccurved_guide_24_0_w2;
MCNUM mcccurved_guide_24_0_h2;
MCNUM mcccurved_guide_24_0_l;
MCNUM mcccurved_guide_24_0_R0;
MCNUM mcccurved_guide_24_0_Qc;
MCNUM mcccurved_guide_24_0_alpha;
MCNUM mcccurved_guide_24_0_m;
MCNUM mcccurved_guide_24_0_W;
MCNUM mcccurved_guide_24_0_nslit;
MCNUM mcccurved_guide_24_0_d;
MCNUM mcccurved_guide_24_0_mleft;
MCNUM mcccurved_guide_24_0_mright;
MCNUM mcccurved_guide_24_0_mtop;
MCNUM mcccurved_guide_24_0_mbottom;
MCNUM mcccurved_guide_24_0_nhslit;
MCNUM mcccurved_guide_24_0_G;
MCNUM mcccurved_guide_24_0_aleft;
MCNUM mcccurved_guide_24_0_aright;
MCNUM mcccurved_guide_24_0_atop;
MCNUM mcccurved_guide_24_0_abottom;
MCNUM mcccurved_guide_24_0_wavy;
MCNUM mcccurved_guide_24_0_wavy_z;
MCNUM mcccurved_guide_24_0_wavy_tb;
MCNUM mcccurved_guide_24_0_wavy_lr;
MCNUM mcccurved_guide_24_0_chamfers;
MCNUM mcccurved_guide_24_0_chamfers_z;
MCNUM mcccurved_guide_24_0_chamfers_lr;
MCNUM mcccurved_guide_24_0_chamfers_tb;
MCNUM mcccurved_guide_24_0_nelements;
MCNUM mcccurved_guide_24_0_nu;
MCNUM mcccurved_guide_24_0_phase;
char mcccurved_guide_24_0_reflect[16384];

/* Setting parameters for component 'curved_guide_25_0' [59]. */
MCNUM mcccurved_guide_25_0_w1;
MCNUM mcccurved_guide_25_0_h1;
MCNUM mcccurved_guide_25_0_w2;
MCNUM mcccurved_guide_25_0_h2;
MCNUM mcccurved_guide_25_0_l;
MCNUM mcccurved_guide_25_0_R0;
MCNUM mcccurved_guide_25_0_Qc;
MCNUM mcccurved_guide_25_0_alpha;
MCNUM mcccurved_guide_25_0_m;
MCNUM mcccurved_guide_25_0_W;
MCNUM mcccurved_guide_25_0_nslit;
MCNUM mcccurved_guide_25_0_d;
MCNUM mcccurved_guide_25_0_mleft;
MCNUM mcccurved_guide_25_0_mright;
MCNUM mcccurved_guide_25_0_mtop;
MCNUM mcccurved_guide_25_0_mbottom;
MCNUM mcccurved_guide_25_0_nhslit;
MCNUM mcccurved_guide_25_0_G;
MCNUM mcccurved_guide_25_0_aleft;
MCNUM mcccurved_guide_25_0_aright;
MCNUM mcccurved_guide_25_0_atop;
MCNUM mcccurved_guide_25_0_abottom;
MCNUM mcccurved_guide_25_0_wavy;
MCNUM mcccurved_guide_25_0_wavy_z;
MCNUM mcccurved_guide_25_0_wavy_tb;
MCNUM mcccurved_guide_25_0_wavy_lr;
MCNUM mcccurved_guide_25_0_chamfers;
MCNUM mcccurved_guide_25_0_chamfers_z;
MCNUM mcccurved_guide_25_0_chamfers_lr;
MCNUM mcccurved_guide_25_0_chamfers_tb;
MCNUM mcccurved_guide_25_0_nelements;
MCNUM mcccurved_guide_25_0_nu;
MCNUM mcccurved_guide_25_0_phase;
char mcccurved_guide_25_0_reflect[16384];

/* Setting parameters for component 'curved_guide_26_0' [60]. */
MCNUM mcccurved_guide_26_0_w1;
MCNUM mcccurved_guide_26_0_h1;
MCNUM mcccurved_guide_26_0_w2;
MCNUM mcccurved_guide_26_0_h2;
MCNUM mcccurved_guide_26_0_l;
MCNUM mcccurved_guide_26_0_R0;
MCNUM mcccurved_guide_26_0_Qc;
MCNUM mcccurved_guide_26_0_alpha;
MCNUM mcccurved_guide_26_0_m;
MCNUM mcccurved_guide_26_0_W;
MCNUM mcccurved_guide_26_0_nslit;
MCNUM mcccurved_guide_26_0_d;
MCNUM mcccurved_guide_26_0_mleft;
MCNUM mcccurved_guide_26_0_mright;
MCNUM mcccurved_guide_26_0_mtop;
MCNUM mcccurved_guide_26_0_mbottom;
MCNUM mcccurved_guide_26_0_nhslit;
MCNUM mcccurved_guide_26_0_G;
MCNUM mcccurved_guide_26_0_aleft;
MCNUM mcccurved_guide_26_0_aright;
MCNUM mcccurved_guide_26_0_atop;
MCNUM mcccurved_guide_26_0_abottom;
MCNUM mcccurved_guide_26_0_wavy;
MCNUM mcccurved_guide_26_0_wavy_z;
MCNUM mcccurved_guide_26_0_wavy_tb;
MCNUM mcccurved_guide_26_0_wavy_lr;
MCNUM mcccurved_guide_26_0_chamfers;
MCNUM mcccurved_guide_26_0_chamfers_z;
MCNUM mcccurved_guide_26_0_chamfers_lr;
MCNUM mcccurved_guide_26_0_chamfers_tb;
MCNUM mcccurved_guide_26_0_nelements;
MCNUM mcccurved_guide_26_0_nu;
MCNUM mcccurved_guide_26_0_phase;
char mcccurved_guide_26_0_reflect[16384];

/* Setting parameters for component 'curved_guide_27_0' [61]. */
MCNUM mcccurved_guide_27_0_w1;
MCNUM mcccurved_guide_27_0_h1;
MCNUM mcccurved_guide_27_0_w2;
MCNUM mcccurved_guide_27_0_h2;
MCNUM mcccurved_guide_27_0_l;
MCNUM mcccurved_guide_27_0_R0;
MCNUM mcccurved_guide_27_0_Qc;
MCNUM mcccurved_guide_27_0_alpha;
MCNUM mcccurved_guide_27_0_m;
MCNUM mcccurved_guide_27_0_W;
MCNUM mcccurved_guide_27_0_nslit;
MCNUM mcccurved_guide_27_0_d;
MCNUM mcccurved_guide_27_0_mleft;
MCNUM mcccurved_guide_27_0_mright;
MCNUM mcccurved_guide_27_0_mtop;
MCNUM mcccurved_guide_27_0_mbottom;
MCNUM mcccurved_guide_27_0_nhslit;
MCNUM mcccurved_guide_27_0_G;
MCNUM mcccurved_guide_27_0_aleft;
MCNUM mcccurved_guide_27_0_aright;
MCNUM mcccurved_guide_27_0_atop;
MCNUM mcccurved_guide_27_0_abottom;
MCNUM mcccurved_guide_27_0_wavy;
MCNUM mcccurved_guide_27_0_wavy_z;
MCNUM mcccurved_guide_27_0_wavy_tb;
MCNUM mcccurved_guide_27_0_wavy_lr;
MCNUM mcccurved_guide_27_0_chamfers;
MCNUM mcccurved_guide_27_0_chamfers_z;
MCNUM mcccurved_guide_27_0_chamfers_lr;
MCNUM mcccurved_guide_27_0_chamfers_tb;
MCNUM mcccurved_guide_27_0_nelements;
MCNUM mcccurved_guide_27_0_nu;
MCNUM mcccurved_guide_27_0_phase;
char mcccurved_guide_27_0_reflect[16384];

/* Setting parameters for component 'curved_guide_28_0' [62]. */
MCNUM mcccurved_guide_28_0_w1;
MCNUM mcccurved_guide_28_0_h1;
MCNUM mcccurved_guide_28_0_w2;
MCNUM mcccurved_guide_28_0_h2;
MCNUM mcccurved_guide_28_0_l;
MCNUM mcccurved_guide_28_0_R0;
MCNUM mcccurved_guide_28_0_Qc;
MCNUM mcccurved_guide_28_0_alpha;
MCNUM mcccurved_guide_28_0_m;
MCNUM mcccurved_guide_28_0_W;
MCNUM mcccurved_guide_28_0_nslit;
MCNUM mcccurved_guide_28_0_d;
MCNUM mcccurved_guide_28_0_mleft;
MCNUM mcccurved_guide_28_0_mright;
MCNUM mcccurved_guide_28_0_mtop;
MCNUM mcccurved_guide_28_0_mbottom;
MCNUM mcccurved_guide_28_0_nhslit;
MCNUM mcccurved_guide_28_0_G;
MCNUM mcccurved_guide_28_0_aleft;
MCNUM mcccurved_guide_28_0_aright;
MCNUM mcccurved_guide_28_0_atop;
MCNUM mcccurved_guide_28_0_abottom;
MCNUM mcccurved_guide_28_0_wavy;
MCNUM mcccurved_guide_28_0_wavy_z;
MCNUM mcccurved_guide_28_0_wavy_tb;
MCNUM mcccurved_guide_28_0_wavy_lr;
MCNUM mcccurved_guide_28_0_chamfers;
MCNUM mcccurved_guide_28_0_chamfers_z;
MCNUM mcccurved_guide_28_0_chamfers_lr;
MCNUM mcccurved_guide_28_0_chamfers_tb;
MCNUM mcccurved_guide_28_0_nelements;
MCNUM mcccurved_guide_28_0_nu;
MCNUM mcccurved_guide_28_0_phase;
char mcccurved_guide_28_0_reflect[16384];

/* Setting parameters for component 'curved_guide_29_0' [63]. */
MCNUM mcccurved_guide_29_0_w1;
MCNUM mcccurved_guide_29_0_h1;
MCNUM mcccurved_guide_29_0_w2;
MCNUM mcccurved_guide_29_0_h2;
MCNUM mcccurved_guide_29_0_l;
MCNUM mcccurved_guide_29_0_R0;
MCNUM mcccurved_guide_29_0_Qc;
MCNUM mcccurved_guide_29_0_alpha;
MCNUM mcccurved_guide_29_0_m;
MCNUM mcccurved_guide_29_0_W;
MCNUM mcccurved_guide_29_0_nslit;
MCNUM mcccurved_guide_29_0_d;
MCNUM mcccurved_guide_29_0_mleft;
MCNUM mcccurved_guide_29_0_mright;
MCNUM mcccurved_guide_29_0_mtop;
MCNUM mcccurved_guide_29_0_mbottom;
MCNUM mcccurved_guide_29_0_nhslit;
MCNUM mcccurved_guide_29_0_G;
MCNUM mcccurved_guide_29_0_aleft;
MCNUM mcccurved_guide_29_0_aright;
MCNUM mcccurved_guide_29_0_atop;
MCNUM mcccurved_guide_29_0_abottom;
MCNUM mcccurved_guide_29_0_wavy;
MCNUM mcccurved_guide_29_0_wavy_z;
MCNUM mcccurved_guide_29_0_wavy_tb;
MCNUM mcccurved_guide_29_0_wavy_lr;
MCNUM mcccurved_guide_29_0_chamfers;
MCNUM mcccurved_guide_29_0_chamfers_z;
MCNUM mcccurved_guide_29_0_chamfers_lr;
MCNUM mcccurved_guide_29_0_chamfers_tb;
MCNUM mcccurved_guide_29_0_nelements;
MCNUM mcccurved_guide_29_0_nu;
MCNUM mcccurved_guide_29_0_phase;
char mcccurved_guide_29_0_reflect[16384];

/* Setting parameters for component 'curved_guide_30_0' [64]. */
MCNUM mcccurved_guide_30_0_w1;
MCNUM mcccurved_guide_30_0_h1;
MCNUM mcccurved_guide_30_0_w2;
MCNUM mcccurved_guide_30_0_h2;
MCNUM mcccurved_guide_30_0_l;
MCNUM mcccurved_guide_30_0_R0;
MCNUM mcccurved_guide_30_0_Qc;
MCNUM mcccurved_guide_30_0_alpha;
MCNUM mcccurved_guide_30_0_m;
MCNUM mcccurved_guide_30_0_W;
MCNUM mcccurved_guide_30_0_nslit;
MCNUM mcccurved_guide_30_0_d;
MCNUM mcccurved_guide_30_0_mleft;
MCNUM mcccurved_guide_30_0_mright;
MCNUM mcccurved_guide_30_0_mtop;
MCNUM mcccurved_guide_30_0_mbottom;
MCNUM mcccurved_guide_30_0_nhslit;
MCNUM mcccurved_guide_30_0_G;
MCNUM mcccurved_guide_30_0_aleft;
MCNUM mcccurved_guide_30_0_aright;
MCNUM mcccurved_guide_30_0_atop;
MCNUM mcccurved_guide_30_0_abottom;
MCNUM mcccurved_guide_30_0_wavy;
MCNUM mcccurved_guide_30_0_wavy_z;
MCNUM mcccurved_guide_30_0_wavy_tb;
MCNUM mcccurved_guide_30_0_wavy_lr;
MCNUM mcccurved_guide_30_0_chamfers;
MCNUM mcccurved_guide_30_0_chamfers_z;
MCNUM mcccurved_guide_30_0_chamfers_lr;
MCNUM mcccurved_guide_30_0_chamfers_tb;
MCNUM mcccurved_guide_30_0_nelements;
MCNUM mcccurved_guide_30_0_nu;
MCNUM mcccurved_guide_30_0_phase;
char mcccurved_guide_30_0_reflect[16384];

/* Setting parameters for component 'curved_guide_31_0' [65]. */
MCNUM mcccurved_guide_31_0_w1;
MCNUM mcccurved_guide_31_0_h1;
MCNUM mcccurved_guide_31_0_w2;
MCNUM mcccurved_guide_31_0_h2;
MCNUM mcccurved_guide_31_0_l;
MCNUM mcccurved_guide_31_0_R0;
MCNUM mcccurved_guide_31_0_Qc;
MCNUM mcccurved_guide_31_0_alpha;
MCNUM mcccurved_guide_31_0_m;
MCNUM mcccurved_guide_31_0_W;
MCNUM mcccurved_guide_31_0_nslit;
MCNUM mcccurved_guide_31_0_d;
MCNUM mcccurved_guide_31_0_mleft;
MCNUM mcccurved_guide_31_0_mright;
MCNUM mcccurved_guide_31_0_mtop;
MCNUM mcccurved_guide_31_0_mbottom;
MCNUM mcccurved_guide_31_0_nhslit;
MCNUM mcccurved_guide_31_0_G;
MCNUM mcccurved_guide_31_0_aleft;
MCNUM mcccurved_guide_31_0_aright;
MCNUM mcccurved_guide_31_0_atop;
MCNUM mcccurved_guide_31_0_abottom;
MCNUM mcccurved_guide_31_0_wavy;
MCNUM mcccurved_guide_31_0_wavy_z;
MCNUM mcccurved_guide_31_0_wavy_tb;
MCNUM mcccurved_guide_31_0_wavy_lr;
MCNUM mcccurved_guide_31_0_chamfers;
MCNUM mcccurved_guide_31_0_chamfers_z;
MCNUM mcccurved_guide_31_0_chamfers_lr;
MCNUM mcccurved_guide_31_0_chamfers_tb;
MCNUM mcccurved_guide_31_0_nelements;
MCNUM mcccurved_guide_31_0_nu;
MCNUM mcccurved_guide_31_0_phase;
char mcccurved_guide_31_0_reflect[16384];

/* Setting parameters for component 'curved_guide_32_0' [66]. */
MCNUM mcccurved_guide_32_0_w1;
MCNUM mcccurved_guide_32_0_h1;
MCNUM mcccurved_guide_32_0_w2;
MCNUM mcccurved_guide_32_0_h2;
MCNUM mcccurved_guide_32_0_l;
MCNUM mcccurved_guide_32_0_R0;
MCNUM mcccurved_guide_32_0_Qc;
MCNUM mcccurved_guide_32_0_alpha;
MCNUM mcccurved_guide_32_0_m;
MCNUM mcccurved_guide_32_0_W;
MCNUM mcccurved_guide_32_0_nslit;
MCNUM mcccurved_guide_32_0_d;
MCNUM mcccurved_guide_32_0_mleft;
MCNUM mcccurved_guide_32_0_mright;
MCNUM mcccurved_guide_32_0_mtop;
MCNUM mcccurved_guide_32_0_mbottom;
MCNUM mcccurved_guide_32_0_nhslit;
MCNUM mcccurved_guide_32_0_G;
MCNUM mcccurved_guide_32_0_aleft;
MCNUM mcccurved_guide_32_0_aright;
MCNUM mcccurved_guide_32_0_atop;
MCNUM mcccurved_guide_32_0_abottom;
MCNUM mcccurved_guide_32_0_wavy;
MCNUM mcccurved_guide_32_0_wavy_z;
MCNUM mcccurved_guide_32_0_wavy_tb;
MCNUM mcccurved_guide_32_0_wavy_lr;
MCNUM mcccurved_guide_32_0_chamfers;
MCNUM mcccurved_guide_32_0_chamfers_z;
MCNUM mcccurved_guide_32_0_chamfers_lr;
MCNUM mcccurved_guide_32_0_chamfers_tb;
MCNUM mcccurved_guide_32_0_nelements;
MCNUM mcccurved_guide_32_0_nu;
MCNUM mcccurved_guide_32_0_phase;
char mcccurved_guide_32_0_reflect[16384];

/* Setting parameters for component 'curved_guide_33_0' [67]. */
MCNUM mcccurved_guide_33_0_w1;
MCNUM mcccurved_guide_33_0_h1;
MCNUM mcccurved_guide_33_0_w2;
MCNUM mcccurved_guide_33_0_h2;
MCNUM mcccurved_guide_33_0_l;
MCNUM mcccurved_guide_33_0_R0;
MCNUM mcccurved_guide_33_0_Qc;
MCNUM mcccurved_guide_33_0_alpha;
MCNUM mcccurved_guide_33_0_m;
MCNUM mcccurved_guide_33_0_W;
MCNUM mcccurved_guide_33_0_nslit;
MCNUM mcccurved_guide_33_0_d;
MCNUM mcccurved_guide_33_0_mleft;
MCNUM mcccurved_guide_33_0_mright;
MCNUM mcccurved_guide_33_0_mtop;
MCNUM mcccurved_guide_33_0_mbottom;
MCNUM mcccurved_guide_33_0_nhslit;
MCNUM mcccurved_guide_33_0_G;
MCNUM mcccurved_guide_33_0_aleft;
MCNUM mcccurved_guide_33_0_aright;
MCNUM mcccurved_guide_33_0_atop;
MCNUM mcccurved_guide_33_0_abottom;
MCNUM mcccurved_guide_33_0_wavy;
MCNUM mcccurved_guide_33_0_wavy_z;
MCNUM mcccurved_guide_33_0_wavy_tb;
MCNUM mcccurved_guide_33_0_wavy_lr;
MCNUM mcccurved_guide_33_0_chamfers;
MCNUM mcccurved_guide_33_0_chamfers_z;
MCNUM mcccurved_guide_33_0_chamfers_lr;
MCNUM mcccurved_guide_33_0_chamfers_tb;
MCNUM mcccurved_guide_33_0_nelements;
MCNUM mcccurved_guide_33_0_nu;
MCNUM mcccurved_guide_33_0_phase;
char mcccurved_guide_33_0_reflect[16384];

/* Setting parameters for component 'curved_guide_34_0' [68]. */
MCNUM mcccurved_guide_34_0_w1;
MCNUM mcccurved_guide_34_0_h1;
MCNUM mcccurved_guide_34_0_w2;
MCNUM mcccurved_guide_34_0_h2;
MCNUM mcccurved_guide_34_0_l;
MCNUM mcccurved_guide_34_0_R0;
MCNUM mcccurved_guide_34_0_Qc;
MCNUM mcccurved_guide_34_0_alpha;
MCNUM mcccurved_guide_34_0_m;
MCNUM mcccurved_guide_34_0_W;
MCNUM mcccurved_guide_34_0_nslit;
MCNUM mcccurved_guide_34_0_d;
MCNUM mcccurved_guide_34_0_mleft;
MCNUM mcccurved_guide_34_0_mright;
MCNUM mcccurved_guide_34_0_mtop;
MCNUM mcccurved_guide_34_0_mbottom;
MCNUM mcccurved_guide_34_0_nhslit;
MCNUM mcccurved_guide_34_0_G;
MCNUM mcccurved_guide_34_0_aleft;
MCNUM mcccurved_guide_34_0_aright;
MCNUM mcccurved_guide_34_0_atop;
MCNUM mcccurved_guide_34_0_abottom;
MCNUM mcccurved_guide_34_0_wavy;
MCNUM mcccurved_guide_34_0_wavy_z;
MCNUM mcccurved_guide_34_0_wavy_tb;
MCNUM mcccurved_guide_34_0_wavy_lr;
MCNUM mcccurved_guide_34_0_chamfers;
MCNUM mcccurved_guide_34_0_chamfers_z;
MCNUM mcccurved_guide_34_0_chamfers_lr;
MCNUM mcccurved_guide_34_0_chamfers_tb;
MCNUM mcccurved_guide_34_0_nelements;
MCNUM mcccurved_guide_34_0_nu;
MCNUM mcccurved_guide_34_0_phase;
char mcccurved_guide_34_0_reflect[16384];

/* Setting parameters for component 'curved_guide_35_0' [69]. */
MCNUM mcccurved_guide_35_0_w1;
MCNUM mcccurved_guide_35_0_h1;
MCNUM mcccurved_guide_35_0_w2;
MCNUM mcccurved_guide_35_0_h2;
MCNUM mcccurved_guide_35_0_l;
MCNUM mcccurved_guide_35_0_R0;
MCNUM mcccurved_guide_35_0_Qc;
MCNUM mcccurved_guide_35_0_alpha;
MCNUM mcccurved_guide_35_0_m;
MCNUM mcccurved_guide_35_0_W;
MCNUM mcccurved_guide_35_0_nslit;
MCNUM mcccurved_guide_35_0_d;
MCNUM mcccurved_guide_35_0_mleft;
MCNUM mcccurved_guide_35_0_mright;
MCNUM mcccurved_guide_35_0_mtop;
MCNUM mcccurved_guide_35_0_mbottom;
MCNUM mcccurved_guide_35_0_nhslit;
MCNUM mcccurved_guide_35_0_G;
MCNUM mcccurved_guide_35_0_aleft;
MCNUM mcccurved_guide_35_0_aright;
MCNUM mcccurved_guide_35_0_atop;
MCNUM mcccurved_guide_35_0_abottom;
MCNUM mcccurved_guide_35_0_wavy;
MCNUM mcccurved_guide_35_0_wavy_z;
MCNUM mcccurved_guide_35_0_wavy_tb;
MCNUM mcccurved_guide_35_0_wavy_lr;
MCNUM mcccurved_guide_35_0_chamfers;
MCNUM mcccurved_guide_35_0_chamfers_z;
MCNUM mcccurved_guide_35_0_chamfers_lr;
MCNUM mcccurved_guide_35_0_chamfers_tb;
MCNUM mcccurved_guide_35_0_nelements;
MCNUM mcccurved_guide_35_0_nu;
MCNUM mcccurved_guide_35_0_phase;
char mcccurved_guide_35_0_reflect[16384];

/* Setting parameters for component 'curved_guide_36_0' [70]. */
MCNUM mcccurved_guide_36_0_w1;
MCNUM mcccurved_guide_36_0_h1;
MCNUM mcccurved_guide_36_0_w2;
MCNUM mcccurved_guide_36_0_h2;
MCNUM mcccurved_guide_36_0_l;
MCNUM mcccurved_guide_36_0_R0;
MCNUM mcccurved_guide_36_0_Qc;
MCNUM mcccurved_guide_36_0_alpha;
MCNUM mcccurved_guide_36_0_m;
MCNUM mcccurved_guide_36_0_W;
MCNUM mcccurved_guide_36_0_nslit;
MCNUM mcccurved_guide_36_0_d;
MCNUM mcccurved_guide_36_0_mleft;
MCNUM mcccurved_guide_36_0_mright;
MCNUM mcccurved_guide_36_0_mtop;
MCNUM mcccurved_guide_36_0_mbottom;
MCNUM mcccurved_guide_36_0_nhslit;
MCNUM mcccurved_guide_36_0_G;
MCNUM mcccurved_guide_36_0_aleft;
MCNUM mcccurved_guide_36_0_aright;
MCNUM mcccurved_guide_36_0_atop;
MCNUM mcccurved_guide_36_0_abottom;
MCNUM mcccurved_guide_36_0_wavy;
MCNUM mcccurved_guide_36_0_wavy_z;
MCNUM mcccurved_guide_36_0_wavy_tb;
MCNUM mcccurved_guide_36_0_wavy_lr;
MCNUM mcccurved_guide_36_0_chamfers;
MCNUM mcccurved_guide_36_0_chamfers_z;
MCNUM mcccurved_guide_36_0_chamfers_lr;
MCNUM mcccurved_guide_36_0_chamfers_tb;
MCNUM mcccurved_guide_36_0_nelements;
MCNUM mcccurved_guide_36_0_nu;
MCNUM mcccurved_guide_36_0_phase;
char mcccurved_guide_36_0_reflect[16384];

/* Definition parameters for component 'elliptical_guide_gravity3' [72]. */
#define mccelliptical_guide_gravity3_mvaluesright mValues3horizontalS
#define mccelliptical_guide_gravity3_mvaluesleft mValues3horizontalS
#define mccelliptical_guide_gravity3_mvaluestop mValues3verticalS
#define mccelliptical_guide_gravity3_mvaluesbottom mValues3verticalS
#define mccelliptical_guide_gravity3_seglength elementLength3S
/* Setting parameters for component 'elliptical_guide_gravity3' [72]. */
MCNUM mccelliptical_guide_gravity3_l;
MCNUM mccelliptical_guide_gravity3_xwidth;
MCNUM mccelliptical_guide_gravity3_yheight;
MCNUM mccelliptical_guide_gravity3_linxw;
MCNUM mccelliptical_guide_gravity3_loutxw;
MCNUM mccelliptical_guide_gravity3_linyh;
MCNUM mccelliptical_guide_gravity3_loutyh;
MCNUM mccelliptical_guide_gravity3_majorAxisxw;
MCNUM mccelliptical_guide_gravity3_minorAxisxw;
MCNUM mccelliptical_guide_gravity3_majorAxisyh;
MCNUM mccelliptical_guide_gravity3_minorAxisyh;
MCNUM mccelliptical_guide_gravity3_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity3_majorAxisoffsetyh;
char mccelliptical_guide_gravity3_dimensionsAt[16384];
char mccelliptical_guide_gravity3_option[16384];
MCNUM mccelliptical_guide_gravity3_R0;
MCNUM mccelliptical_guide_gravity3_Qc;
MCNUM mccelliptical_guide_gravity3_alpha;
MCNUM mccelliptical_guide_gravity3_m;
MCNUM mccelliptical_guide_gravity3_W;
MCNUM mccelliptical_guide_gravity3_alpharight;
MCNUM mccelliptical_guide_gravity3_mright;
MCNUM mccelliptical_guide_gravity3_alphaleft;
MCNUM mccelliptical_guide_gravity3_mleft;
MCNUM mccelliptical_guide_gravity3_alphatop;
MCNUM mccelliptical_guide_gravity3_mtop;
MCNUM mccelliptical_guide_gravity3_alphabottom;
MCNUM mccelliptical_guide_gravity3_mbottom;
char mccelliptical_guide_gravity3_verbose[16384];
MCNUM mccelliptical_guide_gravity3_enableGravity;
MCNUM mccelliptical_guide_gravity3_curvature;

/* Setting parameters for component 'straight_guide_2_1' [74]. */
MCNUM mccstraight_guide_2_1_w1;
MCNUM mccstraight_guide_2_1_h1;
MCNUM mccstraight_guide_2_1_w2;
MCNUM mccstraight_guide_2_1_h2;
MCNUM mccstraight_guide_2_1_l;
MCNUM mccstraight_guide_2_1_R0;
MCNUM mccstraight_guide_2_1_Qc;
MCNUM mccstraight_guide_2_1_alpha;
MCNUM mccstraight_guide_2_1_m;
MCNUM mccstraight_guide_2_1_W;
MCNUM mccstraight_guide_2_1_nslit;
MCNUM mccstraight_guide_2_1_d;
MCNUM mccstraight_guide_2_1_mleft;
MCNUM mccstraight_guide_2_1_mright;
MCNUM mccstraight_guide_2_1_mtop;
MCNUM mccstraight_guide_2_1_mbottom;
MCNUM mccstraight_guide_2_1_nhslit;
MCNUM mccstraight_guide_2_1_G;
MCNUM mccstraight_guide_2_1_aleft;
MCNUM mccstraight_guide_2_1_aright;
MCNUM mccstraight_guide_2_1_atop;
MCNUM mccstraight_guide_2_1_abottom;
MCNUM mccstraight_guide_2_1_wavy;
MCNUM mccstraight_guide_2_1_wavy_z;
MCNUM mccstraight_guide_2_1_wavy_tb;
MCNUM mccstraight_guide_2_1_wavy_lr;
MCNUM mccstraight_guide_2_1_chamfers;
MCNUM mccstraight_guide_2_1_chamfers_z;
MCNUM mccstraight_guide_2_1_chamfers_lr;
MCNUM mccstraight_guide_2_1_chamfers_tb;
MCNUM mccstraight_guide_2_1_nelements;
MCNUM mccstraight_guide_2_1_nu;
MCNUM mccstraight_guide_2_1_phase;
char mccstraight_guide_2_1_reflect[16384];

/* Definition parameters for component 'L_monBeforeBWC' [75]. */
#define mccL_monBeforeBWC_nL 100
/* Setting parameters for component 'L_monBeforeBWC' [75]. */
char mccL_monBeforeBWC_filename[16384];
MCNUM mccL_monBeforeBWC_xmin;
MCNUM mccL_monBeforeBWC_xmax;
MCNUM mccL_monBeforeBWC_ymin;
MCNUM mccL_monBeforeBWC_ymax;
MCNUM mccL_monBeforeBWC_xwidth;
MCNUM mccL_monBeforeBWC_yheight;
MCNUM mccL_monBeforeBWC_Lmin;
MCNUM mccL_monBeforeBWC_Lmax;
MCNUM mccL_monBeforeBWC_restore_neutron;

/* Definition parameters for component 'ToFBeforeBWC' [76]. */
#define mccToFBeforeBWC_nt 1000
/* Setting parameters for component 'ToFBeforeBWC' [76]. */
char mccToFBeforeBWC_filename[16384];
MCNUM mccToFBeforeBWC_xmin;
MCNUM mccToFBeforeBWC_xmax;
MCNUM mccToFBeforeBWC_ymin;
MCNUM mccToFBeforeBWC_ymax;
MCNUM mccToFBeforeBWC_xwidth;
MCNUM mccToFBeforeBWC_yheight;
MCNUM mccToFBeforeBWC_tmin;
MCNUM mccToFBeforeBWC_tmax;
MCNUM mccToFBeforeBWC_dt;
MCNUM mccToFBeforeBWC_restore_neutron;

/* Setting parameters for component 'BWC1' [77]. */
MCNUM mccBWC1_theta_0;
MCNUM mccBWC1_radius;
MCNUM mccBWC1_yheight;
MCNUM mccBWC1_nu;
MCNUM mccBWC1_nslit;
MCNUM mccBWC1_jitter;
MCNUM mccBWC1_delay;
MCNUM mccBWC1_isfirst;
MCNUM mccBWC1_n_pulse;
MCNUM mccBWC1_abs_out;
MCNUM mccBWC1_phase;
MCNUM mccBWC1_xwidth;
MCNUM mccBWC1_verbose;

/* Setting parameters for component 'BWC2' [78]. */
MCNUM mccBWC2_theta_0;
MCNUM mccBWC2_radius;
MCNUM mccBWC2_yheight;
MCNUM mccBWC2_nu;
MCNUM mccBWC2_nslit;
MCNUM mccBWC2_jitter;
MCNUM mccBWC2_delay;
MCNUM mccBWC2_isfirst;
MCNUM mccBWC2_n_pulse;
MCNUM mccBWC2_abs_out;
MCNUM mccBWC2_phase;
MCNUM mccBWC2_xwidth;
MCNUM mccBWC2_verbose;

/* Definition parameters for component 'ToFAfterBWC' [79]. */
#define mccToFAfterBWC_nt 1000
/* Setting parameters for component 'ToFAfterBWC' [79]. */
char mccToFAfterBWC_filename[16384];
MCNUM mccToFAfterBWC_xmin;
MCNUM mccToFAfterBWC_xmax;
MCNUM mccToFAfterBWC_ymin;
MCNUM mccToFAfterBWC_ymax;
MCNUM mccToFAfterBWC_xwidth;
MCNUM mccToFAfterBWC_yheight;
MCNUM mccToFAfterBWC_tmin;
MCNUM mccToFAfterBWC_tmax;
MCNUM mccToFAfterBWC_dt;
MCNUM mccToFAfterBWC_restore_neutron;

/* Definition parameters for component 'L_monAfterBWC' [80]. */
#define mccL_monAfterBWC_nL 100
/* Setting parameters for component 'L_monAfterBWC' [80]. */
char mccL_monAfterBWC_filename[16384];
MCNUM mccL_monAfterBWC_xmin;
MCNUM mccL_monAfterBWC_xmax;
MCNUM mccL_monAfterBWC_ymin;
MCNUM mccL_monAfterBWC_ymax;
MCNUM mccL_monAfterBWC_xwidth;
MCNUM mccL_monAfterBWC_yheight;
MCNUM mccL_monAfterBWC_Lmin;
MCNUM mccL_monAfterBWC_Lmax;
MCNUM mccL_monAfterBWC_restore_neutron;

/* Setting parameters for component 'straight_guide_2_2' [81]. */
MCNUM mccstraight_guide_2_2_w1;
MCNUM mccstraight_guide_2_2_h1;
MCNUM mccstraight_guide_2_2_w2;
MCNUM mccstraight_guide_2_2_h2;
MCNUM mccstraight_guide_2_2_l;
MCNUM mccstraight_guide_2_2_R0;
MCNUM mccstraight_guide_2_2_Qc;
MCNUM mccstraight_guide_2_2_alpha;
MCNUM mccstraight_guide_2_2_m;
MCNUM mccstraight_guide_2_2_W;
MCNUM mccstraight_guide_2_2_nslit;
MCNUM mccstraight_guide_2_2_d;
MCNUM mccstraight_guide_2_2_mleft;
MCNUM mccstraight_guide_2_2_mright;
MCNUM mccstraight_guide_2_2_mtop;
MCNUM mccstraight_guide_2_2_mbottom;
MCNUM mccstraight_guide_2_2_nhslit;
MCNUM mccstraight_guide_2_2_G;
MCNUM mccstraight_guide_2_2_aleft;
MCNUM mccstraight_guide_2_2_aright;
MCNUM mccstraight_guide_2_2_atop;
MCNUM mccstraight_guide_2_2_abottom;
MCNUM mccstraight_guide_2_2_wavy;
MCNUM mccstraight_guide_2_2_wavy_z;
MCNUM mccstraight_guide_2_2_wavy_tb;
MCNUM mccstraight_guide_2_2_wavy_lr;
MCNUM mccstraight_guide_2_2_chamfers;
MCNUM mccstraight_guide_2_2_chamfers_z;
MCNUM mccstraight_guide_2_2_chamfers_lr;
MCNUM mccstraight_guide_2_2_chamfers_tb;
MCNUM mccstraight_guide_2_2_nelements;
MCNUM mccstraight_guide_2_2_nu;
MCNUM mccstraight_guide_2_2_phase;
char mccstraight_guide_2_2_reflect[16384];

/* Definition parameters for component 'elliptical_guide_gravity1_1' [83]. */
#define mccelliptical_guide_gravity1_1_mvaluesright mValues1horizontal_part_1
#define mccelliptical_guide_gravity1_1_mvaluesleft mValues1horizontal_part_1
#define mccelliptical_guide_gravity1_1_mvaluestop mValues1vertical_part_1
#define mccelliptical_guide_gravity1_1_mvaluesbottom mValues1vertical_part_1
#define mccelliptical_guide_gravity1_1_seglength elementLength1_part_1
/* Setting parameters for component 'elliptical_guide_gravity1_1' [83]. */
MCNUM mccelliptical_guide_gravity1_1_l;
MCNUM mccelliptical_guide_gravity1_1_xwidth;
MCNUM mccelliptical_guide_gravity1_1_yheight;
MCNUM mccelliptical_guide_gravity1_1_linxw;
MCNUM mccelliptical_guide_gravity1_1_loutxw;
MCNUM mccelliptical_guide_gravity1_1_linyh;
MCNUM mccelliptical_guide_gravity1_1_loutyh;
MCNUM mccelliptical_guide_gravity1_1_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_1_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_1_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_1_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_1_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_1_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_1_dimensionsAt[16384];
char mccelliptical_guide_gravity1_1_option[16384];
MCNUM mccelliptical_guide_gravity1_1_R0;
MCNUM mccelliptical_guide_gravity1_1_Qc;
MCNUM mccelliptical_guide_gravity1_1_alpha;
MCNUM mccelliptical_guide_gravity1_1_m;
MCNUM mccelliptical_guide_gravity1_1_W;
MCNUM mccelliptical_guide_gravity1_1_alpharight;
MCNUM mccelliptical_guide_gravity1_1_mright;
MCNUM mccelliptical_guide_gravity1_1_alphaleft;
MCNUM mccelliptical_guide_gravity1_1_mleft;
MCNUM mccelliptical_guide_gravity1_1_alphatop;
MCNUM mccelliptical_guide_gravity1_1_mtop;
MCNUM mccelliptical_guide_gravity1_1_alphabottom;
MCNUM mccelliptical_guide_gravity1_1_mbottom;
char mccelliptical_guide_gravity1_1_verbose[16384];
MCNUM mccelliptical_guide_gravity1_1_enableGravity;
MCNUM mccelliptical_guide_gravity1_1_curvature;

/* Setting parameters for component 'DiwJaw3' [84]. */
MCNUM mccDiwJaw3_xmin;
MCNUM mccDiwJaw3_xmax;
MCNUM mccDiwJaw3_ymin;
MCNUM mccDiwJaw3_ymax;
MCNUM mccDiwJaw3_radius;
MCNUM mccDiwJaw3_xwidth;
MCNUM mccDiwJaw3_yheight;

/* Definition parameters for component 'elliptical_guide_gravity1_2' [85]. */
#define mccelliptical_guide_gravity1_2_mvaluesright mValues1horizontal_part_2
#define mccelliptical_guide_gravity1_2_mvaluesleft mValues1horizontal_part_2
#define mccelliptical_guide_gravity1_2_mvaluestop mValues1vertical_part_2
#define mccelliptical_guide_gravity1_2_mvaluesbottom mValues1vertical_part_2
#define mccelliptical_guide_gravity1_2_seglength elementLength1_part_2
/* Setting parameters for component 'elliptical_guide_gravity1_2' [85]. */
MCNUM mccelliptical_guide_gravity1_2_l;
MCNUM mccelliptical_guide_gravity1_2_xwidth;
MCNUM mccelliptical_guide_gravity1_2_yheight;
MCNUM mccelliptical_guide_gravity1_2_linxw;
MCNUM mccelliptical_guide_gravity1_2_loutxw;
MCNUM mccelliptical_guide_gravity1_2_linyh;
MCNUM mccelliptical_guide_gravity1_2_loutyh;
MCNUM mccelliptical_guide_gravity1_2_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_2_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_2_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_2_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_2_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_2_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_2_dimensionsAt[16384];
char mccelliptical_guide_gravity1_2_option[16384];
MCNUM mccelliptical_guide_gravity1_2_R0;
MCNUM mccelliptical_guide_gravity1_2_Qc;
MCNUM mccelliptical_guide_gravity1_2_alpha;
MCNUM mccelliptical_guide_gravity1_2_m;
MCNUM mccelliptical_guide_gravity1_2_W;
MCNUM mccelliptical_guide_gravity1_2_alpharight;
MCNUM mccelliptical_guide_gravity1_2_mright;
MCNUM mccelliptical_guide_gravity1_2_alphaleft;
MCNUM mccelliptical_guide_gravity1_2_mleft;
MCNUM mccelliptical_guide_gravity1_2_alphatop;
MCNUM mccelliptical_guide_gravity1_2_mtop;
MCNUM mccelliptical_guide_gravity1_2_alphabottom;
MCNUM mccelliptical_guide_gravity1_2_mbottom;
char mccelliptical_guide_gravity1_2_verbose[16384];
MCNUM mccelliptical_guide_gravity1_2_enableGravity;
MCNUM mccelliptical_guide_gravity1_2_curvature;

/* Setting parameters for component 'DiwJaw2' [86]. */
MCNUM mccDiwJaw2_xmin;
MCNUM mccDiwJaw2_xmax;
MCNUM mccDiwJaw2_ymin;
MCNUM mccDiwJaw2_ymax;
MCNUM mccDiwJaw2_radius;
MCNUM mccDiwJaw2_xwidth;
MCNUM mccDiwJaw2_yheight;

/* Definition parameters for component 'elliptical_guide_gravity1_3' [87]. */
#define mccelliptical_guide_gravity1_3_mvaluesright mValues1horizontal_part_3
#define mccelliptical_guide_gravity1_3_mvaluesleft mValues1horizontal_part_3
#define mccelliptical_guide_gravity1_3_mvaluestop mValues1vertical_part_3
#define mccelliptical_guide_gravity1_3_mvaluesbottom mValues1vertical_part_3
#define mccelliptical_guide_gravity1_3_seglength elementLength1_part_3
/* Setting parameters for component 'elliptical_guide_gravity1_3' [87]. */
MCNUM mccelliptical_guide_gravity1_3_l;
MCNUM mccelliptical_guide_gravity1_3_xwidth;
MCNUM mccelliptical_guide_gravity1_3_yheight;
MCNUM mccelliptical_guide_gravity1_3_linxw;
MCNUM mccelliptical_guide_gravity1_3_loutxw;
MCNUM mccelliptical_guide_gravity1_3_linyh;
MCNUM mccelliptical_guide_gravity1_3_loutyh;
MCNUM mccelliptical_guide_gravity1_3_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_3_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_3_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_3_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_3_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_3_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_3_dimensionsAt[16384];
char mccelliptical_guide_gravity1_3_option[16384];
MCNUM mccelliptical_guide_gravity1_3_R0;
MCNUM mccelliptical_guide_gravity1_3_Qc;
MCNUM mccelliptical_guide_gravity1_3_alpha;
MCNUM mccelliptical_guide_gravity1_3_m;
MCNUM mccelliptical_guide_gravity1_3_W;
MCNUM mccelliptical_guide_gravity1_3_alpharight;
MCNUM mccelliptical_guide_gravity1_3_mright;
MCNUM mccelliptical_guide_gravity1_3_alphaleft;
MCNUM mccelliptical_guide_gravity1_3_mleft;
MCNUM mccelliptical_guide_gravity1_3_alphatop;
MCNUM mccelliptical_guide_gravity1_3_mtop;
MCNUM mccelliptical_guide_gravity1_3_alphabottom;
MCNUM mccelliptical_guide_gravity1_3_mbottom;
char mccelliptical_guide_gravity1_3_verbose[16384];
MCNUM mccelliptical_guide_gravity1_3_enableGravity;
MCNUM mccelliptical_guide_gravity1_3_curvature;

/* Setting parameters for component 'DiwJaw1' [88]. */
MCNUM mccDiwJaw1_xmin;
MCNUM mccDiwJaw1_xmax;
MCNUM mccDiwJaw1_ymin;
MCNUM mccDiwJaw1_ymax;
MCNUM mccDiwJaw1_radius;
MCNUM mccDiwJaw1_xwidth;
MCNUM mccDiwJaw1_yheight;

/* Definition parameters for component 'elliptical_guide_gravity1_4' [89]. */
#define mccelliptical_guide_gravity1_4_mvaluesright mValues1horizontal_part_4
#define mccelliptical_guide_gravity1_4_mvaluesleft mValues1horizontal_part_4
#define mccelliptical_guide_gravity1_4_mvaluestop mValues1vertical_part_4
#define mccelliptical_guide_gravity1_4_mvaluesbottom mValues1vertical_part_4
#define mccelliptical_guide_gravity1_4_seglength elementLength1_part_4
/* Setting parameters for component 'elliptical_guide_gravity1_4' [89]. */
MCNUM mccelliptical_guide_gravity1_4_l;
MCNUM mccelliptical_guide_gravity1_4_xwidth;
MCNUM mccelliptical_guide_gravity1_4_yheight;
MCNUM mccelliptical_guide_gravity1_4_linxw;
MCNUM mccelliptical_guide_gravity1_4_loutxw;
MCNUM mccelliptical_guide_gravity1_4_linyh;
MCNUM mccelliptical_guide_gravity1_4_loutyh;
MCNUM mccelliptical_guide_gravity1_4_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_4_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_4_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_4_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_4_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_4_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_4_dimensionsAt[16384];
char mccelliptical_guide_gravity1_4_option[16384];
MCNUM mccelliptical_guide_gravity1_4_R0;
MCNUM mccelliptical_guide_gravity1_4_Qc;
MCNUM mccelliptical_guide_gravity1_4_alpha;
MCNUM mccelliptical_guide_gravity1_4_m;
MCNUM mccelliptical_guide_gravity1_4_W;
MCNUM mccelliptical_guide_gravity1_4_alpharight;
MCNUM mccelliptical_guide_gravity1_4_mright;
MCNUM mccelliptical_guide_gravity1_4_alphaleft;
MCNUM mccelliptical_guide_gravity1_4_mleft;
MCNUM mccelliptical_guide_gravity1_4_alphatop;
MCNUM mccelliptical_guide_gravity1_4_mtop;
MCNUM mccelliptical_guide_gravity1_4_alphabottom;
MCNUM mccelliptical_guide_gravity1_4_mbottom;
char mccelliptical_guide_gravity1_4_verbose[16384];
MCNUM mccelliptical_guide_gravity1_4_enableGravity;
MCNUM mccelliptical_guide_gravity1_4_curvature;

/* Setting parameters for component 'VirtualOutput' [91]. */
char mccVirtualOutput_filename[16384];
MCNUM mccVirtualOutput_bufsize;

/* Setting parameters for component 'DiwJaw0' [92]. */
MCNUM mccDiwJaw0_xmin;
MCNUM mccDiwJaw0_xmax;
MCNUM mccDiwJaw0_ymin;
MCNUM mccDiwJaw0_ymax;
MCNUM mccDiwJaw0_radius;
MCNUM mccDiwJaw0_xwidth;
MCNUM mccDiwJaw0_yheight;

/* Definition parameters for component 'Lmon_guide_end' [93]. */
#define mccLmon_guide_end_nL 300
/* Setting parameters for component 'Lmon_guide_end' [93]. */
char mccLmon_guide_end_filename[16384];
MCNUM mccLmon_guide_end_xmin;
MCNUM mccLmon_guide_end_xmax;
MCNUM mccLmon_guide_end_ymin;
MCNUM mccLmon_guide_end_ymax;
MCNUM mccLmon_guide_end_xwidth;
MCNUM mccLmon_guide_end_yheight;
MCNUM mccLmon_guide_end_Lmin;
MCNUM mccLmon_guide_end_Lmax;
MCNUM mccLmon_guide_end_restore_neutron;

/* Definition parameters for component 'Div2d_sample_B' [94]. */
#define mccDiv2d_sample_B_nh 200
#define mccDiv2d_sample_B_nv 200
/* Setting parameters for component 'Div2d_sample_B' [94]. */
char mccDiv2d_sample_B_filename[16384];
MCNUM mccDiv2d_sample_B_xmin;
MCNUM mccDiv2d_sample_B_xmax;
MCNUM mccDiv2d_sample_B_ymin;
MCNUM mccDiv2d_sample_B_ymax;
MCNUM mccDiv2d_sample_B_xwidth;
MCNUM mccDiv2d_sample_B_yheight;
MCNUM mccDiv2d_sample_B_maxdiv_h;
MCNUM mccDiv2d_sample_B_maxdiv_v;
MCNUM mccDiv2d_sample_B_restore_neutron;
MCNUM mccDiv2d_sample_B_nx;
MCNUM mccDiv2d_sample_B_ny;
MCNUM mccDiv2d_sample_B_nz;

/* Definition parameters for component 'Div2d_sample' [95]. */
#define mccDiv2d_sample_nh 200
#define mccDiv2d_sample_nv 200
/* Setting parameters for component 'Div2d_sample' [95]. */
char mccDiv2d_sample_filename[16384];
MCNUM mccDiv2d_sample_xmin;
MCNUM mccDiv2d_sample_xmax;
MCNUM mccDiv2d_sample_ymin;
MCNUM mccDiv2d_sample_ymax;
MCNUM mccDiv2d_sample_xwidth;
MCNUM mccDiv2d_sample_yheight;
MCNUM mccDiv2d_sample_maxdiv_h;
MCNUM mccDiv2d_sample_maxdiv_v;
MCNUM mccDiv2d_sample_restore_neutron;
MCNUM mccDiv2d_sample_nx;
MCNUM mccDiv2d_sample_ny;
MCNUM mccDiv2d_sample_nz;

/* Definition parameters for component 'PSD_sample' [96]. */
#define mccPSD_sample_nx 200
#define mccPSD_sample_ny 200
/* Setting parameters for component 'PSD_sample' [96]. */
char mccPSD_sample_filename[16384];
MCNUM mccPSD_sample_xmin;
MCNUM mccPSD_sample_xmax;
MCNUM mccPSD_sample_ymin;
MCNUM mccPSD_sample_ymax;
MCNUM mccPSD_sample_xwidth;
MCNUM mccPSD_sample_yheight;
MCNUM mccPSD_sample_restore_neutron;

/* Definition parameters for component 'HPSD_sample' [97]. */
#define mccHPSD_sample_nx 100
/* Setting parameters for component 'HPSD_sample' [97]. */
char mccHPSD_sample_filename[16384];
MCNUM mccHPSD_sample_xmin;
MCNUM mccHPSD_sample_xmax;
MCNUM mccHPSD_sample_ymin;
MCNUM mccHPSD_sample_ymax;
MCNUM mccHPSD_sample_xwidth;
MCNUM mccHPSD_sample_yheight;
MCNUM mccHPSD_sample_restore_neutron;

/* Definition parameters for component 'VPSD_sample' [98]. */
#define mccVPSD_sample_ny 100
#define mccVPSD_sample_filename "VPSD_sample" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'VPSD_sample' [98]. */
MCNUM mccVPSD_sample_xmin;
MCNUM mccVPSD_sample_xmax;
MCNUM mccVPSD_sample_ymin;
MCNUM mccVPSD_sample_ymax;
MCNUM mccVPSD_sample_xwidth;
MCNUM mccVPSD_sample_yheight;
MCNUM mccVPSD_sample_restore_neutron;

/* Definition parameters for component 'Hdiv_sample' [99]. */
#define mccHdiv_sample_nh 200
/* Setting parameters for component 'Hdiv_sample' [99]. */
char mccHdiv_sample_filename[16384];
MCNUM mccHdiv_sample_xmin;
MCNUM mccHdiv_sample_xmax;
MCNUM mccHdiv_sample_ymin;
MCNUM mccHdiv_sample_ymax;
MCNUM mccHdiv_sample_xwidth;
MCNUM mccHdiv_sample_yheight;
MCNUM mccHdiv_sample_h_maxdiv;
MCNUM mccHdiv_sample_restore_neutron;

/* Definition parameters for component 'Vdiv_sample' [100]. */
#define mccVdiv_sample_nv 200
#define mccVdiv_sample_filename "Vdiv_sample" /* declared as a string. May produce warnings at compile */
#define mccVdiv_sample_restore_neutron 1
/* Setting parameters for component 'Vdiv_sample' [100]. */
MCNUM mccVdiv_sample_xmin;
MCNUM mccVdiv_sample_xmax;
MCNUM mccVdiv_sample_ymin;
MCNUM mccVdiv_sample_ymax;
MCNUM mccVdiv_sample_xwidth;
MCNUM mccVdiv_sample_yheight;
MCNUM mccVdiv_sample_v_maxdiv;

/* Definition parameters for component 'acceptance_x_divx' [101]. */
#define mccacceptance_x_divx_nh 200
#define mccacceptance_x_divx_ndiv 200
/* Setting parameters for component 'acceptance_x_divx' [101]. */
char mccacceptance_x_divx_filename[16384];
MCNUM mccacceptance_x_divx_xmin;
MCNUM mccacceptance_x_divx_xmax;
MCNUM mccacceptance_x_divx_ymin;
MCNUM mccacceptance_x_divx_ymax;
MCNUM mccacceptance_x_divx_xwidth;
MCNUM mccacceptance_x_divx_yheight;
MCNUM mccacceptance_x_divx_maxdiv_h;
MCNUM mccacceptance_x_divx_restore_neutron;
MCNUM mccacceptance_x_divx_nx;
MCNUM mccacceptance_x_divx_ny;
MCNUM mccacceptance_x_divx_nz;

/* Definition parameters for component 'acceptance_y_divy' [102]. */
#define mccacceptance_y_divy_npos 200
#define mccacceptance_y_divy_ndiv 200
#define mccacceptance_y_divy_filename "acceptance_y_divy" /* declared as a string. May produce warnings at compile */
#define mccacceptance_y_divy_restore_neutron 1
/* Setting parameters for component 'acceptance_y_divy' [102]. */
MCNUM mccacceptance_y_divy_xmin;
MCNUM mccacceptance_y_divy_xmax;
MCNUM mccacceptance_y_divy_ymin;
MCNUM mccacceptance_y_divy_ymax;
MCNUM mccacceptance_y_divy_xwidth;
MCNUM mccacceptance_y_divy_yheight;
MCNUM mccacceptance_y_divy_maxdiv;

/* Definition parameters for component 'Lmon_sample_B' [103]. */
#define mccLmon_sample_B_nL 300
/* Setting parameters for component 'Lmon_sample_B' [103]. */
char mccLmon_sample_B_filename[16384];
MCNUM mccLmon_sample_B_xmin;
MCNUM mccLmon_sample_B_xmax;
MCNUM mccLmon_sample_B_ymin;
MCNUM mccLmon_sample_B_ymax;
MCNUM mccLmon_sample_B_xwidth;
MCNUM mccLmon_sample_B_yheight;
MCNUM mccLmon_sample_B_Lmin;
MCNUM mccLmon_sample_B_Lmax;
MCNUM mccLmon_sample_B_restore_neutron;

/* Definition parameters for component 'Div2d_sample_maxdiv' [104]. */
#define mccDiv2d_sample_maxdiv_nh 200
#define mccDiv2d_sample_maxdiv_nv 200
/* Setting parameters for component 'Div2d_sample_maxdiv' [104]. */
char mccDiv2d_sample_maxdiv_filename[16384];
MCNUM mccDiv2d_sample_maxdiv_xmin;
MCNUM mccDiv2d_sample_maxdiv_xmax;
MCNUM mccDiv2d_sample_maxdiv_ymin;
MCNUM mccDiv2d_sample_maxdiv_ymax;
MCNUM mccDiv2d_sample_maxdiv_xwidth;
MCNUM mccDiv2d_sample_maxdiv_yheight;
MCNUM mccDiv2d_sample_maxdiv_maxdiv_h;
MCNUM mccDiv2d_sample_maxdiv_maxdiv_v;
MCNUM mccDiv2d_sample_maxdiv_restore_neutron;
MCNUM mccDiv2d_sample_maxdiv_nx;
MCNUM mccDiv2d_sample_maxdiv_ny;
MCNUM mccDiv2d_sample_maxdiv_nz;

/* Definition parameters for component 'PSD_sample_maxdiv' [105]. */
#define mccPSD_sample_maxdiv_nx 200
#define mccPSD_sample_maxdiv_ny 200
/* Setting parameters for component 'PSD_sample_maxdiv' [105]. */
char mccPSD_sample_maxdiv_filename[16384];
MCNUM mccPSD_sample_maxdiv_xmin;
MCNUM mccPSD_sample_maxdiv_xmax;
MCNUM mccPSD_sample_maxdiv_ymin;
MCNUM mccPSD_sample_maxdiv_ymax;
MCNUM mccPSD_sample_maxdiv_xwidth;
MCNUM mccPSD_sample_maxdiv_yheight;
MCNUM mccPSD_sample_maxdiv_restore_neutron;

/* Definition parameters for component 'HPSD_sample_maxdiv' [106]. */
#define mccHPSD_sample_maxdiv_nx 100
/* Setting parameters for component 'HPSD_sample_maxdiv' [106]. */
char mccHPSD_sample_maxdiv_filename[16384];
MCNUM mccHPSD_sample_maxdiv_xmin;
MCNUM mccHPSD_sample_maxdiv_xmax;
MCNUM mccHPSD_sample_maxdiv_ymin;
MCNUM mccHPSD_sample_maxdiv_ymax;
MCNUM mccHPSD_sample_maxdiv_xwidth;
MCNUM mccHPSD_sample_maxdiv_yheight;
MCNUM mccHPSD_sample_maxdiv_restore_neutron;

/* Definition parameters for component 'VPSD_sample_maxdiv' [107]. */
#define mccVPSD_sample_maxdiv_ny 100
#define mccVPSD_sample_maxdiv_filename "VPSD_sample_maxdiv" /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'VPSD_sample_maxdiv' [107]. */
MCNUM mccVPSD_sample_maxdiv_xmin;
MCNUM mccVPSD_sample_maxdiv_xmax;
MCNUM mccVPSD_sample_maxdiv_ymin;
MCNUM mccVPSD_sample_maxdiv_ymax;
MCNUM mccVPSD_sample_maxdiv_xwidth;
MCNUM mccVPSD_sample_maxdiv_yheight;
MCNUM mccVPSD_sample_maxdiv_restore_neutron;

/* Definition parameters for component 'Hdiv_sample_maxdiv' [108]. */
#define mccHdiv_sample_maxdiv_nh 200
/* Setting parameters for component 'Hdiv_sample_maxdiv' [108]. */
char mccHdiv_sample_maxdiv_filename[16384];
MCNUM mccHdiv_sample_maxdiv_xmin;
MCNUM mccHdiv_sample_maxdiv_xmax;
MCNUM mccHdiv_sample_maxdiv_ymin;
MCNUM mccHdiv_sample_maxdiv_ymax;
MCNUM mccHdiv_sample_maxdiv_xwidth;
MCNUM mccHdiv_sample_maxdiv_yheight;
MCNUM mccHdiv_sample_maxdiv_h_maxdiv;
MCNUM mccHdiv_sample_maxdiv_restore_neutron;

/* Definition parameters for component 'Vdiv_sample_maxdiv' [109]. */
#define mccVdiv_sample_maxdiv_nv 200
#define mccVdiv_sample_maxdiv_filename "Vdiv_sample_maxdiv" /* declared as a string. May produce warnings at compile */
#define mccVdiv_sample_maxdiv_restore_neutron 1
/* Setting parameters for component 'Vdiv_sample_maxdiv' [109]. */
MCNUM mccVdiv_sample_maxdiv_xmin;
MCNUM mccVdiv_sample_maxdiv_xmax;
MCNUM mccVdiv_sample_maxdiv_ymin;
MCNUM mccVdiv_sample_maxdiv_ymax;
MCNUM mccVdiv_sample_maxdiv_xwidth;
MCNUM mccVdiv_sample_maxdiv_yheight;
MCNUM mccVdiv_sample_maxdiv_v_maxdiv;

/* Definition parameters for component 'acceptance_x_divx_maxdiv' [110]. */
#define mccacceptance_x_divx_maxdiv_nh 200
#define mccacceptance_x_divx_maxdiv_ndiv 200
/* Setting parameters for component 'acceptance_x_divx_maxdiv' [110]. */
char mccacceptance_x_divx_maxdiv_filename[16384];
MCNUM mccacceptance_x_divx_maxdiv_xmin;
MCNUM mccacceptance_x_divx_maxdiv_xmax;
MCNUM mccacceptance_x_divx_maxdiv_ymin;
MCNUM mccacceptance_x_divx_maxdiv_ymax;
MCNUM mccacceptance_x_divx_maxdiv_xwidth;
MCNUM mccacceptance_x_divx_maxdiv_yheight;
MCNUM mccacceptance_x_divx_maxdiv_maxdiv_h;
MCNUM mccacceptance_x_divx_maxdiv_restore_neutron;
MCNUM mccacceptance_x_divx_maxdiv_nx;
MCNUM mccacceptance_x_divx_maxdiv_ny;
MCNUM mccacceptance_x_divx_maxdiv_nz;

/* Definition parameters for component 'acceptance_y_divy_maxdiv' [111]. */
#define mccacceptance_y_divy_maxdiv_npos 200
#define mccacceptance_y_divy_maxdiv_ndiv 200
#define mccacceptance_y_divy_maxdiv_filename "acceptance_y_divy_maxdiv" /* declared as a string. May produce warnings at compile */
#define mccacceptance_y_divy_maxdiv_restore_neutron 1
/* Setting parameters for component 'acceptance_y_divy_maxdiv' [111]. */
MCNUM mccacceptance_y_divy_maxdiv_xmin;
MCNUM mccacceptance_y_divy_maxdiv_xmax;
MCNUM mccacceptance_y_divy_maxdiv_ymin;
MCNUM mccacceptance_y_divy_maxdiv_ymax;
MCNUM mccacceptance_y_divy_maxdiv_xwidth;
MCNUM mccacceptance_y_divy_maxdiv_yheight;
MCNUM mccacceptance_y_divy_maxdiv_maxdiv;

/* Definition parameters for component 'Lmon_sample' [112]. */
#define mccLmon_sample_nL 400
/* Setting parameters for component 'Lmon_sample' [112]. */
char mccLmon_sample_filename[16384];
MCNUM mccLmon_sample_xmin;
MCNUM mccLmon_sample_xmax;
MCNUM mccLmon_sample_ymin;
MCNUM mccLmon_sample_ymax;
MCNUM mccLmon_sample_xwidth;
MCNUM mccLmon_sample_yheight;
MCNUM mccLmon_sample_Lmin;
MCNUM mccLmon_sample_Lmax;
MCNUM mccLmon_sample_restore_neutron;

/* Setting parameters for component 'v_sample' [113]. */
MCNUM mccv_sample_radius;
MCNUM mccv_sample_thickness;
MCNUM mccv_sample_zdepth;
MCNUM mccv_sample_Vc;
MCNUM mccv_sample_sigma_abs;
MCNUM mccv_sample_sigma_inc;
MCNUM mccv_sample_radius_i;
MCNUM mccv_sample_radius_o;
MCNUM mccv_sample_h;
MCNUM mccv_sample_focus_r;
MCNUM mccv_sample_pack;
MCNUM mccv_sample_frac;
MCNUM mccv_sample_f_QE;
MCNUM mccv_sample_gamma;
MCNUM mccv_sample_target_x;
MCNUM mccv_sample_target_y;
MCNUM mccv_sample_target_z;
MCNUM mccv_sample_focus_xw;
MCNUM mccv_sample_focus_yh;
MCNUM mccv_sample_focus_aw;
MCNUM mccv_sample_focus_ah;
MCNUM mccv_sample_xwidth;
MCNUM mccv_sample_yheight;
MCNUM mccv_sample_zthick;
MCNUM mccv_sample_rad_sphere;
MCNUM mccv_sample_sig_a;
MCNUM mccv_sample_sig_i;
MCNUM mccv_sample_V0;
int mccv_sample_target_index;
MCNUM mccv_sample_multiples;

/* Setting parameters for component 'monochromator_flat' [116]. */
char mccmonochromator_flat_reflect[16384];
char mccmonochromator_flat_transmit[16384];
MCNUM mccmonochromator_flat_zwidth;
MCNUM mccmonochromator_flat_yheight;
MCNUM mccmonochromator_flat_gap;
MCNUM mccmonochromator_flat_NH;
MCNUM mccmonochromator_flat_NV;
MCNUM mccmonochromator_flat_mosaich;
MCNUM mccmonochromator_flat_mosaicv;
MCNUM mccmonochromator_flat_r0;
MCNUM mccmonochromator_flat_t0;
MCNUM mccmonochromator_flat_Q;
MCNUM mccmonochromator_flat_RV;
MCNUM mccmonochromator_flat_RH;
MCNUM mccmonochromator_flat_DM;
MCNUM mccmonochromator_flat_mosaic;
MCNUM mccmonochromator_flat_width;
MCNUM mccmonochromator_flat_height;
MCNUM mccmonochromator_flat_verbose;
MCNUM mccmonochromator_flat_order;

/* Setting parameters for component 'monochromator2' [117]. */
char mccmonochromator2_reflect[16384];
char mccmonochromator2_transmit[16384];
MCNUM mccmonochromator2_zwidth;
MCNUM mccmonochromator2_yheight;
MCNUM mccmonochromator2_gap;
MCNUM mccmonochromator2_NH;
MCNUM mccmonochromator2_NV;
MCNUM mccmonochromator2_mosaich;
MCNUM mccmonochromator2_mosaicv;
MCNUM mccmonochromator2_r0;
MCNUM mccmonochromator2_t0;
MCNUM mccmonochromator2_Q;
MCNUM mccmonochromator2_RV;
MCNUM mccmonochromator2_RH;
MCNUM mccmonochromator2_DM;
MCNUM mccmonochromator2_mosaic;
MCNUM mccmonochromator2_width;
MCNUM mccmonochromator2_height;
MCNUM mccmonochromator2_verbose;
MCNUM mccmonochromator2_order;

/* Setting parameters for component 'monochromator3' [118]. */
char mccmonochromator3_reflect[16384];
char mccmonochromator3_transmit[16384];
MCNUM mccmonochromator3_zwidth;
MCNUM mccmonochromator3_yheight;
MCNUM mccmonochromator3_gap;
MCNUM mccmonochromator3_NH;
MCNUM mccmonochromator3_NV;
MCNUM mccmonochromator3_mosaich;
MCNUM mccmonochromator3_mosaicv;
MCNUM mccmonochromator3_r0;
MCNUM mccmonochromator3_t0;
MCNUM mccmonochromator3_Q;
MCNUM mccmonochromator3_RV;
MCNUM mccmonochromator3_RH;
MCNUM mccmonochromator3_DM;
MCNUM mccmonochromator3_mosaic;
MCNUM mccmonochromator3_width;
MCNUM mccmonochromator3_height;
MCNUM mccmonochromator3_verbose;
MCNUM mccmonochromator3_order;

/* Setting parameters for component 'monochromator4' [119]. */
char mccmonochromator4_reflect[16384];
char mccmonochromator4_transmit[16384];
MCNUM mccmonochromator4_zwidth;
MCNUM mccmonochromator4_yheight;
MCNUM mccmonochromator4_gap;
MCNUM mccmonochromator4_NH;
MCNUM mccmonochromator4_NV;
MCNUM mccmonochromator4_mosaich;
MCNUM mccmonochromator4_mosaicv;
MCNUM mccmonochromator4_r0;
MCNUM mccmonochromator4_t0;
MCNUM mccmonochromator4_Q;
MCNUM mccmonochromator4_RV;
MCNUM mccmonochromator4_RH;
MCNUM mccmonochromator4_DM;
MCNUM mccmonochromator4_mosaic;
MCNUM mccmonochromator4_width;
MCNUM mccmonochromator4_height;
MCNUM mccmonochromator4_verbose;
MCNUM mccmonochromator4_order;

/* Setting parameters for component 'monochromator5' [120]. */
char mccmonochromator5_reflect[16384];
char mccmonochromator5_transmit[16384];
MCNUM mccmonochromator5_zwidth;
MCNUM mccmonochromator5_yheight;
MCNUM mccmonochromator5_gap;
MCNUM mccmonochromator5_NH;
MCNUM mccmonochromator5_NV;
MCNUM mccmonochromator5_mosaich;
MCNUM mccmonochromator5_mosaicv;
MCNUM mccmonochromator5_r0;
MCNUM mccmonochromator5_t0;
MCNUM mccmonochromator5_Q;
MCNUM mccmonochromator5_RV;
MCNUM mccmonochromator5_RH;
MCNUM mccmonochromator5_DM;
MCNUM mccmonochromator5_mosaic;
MCNUM mccmonochromator5_width;
MCNUM mccmonochromator5_height;
MCNUM mccmonochromator5_verbose;
MCNUM mccmonochromator5_order;

/* Setting parameters for component 'monochromator6' [121]. */
char mccmonochromator6_reflect[16384];
char mccmonochromator6_transmit[16384];
MCNUM mccmonochromator6_zwidth;
MCNUM mccmonochromator6_yheight;
MCNUM mccmonochromator6_gap;
MCNUM mccmonochromator6_NH;
MCNUM mccmonochromator6_NV;
MCNUM mccmonochromator6_mosaich;
MCNUM mccmonochromator6_mosaicv;
MCNUM mccmonochromator6_r0;
MCNUM mccmonochromator6_t0;
MCNUM mccmonochromator6_Q;
MCNUM mccmonochromator6_RV;
MCNUM mccmonochromator6_RH;
MCNUM mccmonochromator6_DM;
MCNUM mccmonochromator6_mosaic;
MCNUM mccmonochromator6_width;
MCNUM mccmonochromator6_height;
MCNUM mccmonochromator6_verbose;
MCNUM mccmonochromator6_order;

/* Setting parameters for component 'monochromator7' [122]. */
char mccmonochromator7_reflect[16384];
char mccmonochromator7_transmit[16384];
MCNUM mccmonochromator7_zwidth;
MCNUM mccmonochromator7_yheight;
MCNUM mccmonochromator7_gap;
MCNUM mccmonochromator7_NH;
MCNUM mccmonochromator7_NV;
MCNUM mccmonochromator7_mosaich;
MCNUM mccmonochromator7_mosaicv;
MCNUM mccmonochromator7_r0;
MCNUM mccmonochromator7_t0;
MCNUM mccmonochromator7_Q;
MCNUM mccmonochromator7_RV;
MCNUM mccmonochromator7_RH;
MCNUM mccmonochromator7_DM;
MCNUM mccmonochromator7_mosaic;
MCNUM mccmonochromator7_width;
MCNUM mccmonochromator7_height;
MCNUM mccmonochromator7_verbose;
MCNUM mccmonochromator7_order;

/* Definition parameters for component 'psd_monitor' [124]. */
#define mccpsd_monitor_nx 90
#define mccpsd_monitor_ny 90
/* Setting parameters for component 'psd_monitor' [124]. */
char mccpsd_monitor_filename[16384];
MCNUM mccpsd_monitor_xmin;
MCNUM mccpsd_monitor_xmax;
MCNUM mccpsd_monitor_ymin;
MCNUM mccpsd_monitor_ymax;
MCNUM mccpsd_monitor_xwidth;
MCNUM mccpsd_monitor_yheight;
MCNUM mccpsd_monitor_restore_neutron;

/* Definition parameters for component 'e_monitor' [125]. */
#define mcce_monitor_nE 128
/* Setting parameters for component 'e_monitor' [125]. */
char mcce_monitor_filename[16384];
MCNUM mcce_monitor_xmin;
MCNUM mcce_monitor_xmax;
MCNUM mcce_monitor_ymin;
MCNUM mcce_monitor_ymax;
MCNUM mcce_monitor_xwidth;
MCNUM mcce_monitor_yheight;
MCNUM mcce_monitor_Emin;
MCNUM mcce_monitor_Emax;
MCNUM mcce_monitor_restore_neutron;

/* User component declarations. */

/* User declarations for component 'Origin' [1]. */
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
#define profile mccOrigin_profile
#define percent mccOrigin_percent
#define flag_save mccOrigin_flag_save
#define minutes mccOrigin_minutes
#line 44 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\misc\\Progress_bar.comp"
#ifndef PROGRESS_BAR
#define PROGRESS_BAR
#else
#error Only one Progress_bar component may be used in an instrument definition.
#endif

double IntermediateCnts;
time_t StartTime;
time_t EndTime;
time_t CurrentTime;
#line 12594 "BIFROST.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ESS_source' [2]. */
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
#define sector mccESS_source_sector
#define beamline mccESS_source_beamline
#define yheight mccESS_source_yheight
#define cold_frac mccESS_source_cold_frac
#define target_index mccESS_source_target_index
#define dist mccESS_source_dist
#define focus_xw mccESS_source_focus_xw
#define focus_yh mccESS_source_focus_yh
#define c_performance mccESS_source_c_performance
#define t_performance mccESS_source_t_performance
#define Lmin mccESS_source_Lmin
#define Lmax mccESS_source_Lmax
#define tmax_multiplier mccESS_source_tmax_multiplier
#define n_pulses mccESS_source_n_pulses
#define acc_power mccESS_source_acc_power
#define tfocus_dist mccESS_source_tfocus_dist
#define tfocus_time mccESS_source_tfocus_time
#define tfocus_width mccESS_source_tfocus_width
#line 115 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\ESS_butterfly.comp"
/* Centering-parameters, which sector are we in? */
double cx, cz;
int sign_bl_angle,surf_sign;
double orientation_angle;
/* 10 beamlines in sector N and E  - plus one location added for drawing */
double BeamlinesN[] = { 30.0,  36.0,  42.0,  48.0,  54.0,  60.0,  66.0,  72.0,  78.0,  84.0,  90.0};
double BeamlinesE[] = {-30.0, -36.0, -42.0, -48.0, -54.0, -60.0, -66.0, -72.0, -78.0, -84.0, -90.0};
/* 11 beamlines in sector S and W - plus one location added for drawing */
double BeamlinesW[] = { 150.0,  144.7,  138.0,  132.7,  126.0,  120.7,  114.0,  108.7,  102.0,  96.7,  90.0,  84.0};
double BeamlinesS[] = {-150.0, -144.7, -138.0, -132.7, -126.0, -120.7, -114.0, -108.7, -102.0, -96.7, -90.0, -84.0};
double* Beamlines;
/* Moderator widths N+E */
double ColdWidthNE[] = {7e-2, 7.45e-2, 8.3e-2, 8.6e-2, 8.7e-2, 8.8e-2, 8.8e-2, 8.7e-2, 8.6e-2, 8.3e-2};
double ThermalWidthNE[] = {5.4e-2, 6.2e-2, 7.2e-2, 8.2e-2, 8.5e-2, 9.1e-2, 9.6e-2, 10e-2, 10.3e-2, 10.5e-2};
/* Moderator widths S+W */
double ColdWidthSW[] = {7e-2, 7.45e-2, 8.3e-2, 8.6e-2, 8.7e-2, 8.8e-2, 8.8e-2, 8.8e-2, 8.6e-2, 8.4e-2, 6.9e-2};
double ThermalWidthSW[] = {5.4e-2, 6.2e-2, 7.2e-2, 8.2e-2, 8.5e-2, 9.1e-2, 9.6e-2, 9.95e-2, 10.25e-2, 10.45e-2, 10.5e-2};
double* ColdWidths;
double* ThermalWidths;
/* Per-beamport brilliance scaling parameters */
double ColdScalarsN[]={9.8788e-01, 1.0009e+00, 9.9335e-01, 9.5997e-01, 9.0717e-01, 9.1646e-01, 9.1028e-01, 9.1773e-01, 9.2537e-01, 9.1727e-01};
double ColdScalarsE[]={9.9032e-01, 1.0020e+00, 9.9647e-01, 9.6885e-01, 9.0713e-01, 9.1787e-01, 9.1190e-01, 9.2113e-01, 9.2786e-01, 9.2146e-01};
double ColdScalarsW[]={9.9017e-01, 1.0069e+00, 9.9366e-01, 9.7144e-01, 9.0624e-01, 8.9379e-01, 9.1022e-01, 9.2847e-01, 9.2812e-01, 9.2703e-01, 8.3098e-01};
double ColdScalarsS[]={8.6550e-01, 1.0071e+00, 9.9401e-01, 9.6243e-01, 9.0398e-01, 8.9299e-01, 9.0830e-01, 9.2450e-01, 9.2270e-01, 9.2373e-01, 8.2508e-01};
double* ColdScalars;
double ThermalScalarsN[]={8.6782e-01, 7.8627e-01, 7.6528e-01, 7.9469e-01, 7.3645e-01, 7.3012e-01, 7.2755e-01, 7.1750e-01, 7.1973e-01, 7.0459e-01};
double ThermalScalarsE[]={8.6838e-01, 7.8295e-01, 7.6719e-01, 7.9431e-01, 7.3989e-01, 7.3107e-01, 7.2811e-01, 7.2201e-01, 7.2097e-01, 7.0307e-01};
double ThermalScalarsW[]={8.7232e-01, 8.0007e-01, 7.6853e-01, 8.0251e-01, 7.3728e-01, 7.3761e-01, 7.2808e-01, 7.2151e-01, 7.1797e-01, 6.9857e-01, 6.9610e-01};
double ThermalScalarsS[]={8.6910e-01, 7.9964e-01, 7.6365e-01, 7.9922e-01, 7.3479e-01, 7.3836e-01, 7.2773e-01, 7.2202e-01, 7.1667e-01, 7.0149e-01, 7.0084e-01};
double* ThermalScalars;
/* Beamport-dependent translation of moderator sampling axes. 11 positions long - constant after beamport 3 */
double dxCold[]={-0.01, -0.01, -0.002, 0.004,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0};
double dxThermal[]={0.002, 0.003, 0.002, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007};
/* Oversampling for widths plus fraction of moderator surface "not around the corner" */
double oversampT=1.1;
double oversampC=1.0;
double wfrac_cold;
double wfrac_thermal;
double dx_focalpoint;
int jmax;
/* 'Corner' parametrization, i.e. where are the limits of the moderators */
double C1_x,C1_z,C2_x,C2_z,C3_x,C3_z;
double T1_x,T1_z,T2_x,T2_z,T3_x,T3_z;
/* - plus rotated versions of the same... */
double rC1_x,rC1_z,rC2_x,rC2_z,rC3_x,rC3_z;
double rT1_x,rT1_z,rT2_x,rT2_z,rT3_x,rT3_z;
double tx,ty,tz;
double r11, r12, r21, r22;
int iscold;
double xtmp;
double delta_y;
double xf, yf, zf;
double w_mult,w_stat;
double w_geom, w_focus, w_tfocus;
double w_geom_c, w_geom_t;
double tx,ty,tz;
int isleft;
double  Lmin_sampled,  Lmax_sampled,  dt, lambda, l_range;
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2013, All rights reserved
*         DTU Physics, Lyngby, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ESS_butterfly-lib.h
*
* %Identification
* Written by: PW
* Date: Nov 7, 2013
* Origin: DTU Physics
* Release: McStas 2.1
* Version: 0.1
*
* This file is to be imported by the ESS_moderator_long component
* It defines a set of brilliance definitions (used via function pointer) for
* easier use of the component.
*
* Usage: within SHARE
* %include "ESS_butterfly-lib"
*
*******************************************************************************/

#ifndef ESS_BUTTERFLY_LIB_H
#define ESS_BUTTERFLY_LIB_H 0.1
#define ESS_SOURCE_DURATION 2.857e-3
#define ESS_SOURCE_FREQUENCY 14
#define ESS_SOURCE_POWER 5


/* Struct for extra source parameters - for future geometrical adjustments */
struct ess_struct {
  double X;
  double Y;
  double Z;
  double height_t;
  double height_c;
  double Width_c;
  double Width_t;
  double Mwidth_c;
  double Mwidth_t;
  double tmultiplier;
  double Radius_c;
  double beamportangle;
  int Uniform;
  double extractionangle;
  int Wasleft;
};

typedef struct ess_struct ess_moderator_struct;

typedef void (*functype)(double* t , double* p, double lambda,  double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras);

double ESS_2015_Schoenfeldt_cold_spectrum(double lambda,double theta);
double ESS_2015_Schoenfeldt_thermal_spectrum(double lambda, double theta);

/* List of brilliance definitions */
void ESS_2015_Schoenfeldt_cold(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras); 
void ESS_2015_Schoenfeldt_thermal(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras);

/* List of pulse-shape definitions */
double ESS_2015_Schoenfeldt_cold_timedist(double t, double lambda, double height, double pulselength);
double ESS_2015_Schoenfeldt_thermal_timedist(double t, double lambda, double height, double pulselength);

/* List of moderator-geometry-weighting definitions */
double ESS_2014_Schoenfeldt_cold_y0(double y0,double height);
double ESS_2014_Schoenfeldt_cold_x0(double x0,double height, double width);
double ESS_2014_Schoenfeldt_thermal_y0(double y0,double height);
double ESS_2014_Schoenfeldt_thermal_x0(double x0,double height, double width);

double ESS_2015_Schoenfeldt_cold_y0(double y0);
double ESS_2015_Schoenfeldt_cold_x0(double x0, double theta, double width);
double ESS_2015_Schoenfeldt_thermal_y0(double y0);
double ESS_2015_Schoenfeldt_thermal_x0(double x0,double theta, double width);
double ESS_2015_Schoenfeldt_cold_Y(double x0,double height);
double ESS_2015_Schoenfeldt_thermal_Y(double y0,double height);
double ESS_2015_Schoenfeldt_cold_Theta120(double x0,double height);
double ESS_2015_Schoenfeldt_thermal_Theta120(double beamportangle,int isleft);

/* end of ESS_butterfly-lib.h */
#endif

/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2013, All rights reserved
*         DTU Physics, Lyngby, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ESS_butterfly-lib.c
*
* %Identification
* Written by: PW
* Date: Nov 7, 2013
* Origin: DTU Physics
* Release: McStas 2.1
* Version: 0.1
*
* This file is to be imported by the ESS_moderator_long component
* It defines a set of brilliance definitions (used via function pointer) for
* easier use of the component.
*
* Usage: within SHARE
* %include "ESS_butterfly-lib"
*
*******************************************************************************/

#ifndef ESS_BUTTERFLY_LIB_H
#error McStas : please import this library with %include "ESS_butterfly-lib"
#endif

double ESS_2015_Schoenfeldt_cold_spectrum(double lambda,double theta){
  if(lambda<=0)return 0;
  double par0=8.44e13/25.;
  double par1=2.5;
  double par2=2.2;
  
  double par3=-13.-.5*(theta-5);
  double par4=2.53;
  double par5=-0.0478073-0.160*exp(-0.45186*(theta-5.)/10.);
  
  double par6;
  if(theta==5)par6=5.73745e+015/25.;
  else if(theta==15)par6=5.88284e+015/25.;
  else if(theta==25)par6=6.09573e+015/25.;
  else if(theta==35)par6=6.29116e+015/25.;
  else if(theta==45)par6=6.03436e+015/25.;
  else if(theta==55)par6=6.02045e+015/25.;
  double par7=0.788956+0.00854184*(theta-5.)/10.;
  double par8=0.0461868-0.0016464*(theta-5.)/10.;
  double par9=0.325;
  
  double SD_part=par0/((1+exp(par1*(lambda-par2)))*lambda);
  double para_part=pow((1+exp(par3*(lambda-par4))),par5)*(par6*(exp(-par7*(lambda))+par8*exp(-par9*(lambda))));
  return para_part+SD_part;
  
}

double ESS_2015_Schoenfeldt_thermal_spectrum(double lambda, double theta){
    if(lambda<=0)return 0;
    double i=(theta-5.)/10.;
    double par0=4.2906e+013-9.2758e+011*i+8.02603e+011*i*i-1.29523e+011*i*i*i;
    double par2=6.24806e+012-8.84602e+010*i;
    double par3=-0.31107+0.0221138*i;
    double aOlsqr=949./(325*lambda*lambda);
    return par0*2.*aOlsqr*aOlsqr/lambda*pow(lambda,-par3)*exp(-aOlsqr)+par2/((1+exp(2.5*(lambda-0.88)))*lambda);
	  
}


/* This is ESS_2014_Schoenfeldt_cold_y0 - vertical intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_cold_y0(double y0,double height){
  
  double one_over_integral_y0_of_height= height/((0.36434*height*height+2.53796*height-0.107774));
  if(y0 < -height/2. || y0 > height/2. )return 0;
  double cosh_ish=(exp(-7e-1/sqrt(height)*(y0-height/2.))+exp(-7e-1/20.*height+7e-1/sqrt(height)*(y0+height/2.)));
  double sinh_ish=(exp(50/sqrt(height)*(y0-height/2.))-1)*(exp(-50/sqrt(height)*(y0+height/2.))-1);
  double tmp=one_over_integral_y0_of_height*cosh_ish*sinh_ish;
  return tmp;
} /* end of ESS_2014_Schoenfeldt_cold_y0 */

/* This is ESS_2014_Schoenfeldt_thermal_y0 - vertical intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_thermal_y0(double y0,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2014_Schoenfeldt_thermal_y0 */

/* This is ESS_2014_Schoenfeldt_cold_x0 - horizontal intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_cold_x0(double x0,double height, double width){
  double normalization=1;
  if(x0<-width||x0>width)return 0;
  return normalization*(0.008*x0+1)*(exp(height/2.*(x0-width/2))-1)*(exp(-height/2.*(x0+width/2))-1);
} /* end of ESS_2014_Schoenfeldt_cold_x0 */

/* This is ESS_2014_Schoenfeldt_thermal_x0 - horizontal intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_thermal_x0(double x0,double height, double width){
  // Kept for reference only...
  /* if(x0>-width&&x0<width)return 0; */
  /* if(x0<0)return fmax(0,2.5*(0.0524986*fabs(x0)-1.84817-0.0189762*height+(-1.49712e+002*exp(-4.06814e-001*height))*exp(-4.48657e-001*fabs(x0)))*(exp(7*(x0+width))-1)); */
  /* return fmax(0,2.5*(0.84199+0.00307022*height)*(0.0524986*fabs(x0)-1.84817-0.0189762*height+(-1.49712e+002*exp(-4.06814e-001*height))*exp(-4.48657e-001*fabs(x0)))*(exp(-7*(x0-width))-1)); */  
  if(x0>-23./2.&&x0<23./2.)return 0;
  long double cosh_ish=fmin(0.0524986*fabs(x0)-1.84817-0.0189762*height+(-1.49712e+002*exp(-4.06814e-001*height))*exp(-4.48657e-001*fabs(x0)),0);
  if(x0<0)return (-1.73518e-003*height*height+2.10277e-002*height+7.65692e-001) // intensity
	    *cosh_ish*(exp(7.*(x0+23./2.))-1); // slope 
  return (-1.73518e-003*height*height+2.10277e-002*height+7.65692e-001) // intensity
    *(0.84199+0.00307022*height) // asumetry
    *cosh_ish*(exp(-7.*(x0-23./2.))-1); // slope
} /* end of ESS_2014_Schoenfeldt_thermal_x0 */

/* This is the thermal moderator with 2015 updates, fits from Troels Schoenfeldt */
void ESS_2015_Schoenfeldt_thermal(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras)
{
  if ((extras.height_t == 0.03) || (extras.height_t == 0.06)) {
    *p = ESS_2015_Schoenfeldt_thermal_spectrum(lambda, extras.beamportangle);
  } else {
    printf("Sorry! Moderator height must be either %g or %g m\n",0.03,0.06);
    exit(-1);
  }

  /* Troels Schoenfeldt function for timestructure */
  *p *= extras.tmultiplier*ESS_2015_Schoenfeldt_thermal_timedist(*t, lambda, 3 /* cm height */, ESS_SOURCE_DURATION);  
  if (extras.height_c == 0.03) {
    // 3cm case
    *p *= ESS_2015_Schoenfeldt_thermal_y0(100*extras.Y) * ESS_2015_Schoenfeldt_thermal_x0(100*extras.X, extras.beamportangle, extras.Mwidth_t);
  } else {
    // 6cm case
    // Downscale brightness by factor from 
    // "New ESS Moderator Baseline", Ken Andersen, 9/4/2015
    *p *= (6.2e14/9.0e14);
    *p *= ESS_2014_Schoenfeldt_thermal_y0(100*extras.Y, 100*extras.height_c) * ESS_2015_Schoenfeldt_thermal_x0(100*extras.X, extras.beamportangle, extras.Mwidth_t);
  }
} /* end of ESS_2015_Schoenfeldt_thermal */


/* This is the cold moderator with 2015 updates, fits from Troels Schoenfeldt */
/* Parametrization including moderator height for the "pancake" moderator */
void ESS_2015_Schoenfeldt_cold(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras)
{
   if ((extras.height_c == 0.03) || (extras.height_c == 0.06)) {
    *p = ESS_2015_Schoenfeldt_cold_spectrum(lambda,extras.beamportangle);
  } else {
    printf("Sorry! Moderator height must be either %g or %g m\n",0.03,0.06);
    exit(-1);
  }

  /* Troels Schoenfeldt function for timestructure */
  *p *= extras.tmultiplier*ESS_2015_Schoenfeldt_cold_timedist(*t, lambda, 3 /* cm height */, ESS_SOURCE_DURATION);
  
  if (extras.Uniform==0) {
    if (extras.height_c == 0.03) {
      // 3cm case
      *p *= ESS_2015_Schoenfeldt_cold_y0(100*extras.Y) * ESS_2015_Schoenfeldt_cold_x0(100*extras.X, extras.beamportangle, extras.Mwidth_c);
    } else {
      // 6cm case
      // Downscale brightness by factor from 
      // "New ESS Moderator Baseline", Ken Andersen, 9/4/2015
      *p *= (10.1e14/16.0e14);
      *p *= ESS_2014_Schoenfeldt_cold_y0(100*extras.Y, 100*extras.height_c) * ESS_2015_Schoenfeldt_cold_x0(100*extras.X, extras.beamportangle, extras.Mwidth_c);
    }
  }
} /* end of ESS_2015_Schoenfeldt_cold */

/* This is ESS_2015_Schoenfeldt_cold_y0 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_y0(double y0){
    double par3=30;
    double par4=.35;
    long double cosh_ish=exp(-par4*y0)+exp(par4*y0);
    long double sinh_ish=pow(1+exp(par3*(y0-3./2.)),-1)*pow(1+exp(-par3*(y0+3./2.)),-1);
    return 1./2.*(double)((long double)cosh_ish*(long double)sinh_ish);

} /* end of ESS_2015_Schoenfeldt_cold_y0 */

/* This is ESS_2015_Schoenfeldt_thermal_y0 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_y0(double y0){
    if(y0<-3./2.+0.105){
        return 1.005*exp(-pow((y0+3./2.-0.105)/0.372,2));
    } else if(y0>3./2.-0.105){
        return 1.005*exp(-pow((y0-3./2.+0.105)/0.372,2));
    }
    return 1.005;
} /* end of ESS_2015_Schoenfeldt_thermal_y0 */

/* This is ESS_2015_Schoenfeldt_cold_x0 - horizontal intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_x0(double x0,double theta, double width){
  // GEOMETRY / SAMPLING SPACE
    double i=(theta-5.)/10.;
    double par0=0.0146115+0.00797729*i-0.00279541*i*i;
    double par1=0.980886;
    if(i==1)par1=0.974217;
    if(i==2)par1=0.981462;
    if(i==3)par1=1.01466;
    if(i==4)par1=1.11707;
    if(i==5)par1=1.16057;
        
    double par2=-4-.75*i;
    if(i==0)par2=-20;
    double par3=-14.9402-0.178369*i+0.0367007*i*i;
    if(i==0)par3*=0.95;
    double par4=-15;
    if(i==3)par4=-3.5;
    if(i==5)par4=-1.9;
    double par5=-7.07979+0.0835695*i-0.0546662*i*i;
    if(i==5)par5*=0.85;
    
    //printf("Angle %g, width is %g\n",theta,width,cos(theta*DEG2RAD)*width);
    //if(i==4) width=width+0.3;
    //if(i==5) width=width-0.7;

    /* Rescaling to achieve a BF1 model */
    double tmp=(par5-par3)/width;
    //printf("Cold x0 in BF1 units: %g,",x0);
    x0=x0*tmp-7.16;
    //printf("x0 in BF2 units: %g, moderator width is %g from %g\n",x0,width,par5-par3);

    /* if (x0<=par5 && x0>=par3) */
    /*   return 1; */
    /* else */
    /*   return 0; */
    

    double line=par0*(x0+12)+par1;
    double CutLeftCutRight=1./((1+exp(par2*(x0-par3)))*(1+exp(-par4*(x0-par5))));

    return line*CutLeftCutRight;
} /* end of ESS_2015_Schoenfeldt_cold_x0 */

/* This is ESS_2015_Schoenfeldt_thermal_x0 - horizontal intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_x0(double x0,double theta, double width){
    double i=(theta-5.)/10.;
    double par0=-5.54775+0.492804*i;
    double par1=-0.265929-0.711477*i;
    if(theta==55)par1=-2.55;

    double par2=0.821885+0.00914832*i;
    double par3=1.31108-0.00698647*i;
    if(theta==55)par3=1.23;
    double par4=-.035;
    double par5=-0.0817358+0.00807125*i;
        
    double par6=-8;
    double par7=-7.15;
    if(theta==45)par7=-8.2;
    if(theta==55)par7=-7.7;

    double par8=-8;
    double par9=7.15;
    if(theta==45)par9=7.5;
    if(theta==55)par9=8.2;

    /* Rescaling to achieve a BF1 model */
    double tmp=(par9-par7)/width;
    //printf("Thermal x0 in BF1 units: %g,",x0);
    x0=x0*tmp-7.16;
    //printf(" x0 in BF2 units: %g, moderator width is %g from %g\n",x0,width,par9-par7);
    
    /* if (x0<=par9 && x0>=par7) */
    /*   return 1; */
    /* else */
    /*   return 0; */
    
    double soften1=1./(1+exp(8.*(x0-par0)));
    double soften2=1./(1+exp(8.*(x0-par1)));
    double CutLeftCutRight=1./((1+exp(par6*(x0-par7)))*(1+exp(-par8*(x0-par9))));
    double line1=par4*(x0-par0)+par2;
    double line2=(par2-par3)/(par0-par1)*(x0-par0)+par2;
    double line3=par5*(x0-par1)+par3;
    double add45degbumb=1.2*exp(-(x0+7.55)*(x0+7.55)/.35/.35);


    return CutLeftCutRight*(
        (line1)*soften1
        +line2*soften2*(1-soften1)
        +line3*(1-soften2)
        );
} /* end of ESS_2015_Schoenfeldt_thermal_x0 */

/* This is ESS_2015_Schoenfeldt_cold_Y - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_Y(double Y,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_cold_Y */

/* This is ESS_2015_Schoenfeldt_thermal_Y - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_Y(double Y,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_thermal_Y */

/* This is ESS_2015_Schoenfeldt_cold_Theta120 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_Theta120(double Theta120,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_cold_Theta120 */

/* This is ESS_2015_Schoenfeldt_thermal_Theta120 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_Theta120(double beamportangle,int isleft){
  if(!isleft)return cos((beamportangle-30)*DEG2RAD)/cos(30*DEG2RAD);
  return cos((90-beamportangle)*DEG2RAD)/cos(30*DEG2RAD);
/* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_thermal_Theta120 */


/* This is ESS_2015_Schoenfeldt_cold_timedist time-distribution of the 2014 Schoenfeldt cold moderator */ 
double ESS_2015_Schoenfeldt_cold_timedist(double time,double lambda,double height, double pulselength){
        if(time<0)return 0;
        double tau=3.00094e-004*(4.15681e-003*lambda*lambda+2.96212e-001*exp(-1.78408e-001*height)+7.77496e-001)*exp(-6.63537e+001*pow(fmax(1e-13,lambda+.9),-8.64455e+000));
        if(time<pulselength)return ((1-exp(-time/tau)));
        return ((1-exp(-pulselength/tau))*exp(-(time-pulselength)/tau));

} /* end of ESS_2015_Schoenfeldt_cold_timedist */

/* This is ESS_2015_Schoenfeldt_thermal_timedist time-distribution of the 2015 Schoenfeldt cold moderator */    
double ESS_2015_Schoenfeldt_thermal_timedist(double time,double lambda,double height, double pulselength){
        if(time<0)return 0;
        double tau=3.00000e-004*(1.23048e-002*lambda*lambda+1.75628e-001*exp(-1.82452e-001*height)+9.27770e-001)*exp(-3.91090e+001*pow(fmax(1e-13,lambda+9.87990e-001),-7.65675e+000));
        if(time<pulselength)return ((1-exp(-time/tau)));
        return ((1-exp(-pulselength/tau))*exp(-(time-pulselength)/tau));
} /* end of ESS_2015_Schoenfeldt_thermal_timedist */

/* end of ESS_butterfly-lib.c */

ess_moderator_struct modextras;
/* Cold and thermal function pointers */
functype cold_bril;
functype thermal_bril;
double k,v,r;
double dx,dy,dz;
/* variables needed to correct for the emission surface angle */
double internal_angle;

int nearest_angle(double angle) {
    int AngleList[] = {5, 15, 25, 35, 45, 55};
    double diff = 180;
    int jmin=-1;
    int j;
    for (j=0; j<6; j++) {
      if (fabs(AngleList[j]-angle) < diff) {
	diff = fabs(AngleList[j]-angle);
	jmin = j;
      }
    }
    return AngleList[jmin];
  }
  
  double x0,z0;
  double cos_beamport_angle, sin_beamport_angle, cos_thermal, cos_cold, cos_factor;
#line 13184 "BIFROST.c"
#undef tfocus_width
#undef tfocus_time
#undef tfocus_dist
#undef acc_power
#undef n_pulses
#undef tmax_multiplier
#undef Lmax
#undef Lmin
#undef t_performance
#undef c_performance
#undef focus_yh
#undef focus_xw
#undef dist
#undef target_index
#undef cold_frac
#undef yheight
#undef beamline
#undef sector
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'StartOfGuide' [3]. */
#define mccompcurname  StartOfGuide
#define mccompcurtype  Arm
#define mccompcurindex 3
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'NBOA' [4]. */
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
#define l mccNBOA_l
#define xwidth mccNBOA_xwidth
#define yheight mccNBOA_yheight
#define linxw mccNBOA_linxw
#define loutxw mccNBOA_loutxw
#define linyh mccNBOA_linyh
#define loutyh mccNBOA_loutyh
#define majorAxisxw mccNBOA_majorAxisxw
#define minorAxisxw mccNBOA_minorAxisxw
#define majorAxisyh mccNBOA_majorAxisyh
#define minorAxisyh mccNBOA_minorAxisyh
#define majorAxisoffsetxw mccNBOA_majorAxisoffsetxw
#define majorAxisoffsetyh mccNBOA_majorAxisoffsetyh
#define dimensionsAt mccNBOA_dimensionsAt
#define option mccNBOA_option
#define R0 mccNBOA_R0
#define Qc mccNBOA_Qc
#define alpha mccNBOA_alpha
#define m mccNBOA_m
#define W mccNBOA_W
#define alpharight mccNBOA_alpharight
#define mright mccNBOA_mright
#define alphaleft mccNBOA_alphaleft
#define mleft mccNBOA_mleft
#define alphatop mccNBOA_alphatop
#define mtop mccNBOA_mtop
#define alphabottom mccNBOA_alphabottom
#define mbottom mccNBOA_mbottom
#define verbose mccNBOA_verbose
#define enableGravity mccNBOA_enableGravity
#define curvature mccNBOA_curvature
#line 803 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 13344 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_6' [5]. */
#define mccompcurname  EndOfelement_6
#define mccompcurtype  Arm
#define mccompcurindex 5
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monBeforePSC1' [6]. */
#define mccompcurname  L_monBeforePSC1
#define mccompcurtype  L_monitor
#define mccompcurindex 6
#define nL mccL_monBeforePSC1_nL
#define L_N mccL_monBeforePSC1_L_N
#define L_p mccL_monBeforePSC1_L_p
#define L_p2 mccL_monBeforePSC1_L_p2
#define filename mccL_monBeforePSC1_filename
#define xmin mccL_monBeforePSC1_xmin
#define xmax mccL_monBeforePSC1_xmax
#define ymin mccL_monBeforePSC1_ymin
#define ymax mccL_monBeforePSC1_ymax
#define xwidth mccL_monBeforePSC1_xwidth
#define yheight mccL_monBeforePSC1_yheight
#define Lmin mccL_monBeforePSC1_Lmin
#define Lmax mccL_monBeforePSC1_Lmax
#define restore_neutron mccL_monBeforePSC1_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 13424 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFBeforerPSC1' [7]. */
#define mccompcurname  ToFBeforerPSC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 7
#define nt mccToFBeforerPSC1_nt
#define TOF_N mccToFBeforerPSC1_TOF_N
#define TOF_p mccToFBeforerPSC1_TOF_p
#define TOF_p2 mccToFBeforerPSC1_TOF_p2
#define t_min mccToFBeforerPSC1_t_min
#define t_max mccToFBeforerPSC1_t_max
#define delta_t mccToFBeforerPSC1_delta_t
#define filename mccToFBeforerPSC1_filename
#define xmin mccToFBeforerPSC1_xmin
#define xmax mccToFBeforerPSC1_xmax
#define ymin mccToFBeforerPSC1_ymin
#define ymax mccToFBeforerPSC1_ymax
#define xwidth mccToFBeforerPSC1_xwidth
#define yheight mccToFBeforerPSC1_yheight
#define tmin mccToFBeforerPSC1_tmin
#define tmax mccToFBeforerPSC1_tmax
#define dt mccToFBeforerPSC1_dt
#define restore_neutron mccToFBeforerPSC1_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 13470 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_beforePulseShapping1' [8]. */
#define mccompcurname  PSD_beforePulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 8
#define nx mccPSD_beforePulseShapping1_nx
#define ny mccPSD_beforePulseShapping1_ny
#define PSD_N mccPSD_beforePulseShapping1_PSD_N
#define PSD_p mccPSD_beforePulseShapping1_PSD_p
#define PSD_p2 mccPSD_beforePulseShapping1_PSD_p2
#define filename mccPSD_beforePulseShapping1_filename
#define xmin mccPSD_beforePulseShapping1_xmin
#define xmax mccPSD_beforePulseShapping1_xmax
#define ymin mccPSD_beforePulseShapping1_ymin
#define ymax mccPSD_beforePulseShapping1_ymax
#define xwidth mccPSD_beforePulseShapping1_xwidth
#define yheight mccPSD_beforePulseShapping1_yheight
#define restore_neutron mccPSD_beforePulseShapping1_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 13514 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'TofLambdaBeforePSC' [9]. */
#define mccompcurname  TofLambdaBeforePSC
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 9
#define nL mccTofLambdaBeforePSC_nL
#define nt mccTofLambdaBeforePSC_nt
#define tmin mccTofLambdaBeforePSC_tmin
#define tmax mccTofLambdaBeforePSC_tmax
#define tt_0 mccTofLambdaBeforePSC_tt_0
#define tt_1 mccTofLambdaBeforePSC_tt_1
#define TOFL_N mccTofLambdaBeforePSC_TOFL_N
#define TOFL_p mccTofLambdaBeforePSC_TOFL_p
#define TOFL_p2 mccTofLambdaBeforePSC_TOFL_p2
#define filename mccTofLambdaBeforePSC_filename
#define xmin mccTofLambdaBeforePSC_xmin
#define xmax mccTofLambdaBeforePSC_xmax
#define ymin mccTofLambdaBeforePSC_ymin
#define ymax mccTofLambdaBeforePSC_ymax
#define xwidth mccTofLambdaBeforePSC_xwidth
#define yheight mccTofLambdaBeforePSC_yheight
#define Lmin mccTofLambdaBeforePSC_Lmin
#define Lmax mccTofLambdaBeforePSC_Lmax
#define restore_neutron mccTofLambdaBeforePSC_restore_neutron
#line 54 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
double TOFL_N[nt][nL];
double TOFL_p[nt][nL];
double TOFL_p2[nt][nL];
double tt_0, tt_1;
#line 13560 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PulseShapingChopper' [10]. */
#define mccompcurname  PulseShapingChopper
#define mccompcurtype  DiskChopper
#define mccompcurindex 10
#define Tg mccPulseShapingChopper_Tg
#define To mccPulseShapingChopper_To
#define delta_y mccPulseShapingChopper_delta_y
#define height mccPulseShapingChopper_height
#define omega mccPulseShapingChopper_omega
#define theta_0 mccPulseShapingChopper_theta_0
#define radius mccPulseShapingChopper_radius
#define yheight mccPulseShapingChopper_yheight
#define nu mccPulseShapingChopper_nu
#define nslit mccPulseShapingChopper_nslit
#define jitter mccPulseShapingChopper_jitter
#define delay mccPulseShapingChopper_delay
#define isfirst mccPulseShapingChopper_isfirst
#define n_pulse mccPulseShapingChopper_n_pulse
#define abs_out mccPulseShapingChopper_abs_out
#define phase mccPulseShapingChopper_phase
#define xwidth mccPulseShapingChopper_xwidth
#define verbose mccPulseShapingChopper_verbose
#line 63 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 13608 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_AfterPulseShapping1' [11]. */
#define mccompcurname  PSD_AfterPulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 11
#define nx mccPSD_AfterPulseShapping1_nx
#define ny mccPSD_AfterPulseShapping1_ny
#define PSD_N mccPSD_AfterPulseShapping1_PSD_N
#define PSD_p mccPSD_AfterPulseShapping1_PSD_p
#define PSD_p2 mccPSD_AfterPulseShapping1_PSD_p2
#define filename mccPSD_AfterPulseShapping1_filename
#define xmin mccPSD_AfterPulseShapping1_xmin
#define xmax mccPSD_AfterPulseShapping1_xmax
#define ymin mccPSD_AfterPulseShapping1_ymin
#define ymax mccPSD_AfterPulseShapping1_ymax
#define xwidth mccPSD_AfterPulseShapping1_xwidth
#define yheight mccPSD_AfterPulseShapping1_yheight
#define restore_neutron mccPSD_AfterPulseShapping1_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 13652 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFInsidePSC' [12]. */
#define mccompcurname  ToFInsidePSC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 12
#define nt mccToFInsidePSC_nt
#define TOF_N mccToFInsidePSC_TOF_N
#define TOF_p mccToFInsidePSC_TOF_p
#define TOF_p2 mccToFInsidePSC_TOF_p2
#define t_min mccToFInsidePSC_t_min
#define t_max mccToFInsidePSC_t_max
#define delta_t mccToFInsidePSC_delta_t
#define filename mccToFInsidePSC_filename
#define xmin mccToFInsidePSC_xmin
#define xmax mccToFInsidePSC_xmax
#define ymin mccToFInsidePSC_ymin
#define ymax mccToFInsidePSC_ymax
#define xwidth mccToFInsidePSC_xwidth
#define yheight mccToFInsidePSC_yheight
#define tmin mccToFInsidePSC_tmin
#define tmax mccToFInsidePSC_tmax
#define dt mccToFInsidePSC_dt
#define restore_neutron mccToFInsidePSC_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 13697 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PulseShapingChopper2' [13]. */
#define mccompcurname  PulseShapingChopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 13
#define Tg mccPulseShapingChopper2_Tg
#define To mccPulseShapingChopper2_To
#define delta_y mccPulseShapingChopper2_delta_y
#define height mccPulseShapingChopper2_height
#define omega mccPulseShapingChopper2_omega
#define theta_0 mccPulseShapingChopper2_theta_0
#define radius mccPulseShapingChopper2_radius
#define yheight mccPulseShapingChopper2_yheight
#define nu mccPulseShapingChopper2_nu
#define nslit mccPulseShapingChopper2_nslit
#define jitter mccPulseShapingChopper2_jitter
#define delay mccPulseShapingChopper2_delay
#define isfirst mccPulseShapingChopper2_isfirst
#define n_pulse mccPulseShapingChopper2_n_pulse
#define abs_out mccPulseShapingChopper2_abs_out
#define phase mccPulseShapingChopper2_phase
#define xwidth mccPulseShapingChopper2_xwidth
#define verbose mccPulseShapingChopper2_verbose
#line 63 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 13744 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'TofLambdaAfterPSC2' [14]. */
#define mccompcurname  TofLambdaAfterPSC2
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 14
#define nL mccTofLambdaAfterPSC2_nL
#define nt mccTofLambdaAfterPSC2_nt
#define tmin mccTofLambdaAfterPSC2_tmin
#define tmax mccTofLambdaAfterPSC2_tmax
#define tt_0 mccTofLambdaAfterPSC2_tt_0
#define tt_1 mccTofLambdaAfterPSC2_tt_1
#define TOFL_N mccTofLambdaAfterPSC2_TOFL_N
#define TOFL_p mccTofLambdaAfterPSC2_TOFL_p
#define TOFL_p2 mccTofLambdaAfterPSC2_TOFL_p2
#define filename mccTofLambdaAfterPSC2_filename
#define xmin mccTofLambdaAfterPSC2_xmin
#define xmax mccTofLambdaAfterPSC2_xmax
#define ymin mccTofLambdaAfterPSC2_ymin
#define ymax mccTofLambdaAfterPSC2_ymax
#define xwidth mccTofLambdaAfterPSC2_xwidth
#define yheight mccTofLambdaAfterPSC2_yheight
#define Lmin mccTofLambdaAfterPSC2_Lmin
#define Lmax mccTofLambdaAfterPSC2_Lmax
#define restore_neutron mccTofLambdaAfterPSC2_restore_neutron
#line 54 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
double TOFL_N[nt][nL];
double TOFL_p[nt][nL];
double TOFL_p2[nt][nL];
double tt_0, tt_1;
#line 13795 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_AfterPSC2' [15]. */
#define mccompcurname  PSD_AfterPSC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 15
#define nx mccPSD_AfterPSC2_nx
#define ny mccPSD_AfterPSC2_ny
#define PSD_N mccPSD_AfterPSC2_PSD_N
#define PSD_p mccPSD_AfterPSC2_PSD_p
#define PSD_p2 mccPSD_AfterPSC2_PSD_p2
#define filename mccPSD_AfterPSC2_filename
#define xmin mccPSD_AfterPSC2_xmin
#define xmax mccPSD_AfterPSC2_xmax
#define ymin mccPSD_AfterPSC2_ymin
#define ymax mccPSD_AfterPSC2_ymax
#define xwidth mccPSD_AfterPSC2_xwidth
#define yheight mccPSD_AfterPSC2_yheight
#define restore_neutron mccPSD_AfterPSC2_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 13840 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFAfterPSC2' [16]. */
#define mccompcurname  ToFAfterPSC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 16
#define nt mccToFAfterPSC2_nt
#define TOF_N mccToFAfterPSC2_TOF_N
#define TOF_p mccToFAfterPSC2_TOF_p
#define TOF_p2 mccToFAfterPSC2_TOF_p2
#define t_min mccToFAfterPSC2_t_min
#define t_max mccToFAfterPSC2_t_max
#define delta_t mccToFAfterPSC2_delta_t
#define filename mccToFAfterPSC2_filename
#define xmin mccToFAfterPSC2_xmin
#define xmax mccToFAfterPSC2_xmax
#define ymin mccToFAfterPSC2_ymin
#define ymax mccToFAfterPSC2_ymax
#define xwidth mccToFAfterPSC2_xwidth
#define yheight mccToFAfterPSC2_yheight
#define tmin mccToFAfterPSC2_tmin
#define tmax mccToFAfterPSC2_tmax
#define dt mccToFAfterPSC2_dt
#define restore_neutron mccToFAfterPSC2_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 13885 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monAfterPSC2' [17]. */
#define mccompcurname  L_monAfterPSC2
#define mccompcurtype  L_monitor
#define mccompcurindex 17
#define nL mccL_monAfterPSC2_nL
#define L_N mccL_monAfterPSC2_L_N
#define L_p mccL_monAfterPSC2_L_p
#define L_p2 mccL_monAfterPSC2_L_p2
#define filename mccL_monAfterPSC2_filename
#define xmin mccL_monAfterPSC2_xmin
#define xmax mccL_monAfterPSC2_xmax
#define ymin mccL_monAfterPSC2_ymin
#define ymax mccL_monAfterPSC2_ymax
#define xwidth mccL_monAfterPSC2_xwidth
#define yheight mccL_monAfterPSC2_yheight
#define Lmin mccL_monAfterPSC2_Lmin
#define Lmax mccL_monAfterPSC2_Lmax
#define restore_neutron mccL_monAfterPSC2_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 13929 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_5' [18]. */
#define mccompcurname  EndOfelement_5
#define mccompcurtype  Arm
#define mccompcurindex 18
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_1_0' [19]. */
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
#define w1 mcccurved_guide_1_0_w1
#define h1 mcccurved_guide_1_0_h1
#define w2 mcccurved_guide_1_0_w2
#define h2 mcccurved_guide_1_0_h2
#define l mcccurved_guide_1_0_l
#define R0 mcccurved_guide_1_0_R0
#define Qc mcccurved_guide_1_0_Qc
#define alpha mcccurved_guide_1_0_alpha
#define m mcccurved_guide_1_0_m
#define W mcccurved_guide_1_0_W
#define nslit mcccurved_guide_1_0_nslit
#define d mcccurved_guide_1_0_d
#define mleft mcccurved_guide_1_0_mleft
#define mright mcccurved_guide_1_0_mright
#define mtop mcccurved_guide_1_0_mtop
#define mbottom mcccurved_guide_1_0_mbottom
#define nhslit mcccurved_guide_1_0_nhslit
#define G mcccurved_guide_1_0_G
#define aleft mcccurved_guide_1_0_aleft
#define aright mcccurved_guide_1_0_aright
#define atop mcccurved_guide_1_0_atop
#define abottom mcccurved_guide_1_0_abottom
#define wavy mcccurved_guide_1_0_wavy
#define wavy_z mcccurved_guide_1_0_wavy_z
#define wavy_tb mcccurved_guide_1_0_wavy_tb
#define wavy_lr mcccurved_guide_1_0_wavy_lr
#define chamfers mcccurved_guide_1_0_chamfers
#define chamfers_z mcccurved_guide_1_0_chamfers_z
#define chamfers_lr mcccurved_guide_1_0_chamfers_lr
#define chamfers_tb mcccurved_guide_1_0_chamfers_tb
#define nelements mcccurved_guide_1_0_nelements
#define nu mcccurved_guide_1_0_nu
#define phase mcccurved_guide_1_0_phase
#define reflect mcccurved_guide_1_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13999 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_2_0' [20]. */
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
#define w1 mcccurved_guide_2_0_w1
#define h1 mcccurved_guide_2_0_h1
#define w2 mcccurved_guide_2_0_w2
#define h2 mcccurved_guide_2_0_h2
#define l mcccurved_guide_2_0_l
#define R0 mcccurved_guide_2_0_R0
#define Qc mcccurved_guide_2_0_Qc
#define alpha mcccurved_guide_2_0_alpha
#define m mcccurved_guide_2_0_m
#define W mcccurved_guide_2_0_W
#define nslit mcccurved_guide_2_0_nslit
#define d mcccurved_guide_2_0_d
#define mleft mcccurved_guide_2_0_mleft
#define mright mcccurved_guide_2_0_mright
#define mtop mcccurved_guide_2_0_mtop
#define mbottom mcccurved_guide_2_0_mbottom
#define nhslit mcccurved_guide_2_0_nhslit
#define G mcccurved_guide_2_0_G
#define aleft mcccurved_guide_2_0_aleft
#define aright mcccurved_guide_2_0_aright
#define atop mcccurved_guide_2_0_atop
#define abottom mcccurved_guide_2_0_abottom
#define wavy mcccurved_guide_2_0_wavy
#define wavy_z mcccurved_guide_2_0_wavy_z
#define wavy_tb mcccurved_guide_2_0_wavy_tb
#define wavy_lr mcccurved_guide_2_0_wavy_lr
#define chamfers mcccurved_guide_2_0_chamfers
#define chamfers_z mcccurved_guide_2_0_chamfers_z
#define chamfers_lr mcccurved_guide_2_0_chamfers_lr
#define chamfers_tb mcccurved_guide_2_0_chamfers_tb
#define nelements mcccurved_guide_2_0_nelements
#define nu mcccurved_guide_2_0_nu
#define phase mcccurved_guide_2_0_phase
#define reflect mcccurved_guide_2_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14083 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_3_0' [21]. */
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
#define w1 mcccurved_guide_3_0_w1
#define h1 mcccurved_guide_3_0_h1
#define w2 mcccurved_guide_3_0_w2
#define h2 mcccurved_guide_3_0_h2
#define l mcccurved_guide_3_0_l
#define R0 mcccurved_guide_3_0_R0
#define Qc mcccurved_guide_3_0_Qc
#define alpha mcccurved_guide_3_0_alpha
#define m mcccurved_guide_3_0_m
#define W mcccurved_guide_3_0_W
#define nslit mcccurved_guide_3_0_nslit
#define d mcccurved_guide_3_0_d
#define mleft mcccurved_guide_3_0_mleft
#define mright mcccurved_guide_3_0_mright
#define mtop mcccurved_guide_3_0_mtop
#define mbottom mcccurved_guide_3_0_mbottom
#define nhslit mcccurved_guide_3_0_nhslit
#define G mcccurved_guide_3_0_G
#define aleft mcccurved_guide_3_0_aleft
#define aright mcccurved_guide_3_0_aright
#define atop mcccurved_guide_3_0_atop
#define abottom mcccurved_guide_3_0_abottom
#define wavy mcccurved_guide_3_0_wavy
#define wavy_z mcccurved_guide_3_0_wavy_z
#define wavy_tb mcccurved_guide_3_0_wavy_tb
#define wavy_lr mcccurved_guide_3_0_wavy_lr
#define chamfers mcccurved_guide_3_0_chamfers
#define chamfers_z mcccurved_guide_3_0_chamfers_z
#define chamfers_lr mcccurved_guide_3_0_chamfers_lr
#define chamfers_tb mcccurved_guide_3_0_chamfers_tb
#define nelements mcccurved_guide_3_0_nelements
#define nu mcccurved_guide_3_0_nu
#define phase mcccurved_guide_3_0_phase
#define reflect mcccurved_guide_3_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14167 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_4_0' [22]. */
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
#define w1 mcccurved_guide_4_0_w1
#define h1 mcccurved_guide_4_0_h1
#define w2 mcccurved_guide_4_0_w2
#define h2 mcccurved_guide_4_0_h2
#define l mcccurved_guide_4_0_l
#define R0 mcccurved_guide_4_0_R0
#define Qc mcccurved_guide_4_0_Qc
#define alpha mcccurved_guide_4_0_alpha
#define m mcccurved_guide_4_0_m
#define W mcccurved_guide_4_0_W
#define nslit mcccurved_guide_4_0_nslit
#define d mcccurved_guide_4_0_d
#define mleft mcccurved_guide_4_0_mleft
#define mright mcccurved_guide_4_0_mright
#define mtop mcccurved_guide_4_0_mtop
#define mbottom mcccurved_guide_4_0_mbottom
#define nhslit mcccurved_guide_4_0_nhslit
#define G mcccurved_guide_4_0_G
#define aleft mcccurved_guide_4_0_aleft
#define aright mcccurved_guide_4_0_aright
#define atop mcccurved_guide_4_0_atop
#define abottom mcccurved_guide_4_0_abottom
#define wavy mcccurved_guide_4_0_wavy
#define wavy_z mcccurved_guide_4_0_wavy_z
#define wavy_tb mcccurved_guide_4_0_wavy_tb
#define wavy_lr mcccurved_guide_4_0_wavy_lr
#define chamfers mcccurved_guide_4_0_chamfers
#define chamfers_z mcccurved_guide_4_0_chamfers_z
#define chamfers_lr mcccurved_guide_4_0_chamfers_lr
#define chamfers_tb mcccurved_guide_4_0_chamfers_tb
#define nelements mcccurved_guide_4_0_nelements
#define nu mcccurved_guide_4_0_nu
#define phase mcccurved_guide_4_0_phase
#define reflect mcccurved_guide_4_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14251 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_5_beforeChopper' [23]. */
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
#define w1 mcccurved_guide_5_beforeChopper_w1
#define h1 mcccurved_guide_5_beforeChopper_h1
#define w2 mcccurved_guide_5_beforeChopper_w2
#define h2 mcccurved_guide_5_beforeChopper_h2
#define l mcccurved_guide_5_beforeChopper_l
#define R0 mcccurved_guide_5_beforeChopper_R0
#define Qc mcccurved_guide_5_beforeChopper_Qc
#define alpha mcccurved_guide_5_beforeChopper_alpha
#define m mcccurved_guide_5_beforeChopper_m
#define W mcccurved_guide_5_beforeChopper_W
#define nslit mcccurved_guide_5_beforeChopper_nslit
#define d mcccurved_guide_5_beforeChopper_d
#define mleft mcccurved_guide_5_beforeChopper_mleft
#define mright mcccurved_guide_5_beforeChopper_mright
#define mtop mcccurved_guide_5_beforeChopper_mtop
#define mbottom mcccurved_guide_5_beforeChopper_mbottom
#define nhslit mcccurved_guide_5_beforeChopper_nhslit
#define G mcccurved_guide_5_beforeChopper_G
#define aleft mcccurved_guide_5_beforeChopper_aleft
#define aright mcccurved_guide_5_beforeChopper_aright
#define atop mcccurved_guide_5_beforeChopper_atop
#define abottom mcccurved_guide_5_beforeChopper_abottom
#define wavy mcccurved_guide_5_beforeChopper_wavy
#define wavy_z mcccurved_guide_5_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_5_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_5_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_5_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_5_beforeChopper_nelements
#define nu mcccurved_guide_5_beforeChopper_nu
#define phase mcccurved_guide_5_beforeChopper_phase
#define reflect mcccurved_guide_5_beforeChopper_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14335 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monBeforeFOC1' [24]. */
#define mccompcurname  L_monBeforeFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccL_monBeforeFOC1_nL
#define L_N mccL_monBeforeFOC1_L_N
#define L_p mccL_monBeforeFOC1_L_p
#define L_p2 mccL_monBeforeFOC1_L_p2
#define filename mccL_monBeforeFOC1_filename
#define xmin mccL_monBeforeFOC1_xmin
#define xmax mccL_monBeforeFOC1_xmax
#define ymin mccL_monBeforeFOC1_ymin
#define ymax mccL_monBeforeFOC1_ymax
#define xwidth mccL_monBeforeFOC1_xwidth
#define yheight mccL_monBeforeFOC1_yheight
#define Lmin mccL_monBeforeFOC1_Lmin
#define Lmax mccL_monBeforeFOC1_Lmax
#define restore_neutron mccL_monBeforeFOC1_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 14397 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFBeforeFOC1' [25]. */
#define mccompcurname  ToFBeforeFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 25
#define nt mccToFBeforeFOC1_nt
#define TOF_N mccToFBeforeFOC1_TOF_N
#define TOF_p mccToFBeforeFOC1_TOF_p
#define TOF_p2 mccToFBeforeFOC1_TOF_p2
#define t_min mccToFBeforeFOC1_t_min
#define t_max mccToFBeforeFOC1_t_max
#define delta_t mccToFBeforeFOC1_delta_t
#define filename mccToFBeforeFOC1_filename
#define xmin mccToFBeforeFOC1_xmin
#define xmax mccToFBeforeFOC1_xmax
#define ymin mccToFBeforeFOC1_ymin
#define ymax mccToFBeforeFOC1_ymax
#define xwidth mccToFBeforeFOC1_xwidth
#define yheight mccToFBeforeFOC1_yheight
#define tmin mccToFBeforeFOC1_tmin
#define tmax mccToFBeforeFOC1_tmax
#define dt mccToFBeforeFOC1_dt
#define restore_neutron mccToFBeforeFOC1_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 14443 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_beforeFOC1' [26]. */
#define mccompcurname  PSD_beforeFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 26
#define nx mccPSD_beforeFOC1_nx
#define ny mccPSD_beforeFOC1_ny
#define PSD_N mccPSD_beforeFOC1_PSD_N
#define PSD_p mccPSD_beforeFOC1_PSD_p
#define PSD_p2 mccPSD_beforeFOC1_PSD_p2
#define filename mccPSD_beforeFOC1_filename
#define xmin mccPSD_beforeFOC1_xmin
#define xmax mccPSD_beforeFOC1_xmax
#define ymin mccPSD_beforeFOC1_ymin
#define ymax mccPSD_beforeFOC1_ymax
#define xwidth mccPSD_beforeFOC1_xwidth
#define yheight mccPSD_beforeFOC1_yheight
#define restore_neutron mccPSD_beforeFOC1_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 14487 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'FOC1' [27]. */
#define mccompcurname  FOC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 27
#define Tg mccFOC1_Tg
#define To mccFOC1_To
#define delta_y mccFOC1_delta_y
#define height mccFOC1_height
#define omega mccFOC1_omega
#define theta_0 mccFOC1_theta_0
#define radius mccFOC1_radius
#define yheight mccFOC1_yheight
#define nu mccFOC1_nu
#define nslit mccFOC1_nslit
#define jitter mccFOC1_jitter
#define delay mccFOC1_delay
#define isfirst mccFOC1_isfirst
#define n_pulse mccFOC1_n_pulse
#define abs_out mccFOC1_abs_out
#define phase mccFOC1_phase
#define xwidth mccFOC1_xwidth
#define verbose mccFOC1_verbose
#line 63 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 14529 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_afterFOC1' [28]. */
#define mccompcurname  PSD_afterFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 28
#define nx mccPSD_afterFOC1_nx
#define ny mccPSD_afterFOC1_ny
#define PSD_N mccPSD_afterFOC1_PSD_N
#define PSD_p mccPSD_afterFOC1_PSD_p
#define PSD_p2 mccPSD_afterFOC1_PSD_p2
#define filename mccPSD_afterFOC1_filename
#define xmin mccPSD_afterFOC1_xmin
#define xmax mccPSD_afterFOC1_xmax
#define ymin mccPSD_afterFOC1_ymin
#define ymax mccPSD_afterFOC1_ymax
#define xwidth mccPSD_afterFOC1_xwidth
#define yheight mccPSD_afterFOC1_yheight
#define restore_neutron mccPSD_afterFOC1_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 14573 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFAfterFOC1' [29]. */
#define mccompcurname  ToFAfterFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 29
#define nt mccToFAfterFOC1_nt
#define TOF_N mccToFAfterFOC1_TOF_N
#define TOF_p mccToFAfterFOC1_TOF_p
#define TOF_p2 mccToFAfterFOC1_TOF_p2
#define t_min mccToFAfterFOC1_t_min
#define t_max mccToFAfterFOC1_t_max
#define delta_t mccToFAfterFOC1_delta_t
#define filename mccToFAfterFOC1_filename
#define xmin mccToFAfterFOC1_xmin
#define xmax mccToFAfterFOC1_xmax
#define ymin mccToFAfterFOC1_ymin
#define ymax mccToFAfterFOC1_ymax
#define xwidth mccToFAfterFOC1_xwidth
#define yheight mccToFAfterFOC1_yheight
#define tmin mccToFAfterFOC1_tmin
#define tmax mccToFAfterFOC1_tmax
#define dt mccToFAfterFOC1_dt
#define restore_neutron mccToFAfterFOC1_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 14618 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monAfterFOC1' [30]. */
#define mccompcurname  L_monAfterFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 30
#define nL mccL_monAfterFOC1_nL
#define L_N mccL_monAfterFOC1_L_N
#define L_p mccL_monAfterFOC1_L_p
#define L_p2 mccL_monAfterFOC1_L_p2
#define filename mccL_monAfterFOC1_filename
#define xmin mccL_monAfterFOC1_xmin
#define xmax mccL_monAfterFOC1_xmax
#define ymin mccL_monAfterFOC1_ymin
#define ymax mccL_monAfterFOC1_ymax
#define xwidth mccL_monAfterFOC1_xwidth
#define yheight mccL_monAfterFOC1_yheight
#define Lmin mccL_monAfterFOC1_Lmin
#define Lmax mccL_monAfterFOC1_Lmax
#define restore_neutron mccL_monAfterFOC1_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 14662 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_5_afterChopper' [31]. */
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
#define w1 mcccurved_guide_5_afterChopper_w1
#define h1 mcccurved_guide_5_afterChopper_h1
#define w2 mcccurved_guide_5_afterChopper_w2
#define h2 mcccurved_guide_5_afterChopper_h2
#define l mcccurved_guide_5_afterChopper_l
#define R0 mcccurved_guide_5_afterChopper_R0
#define Qc mcccurved_guide_5_afterChopper_Qc
#define alpha mcccurved_guide_5_afterChopper_alpha
#define m mcccurved_guide_5_afterChopper_m
#define W mcccurved_guide_5_afterChopper_W
#define nslit mcccurved_guide_5_afterChopper_nslit
#define d mcccurved_guide_5_afterChopper_d
#define mleft mcccurved_guide_5_afterChopper_mleft
#define mright mcccurved_guide_5_afterChopper_mright
#define mtop mcccurved_guide_5_afterChopper_mtop
#define mbottom mcccurved_guide_5_afterChopper_mbottom
#define nhslit mcccurved_guide_5_afterChopper_nhslit
#define G mcccurved_guide_5_afterChopper_G
#define aleft mcccurved_guide_5_afterChopper_aleft
#define aright mcccurved_guide_5_afterChopper_aright
#define atop mcccurved_guide_5_afterChopper_atop
#define abottom mcccurved_guide_5_afterChopper_abottom
#define wavy mcccurved_guide_5_afterChopper_wavy
#define wavy_z mcccurved_guide_5_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_5_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_afterChopper_wavy_lr
#define chamfers mcccurved_guide_5_afterChopper_chamfers
#define chamfers_z mcccurved_guide_5_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_afterChopper_chamfers_tb
#define nelements mcccurved_guide_5_afterChopper_nelements
#define nu mcccurved_guide_5_afterChopper_nu
#define phase mcccurved_guide_5_afterChopper_phase
#define reflect mcccurved_guide_5_afterChopper_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14724 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_6_0' [32]. */
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
#define w1 mcccurved_guide_6_0_w1
#define h1 mcccurved_guide_6_0_h1
#define w2 mcccurved_guide_6_0_w2
#define h2 mcccurved_guide_6_0_h2
#define l mcccurved_guide_6_0_l
#define R0 mcccurved_guide_6_0_R0
#define Qc mcccurved_guide_6_0_Qc
#define alpha mcccurved_guide_6_0_alpha
#define m mcccurved_guide_6_0_m
#define W mcccurved_guide_6_0_W
#define nslit mcccurved_guide_6_0_nslit
#define d mcccurved_guide_6_0_d
#define mleft mcccurved_guide_6_0_mleft
#define mright mcccurved_guide_6_0_mright
#define mtop mcccurved_guide_6_0_mtop
#define mbottom mcccurved_guide_6_0_mbottom
#define nhslit mcccurved_guide_6_0_nhslit
#define G mcccurved_guide_6_0_G
#define aleft mcccurved_guide_6_0_aleft
#define aright mcccurved_guide_6_0_aright
#define atop mcccurved_guide_6_0_atop
#define abottom mcccurved_guide_6_0_abottom
#define wavy mcccurved_guide_6_0_wavy
#define wavy_z mcccurved_guide_6_0_wavy_z
#define wavy_tb mcccurved_guide_6_0_wavy_tb
#define wavy_lr mcccurved_guide_6_0_wavy_lr
#define chamfers mcccurved_guide_6_0_chamfers
#define chamfers_z mcccurved_guide_6_0_chamfers_z
#define chamfers_lr mcccurved_guide_6_0_chamfers_lr
#define chamfers_tb mcccurved_guide_6_0_chamfers_tb
#define nelements mcccurved_guide_6_0_nelements
#define nu mcccurved_guide_6_0_nu
#define phase mcccurved_guide_6_0_phase
#define reflect mcccurved_guide_6_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14808 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_7_0' [33]. */
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
#define w1 mcccurved_guide_7_0_w1
#define h1 mcccurved_guide_7_0_h1
#define w2 mcccurved_guide_7_0_w2
#define h2 mcccurved_guide_7_0_h2
#define l mcccurved_guide_7_0_l
#define R0 mcccurved_guide_7_0_R0
#define Qc mcccurved_guide_7_0_Qc
#define alpha mcccurved_guide_7_0_alpha
#define m mcccurved_guide_7_0_m
#define W mcccurved_guide_7_0_W
#define nslit mcccurved_guide_7_0_nslit
#define d mcccurved_guide_7_0_d
#define mleft mcccurved_guide_7_0_mleft
#define mright mcccurved_guide_7_0_mright
#define mtop mcccurved_guide_7_0_mtop
#define mbottom mcccurved_guide_7_0_mbottom
#define nhslit mcccurved_guide_7_0_nhslit
#define G mcccurved_guide_7_0_G
#define aleft mcccurved_guide_7_0_aleft
#define aright mcccurved_guide_7_0_aright
#define atop mcccurved_guide_7_0_atop
#define abottom mcccurved_guide_7_0_abottom
#define wavy mcccurved_guide_7_0_wavy
#define wavy_z mcccurved_guide_7_0_wavy_z
#define wavy_tb mcccurved_guide_7_0_wavy_tb
#define wavy_lr mcccurved_guide_7_0_wavy_lr
#define chamfers mcccurved_guide_7_0_chamfers
#define chamfers_z mcccurved_guide_7_0_chamfers_z
#define chamfers_lr mcccurved_guide_7_0_chamfers_lr
#define chamfers_tb mcccurved_guide_7_0_chamfers_tb
#define nelements mcccurved_guide_7_0_nelements
#define nu mcccurved_guide_7_0_nu
#define phase mcccurved_guide_7_0_phase
#define reflect mcccurved_guide_7_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14892 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_8_0' [34]. */
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
#define w1 mcccurved_guide_8_0_w1
#define h1 mcccurved_guide_8_0_h1
#define w2 mcccurved_guide_8_0_w2
#define h2 mcccurved_guide_8_0_h2
#define l mcccurved_guide_8_0_l
#define R0 mcccurved_guide_8_0_R0
#define Qc mcccurved_guide_8_0_Qc
#define alpha mcccurved_guide_8_0_alpha
#define m mcccurved_guide_8_0_m
#define W mcccurved_guide_8_0_W
#define nslit mcccurved_guide_8_0_nslit
#define d mcccurved_guide_8_0_d
#define mleft mcccurved_guide_8_0_mleft
#define mright mcccurved_guide_8_0_mright
#define mtop mcccurved_guide_8_0_mtop
#define mbottom mcccurved_guide_8_0_mbottom
#define nhslit mcccurved_guide_8_0_nhslit
#define G mcccurved_guide_8_0_G
#define aleft mcccurved_guide_8_0_aleft
#define aright mcccurved_guide_8_0_aright
#define atop mcccurved_guide_8_0_atop
#define abottom mcccurved_guide_8_0_abottom
#define wavy mcccurved_guide_8_0_wavy
#define wavy_z mcccurved_guide_8_0_wavy_z
#define wavy_tb mcccurved_guide_8_0_wavy_tb
#define wavy_lr mcccurved_guide_8_0_wavy_lr
#define chamfers mcccurved_guide_8_0_chamfers
#define chamfers_z mcccurved_guide_8_0_chamfers_z
#define chamfers_lr mcccurved_guide_8_0_chamfers_lr
#define chamfers_tb mcccurved_guide_8_0_chamfers_tb
#define nelements mcccurved_guide_8_0_nelements
#define nu mcccurved_guide_8_0_nu
#define phase mcccurved_guide_8_0_phase
#define reflect mcccurved_guide_8_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14976 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_9_0' [35]. */
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
#define w1 mcccurved_guide_9_0_w1
#define h1 mcccurved_guide_9_0_h1
#define w2 mcccurved_guide_9_0_w2
#define h2 mcccurved_guide_9_0_h2
#define l mcccurved_guide_9_0_l
#define R0 mcccurved_guide_9_0_R0
#define Qc mcccurved_guide_9_0_Qc
#define alpha mcccurved_guide_9_0_alpha
#define m mcccurved_guide_9_0_m
#define W mcccurved_guide_9_0_W
#define nslit mcccurved_guide_9_0_nslit
#define d mcccurved_guide_9_0_d
#define mleft mcccurved_guide_9_0_mleft
#define mright mcccurved_guide_9_0_mright
#define mtop mcccurved_guide_9_0_mtop
#define mbottom mcccurved_guide_9_0_mbottom
#define nhslit mcccurved_guide_9_0_nhslit
#define G mcccurved_guide_9_0_G
#define aleft mcccurved_guide_9_0_aleft
#define aright mcccurved_guide_9_0_aright
#define atop mcccurved_guide_9_0_atop
#define abottom mcccurved_guide_9_0_abottom
#define wavy mcccurved_guide_9_0_wavy
#define wavy_z mcccurved_guide_9_0_wavy_z
#define wavy_tb mcccurved_guide_9_0_wavy_tb
#define wavy_lr mcccurved_guide_9_0_wavy_lr
#define chamfers mcccurved_guide_9_0_chamfers
#define chamfers_z mcccurved_guide_9_0_chamfers_z
#define chamfers_lr mcccurved_guide_9_0_chamfers_lr
#define chamfers_tb mcccurved_guide_9_0_chamfers_tb
#define nelements mcccurved_guide_9_0_nelements
#define nu mcccurved_guide_9_0_nu
#define phase mcccurved_guide_9_0_phase
#define reflect mcccurved_guide_9_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15060 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_10_0' [36]. */
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
#define w1 mcccurved_guide_10_0_w1
#define h1 mcccurved_guide_10_0_h1
#define w2 mcccurved_guide_10_0_w2
#define h2 mcccurved_guide_10_0_h2
#define l mcccurved_guide_10_0_l
#define R0 mcccurved_guide_10_0_R0
#define Qc mcccurved_guide_10_0_Qc
#define alpha mcccurved_guide_10_0_alpha
#define m mcccurved_guide_10_0_m
#define W mcccurved_guide_10_0_W
#define nslit mcccurved_guide_10_0_nslit
#define d mcccurved_guide_10_0_d
#define mleft mcccurved_guide_10_0_mleft
#define mright mcccurved_guide_10_0_mright
#define mtop mcccurved_guide_10_0_mtop
#define mbottom mcccurved_guide_10_0_mbottom
#define nhslit mcccurved_guide_10_0_nhslit
#define G mcccurved_guide_10_0_G
#define aleft mcccurved_guide_10_0_aleft
#define aright mcccurved_guide_10_0_aright
#define atop mcccurved_guide_10_0_atop
#define abottom mcccurved_guide_10_0_abottom
#define wavy mcccurved_guide_10_0_wavy
#define wavy_z mcccurved_guide_10_0_wavy_z
#define wavy_tb mcccurved_guide_10_0_wavy_tb
#define wavy_lr mcccurved_guide_10_0_wavy_lr
#define chamfers mcccurved_guide_10_0_chamfers
#define chamfers_z mcccurved_guide_10_0_chamfers_z
#define chamfers_lr mcccurved_guide_10_0_chamfers_lr
#define chamfers_tb mcccurved_guide_10_0_chamfers_tb
#define nelements mcccurved_guide_10_0_nelements
#define nu mcccurved_guide_10_0_nu
#define phase mcccurved_guide_10_0_phase
#define reflect mcccurved_guide_10_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15144 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_11_0' [37]. */
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
#define w1 mcccurved_guide_11_0_w1
#define h1 mcccurved_guide_11_0_h1
#define w2 mcccurved_guide_11_0_w2
#define h2 mcccurved_guide_11_0_h2
#define l mcccurved_guide_11_0_l
#define R0 mcccurved_guide_11_0_R0
#define Qc mcccurved_guide_11_0_Qc
#define alpha mcccurved_guide_11_0_alpha
#define m mcccurved_guide_11_0_m
#define W mcccurved_guide_11_0_W
#define nslit mcccurved_guide_11_0_nslit
#define d mcccurved_guide_11_0_d
#define mleft mcccurved_guide_11_0_mleft
#define mright mcccurved_guide_11_0_mright
#define mtop mcccurved_guide_11_0_mtop
#define mbottom mcccurved_guide_11_0_mbottom
#define nhslit mcccurved_guide_11_0_nhslit
#define G mcccurved_guide_11_0_G
#define aleft mcccurved_guide_11_0_aleft
#define aright mcccurved_guide_11_0_aright
#define atop mcccurved_guide_11_0_atop
#define abottom mcccurved_guide_11_0_abottom
#define wavy mcccurved_guide_11_0_wavy
#define wavy_z mcccurved_guide_11_0_wavy_z
#define wavy_tb mcccurved_guide_11_0_wavy_tb
#define wavy_lr mcccurved_guide_11_0_wavy_lr
#define chamfers mcccurved_guide_11_0_chamfers
#define chamfers_z mcccurved_guide_11_0_chamfers_z
#define chamfers_lr mcccurved_guide_11_0_chamfers_lr
#define chamfers_tb mcccurved_guide_11_0_chamfers_tb
#define nelements mcccurved_guide_11_0_nelements
#define nu mcccurved_guide_11_0_nu
#define phase mcccurved_guide_11_0_phase
#define reflect mcccurved_guide_11_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15228 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_12_0' [38]. */
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
#define w1 mcccurved_guide_12_0_w1
#define h1 mcccurved_guide_12_0_h1
#define w2 mcccurved_guide_12_0_w2
#define h2 mcccurved_guide_12_0_h2
#define l mcccurved_guide_12_0_l
#define R0 mcccurved_guide_12_0_R0
#define Qc mcccurved_guide_12_0_Qc
#define alpha mcccurved_guide_12_0_alpha
#define m mcccurved_guide_12_0_m
#define W mcccurved_guide_12_0_W
#define nslit mcccurved_guide_12_0_nslit
#define d mcccurved_guide_12_0_d
#define mleft mcccurved_guide_12_0_mleft
#define mright mcccurved_guide_12_0_mright
#define mtop mcccurved_guide_12_0_mtop
#define mbottom mcccurved_guide_12_0_mbottom
#define nhslit mcccurved_guide_12_0_nhslit
#define G mcccurved_guide_12_0_G
#define aleft mcccurved_guide_12_0_aleft
#define aright mcccurved_guide_12_0_aright
#define atop mcccurved_guide_12_0_atop
#define abottom mcccurved_guide_12_0_abottom
#define wavy mcccurved_guide_12_0_wavy
#define wavy_z mcccurved_guide_12_0_wavy_z
#define wavy_tb mcccurved_guide_12_0_wavy_tb
#define wavy_lr mcccurved_guide_12_0_wavy_lr
#define chamfers mcccurved_guide_12_0_chamfers
#define chamfers_z mcccurved_guide_12_0_chamfers_z
#define chamfers_lr mcccurved_guide_12_0_chamfers_lr
#define chamfers_tb mcccurved_guide_12_0_chamfers_tb
#define nelements mcccurved_guide_12_0_nelements
#define nu mcccurved_guide_12_0_nu
#define phase mcccurved_guide_12_0_phase
#define reflect mcccurved_guide_12_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15312 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_13_0' [39]. */
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
#define w1 mcccurved_guide_13_0_w1
#define h1 mcccurved_guide_13_0_h1
#define w2 mcccurved_guide_13_0_w2
#define h2 mcccurved_guide_13_0_h2
#define l mcccurved_guide_13_0_l
#define R0 mcccurved_guide_13_0_R0
#define Qc mcccurved_guide_13_0_Qc
#define alpha mcccurved_guide_13_0_alpha
#define m mcccurved_guide_13_0_m
#define W mcccurved_guide_13_0_W
#define nslit mcccurved_guide_13_0_nslit
#define d mcccurved_guide_13_0_d
#define mleft mcccurved_guide_13_0_mleft
#define mright mcccurved_guide_13_0_mright
#define mtop mcccurved_guide_13_0_mtop
#define mbottom mcccurved_guide_13_0_mbottom
#define nhslit mcccurved_guide_13_0_nhslit
#define G mcccurved_guide_13_0_G
#define aleft mcccurved_guide_13_0_aleft
#define aright mcccurved_guide_13_0_aright
#define atop mcccurved_guide_13_0_atop
#define abottom mcccurved_guide_13_0_abottom
#define wavy mcccurved_guide_13_0_wavy
#define wavy_z mcccurved_guide_13_0_wavy_z
#define wavy_tb mcccurved_guide_13_0_wavy_tb
#define wavy_lr mcccurved_guide_13_0_wavy_lr
#define chamfers mcccurved_guide_13_0_chamfers
#define chamfers_z mcccurved_guide_13_0_chamfers_z
#define chamfers_lr mcccurved_guide_13_0_chamfers_lr
#define chamfers_tb mcccurved_guide_13_0_chamfers_tb
#define nelements mcccurved_guide_13_0_nelements
#define nu mcccurved_guide_13_0_nu
#define phase mcccurved_guide_13_0_phase
#define reflect mcccurved_guide_13_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15396 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_14_0' [40]. */
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
#define w1 mcccurved_guide_14_0_w1
#define h1 mcccurved_guide_14_0_h1
#define w2 mcccurved_guide_14_0_w2
#define h2 mcccurved_guide_14_0_h2
#define l mcccurved_guide_14_0_l
#define R0 mcccurved_guide_14_0_R0
#define Qc mcccurved_guide_14_0_Qc
#define alpha mcccurved_guide_14_0_alpha
#define m mcccurved_guide_14_0_m
#define W mcccurved_guide_14_0_W
#define nslit mcccurved_guide_14_0_nslit
#define d mcccurved_guide_14_0_d
#define mleft mcccurved_guide_14_0_mleft
#define mright mcccurved_guide_14_0_mright
#define mtop mcccurved_guide_14_0_mtop
#define mbottom mcccurved_guide_14_0_mbottom
#define nhslit mcccurved_guide_14_0_nhslit
#define G mcccurved_guide_14_0_G
#define aleft mcccurved_guide_14_0_aleft
#define aright mcccurved_guide_14_0_aright
#define atop mcccurved_guide_14_0_atop
#define abottom mcccurved_guide_14_0_abottom
#define wavy mcccurved_guide_14_0_wavy
#define wavy_z mcccurved_guide_14_0_wavy_z
#define wavy_tb mcccurved_guide_14_0_wavy_tb
#define wavy_lr mcccurved_guide_14_0_wavy_lr
#define chamfers mcccurved_guide_14_0_chamfers
#define chamfers_z mcccurved_guide_14_0_chamfers_z
#define chamfers_lr mcccurved_guide_14_0_chamfers_lr
#define chamfers_tb mcccurved_guide_14_0_chamfers_tb
#define nelements mcccurved_guide_14_0_nelements
#define nu mcccurved_guide_14_0_nu
#define phase mcccurved_guide_14_0_phase
#define reflect mcccurved_guide_14_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15480 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_15_0' [41]. */
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
#define w1 mcccurved_guide_15_0_w1
#define h1 mcccurved_guide_15_0_h1
#define w2 mcccurved_guide_15_0_w2
#define h2 mcccurved_guide_15_0_h2
#define l mcccurved_guide_15_0_l
#define R0 mcccurved_guide_15_0_R0
#define Qc mcccurved_guide_15_0_Qc
#define alpha mcccurved_guide_15_0_alpha
#define m mcccurved_guide_15_0_m
#define W mcccurved_guide_15_0_W
#define nslit mcccurved_guide_15_0_nslit
#define d mcccurved_guide_15_0_d
#define mleft mcccurved_guide_15_0_mleft
#define mright mcccurved_guide_15_0_mright
#define mtop mcccurved_guide_15_0_mtop
#define mbottom mcccurved_guide_15_0_mbottom
#define nhslit mcccurved_guide_15_0_nhslit
#define G mcccurved_guide_15_0_G
#define aleft mcccurved_guide_15_0_aleft
#define aright mcccurved_guide_15_0_aright
#define atop mcccurved_guide_15_0_atop
#define abottom mcccurved_guide_15_0_abottom
#define wavy mcccurved_guide_15_0_wavy
#define wavy_z mcccurved_guide_15_0_wavy_z
#define wavy_tb mcccurved_guide_15_0_wavy_tb
#define wavy_lr mcccurved_guide_15_0_wavy_lr
#define chamfers mcccurved_guide_15_0_chamfers
#define chamfers_z mcccurved_guide_15_0_chamfers_z
#define chamfers_lr mcccurved_guide_15_0_chamfers_lr
#define chamfers_tb mcccurved_guide_15_0_chamfers_tb
#define nelements mcccurved_guide_15_0_nelements
#define nu mcccurved_guide_15_0_nu
#define phase mcccurved_guide_15_0_phase
#define reflect mcccurved_guide_15_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15564 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_16_0' [42]. */
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
#define w1 mcccurved_guide_16_0_w1
#define h1 mcccurved_guide_16_0_h1
#define w2 mcccurved_guide_16_0_w2
#define h2 mcccurved_guide_16_0_h2
#define l mcccurved_guide_16_0_l
#define R0 mcccurved_guide_16_0_R0
#define Qc mcccurved_guide_16_0_Qc
#define alpha mcccurved_guide_16_0_alpha
#define m mcccurved_guide_16_0_m
#define W mcccurved_guide_16_0_W
#define nslit mcccurved_guide_16_0_nslit
#define d mcccurved_guide_16_0_d
#define mleft mcccurved_guide_16_0_mleft
#define mright mcccurved_guide_16_0_mright
#define mtop mcccurved_guide_16_0_mtop
#define mbottom mcccurved_guide_16_0_mbottom
#define nhslit mcccurved_guide_16_0_nhslit
#define G mcccurved_guide_16_0_G
#define aleft mcccurved_guide_16_0_aleft
#define aright mcccurved_guide_16_0_aright
#define atop mcccurved_guide_16_0_atop
#define abottom mcccurved_guide_16_0_abottom
#define wavy mcccurved_guide_16_0_wavy
#define wavy_z mcccurved_guide_16_0_wavy_z
#define wavy_tb mcccurved_guide_16_0_wavy_tb
#define wavy_lr mcccurved_guide_16_0_wavy_lr
#define chamfers mcccurved_guide_16_0_chamfers
#define chamfers_z mcccurved_guide_16_0_chamfers_z
#define chamfers_lr mcccurved_guide_16_0_chamfers_lr
#define chamfers_tb mcccurved_guide_16_0_chamfers_tb
#define nelements mcccurved_guide_16_0_nelements
#define nu mcccurved_guide_16_0_nu
#define phase mcccurved_guide_16_0_phase
#define reflect mcccurved_guide_16_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15648 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_17_0' [43]. */
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
#define w1 mcccurved_guide_17_0_w1
#define h1 mcccurved_guide_17_0_h1
#define w2 mcccurved_guide_17_0_w2
#define h2 mcccurved_guide_17_0_h2
#define l mcccurved_guide_17_0_l
#define R0 mcccurved_guide_17_0_R0
#define Qc mcccurved_guide_17_0_Qc
#define alpha mcccurved_guide_17_0_alpha
#define m mcccurved_guide_17_0_m
#define W mcccurved_guide_17_0_W
#define nslit mcccurved_guide_17_0_nslit
#define d mcccurved_guide_17_0_d
#define mleft mcccurved_guide_17_0_mleft
#define mright mcccurved_guide_17_0_mright
#define mtop mcccurved_guide_17_0_mtop
#define mbottom mcccurved_guide_17_0_mbottom
#define nhslit mcccurved_guide_17_0_nhslit
#define G mcccurved_guide_17_0_G
#define aleft mcccurved_guide_17_0_aleft
#define aright mcccurved_guide_17_0_aright
#define atop mcccurved_guide_17_0_atop
#define abottom mcccurved_guide_17_0_abottom
#define wavy mcccurved_guide_17_0_wavy
#define wavy_z mcccurved_guide_17_0_wavy_z
#define wavy_tb mcccurved_guide_17_0_wavy_tb
#define wavy_lr mcccurved_guide_17_0_wavy_lr
#define chamfers mcccurved_guide_17_0_chamfers
#define chamfers_z mcccurved_guide_17_0_chamfers_z
#define chamfers_lr mcccurved_guide_17_0_chamfers_lr
#define chamfers_tb mcccurved_guide_17_0_chamfers_tb
#define nelements mcccurved_guide_17_0_nelements
#define nu mcccurved_guide_17_0_nu
#define phase mcccurved_guide_17_0_phase
#define reflect mcccurved_guide_17_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15732 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_18_beforeChopper' [44]. */
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
#define w1 mcccurved_guide_18_beforeChopper_w1
#define h1 mcccurved_guide_18_beforeChopper_h1
#define w2 mcccurved_guide_18_beforeChopper_w2
#define h2 mcccurved_guide_18_beforeChopper_h2
#define l mcccurved_guide_18_beforeChopper_l
#define R0 mcccurved_guide_18_beforeChopper_R0
#define Qc mcccurved_guide_18_beforeChopper_Qc
#define alpha mcccurved_guide_18_beforeChopper_alpha
#define m mcccurved_guide_18_beforeChopper_m
#define W mcccurved_guide_18_beforeChopper_W
#define nslit mcccurved_guide_18_beforeChopper_nslit
#define d mcccurved_guide_18_beforeChopper_d
#define mleft mcccurved_guide_18_beforeChopper_mleft
#define mright mcccurved_guide_18_beforeChopper_mright
#define mtop mcccurved_guide_18_beforeChopper_mtop
#define mbottom mcccurved_guide_18_beforeChopper_mbottom
#define nhslit mcccurved_guide_18_beforeChopper_nhslit
#define G mcccurved_guide_18_beforeChopper_G
#define aleft mcccurved_guide_18_beforeChopper_aleft
#define aright mcccurved_guide_18_beforeChopper_aright
#define atop mcccurved_guide_18_beforeChopper_atop
#define abottom mcccurved_guide_18_beforeChopper_abottom
#define wavy mcccurved_guide_18_beforeChopper_wavy
#define wavy_z mcccurved_guide_18_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_18_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_18_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_18_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_18_beforeChopper_nelements
#define nu mcccurved_guide_18_beforeChopper_nu
#define phase mcccurved_guide_18_beforeChopper_phase
#define reflect mcccurved_guide_18_beforeChopper_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15816 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monBeforeFOC2' [45]. */
#define mccompcurname  L_monBeforeFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 45
#define nL mccL_monBeforeFOC2_nL
#define L_N mccL_monBeforeFOC2_L_N
#define L_p mccL_monBeforeFOC2_L_p
#define L_p2 mccL_monBeforeFOC2_L_p2
#define filename mccL_monBeforeFOC2_filename
#define xmin mccL_monBeforeFOC2_xmin
#define xmax mccL_monBeforeFOC2_xmax
#define ymin mccL_monBeforeFOC2_ymin
#define ymax mccL_monBeforeFOC2_ymax
#define xwidth mccL_monBeforeFOC2_xwidth
#define yheight mccL_monBeforeFOC2_yheight
#define Lmin mccL_monBeforeFOC2_Lmin
#define Lmax mccL_monBeforeFOC2_Lmax
#define restore_neutron mccL_monBeforeFOC2_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 15878 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFBeforeFOC2' [46]. */
#define mccompcurname  ToFBeforeFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccToFBeforeFOC2_nt
#define TOF_N mccToFBeforeFOC2_TOF_N
#define TOF_p mccToFBeforeFOC2_TOF_p
#define TOF_p2 mccToFBeforeFOC2_TOF_p2
#define t_min mccToFBeforeFOC2_t_min
#define t_max mccToFBeforeFOC2_t_max
#define delta_t mccToFBeforeFOC2_delta_t
#define filename mccToFBeforeFOC2_filename
#define xmin mccToFBeforeFOC2_xmin
#define xmax mccToFBeforeFOC2_xmax
#define ymin mccToFBeforeFOC2_ymin
#define ymax mccToFBeforeFOC2_ymax
#define xwidth mccToFBeforeFOC2_xwidth
#define yheight mccToFBeforeFOC2_yheight
#define tmin mccToFBeforeFOC2_tmin
#define tmax mccToFBeforeFOC2_tmax
#define dt mccToFBeforeFOC2_dt
#define restore_neutron mccToFBeforeFOC2_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 15924 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_beforeFOC2' [47]. */
#define mccompcurname  PSD_beforeFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 47
#define nx mccPSD_beforeFOC2_nx
#define ny mccPSD_beforeFOC2_ny
#define PSD_N mccPSD_beforeFOC2_PSD_N
#define PSD_p mccPSD_beforeFOC2_PSD_p
#define PSD_p2 mccPSD_beforeFOC2_PSD_p2
#define filename mccPSD_beforeFOC2_filename
#define xmin mccPSD_beforeFOC2_xmin
#define xmax mccPSD_beforeFOC2_xmax
#define ymin mccPSD_beforeFOC2_ymin
#define ymax mccPSD_beforeFOC2_ymax
#define xwidth mccPSD_beforeFOC2_xwidth
#define yheight mccPSD_beforeFOC2_yheight
#define restore_neutron mccPSD_beforeFOC2_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 15968 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'FOC2' [48]. */
#define mccompcurname  FOC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 48
#define Tg mccFOC2_Tg
#define To mccFOC2_To
#define delta_y mccFOC2_delta_y
#define height mccFOC2_height
#define omega mccFOC2_omega
#define theta_0 mccFOC2_theta_0
#define radius mccFOC2_radius
#define yheight mccFOC2_yheight
#define nu mccFOC2_nu
#define nslit mccFOC2_nslit
#define jitter mccFOC2_jitter
#define delay mccFOC2_delay
#define isfirst mccFOC2_isfirst
#define n_pulse mccFOC2_n_pulse
#define abs_out mccFOC2_abs_out
#define phase mccFOC2_phase
#define xwidth mccFOC2_xwidth
#define verbose mccFOC2_verbose
#line 63 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 16010 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_afterFOC2' [49]. */
#define mccompcurname  PSD_afterFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccPSD_afterFOC2_nx
#define ny mccPSD_afterFOC2_ny
#define PSD_N mccPSD_afterFOC2_PSD_N
#define PSD_p mccPSD_afterFOC2_PSD_p
#define PSD_p2 mccPSD_afterFOC2_PSD_p2
#define filename mccPSD_afterFOC2_filename
#define xmin mccPSD_afterFOC2_xmin
#define xmax mccPSD_afterFOC2_xmax
#define ymin mccPSD_afterFOC2_ymin
#define ymax mccPSD_afterFOC2_ymax
#define xwidth mccPSD_afterFOC2_xwidth
#define yheight mccPSD_afterFOC2_yheight
#define restore_neutron mccPSD_afterFOC2_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 16054 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFAfterFOC2' [50]. */
#define mccompcurname  ToFAfterFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 50
#define nt mccToFAfterFOC2_nt
#define TOF_N mccToFAfterFOC2_TOF_N
#define TOF_p mccToFAfterFOC2_TOF_p
#define TOF_p2 mccToFAfterFOC2_TOF_p2
#define t_min mccToFAfterFOC2_t_min
#define t_max mccToFAfterFOC2_t_max
#define delta_t mccToFAfterFOC2_delta_t
#define filename mccToFAfterFOC2_filename
#define xmin mccToFAfterFOC2_xmin
#define xmax mccToFAfterFOC2_xmax
#define ymin mccToFAfterFOC2_ymin
#define ymax mccToFAfterFOC2_ymax
#define xwidth mccToFAfterFOC2_xwidth
#define yheight mccToFAfterFOC2_yheight
#define tmin mccToFAfterFOC2_tmin
#define tmax mccToFAfterFOC2_tmax
#define dt mccToFAfterFOC2_dt
#define restore_neutron mccToFAfterFOC2_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 16099 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monAfterFOC2' [51]. */
#define mccompcurname  L_monAfterFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mccL_monAfterFOC2_nL
#define L_N mccL_monAfterFOC2_L_N
#define L_p mccL_monAfterFOC2_L_p
#define L_p2 mccL_monAfterFOC2_L_p2
#define filename mccL_monAfterFOC2_filename
#define xmin mccL_monAfterFOC2_xmin
#define xmax mccL_monAfterFOC2_xmax
#define ymin mccL_monAfterFOC2_ymin
#define ymax mccL_monAfterFOC2_ymax
#define xwidth mccL_monAfterFOC2_xwidth
#define yheight mccL_monAfterFOC2_yheight
#define Lmin mccL_monAfterFOC2_Lmin
#define Lmax mccL_monAfterFOC2_Lmax
#define restore_neutron mccL_monAfterFOC2_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 16143 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_18_afterChopper' [52]. */
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
#define w1 mcccurved_guide_18_afterChopper_w1
#define h1 mcccurved_guide_18_afterChopper_h1
#define w2 mcccurved_guide_18_afterChopper_w2
#define h2 mcccurved_guide_18_afterChopper_h2
#define l mcccurved_guide_18_afterChopper_l
#define R0 mcccurved_guide_18_afterChopper_R0
#define Qc mcccurved_guide_18_afterChopper_Qc
#define alpha mcccurved_guide_18_afterChopper_alpha
#define m mcccurved_guide_18_afterChopper_m
#define W mcccurved_guide_18_afterChopper_W
#define nslit mcccurved_guide_18_afterChopper_nslit
#define d mcccurved_guide_18_afterChopper_d
#define mleft mcccurved_guide_18_afterChopper_mleft
#define mright mcccurved_guide_18_afterChopper_mright
#define mtop mcccurved_guide_18_afterChopper_mtop
#define mbottom mcccurved_guide_18_afterChopper_mbottom
#define nhslit mcccurved_guide_18_afterChopper_nhslit
#define G mcccurved_guide_18_afterChopper_G
#define aleft mcccurved_guide_18_afterChopper_aleft
#define aright mcccurved_guide_18_afterChopper_aright
#define atop mcccurved_guide_18_afterChopper_atop
#define abottom mcccurved_guide_18_afterChopper_abottom
#define wavy mcccurved_guide_18_afterChopper_wavy
#define wavy_z mcccurved_guide_18_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_18_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_afterChopper_wavy_lr
#define chamfers mcccurved_guide_18_afterChopper_chamfers
#define chamfers_z mcccurved_guide_18_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_afterChopper_chamfers_tb
#define nelements mcccurved_guide_18_afterChopper_nelements
#define nu mcccurved_guide_18_afterChopper_nu
#define phase mcccurved_guide_18_afterChopper_phase
#define reflect mcccurved_guide_18_afterChopper_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16205 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_19_0' [53]. */
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
#define w1 mcccurved_guide_19_0_w1
#define h1 mcccurved_guide_19_0_h1
#define w2 mcccurved_guide_19_0_w2
#define h2 mcccurved_guide_19_0_h2
#define l mcccurved_guide_19_0_l
#define R0 mcccurved_guide_19_0_R0
#define Qc mcccurved_guide_19_0_Qc
#define alpha mcccurved_guide_19_0_alpha
#define m mcccurved_guide_19_0_m
#define W mcccurved_guide_19_0_W
#define nslit mcccurved_guide_19_0_nslit
#define d mcccurved_guide_19_0_d
#define mleft mcccurved_guide_19_0_mleft
#define mright mcccurved_guide_19_0_mright
#define mtop mcccurved_guide_19_0_mtop
#define mbottom mcccurved_guide_19_0_mbottom
#define nhslit mcccurved_guide_19_0_nhslit
#define G mcccurved_guide_19_0_G
#define aleft mcccurved_guide_19_0_aleft
#define aright mcccurved_guide_19_0_aright
#define atop mcccurved_guide_19_0_atop
#define abottom mcccurved_guide_19_0_abottom
#define wavy mcccurved_guide_19_0_wavy
#define wavy_z mcccurved_guide_19_0_wavy_z
#define wavy_tb mcccurved_guide_19_0_wavy_tb
#define wavy_lr mcccurved_guide_19_0_wavy_lr
#define chamfers mcccurved_guide_19_0_chamfers
#define chamfers_z mcccurved_guide_19_0_chamfers_z
#define chamfers_lr mcccurved_guide_19_0_chamfers_lr
#define chamfers_tb mcccurved_guide_19_0_chamfers_tb
#define nelements mcccurved_guide_19_0_nelements
#define nu mcccurved_guide_19_0_nu
#define phase mcccurved_guide_19_0_phase
#define reflect mcccurved_guide_19_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16289 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_20_0' [54]. */
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
#define w1 mcccurved_guide_20_0_w1
#define h1 mcccurved_guide_20_0_h1
#define w2 mcccurved_guide_20_0_w2
#define h2 mcccurved_guide_20_0_h2
#define l mcccurved_guide_20_0_l
#define R0 mcccurved_guide_20_0_R0
#define Qc mcccurved_guide_20_0_Qc
#define alpha mcccurved_guide_20_0_alpha
#define m mcccurved_guide_20_0_m
#define W mcccurved_guide_20_0_W
#define nslit mcccurved_guide_20_0_nslit
#define d mcccurved_guide_20_0_d
#define mleft mcccurved_guide_20_0_mleft
#define mright mcccurved_guide_20_0_mright
#define mtop mcccurved_guide_20_0_mtop
#define mbottom mcccurved_guide_20_0_mbottom
#define nhslit mcccurved_guide_20_0_nhslit
#define G mcccurved_guide_20_0_G
#define aleft mcccurved_guide_20_0_aleft
#define aright mcccurved_guide_20_0_aright
#define atop mcccurved_guide_20_0_atop
#define abottom mcccurved_guide_20_0_abottom
#define wavy mcccurved_guide_20_0_wavy
#define wavy_z mcccurved_guide_20_0_wavy_z
#define wavy_tb mcccurved_guide_20_0_wavy_tb
#define wavy_lr mcccurved_guide_20_0_wavy_lr
#define chamfers mcccurved_guide_20_0_chamfers
#define chamfers_z mcccurved_guide_20_0_chamfers_z
#define chamfers_lr mcccurved_guide_20_0_chamfers_lr
#define chamfers_tb mcccurved_guide_20_0_chamfers_tb
#define nelements mcccurved_guide_20_0_nelements
#define nu mcccurved_guide_20_0_nu
#define phase mcccurved_guide_20_0_phase
#define reflect mcccurved_guide_20_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16373 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_21_0' [55]. */
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
#define w1 mcccurved_guide_21_0_w1
#define h1 mcccurved_guide_21_0_h1
#define w2 mcccurved_guide_21_0_w2
#define h2 mcccurved_guide_21_0_h2
#define l mcccurved_guide_21_0_l
#define R0 mcccurved_guide_21_0_R0
#define Qc mcccurved_guide_21_0_Qc
#define alpha mcccurved_guide_21_0_alpha
#define m mcccurved_guide_21_0_m
#define W mcccurved_guide_21_0_W
#define nslit mcccurved_guide_21_0_nslit
#define d mcccurved_guide_21_0_d
#define mleft mcccurved_guide_21_0_mleft
#define mright mcccurved_guide_21_0_mright
#define mtop mcccurved_guide_21_0_mtop
#define mbottom mcccurved_guide_21_0_mbottom
#define nhslit mcccurved_guide_21_0_nhslit
#define G mcccurved_guide_21_0_G
#define aleft mcccurved_guide_21_0_aleft
#define aright mcccurved_guide_21_0_aright
#define atop mcccurved_guide_21_0_atop
#define abottom mcccurved_guide_21_0_abottom
#define wavy mcccurved_guide_21_0_wavy
#define wavy_z mcccurved_guide_21_0_wavy_z
#define wavy_tb mcccurved_guide_21_0_wavy_tb
#define wavy_lr mcccurved_guide_21_0_wavy_lr
#define chamfers mcccurved_guide_21_0_chamfers
#define chamfers_z mcccurved_guide_21_0_chamfers_z
#define chamfers_lr mcccurved_guide_21_0_chamfers_lr
#define chamfers_tb mcccurved_guide_21_0_chamfers_tb
#define nelements mcccurved_guide_21_0_nelements
#define nu mcccurved_guide_21_0_nu
#define phase mcccurved_guide_21_0_phase
#define reflect mcccurved_guide_21_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16457 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_22_0' [56]. */
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
#define w1 mcccurved_guide_22_0_w1
#define h1 mcccurved_guide_22_0_h1
#define w2 mcccurved_guide_22_0_w2
#define h2 mcccurved_guide_22_0_h2
#define l mcccurved_guide_22_0_l
#define R0 mcccurved_guide_22_0_R0
#define Qc mcccurved_guide_22_0_Qc
#define alpha mcccurved_guide_22_0_alpha
#define m mcccurved_guide_22_0_m
#define W mcccurved_guide_22_0_W
#define nslit mcccurved_guide_22_0_nslit
#define d mcccurved_guide_22_0_d
#define mleft mcccurved_guide_22_0_mleft
#define mright mcccurved_guide_22_0_mright
#define mtop mcccurved_guide_22_0_mtop
#define mbottom mcccurved_guide_22_0_mbottom
#define nhslit mcccurved_guide_22_0_nhslit
#define G mcccurved_guide_22_0_G
#define aleft mcccurved_guide_22_0_aleft
#define aright mcccurved_guide_22_0_aright
#define atop mcccurved_guide_22_0_atop
#define abottom mcccurved_guide_22_0_abottom
#define wavy mcccurved_guide_22_0_wavy
#define wavy_z mcccurved_guide_22_0_wavy_z
#define wavy_tb mcccurved_guide_22_0_wavy_tb
#define wavy_lr mcccurved_guide_22_0_wavy_lr
#define chamfers mcccurved_guide_22_0_chamfers
#define chamfers_z mcccurved_guide_22_0_chamfers_z
#define chamfers_lr mcccurved_guide_22_0_chamfers_lr
#define chamfers_tb mcccurved_guide_22_0_chamfers_tb
#define nelements mcccurved_guide_22_0_nelements
#define nu mcccurved_guide_22_0_nu
#define phase mcccurved_guide_22_0_phase
#define reflect mcccurved_guide_22_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16541 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_23_0' [57]. */
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
#define w1 mcccurved_guide_23_0_w1
#define h1 mcccurved_guide_23_0_h1
#define w2 mcccurved_guide_23_0_w2
#define h2 mcccurved_guide_23_0_h2
#define l mcccurved_guide_23_0_l
#define R0 mcccurved_guide_23_0_R0
#define Qc mcccurved_guide_23_0_Qc
#define alpha mcccurved_guide_23_0_alpha
#define m mcccurved_guide_23_0_m
#define W mcccurved_guide_23_0_W
#define nslit mcccurved_guide_23_0_nslit
#define d mcccurved_guide_23_0_d
#define mleft mcccurved_guide_23_0_mleft
#define mright mcccurved_guide_23_0_mright
#define mtop mcccurved_guide_23_0_mtop
#define mbottom mcccurved_guide_23_0_mbottom
#define nhslit mcccurved_guide_23_0_nhslit
#define G mcccurved_guide_23_0_G
#define aleft mcccurved_guide_23_0_aleft
#define aright mcccurved_guide_23_0_aright
#define atop mcccurved_guide_23_0_atop
#define abottom mcccurved_guide_23_0_abottom
#define wavy mcccurved_guide_23_0_wavy
#define wavy_z mcccurved_guide_23_0_wavy_z
#define wavy_tb mcccurved_guide_23_0_wavy_tb
#define wavy_lr mcccurved_guide_23_0_wavy_lr
#define chamfers mcccurved_guide_23_0_chamfers
#define chamfers_z mcccurved_guide_23_0_chamfers_z
#define chamfers_lr mcccurved_guide_23_0_chamfers_lr
#define chamfers_tb mcccurved_guide_23_0_chamfers_tb
#define nelements mcccurved_guide_23_0_nelements
#define nu mcccurved_guide_23_0_nu
#define phase mcccurved_guide_23_0_phase
#define reflect mcccurved_guide_23_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16625 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_24_0' [58]. */
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
#define w1 mcccurved_guide_24_0_w1
#define h1 mcccurved_guide_24_0_h1
#define w2 mcccurved_guide_24_0_w2
#define h2 mcccurved_guide_24_0_h2
#define l mcccurved_guide_24_0_l
#define R0 mcccurved_guide_24_0_R0
#define Qc mcccurved_guide_24_0_Qc
#define alpha mcccurved_guide_24_0_alpha
#define m mcccurved_guide_24_0_m
#define W mcccurved_guide_24_0_W
#define nslit mcccurved_guide_24_0_nslit
#define d mcccurved_guide_24_0_d
#define mleft mcccurved_guide_24_0_mleft
#define mright mcccurved_guide_24_0_mright
#define mtop mcccurved_guide_24_0_mtop
#define mbottom mcccurved_guide_24_0_mbottom
#define nhslit mcccurved_guide_24_0_nhslit
#define G mcccurved_guide_24_0_G
#define aleft mcccurved_guide_24_0_aleft
#define aright mcccurved_guide_24_0_aright
#define atop mcccurved_guide_24_0_atop
#define abottom mcccurved_guide_24_0_abottom
#define wavy mcccurved_guide_24_0_wavy
#define wavy_z mcccurved_guide_24_0_wavy_z
#define wavy_tb mcccurved_guide_24_0_wavy_tb
#define wavy_lr mcccurved_guide_24_0_wavy_lr
#define chamfers mcccurved_guide_24_0_chamfers
#define chamfers_z mcccurved_guide_24_0_chamfers_z
#define chamfers_lr mcccurved_guide_24_0_chamfers_lr
#define chamfers_tb mcccurved_guide_24_0_chamfers_tb
#define nelements mcccurved_guide_24_0_nelements
#define nu mcccurved_guide_24_0_nu
#define phase mcccurved_guide_24_0_phase
#define reflect mcccurved_guide_24_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16709 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_25_0' [59]. */
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
#define w1 mcccurved_guide_25_0_w1
#define h1 mcccurved_guide_25_0_h1
#define w2 mcccurved_guide_25_0_w2
#define h2 mcccurved_guide_25_0_h2
#define l mcccurved_guide_25_0_l
#define R0 mcccurved_guide_25_0_R0
#define Qc mcccurved_guide_25_0_Qc
#define alpha mcccurved_guide_25_0_alpha
#define m mcccurved_guide_25_0_m
#define W mcccurved_guide_25_0_W
#define nslit mcccurved_guide_25_0_nslit
#define d mcccurved_guide_25_0_d
#define mleft mcccurved_guide_25_0_mleft
#define mright mcccurved_guide_25_0_mright
#define mtop mcccurved_guide_25_0_mtop
#define mbottom mcccurved_guide_25_0_mbottom
#define nhslit mcccurved_guide_25_0_nhslit
#define G mcccurved_guide_25_0_G
#define aleft mcccurved_guide_25_0_aleft
#define aright mcccurved_guide_25_0_aright
#define atop mcccurved_guide_25_0_atop
#define abottom mcccurved_guide_25_0_abottom
#define wavy mcccurved_guide_25_0_wavy
#define wavy_z mcccurved_guide_25_0_wavy_z
#define wavy_tb mcccurved_guide_25_0_wavy_tb
#define wavy_lr mcccurved_guide_25_0_wavy_lr
#define chamfers mcccurved_guide_25_0_chamfers
#define chamfers_z mcccurved_guide_25_0_chamfers_z
#define chamfers_lr mcccurved_guide_25_0_chamfers_lr
#define chamfers_tb mcccurved_guide_25_0_chamfers_tb
#define nelements mcccurved_guide_25_0_nelements
#define nu mcccurved_guide_25_0_nu
#define phase mcccurved_guide_25_0_phase
#define reflect mcccurved_guide_25_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16793 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_26_0' [60]. */
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 60
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
#define w1 mcccurved_guide_26_0_w1
#define h1 mcccurved_guide_26_0_h1
#define w2 mcccurved_guide_26_0_w2
#define h2 mcccurved_guide_26_0_h2
#define l mcccurved_guide_26_0_l
#define R0 mcccurved_guide_26_0_R0
#define Qc mcccurved_guide_26_0_Qc
#define alpha mcccurved_guide_26_0_alpha
#define m mcccurved_guide_26_0_m
#define W mcccurved_guide_26_0_W
#define nslit mcccurved_guide_26_0_nslit
#define d mcccurved_guide_26_0_d
#define mleft mcccurved_guide_26_0_mleft
#define mright mcccurved_guide_26_0_mright
#define mtop mcccurved_guide_26_0_mtop
#define mbottom mcccurved_guide_26_0_mbottom
#define nhslit mcccurved_guide_26_0_nhslit
#define G mcccurved_guide_26_0_G
#define aleft mcccurved_guide_26_0_aleft
#define aright mcccurved_guide_26_0_aright
#define atop mcccurved_guide_26_0_atop
#define abottom mcccurved_guide_26_0_abottom
#define wavy mcccurved_guide_26_0_wavy
#define wavy_z mcccurved_guide_26_0_wavy_z
#define wavy_tb mcccurved_guide_26_0_wavy_tb
#define wavy_lr mcccurved_guide_26_0_wavy_lr
#define chamfers mcccurved_guide_26_0_chamfers
#define chamfers_z mcccurved_guide_26_0_chamfers_z
#define chamfers_lr mcccurved_guide_26_0_chamfers_lr
#define chamfers_tb mcccurved_guide_26_0_chamfers_tb
#define nelements mcccurved_guide_26_0_nelements
#define nu mcccurved_guide_26_0_nu
#define phase mcccurved_guide_26_0_phase
#define reflect mcccurved_guide_26_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16877 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_27_0' [61]. */
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 61
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
#define w1 mcccurved_guide_27_0_w1
#define h1 mcccurved_guide_27_0_h1
#define w2 mcccurved_guide_27_0_w2
#define h2 mcccurved_guide_27_0_h2
#define l mcccurved_guide_27_0_l
#define R0 mcccurved_guide_27_0_R0
#define Qc mcccurved_guide_27_0_Qc
#define alpha mcccurved_guide_27_0_alpha
#define m mcccurved_guide_27_0_m
#define W mcccurved_guide_27_0_W
#define nslit mcccurved_guide_27_0_nslit
#define d mcccurved_guide_27_0_d
#define mleft mcccurved_guide_27_0_mleft
#define mright mcccurved_guide_27_0_mright
#define mtop mcccurved_guide_27_0_mtop
#define mbottom mcccurved_guide_27_0_mbottom
#define nhslit mcccurved_guide_27_0_nhslit
#define G mcccurved_guide_27_0_G
#define aleft mcccurved_guide_27_0_aleft
#define aright mcccurved_guide_27_0_aright
#define atop mcccurved_guide_27_0_atop
#define abottom mcccurved_guide_27_0_abottom
#define wavy mcccurved_guide_27_0_wavy
#define wavy_z mcccurved_guide_27_0_wavy_z
#define wavy_tb mcccurved_guide_27_0_wavy_tb
#define wavy_lr mcccurved_guide_27_0_wavy_lr
#define chamfers mcccurved_guide_27_0_chamfers
#define chamfers_z mcccurved_guide_27_0_chamfers_z
#define chamfers_lr mcccurved_guide_27_0_chamfers_lr
#define chamfers_tb mcccurved_guide_27_0_chamfers_tb
#define nelements mcccurved_guide_27_0_nelements
#define nu mcccurved_guide_27_0_nu
#define phase mcccurved_guide_27_0_phase
#define reflect mcccurved_guide_27_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16961 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_28_0' [62]. */
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 62
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
#define w1 mcccurved_guide_28_0_w1
#define h1 mcccurved_guide_28_0_h1
#define w2 mcccurved_guide_28_0_w2
#define h2 mcccurved_guide_28_0_h2
#define l mcccurved_guide_28_0_l
#define R0 mcccurved_guide_28_0_R0
#define Qc mcccurved_guide_28_0_Qc
#define alpha mcccurved_guide_28_0_alpha
#define m mcccurved_guide_28_0_m
#define W mcccurved_guide_28_0_W
#define nslit mcccurved_guide_28_0_nslit
#define d mcccurved_guide_28_0_d
#define mleft mcccurved_guide_28_0_mleft
#define mright mcccurved_guide_28_0_mright
#define mtop mcccurved_guide_28_0_mtop
#define mbottom mcccurved_guide_28_0_mbottom
#define nhslit mcccurved_guide_28_0_nhslit
#define G mcccurved_guide_28_0_G
#define aleft mcccurved_guide_28_0_aleft
#define aright mcccurved_guide_28_0_aright
#define atop mcccurved_guide_28_0_atop
#define abottom mcccurved_guide_28_0_abottom
#define wavy mcccurved_guide_28_0_wavy
#define wavy_z mcccurved_guide_28_0_wavy_z
#define wavy_tb mcccurved_guide_28_0_wavy_tb
#define wavy_lr mcccurved_guide_28_0_wavy_lr
#define chamfers mcccurved_guide_28_0_chamfers
#define chamfers_z mcccurved_guide_28_0_chamfers_z
#define chamfers_lr mcccurved_guide_28_0_chamfers_lr
#define chamfers_tb mcccurved_guide_28_0_chamfers_tb
#define nelements mcccurved_guide_28_0_nelements
#define nu mcccurved_guide_28_0_nu
#define phase mcccurved_guide_28_0_phase
#define reflect mcccurved_guide_28_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17045 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_29_0' [63]. */
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 63
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
#define w1 mcccurved_guide_29_0_w1
#define h1 mcccurved_guide_29_0_h1
#define w2 mcccurved_guide_29_0_w2
#define h2 mcccurved_guide_29_0_h2
#define l mcccurved_guide_29_0_l
#define R0 mcccurved_guide_29_0_R0
#define Qc mcccurved_guide_29_0_Qc
#define alpha mcccurved_guide_29_0_alpha
#define m mcccurved_guide_29_0_m
#define W mcccurved_guide_29_0_W
#define nslit mcccurved_guide_29_0_nslit
#define d mcccurved_guide_29_0_d
#define mleft mcccurved_guide_29_0_mleft
#define mright mcccurved_guide_29_0_mright
#define mtop mcccurved_guide_29_0_mtop
#define mbottom mcccurved_guide_29_0_mbottom
#define nhslit mcccurved_guide_29_0_nhslit
#define G mcccurved_guide_29_0_G
#define aleft mcccurved_guide_29_0_aleft
#define aright mcccurved_guide_29_0_aright
#define atop mcccurved_guide_29_0_atop
#define abottom mcccurved_guide_29_0_abottom
#define wavy mcccurved_guide_29_0_wavy
#define wavy_z mcccurved_guide_29_0_wavy_z
#define wavy_tb mcccurved_guide_29_0_wavy_tb
#define wavy_lr mcccurved_guide_29_0_wavy_lr
#define chamfers mcccurved_guide_29_0_chamfers
#define chamfers_z mcccurved_guide_29_0_chamfers_z
#define chamfers_lr mcccurved_guide_29_0_chamfers_lr
#define chamfers_tb mcccurved_guide_29_0_chamfers_tb
#define nelements mcccurved_guide_29_0_nelements
#define nu mcccurved_guide_29_0_nu
#define phase mcccurved_guide_29_0_phase
#define reflect mcccurved_guide_29_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17129 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_30_0' [64]. */
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
#define w1 mcccurved_guide_30_0_w1
#define h1 mcccurved_guide_30_0_h1
#define w2 mcccurved_guide_30_0_w2
#define h2 mcccurved_guide_30_0_h2
#define l mcccurved_guide_30_0_l
#define R0 mcccurved_guide_30_0_R0
#define Qc mcccurved_guide_30_0_Qc
#define alpha mcccurved_guide_30_0_alpha
#define m mcccurved_guide_30_0_m
#define W mcccurved_guide_30_0_W
#define nslit mcccurved_guide_30_0_nslit
#define d mcccurved_guide_30_0_d
#define mleft mcccurved_guide_30_0_mleft
#define mright mcccurved_guide_30_0_mright
#define mtop mcccurved_guide_30_0_mtop
#define mbottom mcccurved_guide_30_0_mbottom
#define nhslit mcccurved_guide_30_0_nhslit
#define G mcccurved_guide_30_0_G
#define aleft mcccurved_guide_30_0_aleft
#define aright mcccurved_guide_30_0_aright
#define atop mcccurved_guide_30_0_atop
#define abottom mcccurved_guide_30_0_abottom
#define wavy mcccurved_guide_30_0_wavy
#define wavy_z mcccurved_guide_30_0_wavy_z
#define wavy_tb mcccurved_guide_30_0_wavy_tb
#define wavy_lr mcccurved_guide_30_0_wavy_lr
#define chamfers mcccurved_guide_30_0_chamfers
#define chamfers_z mcccurved_guide_30_0_chamfers_z
#define chamfers_lr mcccurved_guide_30_0_chamfers_lr
#define chamfers_tb mcccurved_guide_30_0_chamfers_tb
#define nelements mcccurved_guide_30_0_nelements
#define nu mcccurved_guide_30_0_nu
#define phase mcccurved_guide_30_0_phase
#define reflect mcccurved_guide_30_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17213 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_31_0' [65]. */
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
#define w1 mcccurved_guide_31_0_w1
#define h1 mcccurved_guide_31_0_h1
#define w2 mcccurved_guide_31_0_w2
#define h2 mcccurved_guide_31_0_h2
#define l mcccurved_guide_31_0_l
#define R0 mcccurved_guide_31_0_R0
#define Qc mcccurved_guide_31_0_Qc
#define alpha mcccurved_guide_31_0_alpha
#define m mcccurved_guide_31_0_m
#define W mcccurved_guide_31_0_W
#define nslit mcccurved_guide_31_0_nslit
#define d mcccurved_guide_31_0_d
#define mleft mcccurved_guide_31_0_mleft
#define mright mcccurved_guide_31_0_mright
#define mtop mcccurved_guide_31_0_mtop
#define mbottom mcccurved_guide_31_0_mbottom
#define nhslit mcccurved_guide_31_0_nhslit
#define G mcccurved_guide_31_0_G
#define aleft mcccurved_guide_31_0_aleft
#define aright mcccurved_guide_31_0_aright
#define atop mcccurved_guide_31_0_atop
#define abottom mcccurved_guide_31_0_abottom
#define wavy mcccurved_guide_31_0_wavy
#define wavy_z mcccurved_guide_31_0_wavy_z
#define wavy_tb mcccurved_guide_31_0_wavy_tb
#define wavy_lr mcccurved_guide_31_0_wavy_lr
#define chamfers mcccurved_guide_31_0_chamfers
#define chamfers_z mcccurved_guide_31_0_chamfers_z
#define chamfers_lr mcccurved_guide_31_0_chamfers_lr
#define chamfers_tb mcccurved_guide_31_0_chamfers_tb
#define nelements mcccurved_guide_31_0_nelements
#define nu mcccurved_guide_31_0_nu
#define phase mcccurved_guide_31_0_phase
#define reflect mcccurved_guide_31_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17297 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_32_0' [66]. */
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
#define w1 mcccurved_guide_32_0_w1
#define h1 mcccurved_guide_32_0_h1
#define w2 mcccurved_guide_32_0_w2
#define h2 mcccurved_guide_32_0_h2
#define l mcccurved_guide_32_0_l
#define R0 mcccurved_guide_32_0_R0
#define Qc mcccurved_guide_32_0_Qc
#define alpha mcccurved_guide_32_0_alpha
#define m mcccurved_guide_32_0_m
#define W mcccurved_guide_32_0_W
#define nslit mcccurved_guide_32_0_nslit
#define d mcccurved_guide_32_0_d
#define mleft mcccurved_guide_32_0_mleft
#define mright mcccurved_guide_32_0_mright
#define mtop mcccurved_guide_32_0_mtop
#define mbottom mcccurved_guide_32_0_mbottom
#define nhslit mcccurved_guide_32_0_nhslit
#define G mcccurved_guide_32_0_G
#define aleft mcccurved_guide_32_0_aleft
#define aright mcccurved_guide_32_0_aright
#define atop mcccurved_guide_32_0_atop
#define abottom mcccurved_guide_32_0_abottom
#define wavy mcccurved_guide_32_0_wavy
#define wavy_z mcccurved_guide_32_0_wavy_z
#define wavy_tb mcccurved_guide_32_0_wavy_tb
#define wavy_lr mcccurved_guide_32_0_wavy_lr
#define chamfers mcccurved_guide_32_0_chamfers
#define chamfers_z mcccurved_guide_32_0_chamfers_z
#define chamfers_lr mcccurved_guide_32_0_chamfers_lr
#define chamfers_tb mcccurved_guide_32_0_chamfers_tb
#define nelements mcccurved_guide_32_0_nelements
#define nu mcccurved_guide_32_0_nu
#define phase mcccurved_guide_32_0_phase
#define reflect mcccurved_guide_32_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17381 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_33_0' [67]. */
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
#define w1 mcccurved_guide_33_0_w1
#define h1 mcccurved_guide_33_0_h1
#define w2 mcccurved_guide_33_0_w2
#define h2 mcccurved_guide_33_0_h2
#define l mcccurved_guide_33_0_l
#define R0 mcccurved_guide_33_0_R0
#define Qc mcccurved_guide_33_0_Qc
#define alpha mcccurved_guide_33_0_alpha
#define m mcccurved_guide_33_0_m
#define W mcccurved_guide_33_0_W
#define nslit mcccurved_guide_33_0_nslit
#define d mcccurved_guide_33_0_d
#define mleft mcccurved_guide_33_0_mleft
#define mright mcccurved_guide_33_0_mright
#define mtop mcccurved_guide_33_0_mtop
#define mbottom mcccurved_guide_33_0_mbottom
#define nhslit mcccurved_guide_33_0_nhslit
#define G mcccurved_guide_33_0_G
#define aleft mcccurved_guide_33_0_aleft
#define aright mcccurved_guide_33_0_aright
#define atop mcccurved_guide_33_0_atop
#define abottom mcccurved_guide_33_0_abottom
#define wavy mcccurved_guide_33_0_wavy
#define wavy_z mcccurved_guide_33_0_wavy_z
#define wavy_tb mcccurved_guide_33_0_wavy_tb
#define wavy_lr mcccurved_guide_33_0_wavy_lr
#define chamfers mcccurved_guide_33_0_chamfers
#define chamfers_z mcccurved_guide_33_0_chamfers_z
#define chamfers_lr mcccurved_guide_33_0_chamfers_lr
#define chamfers_tb mcccurved_guide_33_0_chamfers_tb
#define nelements mcccurved_guide_33_0_nelements
#define nu mcccurved_guide_33_0_nu
#define phase mcccurved_guide_33_0_phase
#define reflect mcccurved_guide_33_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17465 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_34_0' [68]. */
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
#define w1 mcccurved_guide_34_0_w1
#define h1 mcccurved_guide_34_0_h1
#define w2 mcccurved_guide_34_0_w2
#define h2 mcccurved_guide_34_0_h2
#define l mcccurved_guide_34_0_l
#define R0 mcccurved_guide_34_0_R0
#define Qc mcccurved_guide_34_0_Qc
#define alpha mcccurved_guide_34_0_alpha
#define m mcccurved_guide_34_0_m
#define W mcccurved_guide_34_0_W
#define nslit mcccurved_guide_34_0_nslit
#define d mcccurved_guide_34_0_d
#define mleft mcccurved_guide_34_0_mleft
#define mright mcccurved_guide_34_0_mright
#define mtop mcccurved_guide_34_0_mtop
#define mbottom mcccurved_guide_34_0_mbottom
#define nhslit mcccurved_guide_34_0_nhslit
#define G mcccurved_guide_34_0_G
#define aleft mcccurved_guide_34_0_aleft
#define aright mcccurved_guide_34_0_aright
#define atop mcccurved_guide_34_0_atop
#define abottom mcccurved_guide_34_0_abottom
#define wavy mcccurved_guide_34_0_wavy
#define wavy_z mcccurved_guide_34_0_wavy_z
#define wavy_tb mcccurved_guide_34_0_wavy_tb
#define wavy_lr mcccurved_guide_34_0_wavy_lr
#define chamfers mcccurved_guide_34_0_chamfers
#define chamfers_z mcccurved_guide_34_0_chamfers_z
#define chamfers_lr mcccurved_guide_34_0_chamfers_lr
#define chamfers_tb mcccurved_guide_34_0_chamfers_tb
#define nelements mcccurved_guide_34_0_nelements
#define nu mcccurved_guide_34_0_nu
#define phase mcccurved_guide_34_0_phase
#define reflect mcccurved_guide_34_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17549 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_35_0' [69]. */
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 69
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
#define w1 mcccurved_guide_35_0_w1
#define h1 mcccurved_guide_35_0_h1
#define w2 mcccurved_guide_35_0_w2
#define h2 mcccurved_guide_35_0_h2
#define l mcccurved_guide_35_0_l
#define R0 mcccurved_guide_35_0_R0
#define Qc mcccurved_guide_35_0_Qc
#define alpha mcccurved_guide_35_0_alpha
#define m mcccurved_guide_35_0_m
#define W mcccurved_guide_35_0_W
#define nslit mcccurved_guide_35_0_nslit
#define d mcccurved_guide_35_0_d
#define mleft mcccurved_guide_35_0_mleft
#define mright mcccurved_guide_35_0_mright
#define mtop mcccurved_guide_35_0_mtop
#define mbottom mcccurved_guide_35_0_mbottom
#define nhslit mcccurved_guide_35_0_nhslit
#define G mcccurved_guide_35_0_G
#define aleft mcccurved_guide_35_0_aleft
#define aright mcccurved_guide_35_0_aright
#define atop mcccurved_guide_35_0_atop
#define abottom mcccurved_guide_35_0_abottom
#define wavy mcccurved_guide_35_0_wavy
#define wavy_z mcccurved_guide_35_0_wavy_z
#define wavy_tb mcccurved_guide_35_0_wavy_tb
#define wavy_lr mcccurved_guide_35_0_wavy_lr
#define chamfers mcccurved_guide_35_0_chamfers
#define chamfers_z mcccurved_guide_35_0_chamfers_z
#define chamfers_lr mcccurved_guide_35_0_chamfers_lr
#define chamfers_tb mcccurved_guide_35_0_chamfers_tb
#define nelements mcccurved_guide_35_0_nelements
#define nu mcccurved_guide_35_0_nu
#define phase mcccurved_guide_35_0_phase
#define reflect mcccurved_guide_35_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17633 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_36_0' [70]. */
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
#define w1 mcccurved_guide_36_0_w1
#define h1 mcccurved_guide_36_0_h1
#define w2 mcccurved_guide_36_0_w2
#define h2 mcccurved_guide_36_0_h2
#define l mcccurved_guide_36_0_l
#define R0 mcccurved_guide_36_0_R0
#define Qc mcccurved_guide_36_0_Qc
#define alpha mcccurved_guide_36_0_alpha
#define m mcccurved_guide_36_0_m
#define W mcccurved_guide_36_0_W
#define nslit mcccurved_guide_36_0_nslit
#define d mcccurved_guide_36_0_d
#define mleft mcccurved_guide_36_0_mleft
#define mright mcccurved_guide_36_0_mright
#define mtop mcccurved_guide_36_0_mtop
#define mbottom mcccurved_guide_36_0_mbottom
#define nhslit mcccurved_guide_36_0_nhslit
#define G mcccurved_guide_36_0_G
#define aleft mcccurved_guide_36_0_aleft
#define aright mcccurved_guide_36_0_aright
#define atop mcccurved_guide_36_0_atop
#define abottom mcccurved_guide_36_0_abottom
#define wavy mcccurved_guide_36_0_wavy
#define wavy_z mcccurved_guide_36_0_wavy_z
#define wavy_tb mcccurved_guide_36_0_wavy_tb
#define wavy_lr mcccurved_guide_36_0_wavy_lr
#define chamfers mcccurved_guide_36_0_chamfers
#define chamfers_z mcccurved_guide_36_0_chamfers_z
#define chamfers_lr mcccurved_guide_36_0_chamfers_lr
#define chamfers_tb mcccurved_guide_36_0_chamfers_tb
#define nelements mcccurved_guide_36_0_nelements
#define nu mcccurved_guide_36_0_nu
#define phase mcccurved_guide_36_0_phase
#define reflect mcccurved_guide_36_0_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17717 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_4' [71]. */
#define mccompcurname  EndOfelement_4
#define mccompcurtype  Arm
#define mccompcurindex 71
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity3' [72]. */
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 72
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
#define l mccelliptical_guide_gravity3_l
#define xwidth mccelliptical_guide_gravity3_xwidth
#define yheight mccelliptical_guide_gravity3_yheight
#define linxw mccelliptical_guide_gravity3_linxw
#define loutxw mccelliptical_guide_gravity3_loutxw
#define linyh mccelliptical_guide_gravity3_linyh
#define loutyh mccelliptical_guide_gravity3_loutyh
#define majorAxisxw mccelliptical_guide_gravity3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity3_dimensionsAt
#define option mccelliptical_guide_gravity3_option
#define R0 mccelliptical_guide_gravity3_R0
#define Qc mccelliptical_guide_gravity3_Qc
#define alpha mccelliptical_guide_gravity3_alpha
#define m mccelliptical_guide_gravity3_m
#define W mccelliptical_guide_gravity3_W
#define alpharight mccelliptical_guide_gravity3_alpharight
#define mright mccelliptical_guide_gravity3_mright
#define alphaleft mccelliptical_guide_gravity3_alphaleft
#define mleft mccelliptical_guide_gravity3_mleft
#define alphatop mccelliptical_guide_gravity3_alphatop
#define mtop mccelliptical_guide_gravity3_mtop
#define alphabottom mccelliptical_guide_gravity3_alphabottom
#define mbottom mccelliptical_guide_gravity3_mbottom
#define verbose mccelliptical_guide_gravity3_verbose
#define enableGravity mccelliptical_guide_gravity3_enableGravity
#define curvature mccelliptical_guide_gravity3_curvature
#line 803 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 17828 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_3' [73]. */
#define mccompcurname  EndOfelement_3
#define mccompcurtype  Arm
#define mccompcurindex 73
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'straight_guide_2_1' [74]. */
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
#define w1 mccstraight_guide_2_1_w1
#define h1 mccstraight_guide_2_1_h1
#define w2 mccstraight_guide_2_1_w2
#define h2 mccstraight_guide_2_1_h2
#define l mccstraight_guide_2_1_l
#define R0 mccstraight_guide_2_1_R0
#define Qc mccstraight_guide_2_1_Qc
#define alpha mccstraight_guide_2_1_alpha
#define m mccstraight_guide_2_1_m
#define W mccstraight_guide_2_1_W
#define nslit mccstraight_guide_2_1_nslit
#define d mccstraight_guide_2_1_d
#define mleft mccstraight_guide_2_1_mleft
#define mright mccstraight_guide_2_1_mright
#define mtop mccstraight_guide_2_1_mtop
#define mbottom mccstraight_guide_2_1_mbottom
#define nhslit mccstraight_guide_2_1_nhslit
#define G mccstraight_guide_2_1_G
#define aleft mccstraight_guide_2_1_aleft
#define aright mccstraight_guide_2_1_aright
#define atop mccstraight_guide_2_1_atop
#define abottom mccstraight_guide_2_1_abottom
#define wavy mccstraight_guide_2_1_wavy
#define wavy_z mccstraight_guide_2_1_wavy_z
#define wavy_tb mccstraight_guide_2_1_wavy_tb
#define wavy_lr mccstraight_guide_2_1_wavy_lr
#define chamfers mccstraight_guide_2_1_chamfers
#define chamfers_z mccstraight_guide_2_1_chamfers_z
#define chamfers_lr mccstraight_guide_2_1_chamfers_lr
#define chamfers_tb mccstraight_guide_2_1_chamfers_tb
#define nelements mccstraight_guide_2_1_nelements
#define nu mccstraight_guide_2_1_nu
#define phase mccstraight_guide_2_1_phase
#define reflect mccstraight_guide_2_1_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17930 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monBeforeBWC' [75]. */
#define mccompcurname  L_monBeforeBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 75
#define nL mccL_monBeforeBWC_nL
#define L_N mccL_monBeforeBWC_L_N
#define L_p mccL_monBeforeBWC_L_p
#define L_p2 mccL_monBeforeBWC_L_p2
#define filename mccL_monBeforeBWC_filename
#define xmin mccL_monBeforeBWC_xmin
#define xmax mccL_monBeforeBWC_xmax
#define ymin mccL_monBeforeBWC_ymin
#define ymax mccL_monBeforeBWC_ymax
#define xwidth mccL_monBeforeBWC_xwidth
#define yheight mccL_monBeforeBWC_yheight
#define Lmin mccL_monBeforeBWC_Lmin
#define Lmax mccL_monBeforeBWC_Lmax
#define restore_neutron mccL_monBeforeBWC_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 17992 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFBeforeBWC' [76]. */
#define mccompcurname  ToFBeforeBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 76
#define nt mccToFBeforeBWC_nt
#define TOF_N mccToFBeforeBWC_TOF_N
#define TOF_p mccToFBeforeBWC_TOF_p
#define TOF_p2 mccToFBeforeBWC_TOF_p2
#define t_min mccToFBeforeBWC_t_min
#define t_max mccToFBeforeBWC_t_max
#define delta_t mccToFBeforeBWC_delta_t
#define filename mccToFBeforeBWC_filename
#define xmin mccToFBeforeBWC_xmin
#define xmax mccToFBeforeBWC_xmax
#define ymin mccToFBeforeBWC_ymin
#define ymax mccToFBeforeBWC_ymax
#define xwidth mccToFBeforeBWC_xwidth
#define yheight mccToFBeforeBWC_yheight
#define tmin mccToFBeforeBWC_tmin
#define tmax mccToFBeforeBWC_tmax
#define dt mccToFBeforeBWC_dt
#define restore_neutron mccToFBeforeBWC_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 18038 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BWC1' [77]. */
#define mccompcurname  BWC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 77
#define Tg mccBWC1_Tg
#define To mccBWC1_To
#define delta_y mccBWC1_delta_y
#define height mccBWC1_height
#define omega mccBWC1_omega
#define theta_0 mccBWC1_theta_0
#define radius mccBWC1_radius
#define yheight mccBWC1_yheight
#define nu mccBWC1_nu
#define nslit mccBWC1_nslit
#define jitter mccBWC1_jitter
#define delay mccBWC1_delay
#define isfirst mccBWC1_isfirst
#define n_pulse mccBWC1_n_pulse
#define abs_out mccBWC1_abs_out
#define phase mccBWC1_phase
#define xwidth mccBWC1_xwidth
#define verbose mccBWC1_verbose
#line 63 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 18085 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'BWC2' [78]. */
#define mccompcurname  BWC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 78
#define Tg mccBWC2_Tg
#define To mccBWC2_To
#define delta_y mccBWC2_delta_y
#define height mccBWC2_height
#define omega mccBWC2_omega
#define theta_0 mccBWC2_theta_0
#define radius mccBWC2_radius
#define yheight mccBWC2_yheight
#define nu mccBWC2_nu
#define nslit mccBWC2_nslit
#define jitter mccBWC2_jitter
#define delay mccBWC2_delay
#define isfirst mccBWC2_isfirst
#define n_pulse mccBWC2_n_pulse
#define abs_out mccBWC2_abs_out
#define phase mccBWC2_phase
#define xwidth mccBWC2_xwidth
#define verbose mccBWC2_verbose
#line 63 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 18132 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ToFAfterBWC' [79]. */
#define mccompcurname  ToFAfterBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 79
#define nt mccToFAfterBWC_nt
#define TOF_N mccToFAfterBWC_TOF_N
#define TOF_p mccToFAfterBWC_TOF_p
#define TOF_p2 mccToFAfterBWC_TOF_p2
#define t_min mccToFAfterBWC_t_min
#define t_max mccToFAfterBWC_t_max
#define delta_t mccToFAfterBWC_delta_t
#define filename mccToFAfterBWC_filename
#define xmin mccToFAfterBWC_xmin
#define xmax mccToFAfterBWC_xmax
#define ymin mccToFAfterBWC_ymin
#define ymax mccToFAfterBWC_ymax
#define xwidth mccToFAfterBWC_xwidth
#define yheight mccToFAfterBWC_yheight
#define tmin mccToFAfterBWC_tmin
#define tmax mccToFAfterBWC_tmax
#define dt mccToFAfterBWC_dt
#define restore_neutron mccToFAfterBWC_restore_neutron
#line 53 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 18182 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'L_monAfterBWC' [80]. */
#define mccompcurname  L_monAfterBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 80
#define nL mccL_monAfterBWC_nL
#define L_N mccL_monAfterBWC_L_N
#define L_p mccL_monAfterBWC_L_p
#define L_p2 mccL_monAfterBWC_L_p2
#define filename mccL_monAfterBWC_filename
#define xmin mccL_monAfterBWC_xmin
#define xmax mccL_monAfterBWC_xmax
#define ymin mccL_monAfterBWC_ymin
#define ymax mccL_monAfterBWC_ymax
#define xwidth mccL_monAfterBWC_xwidth
#define yheight mccL_monAfterBWC_yheight
#define Lmin mccL_monAfterBWC_Lmin
#define Lmax mccL_monAfterBWC_Lmax
#define restore_neutron mccL_monAfterBWC_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 18226 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'straight_guide_2_2' [81]. */
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 81
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
#define w1 mccstraight_guide_2_2_w1
#define h1 mccstraight_guide_2_2_h1
#define w2 mccstraight_guide_2_2_w2
#define h2 mccstraight_guide_2_2_h2
#define l mccstraight_guide_2_2_l
#define R0 mccstraight_guide_2_2_R0
#define Qc mccstraight_guide_2_2_Qc
#define alpha mccstraight_guide_2_2_alpha
#define m mccstraight_guide_2_2_m
#define W mccstraight_guide_2_2_W
#define nslit mccstraight_guide_2_2_nslit
#define d mccstraight_guide_2_2_d
#define mleft mccstraight_guide_2_2_mleft
#define mright mccstraight_guide_2_2_mright
#define mtop mccstraight_guide_2_2_mtop
#define mbottom mccstraight_guide_2_2_mbottom
#define nhslit mccstraight_guide_2_2_nhslit
#define G mccstraight_guide_2_2_G
#define aleft mccstraight_guide_2_2_aleft
#define aright mccstraight_guide_2_2_aright
#define atop mccstraight_guide_2_2_atop
#define abottom mccstraight_guide_2_2_abottom
#define wavy mccstraight_guide_2_2_wavy
#define wavy_z mccstraight_guide_2_2_wavy_z
#define wavy_tb mccstraight_guide_2_2_wavy_tb
#define wavy_lr mccstraight_guide_2_2_wavy_lr
#define chamfers mccstraight_guide_2_2_chamfers
#define chamfers_z mccstraight_guide_2_2_chamfers_z
#define chamfers_lr mccstraight_guide_2_2_chamfers_lr
#define chamfers_tb mccstraight_guide_2_2_chamfers_tb
#define nelements mccstraight_guide_2_2_nelements
#define nu mccstraight_guide_2_2_nu
#define phase mccstraight_guide_2_2_phase
#define reflect mccstraight_guide_2_2_reflect
#line 335 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18288 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_2' [82]. */
#define mccompcurname  EndOfelement_2
#define mccompcurtype  Arm
#define mccompcurindex 82
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_1' [83]. */
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 83
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
#define l mccelliptical_guide_gravity1_1_l
#define xwidth mccelliptical_guide_gravity1_1_xwidth
#define yheight mccelliptical_guide_gravity1_1_yheight
#define linxw mccelliptical_guide_gravity1_1_linxw
#define loutxw mccelliptical_guide_gravity1_1_loutxw
#define linyh mccelliptical_guide_gravity1_1_linyh
#define loutyh mccelliptical_guide_gravity1_1_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_1_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_1_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_1_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_1_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_1_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_1_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_1_dimensionsAt
#define option mccelliptical_guide_gravity1_1_option
#define R0 mccelliptical_guide_gravity1_1_R0
#define Qc mccelliptical_guide_gravity1_1_Qc
#define alpha mccelliptical_guide_gravity1_1_alpha
#define m mccelliptical_guide_gravity1_1_m
#define W mccelliptical_guide_gravity1_1_W
#define alpharight mccelliptical_guide_gravity1_1_alpharight
#define mright mccelliptical_guide_gravity1_1_mright
#define alphaleft mccelliptical_guide_gravity1_1_alphaleft
#define mleft mccelliptical_guide_gravity1_1_mleft
#define alphatop mccelliptical_guide_gravity1_1_alphatop
#define mtop mccelliptical_guide_gravity1_1_mtop
#define alphabottom mccelliptical_guide_gravity1_1_alphabottom
#define mbottom mccelliptical_guide_gravity1_1_mbottom
#define verbose mccelliptical_guide_gravity1_1_verbose
#define enableGravity mccelliptical_guide_gravity1_1_enableGravity
#define curvature mccelliptical_guide_gravity1_1_curvature
#line 803 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 18399 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw3' [84]. */
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 84
#define xmin mccDiwJaw3_xmin
#define xmax mccDiwJaw3_xmax
#define ymin mccDiwJaw3_ymin
#define ymax mccDiwJaw3_ymax
#define radius mccDiwJaw3_radius
#define xwidth mccDiwJaw3_xwidth
#define yheight mccDiwJaw3_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_2' [85]. */
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 85
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
#define l mccelliptical_guide_gravity1_2_l
#define xwidth mccelliptical_guide_gravity1_2_xwidth
#define yheight mccelliptical_guide_gravity1_2_yheight
#define linxw mccelliptical_guide_gravity1_2_linxw
#define loutxw mccelliptical_guide_gravity1_2_loutxw
#define linyh mccelliptical_guide_gravity1_2_linyh
#define loutyh mccelliptical_guide_gravity1_2_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_2_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_2_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_2_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_2_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_2_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_2_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_2_dimensionsAt
#define option mccelliptical_guide_gravity1_2_option
#define R0 mccelliptical_guide_gravity1_2_R0
#define Qc mccelliptical_guide_gravity1_2_Qc
#define alpha mccelliptical_guide_gravity1_2_alpha
#define m mccelliptical_guide_gravity1_2_m
#define W mccelliptical_guide_gravity1_2_W
#define alpharight mccelliptical_guide_gravity1_2_alpharight
#define mright mccelliptical_guide_gravity1_2_mright
#define alphaleft mccelliptical_guide_gravity1_2_alphaleft
#define mleft mccelliptical_guide_gravity1_2_mleft
#define alphatop mccelliptical_guide_gravity1_2_alphatop
#define mtop mccelliptical_guide_gravity1_2_mtop
#define alphabottom mccelliptical_guide_gravity1_2_alphabottom
#define mbottom mccelliptical_guide_gravity1_2_mbottom
#define verbose mccelliptical_guide_gravity1_2_verbose
#define enableGravity mccelliptical_guide_gravity1_2_enableGravity
#define curvature mccelliptical_guide_gravity1_2_curvature
#line 803 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 18534 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw2' [86]. */
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 86
#define xmin mccDiwJaw2_xmin
#define xmax mccDiwJaw2_xmax
#define ymin mccDiwJaw2_ymin
#define ymax mccDiwJaw2_ymax
#define radius mccDiwJaw2_radius
#define xwidth mccDiwJaw2_xwidth
#define yheight mccDiwJaw2_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_3' [87]. */
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 87
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
#define l mccelliptical_guide_gravity1_3_l
#define xwidth mccelliptical_guide_gravity1_3_xwidth
#define yheight mccelliptical_guide_gravity1_3_yheight
#define linxw mccelliptical_guide_gravity1_3_linxw
#define loutxw mccelliptical_guide_gravity1_3_loutxw
#define linyh mccelliptical_guide_gravity1_3_linyh
#define loutyh mccelliptical_guide_gravity1_3_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_3_dimensionsAt
#define option mccelliptical_guide_gravity1_3_option
#define R0 mccelliptical_guide_gravity1_3_R0
#define Qc mccelliptical_guide_gravity1_3_Qc
#define alpha mccelliptical_guide_gravity1_3_alpha
#define m mccelliptical_guide_gravity1_3_m
#define W mccelliptical_guide_gravity1_3_W
#define alpharight mccelliptical_guide_gravity1_3_alpharight
#define mright mccelliptical_guide_gravity1_3_mright
#define alphaleft mccelliptical_guide_gravity1_3_alphaleft
#define mleft mccelliptical_guide_gravity1_3_mleft
#define alphatop mccelliptical_guide_gravity1_3_alphatop
#define mtop mccelliptical_guide_gravity1_3_mtop
#define alphabottom mccelliptical_guide_gravity1_3_alphabottom
#define mbottom mccelliptical_guide_gravity1_3_mbottom
#define verbose mccelliptical_guide_gravity1_3_verbose
#define enableGravity mccelliptical_guide_gravity1_3_enableGravity
#define curvature mccelliptical_guide_gravity1_3_curvature
#line 803 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 18669 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw1' [88]. */
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 88
#define xmin mccDiwJaw1_xmin
#define xmax mccDiwJaw1_xmax
#define ymin mccDiwJaw1_ymin
#define ymax mccDiwJaw1_ymax
#define radius mccDiwJaw1_radius
#define xwidth mccDiwJaw1_xwidth
#define yheight mccDiwJaw1_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_4' [89]. */
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 89
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
#define l mccelliptical_guide_gravity1_4_l
#define xwidth mccelliptical_guide_gravity1_4_xwidth
#define yheight mccelliptical_guide_gravity1_4_yheight
#define linxw mccelliptical_guide_gravity1_4_linxw
#define loutxw mccelliptical_guide_gravity1_4_loutxw
#define linyh mccelliptical_guide_gravity1_4_linyh
#define loutyh mccelliptical_guide_gravity1_4_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_4_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_4_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_4_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_4_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_4_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_4_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_4_dimensionsAt
#define option mccelliptical_guide_gravity1_4_option
#define R0 mccelliptical_guide_gravity1_4_R0
#define Qc mccelliptical_guide_gravity1_4_Qc
#define alpha mccelliptical_guide_gravity1_4_alpha
#define m mccelliptical_guide_gravity1_4_m
#define W mccelliptical_guide_gravity1_4_W
#define alpharight mccelliptical_guide_gravity1_4_alpharight
#define mright mccelliptical_guide_gravity1_4_mright
#define alphaleft mccelliptical_guide_gravity1_4_alphaleft
#define mleft mccelliptical_guide_gravity1_4_mleft
#define alphatop mccelliptical_guide_gravity1_4_alphatop
#define mtop mccelliptical_guide_gravity1_4_mtop
#define alphabottom mccelliptical_guide_gravity1_4_alphabottom
#define mbottom mccelliptical_guide_gravity1_4_mbottom
#define verbose mccelliptical_guide_gravity1_4_verbose
#define enableGravity mccelliptical_guide_gravity1_4_enableGravity
#define curvature mccelliptical_guide_gravity1_4_curvature
#line 803 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 18804 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_1' [90]. */
#define mccompcurname  EndOfelement_1
#define mccompcurtype  Arm
#define mccompcurindex 90
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'VirtualOutput' [91]. */
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 91
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
#define filename mccVirtualOutput_filename
#define bufsize mccVirtualOutput_bufsize
#line 72 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\Virtual_output.comp"
char type[10];
MonitornD_Defines_type DEFS;
MonitornD_Variables_type Vars;
#line 18875 "BIFROST.c"
#undef bufsize
#undef filename
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw0' [92]. */
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 92
#define xmin mccDiwJaw0_xmin
#define xmax mccDiwJaw0_xmax
#define ymin mccDiwJaw0_ymin
#define ymax mccDiwJaw0_ymax
#define radius mccDiwJaw0_radius
#define xwidth mccDiwJaw0_xwidth
#define yheight mccDiwJaw0_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Lmon_guide_end' [93]. */
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
#define filename mccLmon_guide_end_filename
#define xmin mccLmon_guide_end_xmin
#define xmax mccLmon_guide_end_xmax
#define ymin mccLmon_guide_end_ymin
#define ymax mccLmon_guide_end_ymax
#define xwidth mccLmon_guide_end_xwidth
#define yheight mccLmon_guide_end_yheight
#define Lmin mccLmon_guide_end_Lmin
#define Lmax mccLmon_guide_end_Lmax
#define restore_neutron mccLmon_guide_end_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 18927 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Div2d_sample_B' [94]. */
#define mccompcurname  Div2d_sample_B
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 94
#define nh mccDiv2d_sample_B_nh
#define nv mccDiv2d_sample_B_nv
#define Div_N mccDiv2d_sample_B_Div_N
#define Div_p mccDiv2d_sample_B_Div_p
#define Div_p2 mccDiv2d_sample_B_Div_p2
#define filename mccDiv2d_sample_B_filename
#define xmin mccDiv2d_sample_B_xmin
#define xmax mccDiv2d_sample_B_xmax
#define ymin mccDiv2d_sample_B_ymin
#define ymax mccDiv2d_sample_B_ymax
#define xwidth mccDiv2d_sample_B_xwidth
#define yheight mccDiv2d_sample_B_yheight
#define maxdiv_h mccDiv2d_sample_B_maxdiv_h
#define maxdiv_v mccDiv2d_sample_B_maxdiv_v
#define restore_neutron mccDiv2d_sample_B_restore_neutron
#define nx mccDiv2d_sample_B_nx
#define ny mccDiv2d_sample_B_ny
#define nz mccDiv2d_sample_B_nz
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
double Div_N[nh][nv];
double Div_p[nh][nv];
double Div_p2[nh][nv];
#line 18972 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Div2d_sample' [95]. */
#define mccompcurname  Div2d_sample
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 95
#define nh mccDiv2d_sample_nh
#define nv mccDiv2d_sample_nv
#define Div_N mccDiv2d_sample_Div_N
#define Div_p mccDiv2d_sample_Div_p
#define Div_p2 mccDiv2d_sample_Div_p2
#define filename mccDiv2d_sample_filename
#define xmin mccDiv2d_sample_xmin
#define xmax mccDiv2d_sample_xmax
#define ymin mccDiv2d_sample_ymin
#define ymax mccDiv2d_sample_ymax
#define xwidth mccDiv2d_sample_xwidth
#define yheight mccDiv2d_sample_yheight
#define maxdiv_h mccDiv2d_sample_maxdiv_h
#define maxdiv_v mccDiv2d_sample_maxdiv_v
#define restore_neutron mccDiv2d_sample_restore_neutron
#define nx mccDiv2d_sample_nx
#define ny mccDiv2d_sample_ny
#define nz mccDiv2d_sample_nz
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
double Div_N[nh][nv];
double Div_p[nh][nv];
double Div_p2[nh][nv];
#line 19021 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_sample' [96]. */
#define mccompcurname  PSD_sample
#define mccompcurtype  PSD_monitor
#define mccompcurindex 96
#define nx mccPSD_sample_nx
#define ny mccPSD_sample_ny
#define PSD_N mccPSD_sample_PSD_N
#define PSD_p mccPSD_sample_PSD_p
#define PSD_p2 mccPSD_sample_PSD_p2
#define filename mccPSD_sample_filename
#define xmin mccPSD_sample_xmin
#define xmax mccPSD_sample_xmax
#define ymin mccPSD_sample_ymin
#define ymax mccPSD_sample_ymax
#define xwidth mccPSD_sample_xwidth
#define yheight mccPSD_sample_yheight
#define restore_neutron mccPSD_sample_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 19065 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'HPSD_sample' [97]. */
#define mccompcurname  HPSD_sample
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 97
#define nx mccHPSD_sample_nx
#define PSDlin_N mccHPSD_sample_PSDlin_N
#define PSDlin_p mccHPSD_sample_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_PSDlin_p2
#define filename mccHPSD_sample_filename
#define xmin mccHPSD_sample_xmin
#define xmax mccHPSD_sample_xmax
#define ymin mccHPSD_sample_ymin
#define ymax mccHPSD_sample_ymax
#define xwidth mccHPSD_sample_xwidth
#define yheight mccHPSD_sample_yheight
#define restore_neutron mccHPSD_sample_restore_neutron
#line 52 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
    double PSDlin_N[nx];
    double PSDlin_p[nx];
    double PSDlin_p2[nx];
#line 19103 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'VPSD_sample' [98]. */
#define mccompcurname  VPSD_sample
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 98
#define ny mccVPSD_sample_ny
#define filename mccVPSD_sample_filename
#define PSDlin_N mccVPSD_sample_PSDlin_N
#define PSDlin_p mccVPSD_sample_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_PSDlin_p2
#define xmin mccVPSD_sample_xmin
#define xmax mccVPSD_sample_xmax
#define ymin mccVPSD_sample_ymin
#define ymax mccVPSD_sample_ymax
#define xwidth mccVPSD_sample_xwidth
#define yheight mccVPSD_sample_yheight
#define restore_neutron mccVPSD_sample_restore_neutron
#line 51 "PSDlin_y_monitor.comp"
    double PSDlin_N[ny];
    double PSDlin_p[ny];
    double PSDlin_p2[ny];
#line 19140 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Hdiv_sample' [99]. */
#define mccompcurname  Hdiv_sample
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 99
#define nh mccHdiv_sample_nh
#define Div_N mccHdiv_sample_Div_N
#define Div_p mccHdiv_sample_Div_p
#define Div_p2 mccHdiv_sample_Div_p2
#define filename mccHdiv_sample_filename
#define xmin mccHdiv_sample_xmin
#define xmax mccHdiv_sample_xmax
#define ymin mccHdiv_sample_ymin
#define ymax mccHdiv_sample_ymax
#define xwidth mccHdiv_sample_xwidth
#define yheight mccHdiv_sample_yheight
#define h_maxdiv mccHdiv_sample_h_maxdiv
#define restore_neutron mccHdiv_sample_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
double Div_N[nh];
double Div_p[nh];
double Div_p2[nh];
#line 19178 "BIFROST.c"
#undef restore_neutron
#undef h_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Vdiv_sample' [100]. */
#define mccompcurname  Vdiv_sample
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 100
#define nv mccVdiv_sample_nv
#define filename mccVdiv_sample_filename
#define restore_neutron mccVdiv_sample_restore_neutron
#define Div_N mccVdiv_sample_Div_N
#define Div_p mccVdiv_sample_Div_p
#define Div_p2 mccVdiv_sample_Div_p2
#define xmin mccVdiv_sample_xmin
#define xmax mccVdiv_sample_xmax
#define ymin mccVdiv_sample_ymin
#define ymax mccVdiv_sample_ymax
#define xwidth mccVdiv_sample_xwidth
#define yheight mccVdiv_sample_yheight
#define v_maxdiv mccVdiv_sample_v_maxdiv
#line 59 "Vdiv_monitor.comp"
    double Div_N[nv];
    double Div_p[nv];
    double Div_p2[nv];
#line 19217 "BIFROST.c"
#undef v_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'acceptance_x_divx' [101]. */
#define mccompcurname  acceptance_x_divx
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 101
#define nh mccacceptance_x_divx_nh
#define ndiv mccacceptance_x_divx_ndiv
#define Div_N mccacceptance_x_divx_Div_N
#define Div_p mccacceptance_x_divx_Div_p
#define Div_p2 mccacceptance_x_divx_Div_p2
#define filename mccacceptance_x_divx_filename
#define xmin mccacceptance_x_divx_xmin
#define xmax mccacceptance_x_divx_xmax
#define ymin mccacceptance_x_divx_ymin
#define ymax mccacceptance_x_divx_ymax
#define xwidth mccacceptance_x_divx_xwidth
#define yheight mccacceptance_x_divx_yheight
#define maxdiv_h mccacceptance_x_divx_maxdiv_h
#define restore_neutron mccacceptance_x_divx_restore_neutron
#define nx mccacceptance_x_divx_nx
#define ny mccacceptance_x_divx_ny
#define nz mccacceptance_x_divx_nz
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
double Div_N[nh][ndiv];
double Div_p[nh][ndiv];
double Div_p2[nh][ndiv];
#line 19260 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'acceptance_y_divy' [102]. */
#define mccompcurname  acceptance_y_divy
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 102
#define npos mccacceptance_y_divy_npos
#define ndiv mccacceptance_y_divy_ndiv
#define filename mccacceptance_y_divy_filename
#define restore_neutron mccacceptance_y_divy_restore_neutron
#define Div_N mccacceptance_y_divy_Div_N
#define Div_p mccacceptance_y_divy_Div_p
#define Div_p2 mccacceptance_y_divy_Div_p2
#define xmin mccacceptance_y_divy_xmin
#define xmax mccacceptance_y_divy_xmax
#define ymin mccacceptance_y_divy_ymin
#define ymax mccacceptance_y_divy_ymax
#define xwidth mccacceptance_y_divy_xwidth
#define yheight mccacceptance_y_divy_yheight
#define maxdiv mccacceptance_y_divy_maxdiv
#line 58 "DivPos_y_monitor.comp"
    double Div_N[npos][ndiv];
    double Div_p[npos][ndiv];
    double Div_p2[npos][ndiv];
#line 19304 "BIFROST.c"
#undef maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Lmon_sample_B' [103]. */
#define mccompcurname  Lmon_sample_B
#define mccompcurtype  L_monitor
#define mccompcurindex 103
#define nL mccLmon_sample_B_nL
#define L_N mccLmon_sample_B_L_N
#define L_p mccLmon_sample_B_L_p
#define L_p2 mccLmon_sample_B_L_p2
#define filename mccLmon_sample_B_filename
#define xmin mccLmon_sample_B_xmin
#define xmax mccLmon_sample_B_xmax
#define ymin mccLmon_sample_B_ymin
#define ymax mccLmon_sample_B_ymax
#define xwidth mccLmon_sample_B_xwidth
#define yheight mccLmon_sample_B_yheight
#define Lmin mccLmon_sample_B_Lmin
#define Lmax mccLmon_sample_B_Lmax
#define restore_neutron mccLmon_sample_B_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 19344 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Div2d_sample_maxdiv' [104]. */
#define mccompcurname  Div2d_sample_maxdiv
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 104
#define nh mccDiv2d_sample_maxdiv_nh
#define nv mccDiv2d_sample_maxdiv_nv
#define Div_N mccDiv2d_sample_maxdiv_Div_N
#define Div_p mccDiv2d_sample_maxdiv_Div_p
#define Div_p2 mccDiv2d_sample_maxdiv_Div_p2
#define filename mccDiv2d_sample_maxdiv_filename
#define xmin mccDiv2d_sample_maxdiv_xmin
#define xmax mccDiv2d_sample_maxdiv_xmax
#define ymin mccDiv2d_sample_maxdiv_ymin
#define ymax mccDiv2d_sample_maxdiv_ymax
#define xwidth mccDiv2d_sample_maxdiv_xwidth
#define yheight mccDiv2d_sample_maxdiv_yheight
#define maxdiv_h mccDiv2d_sample_maxdiv_maxdiv_h
#define maxdiv_v mccDiv2d_sample_maxdiv_maxdiv_v
#define restore_neutron mccDiv2d_sample_maxdiv_restore_neutron
#define nx mccDiv2d_sample_maxdiv_nx
#define ny mccDiv2d_sample_maxdiv_ny
#define nz mccDiv2d_sample_maxdiv_nz
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
double Div_N[nh][nv];
double Div_p[nh][nv];
double Div_p2[nh][nv];
#line 19389 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_sample_maxdiv' [105]. */
#define mccompcurname  PSD_sample_maxdiv
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define nx mccPSD_sample_maxdiv_nx
#define ny mccPSD_sample_maxdiv_ny
#define PSD_N mccPSD_sample_maxdiv_PSD_N
#define PSD_p mccPSD_sample_maxdiv_PSD_p
#define PSD_p2 mccPSD_sample_maxdiv_PSD_p2
#define filename mccPSD_sample_maxdiv_filename
#define xmin mccPSD_sample_maxdiv_xmin
#define xmax mccPSD_sample_maxdiv_xmax
#define ymin mccPSD_sample_maxdiv_ymin
#define ymax mccPSD_sample_maxdiv_ymax
#define xwidth mccPSD_sample_maxdiv_xwidth
#define yheight mccPSD_sample_maxdiv_yheight
#define restore_neutron mccPSD_sample_maxdiv_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 19433 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'HPSD_sample_maxdiv' [106]. */
#define mccompcurname  HPSD_sample_maxdiv
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 106
#define nx mccHPSD_sample_maxdiv_nx
#define PSDlin_N mccHPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccHPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_maxdiv_PSDlin_p2
#define filename mccHPSD_sample_maxdiv_filename
#define xmin mccHPSD_sample_maxdiv_xmin
#define xmax mccHPSD_sample_maxdiv_xmax
#define ymin mccHPSD_sample_maxdiv_ymin
#define ymax mccHPSD_sample_maxdiv_ymax
#define xwidth mccHPSD_sample_maxdiv_xwidth
#define yheight mccHPSD_sample_maxdiv_yheight
#define restore_neutron mccHPSD_sample_maxdiv_restore_neutron
#line 52 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
    double PSDlin_N[nx];
    double PSDlin_p[nx];
    double PSDlin_p2[nx];
#line 19471 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'VPSD_sample_maxdiv' [107]. */
#define mccompcurname  VPSD_sample_maxdiv
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 107
#define ny mccVPSD_sample_maxdiv_ny
#define filename mccVPSD_sample_maxdiv_filename
#define PSDlin_N mccVPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccVPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_maxdiv_PSDlin_p2
#define xmin mccVPSD_sample_maxdiv_xmin
#define xmax mccVPSD_sample_maxdiv_xmax
#define ymin mccVPSD_sample_maxdiv_ymin
#define ymax mccVPSD_sample_maxdiv_ymax
#define xwidth mccVPSD_sample_maxdiv_xwidth
#define yheight mccVPSD_sample_maxdiv_yheight
#define restore_neutron mccVPSD_sample_maxdiv_restore_neutron
#line 51 "PSDlin_y_monitor.comp"
    double PSDlin_N[ny];
    double PSDlin_p[ny];
    double PSDlin_p2[ny];
#line 19508 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Hdiv_sample_maxdiv' [108]. */
#define mccompcurname  Hdiv_sample_maxdiv
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 108
#define nh mccHdiv_sample_maxdiv_nh
#define Div_N mccHdiv_sample_maxdiv_Div_N
#define Div_p mccHdiv_sample_maxdiv_Div_p
#define Div_p2 mccHdiv_sample_maxdiv_Div_p2
#define filename mccHdiv_sample_maxdiv_filename
#define xmin mccHdiv_sample_maxdiv_xmin
#define xmax mccHdiv_sample_maxdiv_xmax
#define ymin mccHdiv_sample_maxdiv_ymin
#define ymax mccHdiv_sample_maxdiv_ymax
#define xwidth mccHdiv_sample_maxdiv_xwidth
#define yheight mccHdiv_sample_maxdiv_yheight
#define h_maxdiv mccHdiv_sample_maxdiv_h_maxdiv
#define restore_neutron mccHdiv_sample_maxdiv_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
double Div_N[nh];
double Div_p[nh];
double Div_p2[nh];
#line 19546 "BIFROST.c"
#undef restore_neutron
#undef h_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Vdiv_sample_maxdiv' [109]. */
#define mccompcurname  Vdiv_sample_maxdiv
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 109
#define nv mccVdiv_sample_maxdiv_nv
#define filename mccVdiv_sample_maxdiv_filename
#define restore_neutron mccVdiv_sample_maxdiv_restore_neutron
#define Div_N mccVdiv_sample_maxdiv_Div_N
#define Div_p mccVdiv_sample_maxdiv_Div_p
#define Div_p2 mccVdiv_sample_maxdiv_Div_p2
#define xmin mccVdiv_sample_maxdiv_xmin
#define xmax mccVdiv_sample_maxdiv_xmax
#define ymin mccVdiv_sample_maxdiv_ymin
#define ymax mccVdiv_sample_maxdiv_ymax
#define xwidth mccVdiv_sample_maxdiv_xwidth
#define yheight mccVdiv_sample_maxdiv_yheight
#define v_maxdiv mccVdiv_sample_maxdiv_v_maxdiv
#line 59 "Vdiv_monitor.comp"
    double Div_N[nv];
    double Div_p[nv];
    double Div_p2[nv];
#line 19585 "BIFROST.c"
#undef v_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'acceptance_x_divx_maxdiv' [110]. */
#define mccompcurname  acceptance_x_divx_maxdiv
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 110
#define nh mccacceptance_x_divx_maxdiv_nh
#define ndiv mccacceptance_x_divx_maxdiv_ndiv
#define Div_N mccacceptance_x_divx_maxdiv_Div_N
#define Div_p mccacceptance_x_divx_maxdiv_Div_p
#define Div_p2 mccacceptance_x_divx_maxdiv_Div_p2
#define filename mccacceptance_x_divx_maxdiv_filename
#define xmin mccacceptance_x_divx_maxdiv_xmin
#define xmax mccacceptance_x_divx_maxdiv_xmax
#define ymin mccacceptance_x_divx_maxdiv_ymin
#define ymax mccacceptance_x_divx_maxdiv_ymax
#define xwidth mccacceptance_x_divx_maxdiv_xwidth
#define yheight mccacceptance_x_divx_maxdiv_yheight
#define maxdiv_h mccacceptance_x_divx_maxdiv_maxdiv_h
#define restore_neutron mccacceptance_x_divx_maxdiv_restore_neutron
#define nx mccacceptance_x_divx_maxdiv_nx
#define ny mccacceptance_x_divx_maxdiv_ny
#define nz mccacceptance_x_divx_maxdiv_nz
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
double Div_N[nh][ndiv];
double Div_p[nh][ndiv];
double Div_p2[nh][ndiv];
#line 19628 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'acceptance_y_divy_maxdiv' [111]. */
#define mccompcurname  acceptance_y_divy_maxdiv
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 111
#define npos mccacceptance_y_divy_maxdiv_npos
#define ndiv mccacceptance_y_divy_maxdiv_ndiv
#define filename mccacceptance_y_divy_maxdiv_filename
#define restore_neutron mccacceptance_y_divy_maxdiv_restore_neutron
#define Div_N mccacceptance_y_divy_maxdiv_Div_N
#define Div_p mccacceptance_y_divy_maxdiv_Div_p
#define Div_p2 mccacceptance_y_divy_maxdiv_Div_p2
#define xmin mccacceptance_y_divy_maxdiv_xmin
#define xmax mccacceptance_y_divy_maxdiv_xmax
#define ymin mccacceptance_y_divy_maxdiv_ymin
#define ymax mccacceptance_y_divy_maxdiv_ymax
#define xwidth mccacceptance_y_divy_maxdiv_xwidth
#define yheight mccacceptance_y_divy_maxdiv_yheight
#define maxdiv mccacceptance_y_divy_maxdiv_maxdiv
#line 58 "DivPos_y_monitor.comp"
    double Div_N[npos][ndiv];
    double Div_p[npos][ndiv];
    double Div_p2[npos][ndiv];
#line 19672 "BIFROST.c"
#undef maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Lmon_sample' [112]. */
#define mccompcurname  Lmon_sample
#define mccompcurtype  L_monitor
#define mccompcurindex 112
#define nL mccLmon_sample_nL
#define L_N mccLmon_sample_L_N
#define L_p mccLmon_sample_L_p
#define L_p2 mccLmon_sample_L_p2
#define filename mccLmon_sample_filename
#define xmin mccLmon_sample_xmin
#define xmax mccLmon_sample_xmax
#define ymin mccLmon_sample_ymin
#define ymax mccLmon_sample_ymax
#define xwidth mccLmon_sample_xwidth
#define yheight mccLmon_sample_yheight
#define Lmin mccLmon_sample_Lmin
#define Lmax mccLmon_sample_Lmax
#define restore_neutron mccLmon_sample_restore_neutron
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 19712 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'v_sample' [113]. */
#define mccompcurname  v_sample
#define mccompcurtype  V_sample
#define mccompcurindex 113
#define VarsV mccv_sample_VarsV
#define radius mccv_sample_radius
#define thickness mccv_sample_thickness
#define zdepth mccv_sample_zdepth
#define Vc mccv_sample_Vc
#define sigma_abs mccv_sample_sigma_abs
#define sigma_inc mccv_sample_sigma_inc
#define radius_i mccv_sample_radius_i
#define radius_o mccv_sample_radius_o
#define h mccv_sample_h
#define focus_r mccv_sample_focus_r
#define pack mccv_sample_pack
#define frac mccv_sample_frac
#define f_QE mccv_sample_f_QE
#define gamma mccv_sample_gamma
#define target_x mccv_sample_target_x
#define target_y mccv_sample_target_y
#define target_z mccv_sample_target_z
#define focus_xw mccv_sample_focus_xw
#define focus_yh mccv_sample_focus_yh
#define focus_aw mccv_sample_focus_aw
#define focus_ah mccv_sample_focus_ah
#define xwidth mccv_sample_xwidth
#define yheight mccv_sample_yheight
#define zthick mccv_sample_zthick
#define rad_sphere mccv_sample_rad_sphere
#define sig_a mccv_sample_sig_a
#define sig_i mccv_sample_sig_i
#define V0 mccv_sample_V0
#define target_index mccv_sample_target_index
#define multiples mccv_sample_multiples
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\obsolete\\V_sample.comp"
  struct StructVarsV VarsV;
#line 19768 "BIFROST.c"
#undef multiples
#undef target_index
#undef V0
#undef sig_i
#undef sig_a
#undef rad_sphere
#undef zthick
#undef yheight
#undef xwidth
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef target_z
#undef target_y
#undef target_x
#undef gamma
#undef f_QE
#undef frac
#undef pack
#undef focus_r
#undef h
#undef radius_o
#undef radius_i
#undef sigma_inc
#undef sigma_abs
#undef Vc
#undef zdepth
#undef thickness
#undef radius
#undef VarsV
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Mono_Cradle' [114]. */
#define mccompcurname  Mono_Cradle
#define mccompcurtype  Arm
#define mccompcurindex 114
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'XY_ARM' [115]. */
#define mccompcurname  XY_ARM
#define mccompcurtype  Arm
#define mccompcurindex 115
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator_flat' [116]. */
#define mccompcurname  monochromator_flat
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 116
#define mos_rms_y mccmonochromator_flat_mos_rms_y
#define mos_rms_z mccmonochromator_flat_mos_rms_z
#define mos_rms_max mccmonochromator_flat_mos_rms_max
#define mono_Q mccmonochromator_flat_mono_Q
#define SlabWidth mccmonochromator_flat_SlabWidth
#define SlabHeight mccmonochromator_flat_SlabHeight
#define rTable mccmonochromator_flat_rTable
#define tTable mccmonochromator_flat_tTable
#define row mccmonochromator_flat_row
#define col mccmonochromator_flat_col
#define tiltH mccmonochromator_flat_tiltH
#define tiltV mccmonochromator_flat_tiltV
#define reflect mccmonochromator_flat_reflect
#define transmit mccmonochromator_flat_transmit
#define zwidth mccmonochromator_flat_zwidth
#define yheight mccmonochromator_flat_yheight
#define gap mccmonochromator_flat_gap
#define NH mccmonochromator_flat_NH
#define NV mccmonochromator_flat_NV
#define mosaich mccmonochromator_flat_mosaich
#define mosaicv mccmonochromator_flat_mosaicv
#define r0 mccmonochromator_flat_r0
#define t0 mccmonochromator_flat_t0
#define Q mccmonochromator_flat_Q
#define RV mccmonochromator_flat_RV
#define RH mccmonochromator_flat_RH
#define DM mccmonochromator_flat_DM
#define mosaic mccmonochromator_flat_mosaic
#define width mccmonochromator_flat_width
#define height mccmonochromator_flat_height
#define verbose mccmonochromator_flat_verbose
#define order mccmonochromator_flat_order
#line 136 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 19866 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator2' [117]. */
#define mccompcurname  monochromator2
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 117
#define mos_rms_y mccmonochromator2_mos_rms_y
#define mos_rms_z mccmonochromator2_mos_rms_z
#define mos_rms_max mccmonochromator2_mos_rms_max
#define mono_Q mccmonochromator2_mono_Q
#define SlabWidth mccmonochromator2_SlabWidth
#define SlabHeight mccmonochromator2_SlabHeight
#define rTable mccmonochromator2_rTable
#define tTable mccmonochromator2_tTable
#define row mccmonochromator2_row
#define col mccmonochromator2_col
#define tiltH mccmonochromator2_tiltH
#define tiltV mccmonochromator2_tiltV
#define reflect mccmonochromator2_reflect
#define transmit mccmonochromator2_transmit
#define zwidth mccmonochromator2_zwidth
#define yheight mccmonochromator2_yheight
#define gap mccmonochromator2_gap
#define NH mccmonochromator2_NH
#define NV mccmonochromator2_NV
#define mosaich mccmonochromator2_mosaich
#define mosaicv mccmonochromator2_mosaicv
#define r0 mccmonochromator2_r0
#define t0 mccmonochromator2_t0
#define Q mccmonochromator2_Q
#define RV mccmonochromator2_RV
#define RH mccmonochromator2_RH
#define DM mccmonochromator2_DM
#define mosaic mccmonochromator2_mosaic
#define width mccmonochromator2_width
#define height mccmonochromator2_height
#define verbose mccmonochromator2_verbose
#define order mccmonochromator2_order
#line 136 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 19949 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator3' [118]. */
#define mccompcurname  monochromator3
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 118
#define mos_rms_y mccmonochromator3_mos_rms_y
#define mos_rms_z mccmonochromator3_mos_rms_z
#define mos_rms_max mccmonochromator3_mos_rms_max
#define mono_Q mccmonochromator3_mono_Q
#define SlabWidth mccmonochromator3_SlabWidth
#define SlabHeight mccmonochromator3_SlabHeight
#define rTable mccmonochromator3_rTable
#define tTable mccmonochromator3_tTable
#define row mccmonochromator3_row
#define col mccmonochromator3_col
#define tiltH mccmonochromator3_tiltH
#define tiltV mccmonochromator3_tiltV
#define reflect mccmonochromator3_reflect
#define transmit mccmonochromator3_transmit
#define zwidth mccmonochromator3_zwidth
#define yheight mccmonochromator3_yheight
#define gap mccmonochromator3_gap
#define NH mccmonochromator3_NH
#define NV mccmonochromator3_NV
#define mosaich mccmonochromator3_mosaich
#define mosaicv mccmonochromator3_mosaicv
#define r0 mccmonochromator3_r0
#define t0 mccmonochromator3_t0
#define Q mccmonochromator3_Q
#define RV mccmonochromator3_RV
#define RH mccmonochromator3_RH
#define DM mccmonochromator3_DM
#define mosaic mccmonochromator3_mosaic
#define width mccmonochromator3_width
#define height mccmonochromator3_height
#define verbose mccmonochromator3_verbose
#define order mccmonochromator3_order
#line 136 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 20032 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator4' [119]. */
#define mccompcurname  monochromator4
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 119
#define mos_rms_y mccmonochromator4_mos_rms_y
#define mos_rms_z mccmonochromator4_mos_rms_z
#define mos_rms_max mccmonochromator4_mos_rms_max
#define mono_Q mccmonochromator4_mono_Q
#define SlabWidth mccmonochromator4_SlabWidth
#define SlabHeight mccmonochromator4_SlabHeight
#define rTable mccmonochromator4_rTable
#define tTable mccmonochromator4_tTable
#define row mccmonochromator4_row
#define col mccmonochromator4_col
#define tiltH mccmonochromator4_tiltH
#define tiltV mccmonochromator4_tiltV
#define reflect mccmonochromator4_reflect
#define transmit mccmonochromator4_transmit
#define zwidth mccmonochromator4_zwidth
#define yheight mccmonochromator4_yheight
#define gap mccmonochromator4_gap
#define NH mccmonochromator4_NH
#define NV mccmonochromator4_NV
#define mosaich mccmonochromator4_mosaich
#define mosaicv mccmonochromator4_mosaicv
#define r0 mccmonochromator4_r0
#define t0 mccmonochromator4_t0
#define Q mccmonochromator4_Q
#define RV mccmonochromator4_RV
#define RH mccmonochromator4_RH
#define DM mccmonochromator4_DM
#define mosaic mccmonochromator4_mosaic
#define width mccmonochromator4_width
#define height mccmonochromator4_height
#define verbose mccmonochromator4_verbose
#define order mccmonochromator4_order
#line 136 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 20115 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator5' [120]. */
#define mccompcurname  monochromator5
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 120
#define mos_rms_y mccmonochromator5_mos_rms_y
#define mos_rms_z mccmonochromator5_mos_rms_z
#define mos_rms_max mccmonochromator5_mos_rms_max
#define mono_Q mccmonochromator5_mono_Q
#define SlabWidth mccmonochromator5_SlabWidth
#define SlabHeight mccmonochromator5_SlabHeight
#define rTable mccmonochromator5_rTable
#define tTable mccmonochromator5_tTable
#define row mccmonochromator5_row
#define col mccmonochromator5_col
#define tiltH mccmonochromator5_tiltH
#define tiltV mccmonochromator5_tiltV
#define reflect mccmonochromator5_reflect
#define transmit mccmonochromator5_transmit
#define zwidth mccmonochromator5_zwidth
#define yheight mccmonochromator5_yheight
#define gap mccmonochromator5_gap
#define NH mccmonochromator5_NH
#define NV mccmonochromator5_NV
#define mosaich mccmonochromator5_mosaich
#define mosaicv mccmonochromator5_mosaicv
#define r0 mccmonochromator5_r0
#define t0 mccmonochromator5_t0
#define Q mccmonochromator5_Q
#define RV mccmonochromator5_RV
#define RH mccmonochromator5_RH
#define DM mccmonochromator5_DM
#define mosaic mccmonochromator5_mosaic
#define width mccmonochromator5_width
#define height mccmonochromator5_height
#define verbose mccmonochromator5_verbose
#define order mccmonochromator5_order
#line 136 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 20198 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator6' [121]. */
#define mccompcurname  monochromator6
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 121
#define mos_rms_y mccmonochromator6_mos_rms_y
#define mos_rms_z mccmonochromator6_mos_rms_z
#define mos_rms_max mccmonochromator6_mos_rms_max
#define mono_Q mccmonochromator6_mono_Q
#define SlabWidth mccmonochromator6_SlabWidth
#define SlabHeight mccmonochromator6_SlabHeight
#define rTable mccmonochromator6_rTable
#define tTable mccmonochromator6_tTable
#define row mccmonochromator6_row
#define col mccmonochromator6_col
#define tiltH mccmonochromator6_tiltH
#define tiltV mccmonochromator6_tiltV
#define reflect mccmonochromator6_reflect
#define transmit mccmonochromator6_transmit
#define zwidth mccmonochromator6_zwidth
#define yheight mccmonochromator6_yheight
#define gap mccmonochromator6_gap
#define NH mccmonochromator6_NH
#define NV mccmonochromator6_NV
#define mosaich mccmonochromator6_mosaich
#define mosaicv mccmonochromator6_mosaicv
#define r0 mccmonochromator6_r0
#define t0 mccmonochromator6_t0
#define Q mccmonochromator6_Q
#define RV mccmonochromator6_RV
#define RH mccmonochromator6_RH
#define DM mccmonochromator6_DM
#define mosaic mccmonochromator6_mosaic
#define width mccmonochromator6_width
#define height mccmonochromator6_height
#define verbose mccmonochromator6_verbose
#define order mccmonochromator6_order
#line 136 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 20281 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'monochromator7' [122]. */
#define mccompcurname  monochromator7
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 122
#define mos_rms_y mccmonochromator7_mos_rms_y
#define mos_rms_z mccmonochromator7_mos_rms_z
#define mos_rms_max mccmonochromator7_mos_rms_max
#define mono_Q mccmonochromator7_mono_Q
#define SlabWidth mccmonochromator7_SlabWidth
#define SlabHeight mccmonochromator7_SlabHeight
#define rTable mccmonochromator7_rTable
#define tTable mccmonochromator7_tTable
#define row mccmonochromator7_row
#define col mccmonochromator7_col
#define tiltH mccmonochromator7_tiltH
#define tiltV mccmonochromator7_tiltV
#define reflect mccmonochromator7_reflect
#define transmit mccmonochromator7_transmit
#define zwidth mccmonochromator7_zwidth
#define yheight mccmonochromator7_yheight
#define gap mccmonochromator7_gap
#define NH mccmonochromator7_NH
#define NV mccmonochromator7_NV
#define mosaich mccmonochromator7_mosaich
#define mosaicv mccmonochromator7_mosaicv
#define r0 mccmonochromator7_r0
#define t0 mccmonochromator7_t0
#define Q mccmonochromator7_Q
#define RV mccmonochromator7_RV
#define RH mccmonochromator7_RH
#define DM mccmonochromator7_DM
#define mosaic mccmonochromator7_mosaic
#define width mccmonochromator7_width
#define height mccmonochromator7_height
#define verbose mccmonochromator7_verbose
#define order mccmonochromator7_order
#line 136 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
  double mos_rms_y; /* root-mean-square of mosaic, in radians */
  double mos_rms_z;
  double mos_rms_max;
  double mono_Q;
  double SlabWidth, SlabHeight;
  t_Table rTable, tTable;
  double row,col;
  double* tiltH;
  double* tiltV;
#line 20364 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Mono_Out' [123]. */
#define mccompcurname  Mono_Out
#define mccompcurtype  Arm
#define mccompcurindex 123
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'psd_monitor' [124]. */
#define mccompcurname  psd_monitor
#define mccompcurtype  PSD_monitor
#define mccompcurindex 124
#define nx mccpsd_monitor_nx
#define ny mccpsd_monitor_ny
#define PSD_N mccpsd_monitor_PSD_N
#define PSD_p mccpsd_monitor_PSD_p
#define PSD_p2 mccpsd_monitor_PSD_p2
#define filename mccpsd_monitor_filename
#define xmin mccpsd_monitor_xmin
#define xmax mccpsd_monitor_xmax
#define ymin mccpsd_monitor_ymin
#define ymax mccpsd_monitor_ymax
#define xwidth mccpsd_monitor_xwidth
#define yheight mccpsd_monitor_yheight
#define restore_neutron mccpsd_monitor_restore_neutron
#line 55 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
double PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
#line 20430 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'e_monitor' [125]. */
#define mccompcurname  e_monitor
#define mccompcurtype  E_monitor
#define mccompcurindex 125
#define nE mcce_monitor_nE
#define E_N mcce_monitor_E_N
#define E_p mcce_monitor_E_p
#define E_p2 mcce_monitor_E_p2
#define S_p mcce_monitor_S_p
#define S_pE mcce_monitor_S_pE
#define S_pE2 mcce_monitor_S_pE2
#define filename mcce_monitor_filename
#define xmin mcce_monitor_xmin
#define xmax mcce_monitor_xmax
#define ymin mcce_monitor_ymin
#define ymax mcce_monitor_ymax
#define xwidth mcce_monitor_xwidth
#define yheight mcce_monitor_yheight
#define Emin mcce_monitor_Emin
#define Emax mcce_monitor_Emax
#define restore_neutron mcce_monitor_restore_neutron
#line 59 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 20473 "BIFROST.c"
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

Coords mcposaOrigin, mcposrOrigin;
Rotation mcrotaOrigin, mcrotrOrigin;
Coords mcposaESS_source, mcposrESS_source;
Rotation mcrotaESS_source, mcrotrESS_source;
Coords mcposaStartOfGuide, mcposrStartOfGuide;
Rotation mcrotaStartOfGuide, mcrotrStartOfGuide;
Coords mcposaNBOA, mcposrNBOA;
Rotation mcrotaNBOA, mcrotrNBOA;
Coords mcposaEndOfelement_6, mcposrEndOfelement_6;
Rotation mcrotaEndOfelement_6, mcrotrEndOfelement_6;
Coords mcposaL_monBeforePSC1, mcposrL_monBeforePSC1;
Rotation mcrotaL_monBeforePSC1, mcrotrL_monBeforePSC1;
Coords mcposaToFBeforerPSC1, mcposrToFBeforerPSC1;
Rotation mcrotaToFBeforerPSC1, mcrotrToFBeforerPSC1;
Coords mcposaPSD_beforePulseShapping1, mcposrPSD_beforePulseShapping1;
Rotation mcrotaPSD_beforePulseShapping1, mcrotrPSD_beforePulseShapping1;
Coords mcposaTofLambdaBeforePSC, mcposrTofLambdaBeforePSC;
Rotation mcrotaTofLambdaBeforePSC, mcrotrTofLambdaBeforePSC;
Coords mcposaPulseShapingChopper, mcposrPulseShapingChopper;
Rotation mcrotaPulseShapingChopper, mcrotrPulseShapingChopper;
Coords mcposaPSD_AfterPulseShapping1, mcposrPSD_AfterPulseShapping1;
Rotation mcrotaPSD_AfterPulseShapping1, mcrotrPSD_AfterPulseShapping1;
Coords mcposaToFInsidePSC, mcposrToFInsidePSC;
Rotation mcrotaToFInsidePSC, mcrotrToFInsidePSC;
Coords mcposaPulseShapingChopper2, mcposrPulseShapingChopper2;
Rotation mcrotaPulseShapingChopper2, mcrotrPulseShapingChopper2;
Coords mcposaTofLambdaAfterPSC2, mcposrTofLambdaAfterPSC2;
Rotation mcrotaTofLambdaAfterPSC2, mcrotrTofLambdaAfterPSC2;
Coords mcposaPSD_AfterPSC2, mcposrPSD_AfterPSC2;
Rotation mcrotaPSD_AfterPSC2, mcrotrPSD_AfterPSC2;
Coords mcposaToFAfterPSC2, mcposrToFAfterPSC2;
Rotation mcrotaToFAfterPSC2, mcrotrToFAfterPSC2;
Coords mcposaL_monAfterPSC2, mcposrL_monAfterPSC2;
Rotation mcrotaL_monAfterPSC2, mcrotrL_monAfterPSC2;
Coords mcposaEndOfelement_5, mcposrEndOfelement_5;
Rotation mcrotaEndOfelement_5, mcrotrEndOfelement_5;
Coords mcposacurved_guide_1_0, mcposrcurved_guide_1_0;
Rotation mcrotacurved_guide_1_0, mcrotrcurved_guide_1_0;
Coords mcposacurved_guide_2_0, mcposrcurved_guide_2_0;
Rotation mcrotacurved_guide_2_0, mcrotrcurved_guide_2_0;
Coords mcposacurved_guide_3_0, mcposrcurved_guide_3_0;
Rotation mcrotacurved_guide_3_0, mcrotrcurved_guide_3_0;
Coords mcposacurved_guide_4_0, mcposrcurved_guide_4_0;
Rotation mcrotacurved_guide_4_0, mcrotrcurved_guide_4_0;
Coords mcposacurved_guide_5_beforeChopper, mcposrcurved_guide_5_beforeChopper;
Rotation mcrotacurved_guide_5_beforeChopper, mcrotrcurved_guide_5_beforeChopper;
Coords mcposaL_monBeforeFOC1, mcposrL_monBeforeFOC1;
Rotation mcrotaL_monBeforeFOC1, mcrotrL_monBeforeFOC1;
Coords mcposaToFBeforeFOC1, mcposrToFBeforeFOC1;
Rotation mcrotaToFBeforeFOC1, mcrotrToFBeforeFOC1;
Coords mcposaPSD_beforeFOC1, mcposrPSD_beforeFOC1;
Rotation mcrotaPSD_beforeFOC1, mcrotrPSD_beforeFOC1;
Coords mcposaFOC1, mcposrFOC1;
Rotation mcrotaFOC1, mcrotrFOC1;
Coords mcposaPSD_afterFOC1, mcposrPSD_afterFOC1;
Rotation mcrotaPSD_afterFOC1, mcrotrPSD_afterFOC1;
Coords mcposaToFAfterFOC1, mcposrToFAfterFOC1;
Rotation mcrotaToFAfterFOC1, mcrotrToFAfterFOC1;
Coords mcposaL_monAfterFOC1, mcposrL_monAfterFOC1;
Rotation mcrotaL_monAfterFOC1, mcrotrL_monAfterFOC1;
Coords mcposacurved_guide_5_afterChopper, mcposrcurved_guide_5_afterChopper;
Rotation mcrotacurved_guide_5_afterChopper, mcrotrcurved_guide_5_afterChopper;
Coords mcposacurved_guide_6_0, mcposrcurved_guide_6_0;
Rotation mcrotacurved_guide_6_0, mcrotrcurved_guide_6_0;
Coords mcposacurved_guide_7_0, mcposrcurved_guide_7_0;
Rotation mcrotacurved_guide_7_0, mcrotrcurved_guide_7_0;
Coords mcposacurved_guide_8_0, mcposrcurved_guide_8_0;
Rotation mcrotacurved_guide_8_0, mcrotrcurved_guide_8_0;
Coords mcposacurved_guide_9_0, mcposrcurved_guide_9_0;
Rotation mcrotacurved_guide_9_0, mcrotrcurved_guide_9_0;
Coords mcposacurved_guide_10_0, mcposrcurved_guide_10_0;
Rotation mcrotacurved_guide_10_0, mcrotrcurved_guide_10_0;
Coords mcposacurved_guide_11_0, mcposrcurved_guide_11_0;
Rotation mcrotacurved_guide_11_0, mcrotrcurved_guide_11_0;
Coords mcposacurved_guide_12_0, mcposrcurved_guide_12_0;
Rotation mcrotacurved_guide_12_0, mcrotrcurved_guide_12_0;
Coords mcposacurved_guide_13_0, mcposrcurved_guide_13_0;
Rotation mcrotacurved_guide_13_0, mcrotrcurved_guide_13_0;
Coords mcposacurved_guide_14_0, mcposrcurved_guide_14_0;
Rotation mcrotacurved_guide_14_0, mcrotrcurved_guide_14_0;
Coords mcposacurved_guide_15_0, mcposrcurved_guide_15_0;
Rotation mcrotacurved_guide_15_0, mcrotrcurved_guide_15_0;
Coords mcposacurved_guide_16_0, mcposrcurved_guide_16_0;
Rotation mcrotacurved_guide_16_0, mcrotrcurved_guide_16_0;
Coords mcposacurved_guide_17_0, mcposrcurved_guide_17_0;
Rotation mcrotacurved_guide_17_0, mcrotrcurved_guide_17_0;
Coords mcposacurved_guide_18_beforeChopper, mcposrcurved_guide_18_beforeChopper;
Rotation mcrotacurved_guide_18_beforeChopper, mcrotrcurved_guide_18_beforeChopper;
Coords mcposaL_monBeforeFOC2, mcposrL_monBeforeFOC2;
Rotation mcrotaL_monBeforeFOC2, mcrotrL_monBeforeFOC2;
Coords mcposaToFBeforeFOC2, mcposrToFBeforeFOC2;
Rotation mcrotaToFBeforeFOC2, mcrotrToFBeforeFOC2;
Coords mcposaPSD_beforeFOC2, mcposrPSD_beforeFOC2;
Rotation mcrotaPSD_beforeFOC2, mcrotrPSD_beforeFOC2;
Coords mcposaFOC2, mcposrFOC2;
Rotation mcrotaFOC2, mcrotrFOC2;
Coords mcposaPSD_afterFOC2, mcposrPSD_afterFOC2;
Rotation mcrotaPSD_afterFOC2, mcrotrPSD_afterFOC2;
Coords mcposaToFAfterFOC2, mcposrToFAfterFOC2;
Rotation mcrotaToFAfterFOC2, mcrotrToFAfterFOC2;
Coords mcposaL_monAfterFOC2, mcposrL_monAfterFOC2;
Rotation mcrotaL_monAfterFOC2, mcrotrL_monAfterFOC2;
Coords mcposacurved_guide_18_afterChopper, mcposrcurved_guide_18_afterChopper;
Rotation mcrotacurved_guide_18_afterChopper, mcrotrcurved_guide_18_afterChopper;
Coords mcposacurved_guide_19_0, mcposrcurved_guide_19_0;
Rotation mcrotacurved_guide_19_0, mcrotrcurved_guide_19_0;
Coords mcposacurved_guide_20_0, mcposrcurved_guide_20_0;
Rotation mcrotacurved_guide_20_0, mcrotrcurved_guide_20_0;
Coords mcposacurved_guide_21_0, mcposrcurved_guide_21_0;
Rotation mcrotacurved_guide_21_0, mcrotrcurved_guide_21_0;
Coords mcposacurved_guide_22_0, mcposrcurved_guide_22_0;
Rotation mcrotacurved_guide_22_0, mcrotrcurved_guide_22_0;
Coords mcposacurved_guide_23_0, mcposrcurved_guide_23_0;
Rotation mcrotacurved_guide_23_0, mcrotrcurved_guide_23_0;
Coords mcposacurved_guide_24_0, mcposrcurved_guide_24_0;
Rotation mcrotacurved_guide_24_0, mcrotrcurved_guide_24_0;
Coords mcposacurved_guide_25_0, mcposrcurved_guide_25_0;
Rotation mcrotacurved_guide_25_0, mcrotrcurved_guide_25_0;
Coords mcposacurved_guide_26_0, mcposrcurved_guide_26_0;
Rotation mcrotacurved_guide_26_0, mcrotrcurved_guide_26_0;
Coords mcposacurved_guide_27_0, mcposrcurved_guide_27_0;
Rotation mcrotacurved_guide_27_0, mcrotrcurved_guide_27_0;
Coords mcposacurved_guide_28_0, mcposrcurved_guide_28_0;
Rotation mcrotacurved_guide_28_0, mcrotrcurved_guide_28_0;
Coords mcposacurved_guide_29_0, mcposrcurved_guide_29_0;
Rotation mcrotacurved_guide_29_0, mcrotrcurved_guide_29_0;
Coords mcposacurved_guide_30_0, mcposrcurved_guide_30_0;
Rotation mcrotacurved_guide_30_0, mcrotrcurved_guide_30_0;
Coords mcposacurved_guide_31_0, mcposrcurved_guide_31_0;
Rotation mcrotacurved_guide_31_0, mcrotrcurved_guide_31_0;
Coords mcposacurved_guide_32_0, mcposrcurved_guide_32_0;
Rotation mcrotacurved_guide_32_0, mcrotrcurved_guide_32_0;
Coords mcposacurved_guide_33_0, mcposrcurved_guide_33_0;
Rotation mcrotacurved_guide_33_0, mcrotrcurved_guide_33_0;
Coords mcposacurved_guide_34_0, mcposrcurved_guide_34_0;
Rotation mcrotacurved_guide_34_0, mcrotrcurved_guide_34_0;
Coords mcposacurved_guide_35_0, mcposrcurved_guide_35_0;
Rotation mcrotacurved_guide_35_0, mcrotrcurved_guide_35_0;
Coords mcposacurved_guide_36_0, mcposrcurved_guide_36_0;
Rotation mcrotacurved_guide_36_0, mcrotrcurved_guide_36_0;
Coords mcposaEndOfelement_4, mcposrEndOfelement_4;
Rotation mcrotaEndOfelement_4, mcrotrEndOfelement_4;
Coords mcposaelliptical_guide_gravity3, mcposrelliptical_guide_gravity3;
Rotation mcrotaelliptical_guide_gravity3, mcrotrelliptical_guide_gravity3;
Coords mcposaEndOfelement_3, mcposrEndOfelement_3;
Rotation mcrotaEndOfelement_3, mcrotrEndOfelement_3;
Coords mcposastraight_guide_2_1, mcposrstraight_guide_2_1;
Rotation mcrotastraight_guide_2_1, mcrotrstraight_guide_2_1;
Coords mcposaL_monBeforeBWC, mcposrL_monBeforeBWC;
Rotation mcrotaL_monBeforeBWC, mcrotrL_monBeforeBWC;
Coords mcposaToFBeforeBWC, mcposrToFBeforeBWC;
Rotation mcrotaToFBeforeBWC, mcrotrToFBeforeBWC;
Coords mcposaBWC1, mcposrBWC1;
Rotation mcrotaBWC1, mcrotrBWC1;
Coords mcposaBWC2, mcposrBWC2;
Rotation mcrotaBWC2, mcrotrBWC2;
Coords mcposaToFAfterBWC, mcposrToFAfterBWC;
Rotation mcrotaToFAfterBWC, mcrotrToFAfterBWC;
Coords mcposaL_monAfterBWC, mcposrL_monAfterBWC;
Rotation mcrotaL_monAfterBWC, mcrotrL_monAfterBWC;
Coords mcposastraight_guide_2_2, mcposrstraight_guide_2_2;
Rotation mcrotastraight_guide_2_2, mcrotrstraight_guide_2_2;
Coords mcposaEndOfelement_2, mcposrEndOfelement_2;
Rotation mcrotaEndOfelement_2, mcrotrEndOfelement_2;
Coords mcposaelliptical_guide_gravity1_1, mcposrelliptical_guide_gravity1_1;
Rotation mcrotaelliptical_guide_gravity1_1, mcrotrelliptical_guide_gravity1_1;
Coords mcposaDiwJaw3, mcposrDiwJaw3;
Rotation mcrotaDiwJaw3, mcrotrDiwJaw3;
Coords mcposaelliptical_guide_gravity1_2, mcposrelliptical_guide_gravity1_2;
Rotation mcrotaelliptical_guide_gravity1_2, mcrotrelliptical_guide_gravity1_2;
Coords mcposaDiwJaw2, mcposrDiwJaw2;
Rotation mcrotaDiwJaw2, mcrotrDiwJaw2;
Coords mcposaelliptical_guide_gravity1_3, mcposrelliptical_guide_gravity1_3;
Rotation mcrotaelliptical_guide_gravity1_3, mcrotrelliptical_guide_gravity1_3;
Coords mcposaDiwJaw1, mcposrDiwJaw1;
Rotation mcrotaDiwJaw1, mcrotrDiwJaw1;
Coords mcposaelliptical_guide_gravity1_4, mcposrelliptical_guide_gravity1_4;
Rotation mcrotaelliptical_guide_gravity1_4, mcrotrelliptical_guide_gravity1_4;
Coords mcposaEndOfelement_1, mcposrEndOfelement_1;
Rotation mcrotaEndOfelement_1, mcrotrEndOfelement_1;
Coords mcposaVirtualOutput, mcposrVirtualOutput;
Rotation mcrotaVirtualOutput, mcrotrVirtualOutput;
Coords mcposaDiwJaw0, mcposrDiwJaw0;
Rotation mcrotaDiwJaw0, mcrotrDiwJaw0;
Coords mcposaLmon_guide_end, mcposrLmon_guide_end;
Rotation mcrotaLmon_guide_end, mcrotrLmon_guide_end;
Coords mcposaDiv2d_sample_B, mcposrDiv2d_sample_B;
Rotation mcrotaDiv2d_sample_B, mcrotrDiv2d_sample_B;
Coords mcposaDiv2d_sample, mcposrDiv2d_sample;
Rotation mcrotaDiv2d_sample, mcrotrDiv2d_sample;
Coords mcposaPSD_sample, mcposrPSD_sample;
Rotation mcrotaPSD_sample, mcrotrPSD_sample;
Coords mcposaHPSD_sample, mcposrHPSD_sample;
Rotation mcrotaHPSD_sample, mcrotrHPSD_sample;
Coords mcposaVPSD_sample, mcposrVPSD_sample;
Rotation mcrotaVPSD_sample, mcrotrVPSD_sample;
Coords mcposaHdiv_sample, mcposrHdiv_sample;
Rotation mcrotaHdiv_sample, mcrotrHdiv_sample;
Coords mcposaVdiv_sample, mcposrVdiv_sample;
Rotation mcrotaVdiv_sample, mcrotrVdiv_sample;
Coords mcposaacceptance_x_divx, mcposracceptance_x_divx;
Rotation mcrotaacceptance_x_divx, mcrotracceptance_x_divx;
Coords mcposaacceptance_y_divy, mcposracceptance_y_divy;
Rotation mcrotaacceptance_y_divy, mcrotracceptance_y_divy;
Coords mcposaLmon_sample_B, mcposrLmon_sample_B;
Rotation mcrotaLmon_sample_B, mcrotrLmon_sample_B;
Coords mcposaDiv2d_sample_maxdiv, mcposrDiv2d_sample_maxdiv;
Rotation mcrotaDiv2d_sample_maxdiv, mcrotrDiv2d_sample_maxdiv;
Coords mcposaPSD_sample_maxdiv, mcposrPSD_sample_maxdiv;
Rotation mcrotaPSD_sample_maxdiv, mcrotrPSD_sample_maxdiv;
Coords mcposaHPSD_sample_maxdiv, mcposrHPSD_sample_maxdiv;
Rotation mcrotaHPSD_sample_maxdiv, mcrotrHPSD_sample_maxdiv;
Coords mcposaVPSD_sample_maxdiv, mcposrVPSD_sample_maxdiv;
Rotation mcrotaVPSD_sample_maxdiv, mcrotrVPSD_sample_maxdiv;
Coords mcposaHdiv_sample_maxdiv, mcposrHdiv_sample_maxdiv;
Rotation mcrotaHdiv_sample_maxdiv, mcrotrHdiv_sample_maxdiv;
Coords mcposaVdiv_sample_maxdiv, mcposrVdiv_sample_maxdiv;
Rotation mcrotaVdiv_sample_maxdiv, mcrotrVdiv_sample_maxdiv;
Coords mcposaacceptance_x_divx_maxdiv, mcposracceptance_x_divx_maxdiv;
Rotation mcrotaacceptance_x_divx_maxdiv, mcrotracceptance_x_divx_maxdiv;
Coords mcposaacceptance_y_divy_maxdiv, mcposracceptance_y_divy_maxdiv;
Rotation mcrotaacceptance_y_divy_maxdiv, mcrotracceptance_y_divy_maxdiv;
Coords mcposaLmon_sample, mcposrLmon_sample;
Rotation mcrotaLmon_sample, mcrotrLmon_sample;
Coords mcposav_sample, mcposrv_sample;
Rotation mcrotav_sample, mcrotrv_sample;
Coords mcposaMono_Cradle, mcposrMono_Cradle;
Rotation mcrotaMono_Cradle, mcrotrMono_Cradle;
Coords mcposaXY_ARM, mcposrXY_ARM;
Rotation mcrotaXY_ARM, mcrotrXY_ARM;
Coords mcposamonochromator_flat, mcposrmonochromator_flat;
Rotation mcrotamonochromator_flat, mcrotrmonochromator_flat;
Coords mcposamonochromator2, mcposrmonochromator2;
Rotation mcrotamonochromator2, mcrotrmonochromator2;
Coords mcposamonochromator3, mcposrmonochromator3;
Rotation mcrotamonochromator3, mcrotrmonochromator3;
Coords mcposamonochromator4, mcposrmonochromator4;
Rotation mcrotamonochromator4, mcrotrmonochromator4;
Coords mcposamonochromator5, mcposrmonochromator5;
Rotation mcrotamonochromator5, mcrotrmonochromator5;
Coords mcposamonochromator6, mcposrmonochromator6;
Rotation mcrotamonochromator6, mcrotrmonochromator6;
Coords mcposamonochromator7, mcposrmonochromator7;
Rotation mcrotamonochromator7, mcrotrmonochromator7;
Coords mcposaMono_Out, mcposrMono_Out;
Rotation mcrotaMono_Out, mcrotrMono_Out;
Coords mcposapsd_monitor, mcposrpsd_monitor;
Rotation mcrotapsd_monitor, mcrotrpsd_monitor;
Coords mcposae_monitor, mcposre_monitor;
Rotation mcrotae_monitor, mcrotre_monitor;

MCNUM mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz, mcnt, mcnsx, mcnsy, mcnsz, mcnp;

/* end declare */

void mcinit(void) {
#define mccompcurname  BIFROST
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaBIFROST coords_set(0,0,0)
#define WaveMin mcipWaveMin
#define WaveMax mcipWaveMax
#define pin_holeY mcippin_holeY
#define pin_holeX mcippin_holeX
#define E_0 mcipE_0
#define L_0 mcipL_0
#define chopPulseOpening mcipchopPulseOpening
#define chopPulseFrequencyOrder mcipchopPulseFrequencyOrder
#define sampleSizeX mcipsampleSizeX
#define sampleSizeY mcipsampleSizeY
#define chopBWPos mcipchopBWPos
#define DivSlit0_width mcipDivSlit0_width
#define DivSlit1_width mcipDivSlit1_width
#define DivSlit2_width mcipDivSlit2_width
#define DivSlit3_width mcipDivSlit3_width
#define BWopen mcipBWopen
#define FOCopen1 mcipFOCopen1
#define FOCopen2 mcipFOCopen2
#define Npulse mcipNpulse
#define PscOff mcipPscOff
#define discD mcipdiscD
#define monigap_length mcipmonigap_length
#define print mcipprint
#define makeVirtualSource mcipmakeVirtualSource
#define printMValues mcipprintMValues
#define OMA mcipOMA
#define TTA mcipTTA
#define phi mcipphi
#define dphi mcipdphi
#line 150 "BIFROST.instr"
{


// If there is set a value of L_0, overwrite E_0 and calculate E_0 from L_0 
if (L_0>0){
	E_0=81.82/(L_0*L_0);
}



// Following is all the m-values for the entire guide hardcoaded in arrays along with the element lengths for each m-value. 
// It is important to note that the naming convention here goes the opposite way of the neutron path, meaning that mValues1 describes the m-values on the element closest to the sample and mValues6 are closest to the source.

 //// Part 1 //// 
 elementLength1_part_1[0] = 0.50000; 
 mValues1vertical_part_1[0] = 1.50; 
 mValues1horizontal_part_1[0] = 1.50;

 elementLength1_part_1[1] = 0.50000; 
 mValues1vertical_part_1[1] = 1.50; 
 mValues1horizontal_part_1[1] = 1.50;

 elementLength1_part_1[2] = 0.50000; 
 mValues1vertical_part_1[2] = 1.50; 
 mValues1horizontal_part_1[2] = 1.50;

 elementLength1_part_1[3] = 0.50000; 
 mValues1vertical_part_1[3] = 1.50; 
 mValues1horizontal_part_1[3] = 1.50;

 elementLength1_part_1[4] = 0.50000; 
 mValues1vertical_part_1[4] = 1.50; 
 mValues1horizontal_part_1[4] = 1.50;

 elementLength1_part_1[5] = 0.50000; 
 mValues1vertical_part_1[5] = 1.50; 
 mValues1horizontal_part_1[5] = 1.50;

 elementLength1_part_1[6] = 0.50000; 
 mValues1vertical_part_1[6] = 1.50; 
 mValues1horizontal_part_1[6] = 1.50;

 elementLength1_part_1[7] = 0.50000; 
 mValues1vertical_part_1[7] = 1.50; 
 mValues1horizontal_part_1[7] = 1.50;

 elementLength1_part_1[8] = 0.50000; 
 mValues1vertical_part_1[8] = 1.50; 
 mValues1horizontal_part_1[8] = 1.50;

 elementLength1_part_1[9] = 0.50000; 
 mValues1vertical_part_1[9] = 1.50; 
 mValues1horizontal_part_1[9] = 1.50;

 elementLength1_part_1[10] = 0.50000; 
 mValues1vertical_part_1[10] = 1.50; 
 mValues1horizontal_part_1[10] = 1.50;

 elementLength1_part_1[11] = 0.50000; 
 mValues1vertical_part_1[11] = 1.50; 
 mValues1horizontal_part_1[11] = 1.50;

 elementLength1_part_1[12] = 0.50000; 
 mValues1vertical_part_1[12] = 1.50; 
 mValues1horizontal_part_1[12] = 1.50;

 elementLength1_part_1[13] = 0.50000; 
 mValues1vertical_part_1[13] = 1.50; 
 mValues1horizontal_part_1[13] = 1.50;

 elementLength1_part_1[14] = 0.50000; 
 mValues1vertical_part_1[14] = 1.50; 
 mValues1horizontal_part_1[14] = 1.50;

 elementLength1_part_1[15] = 0.50000; 
 mValues1vertical_part_1[15] = 1.50; 
 mValues1horizontal_part_1[15] = 1.50;

 elementLength1_part_1[16] = 0.50000; 
 mValues1vertical_part_1[16] = 1.50; 
 mValues1horizontal_part_1[16] = 1.50;

 elementLength1_part_1[17] = 0.50000; 
 mValues1vertical_part_1[17] = 1.50; 
 mValues1horizontal_part_1[17] = 1.50;

 elementLength1_part_1[18] = 0.50000; 
 mValues1vertical_part_1[18] = 1.50; 
 mValues1horizontal_part_1[18] = 1.50;

 elementLength1_part_1[19] = 0.50000; 
 mValues1vertical_part_1[19] = 1.50; 
 mValues1horizontal_part_1[19] = 1.50;

 elementLength1_part_1[20] = 0.50000; 
 mValues1vertical_part_1[20] = 1.50; 
 mValues1horizontal_part_1[20] = 1.50;

 elementLength1_part_1[21] = 0.50000; 
 mValues1vertical_part_1[21] = 1.50; 
 mValues1horizontal_part_1[21] = 1.50;

 elementLength1_part_1[22] = 0.50000; 
 mValues1vertical_part_1[22] = 2.00; 
 mValues1horizontal_part_1[22] = 1.50;

 elementLength1_part_1[23] = 0.50000; 
 mValues1vertical_part_1[23] = 2.00; 
 mValues1horizontal_part_1[23] = 1.50;

 elementLength1_part_1[24] = 0.50000; 
 mValues1vertical_part_1[24] = 2.00; 
 mValues1horizontal_part_1[24] = 1.50;

 elementLength1_part_1[25] = 0.50000; 
 mValues1vertical_part_1[25] = 2.00; 
 mValues1horizontal_part_1[25] = 1.50;

 elementLength1_part_1[26] = 0.50000; 
 mValues1vertical_part_1[26] = 2.00; 
 mValues1horizontal_part_1[26] = 1.50;

 elementLength1_part_1[27] = 0.50000; 
 mValues1vertical_part_1[27] = 2.00; 
 mValues1horizontal_part_1[27] = 1.50;

 elementLength1_part_1[28] = 0.50000; 
 mValues1vertical_part_1[28] = 2.00; 
 mValues1horizontal_part_1[28] = 1.50;

 elementLength1_part_1[29] = 0.50000; 
 mValues1vertical_part_1[29] = 2.00; 
 mValues1horizontal_part_1[29] = 1.50;

 elementLength1_part_1[30] = 0.50000; 
 mValues1vertical_part_1[30] = 2.00; 
 mValues1horizontal_part_1[30] = 1.50;

 elementLength1_part_1[31] = 0.50000; 
 mValues1vertical_part_1[31] = 2.00; 
 mValues1horizontal_part_1[31] = 1.50;

 elementLength1_part_1[32] = 0.50000; 
 mValues1vertical_part_1[32] = 2.00; 
 mValues1horizontal_part_1[32] = 2.00;

 elementLength1_part_1[33] = 0.50000; 
 mValues1vertical_part_1[33] = 2.00; 
 mValues1horizontal_part_1[33] = 2.00;

 elementLength1_part_1[34] = 0.50000; 
 mValues1vertical_part_1[34] = 2.00; 
 mValues1horizontal_part_1[34] = 2.00;

 elementLength1_part_1[35] = 0.50000; 
 mValues1vertical_part_1[35] = 2.00; 
 mValues1horizontal_part_1[35] = 2.00;

 elementLength1_part_1[36] = 0.01580;  // Gap 
 mValues1vertical_part_1[36] = 0.00; 
 mValues1horizontal_part_1[36] = 0.00;

 elementLength1_part_1[37] = 0.48420; 
 mValues1vertical_part_1[37] = 2.00; 
 mValues1horizontal_part_1[37] = 2.00;

 elementLength1_part_1[38] = 0.50000; 
 mValues1vertical_part_1[38] = 2.00; 
 mValues1horizontal_part_1[38] = 2.50;

 elementLength1_part_1[39] = 0.50000; 
 mValues1vertical_part_1[39] = 2.50; 
 mValues1horizontal_part_1[39] = 2.50;

 elementLength1_part_1[40] = 0.14320; 
 mValues1vertical_part_1[40] = 2.50; 
 mValues1horizontal_part_1[40] = 2.50;

 
 //// Part 2 //// 
 elementLength1_part_2[0] = 0.31680; 
 mValues1vertical_part_2[0] = 2.50; 
 mValues1horizontal_part_2[0] = 2.50;

 elementLength1_part_2[1] = 0.50000; 
 mValues1vertical_part_2[1] = 3.00; 
 mValues1horizontal_part_2[1] = 3.00;

 elementLength1_part_2[2] = 0.46320; 
 mValues1vertical_part_2[2] = 3.00; 
 mValues1horizontal_part_2[2] = 3.00;

 
 //// Part 3 //// 
 elementLength1_part_3[0] = 0.0596; 
 mValues1vertical_part_3[0] = 3.00; 
 mValues1horizontal_part_3[0] = 3.00;

 elementLength1_part_3[1] = 0.500; 
 mValues1vertical_part_3[1] = 3.50; 
 mValues1horizontal_part_3[1] = 3.00;

 
 //// Part 4 //// 
 elementLength1_part_4[0] = 0.06670 ; 
 mValues1vertical_part_4[0] = 3.50; 
 mValues1horizontal_part_4[0] = 3.00;

 elementLength1_part_4[1] = 0.50000; 
 mValues1vertical_part_4[1] = 3.50; 
 mValues1horizontal_part_4[1] = 3.5;

// A bit extra due to mismatch in coating lengths after rounding element length to 0.5 meters:
// 0.47 cm of this is applied in last tested version (sep 12 2018)
 elementLength1_part_4[2] = 0.0047;  
 mValues1vertical_part_4[2] = 3.50; 
 mValues1horizontal_part_4[2] = 3.5;


elementLength3S[0]=0.50;
mValues3verticalS[0]=2.000000;
mValues3horizontalS[0]=2.500000;
elementLength3S[1]=0.50;
mValues3verticalS[1]=2.000000;
mValues3horizontalS[1]=2.500000;
elementLength3S[2]=0.50;
mValues3verticalS[2]=2.000000;
mValues3horizontalS[2]=2.500000;
elementLength3S[3]=0.50;
mValues3verticalS[3]=2.000000;
mValues3horizontalS[3]=2.500000;
elementLength3S[4]=0.50;
mValues3verticalS[4]=2.000000;
mValues3horizontalS[4]=2.500000;
elementLength3S[5]=0.50;
mValues3verticalS[5]=2.000000;
mValues3horizontalS[5]=2.500000;
elementLength3S[6]=0.50;
mValues3verticalS[6]=2.000000;
mValues3horizontalS[6]=2.500000;

// Moni gap
elementLength3S[7]=monigap_length;
mValues3verticalS[7]=0;
mValues3horizontalS[7]=0;


elementLength3S[7+1]=0.50-monigap_length;
mValues3verticalS[7+1]=2.000000;
mValues3horizontalS[7+1]=2.000000;
elementLength3S[8+1]=0.50;
mValues3verticalS[8+1]=2.000000;
mValues3horizontalS[8+1]=2.000000;
elementLength3S[9+1]=0.50;
mValues3verticalS[9+1]=2.000000;
mValues3horizontalS[9+1]=2.000000;
elementLength3S[10+1]=0.50;
mValues3verticalS[10+1]=2.000000;
mValues3horizontalS[10+1]=2.000000;
elementLength3S[11+1]=0.50;
mValues3verticalS[11+1]=2.000000;
mValues3horizontalS[11+1]=2.000000;
elementLength3S[12+1]=0.50;
mValues3verticalS[12+1]=2.000000;
mValues3horizontalS[12+1]=2.000000;
elementLength3S[13+1]=0.50;
mValues3verticalS[13+1]=1.500000;
mValues3horizontalS[13+1]=2.000000;
elementLength3S[14+1]=0.50;
mValues3verticalS[14+1]=1.500000;
mValues3horizontalS[14+1]=2.000000;
elementLength3S[15+1]=0.50;
mValues3verticalS[15+1]=1.500000;
mValues3horizontalS[15+1]=2.000000;
elementLength3S[16+1]=0.50;
mValues3verticalS[16+1]=1.500000;
mValues3horizontalS[16+1]=2.000000;
elementLength3S[17+1]=0.50;
mValues3verticalS[17+1]=1.500000;
mValues3horizontalS[17+1]=2.000000;
elementLength3S[18+1]=0.50;
mValues3verticalS[18+1]=1.500000;
mValues3horizontalS[18+1]=2.000000;
elementLength3S[19+1]=0.50;
mValues3verticalS[19+1]=1.500000;
mValues3horizontalS[19+1]=2.000000;
elementLength3S[20+1]=0.50;
mValues3verticalS[20+1]=1.500000;
mValues3horizontalS[20+1]=2.000000;
elementLength3S[21+1]=0.50;
mValues3verticalS[21+1]=1.500000;
mValues3horizontalS[21+1]=2.000000;
elementLength3S[22+1]=0.50;
mValues3verticalS[22+1]=1.500000;
mValues3horizontalS[22+1]=2.000000;
elementLength3S[23+1]=0.50;
mValues3verticalS[23+1]=1.500000;
mValues3horizontalS[23+1]=1.500000;
elementLength3S[24+1]=0.50;
mValues3verticalS[24+1]=1.500000;
mValues3horizontalS[24+1]=1.500000;
elementLength3S[25+1]=0.50;
mValues3verticalS[25+1]=1.500000;
mValues3horizontalS[25+1]=1.500000;
elementLength3S[26+1]=0.50;
mValues3verticalS[26+1]=1.500000;
mValues3horizontalS[26+1]=1.500000;
elementLength3S[27+1]=0.50;
mValues3verticalS[27+1]=1.500000;
mValues3horizontalS[27+1]=1.500000;
elementLength3S[28+1]=0.50;
mValues3verticalS[28+1]=1.500000;
mValues3horizontalS[28+1]=1.500000;
elementLength3S[29+1]=0.50;
mValues3verticalS[29+1]=1.500000;
mValues3horizontalS[29+1]=1.500000;
elementLength3S[30+1]=0.50;
mValues3verticalS[30+1]=1.500000;
mValues3horizontalS[30+1]=1.500000;
elementLength3S[31+1]=0.50;
mValues3verticalS[31+1]=1.500000;
mValues3horizontalS[31+1]=1.500000;
elementLength3S[32+1]=0.50;
mValues3verticalS[32+1]=1.500000;
mValues3horizontalS[32+1]=1.500000;
elementLength3S[33+1]=0.50;
mValues3verticalS[33+1]=1.500000;
mValues3horizontalS[33+1]=1.500000;
elementLength3S[34+1]=0.50;
mValues3verticalS[34+1]=1.500000;
mValues3horizontalS[34+1]=1.500000;
elementLength3S[35+1]=0.50;
mValues3verticalS[35+1]=1.500000;
mValues3horizontalS[35+1]=1.500000;
elementLength3S[36+1]=0.50;
mValues3verticalS[36+1]=1.500000;
mValues3horizontalS[36+1]=1.500000;
elementLength3S[37+1]=0.50;
mValues3verticalS[37+1]=1.500000;
mValues3horizontalS[37+1]=1.500000;
elementLength3S[38+1]=0.50;
mValues3verticalS[38+1]=1.500000;
mValues3horizontalS[38+1]=1.500000;
elementLength3S[39+1]=0.50;
mValues3verticalS[39+1]=1.500000;
mValues3horizontalS[39+1]=1.500000;
elementLength3S[40+1]=0.50;
mValues3verticalS[40+1]=1.500000;
mValues3horizontalS[40+1]=1.500000;
elementLength3S[41+1]=0.50;
mValues3verticalS[41+1]=1.500000;
mValues3horizontalS[41+1]=1.500000;
elementLength3S[42+1]=0.50;
mValues3verticalS[42+1]=1.500000;
mValues3horizontalS[42+1]=1.500000;
elementLength3S[43+1]=0.50;
mValues3verticalS[43+1]=1.500000;
mValues3horizontalS[43+1]=1.500000;
elementLength3S[44+1]=0.50;
mValues3verticalS[44+1]=1.500000;
mValues3horizontalS[44+1]=1.500000;
elementLength3S[45+1]=0.50;
mValues3verticalS[45+1]=1.500000;
mValues3horizontalS[45+1]=1.500000;
elementLength3S[46+1]=0.50;
mValues3verticalS[46+1]=1.500000;
mValues3horizontalS[46+1]=1.500000;
elementLength3S[47+1]=0.50;
mValues3verticalS[47+1]=1.500000;
mValues3horizontalS[47+1]=1.500000;
elementLength3S[48+1]=0.50;
mValues3verticalS[48+1]=1.500000;
mValues3horizontalS[48+1]=1.500000;
elementLength3S[49+1]=0.50 - 0.0712; // Slightly shorter segment last
mValues3verticalS[49+1]=1.500000;
mValues3horizontalS[49+1]=1.500000;


elementLength6S[0]=0.488444444444444;
mValues6verticalS[0]=3.500000;
mValues6horizontalS[0]=3.000000;
elementLength6S[1]=0.488444444444444;
mValues6verticalS[1]=3.500000;
mValues6horizontalS[1]=3.000000;
elementLength6S[2]=0.488444444444444;
mValues6verticalS[2]=3.000000;
mValues6horizontalS[2]=2.500000;
elementLength6S[3]=0.488444444444444;
mValues6verticalS[3]=3.000000;
mValues6horizontalS[3]=2.500000;
elementLength6S[4]=0.488444444444444;
mValues6verticalS[4]=2.500000;
mValues6horizontalS[4]=2.500000;
elementLength6S[5]=0.488444444444444;
mValues6verticalS[5]=2.500000;
mValues6horizontalS[5]=2.000000;
elementLength6S[6]=0.488444444444444;
mValues6verticalS[6]=2.500000;
mValues6horizontalS[6]=1.500000;

elementLength6S[7]=0.061218888888892 ; // Shorter due to window #1
mValues6verticalS[7]=2.500000;
mValues6horizontalS[7]=1.500000;

elementLength6S[8]=0.02349; // feeder window #1
mValues6verticalS[8]=0;
mValues6horizontalS[8]=0;

elementLength6S[9]=0.488444444444444 - 0.061218888888892 - 0.02349; // End of piece 7 (the window and start of the mirror si substracted from its length)
mValues6verticalS[9]=2.000000;
mValues6horizontalS[9]=1.500000;

elementLength6S[10]=0.076264444; // shorter due to window #2
mValues6verticalS[10]=2.000000;
mValues6horizontalS[10]=1.500000;

elementLength6S[11]=0.015; // feeder window #2
mValues6verticalS[11]=0;
mValues6horizontalS[11]=0;

elementLength6S[12]=0.488444444444444 - 0.015 - 0.076264444 - 0.00047; // End of Feeder (after window 2)
mValues6verticalS[12]=2.0;
mValues6horizontalS[12]=1.5;

/************************************************/
/*                  Chopper calculations                    */
/************************************************/
 
PulseHighFluxOffset=2.0e-4; // Time from T0 to high pulse.
ModPulseLengthHighF=2.86e-3; // width of high pulse

InstLength=162.0;
chopPulseDist= 4.41+0.032+2.0-0.1;  // Distance fro moderator to Pulse chapping chopper
//chopFrameOverlap1Pos= 2.0;    // Distance from pulse shapping choppers to first frame owerlap chopper
//chopFrameOverlap2Pos=7.0;     // Distance from pulse shapping choppers to second frame owerlap chopper
//chopBWPos=71.4403;           // Distance from pulse shapping choppers to tail romval chopper

if  (chopPulseFrequencyOrder*chopPulseOpening > 170.0/360.0/14.0) {    /******* Check if pulse shapping chopper opening is large enough for requested frequency or reduce frequency *******/
	 chopPulseFrequencyOrder=floor(170.0/360.0/14.0/chopPulseOpening);
	printf(" \n \n Warning: Impossible combination of chopPulseFrequencyOrder and chopPulseOpening chosen, chopPulseFrequencyOrder reduced to: %f  \n", chopPulseFrequencyOrder);
}

lambda_1=1.0/(0.1106*sqrt(E_0));  /**** general chopper calculations **********/
WavelengthBand = 1/(InstLength-chopPulseDist)/14.0/2.528e-4;
lambda_0=lambda_1-WavelengthBand;
v_0=3956.0/lambda_1;  
v_1=3956.0/lambda_0;

t_samp_center=PulseHighFluxOffset+ModPulseLengthHighF/2.0+(InstLength/v_1+InstLength/v_0)/2.0;
t_samp_0=t_samp_center-1.0/14.0/2.0;
t_samp_1=t_samp_center+1.0/14.0/2.0;

/***********  Pulse shaping chopper calculations **********/
chopPulseOffset=(chopPulseDist/v_1+chopPulseDist/v_0)/2.0+ModPulseLengthHighF/2.0+PulseHighFluxOffset;
chopPulsePossibleOpening=chopPulseDist/v_0-chopPulseOffset;
chopPulsePhaseOffset=  (chopPulseOffset+ chopPulseOpening/2.0)*14.0*chopPulseFrequencyOrder*360.0-170.0/2.0;
chopPulse2PhaseOffset= chopPulsePhaseOffset- 360.0*(chopPulseOpening*14.0*chopPulseFrequencyOrder)+170.0;

if  (chopPulseFrequencyOrder == 0) { 
	chopPulsePhaseOffset= 0;
	chopPulse2PhaseOffset= 0;
		printf(" \n \n Warning: Pulse shaping chopper parked! Setting the offsets to zero");
}


/*********** Frame Overlap chopper calculations ******************/
chopFrameOverlap1Open= 1.0/14.0/InstLength*(chopFrameOverlap1Pos)*1.5 ;
chopFrameOverlap1Offset=(  ( (chopFrameOverlap1Pos)/v_1+(chopFrameOverlap1Pos)/v_0)/2.0+PulseHighFluxOffset+ModPulseLengthHighF/2.0) ;
chopFrameOverlap1PhaseOffset=  (chopFrameOverlap1Offset)*14.0*360.0;

chopFrameOverlap2Open= 1.0/14.0/InstLength*(chopFrameOverlap2Pos)*1.65 ;
chopFrameOverlap2Offset=(  ( (chopFrameOverlap2Pos)/v_1+(chopFrameOverlap2Pos)/v_0)/2.0+PulseHighFluxOffset+ModPulseLengthHighF/2.0) ;
chopFrameOverlap2PhaseOffset=  (chopFrameOverlap2Offset)*14.0*360.0;

/********** Bandwidth chopper calculations ****************/

//chopBW_t0= chopPulseOffset-chopPulseOpening/2.0 + (t_samp_0-(chopPulseOffset-chopPulseOpening/2.0)) / (InstLength-chopPulseDist) * (InstLength-chopBWPos) ;
//chopBW_t1= chopPulseOffset+chopPulseOpening/2.0 + (t_samp_1-(chopPulseOffset+chopPulseOpening/2.0)) / (InstLength-chopPulseDist) * (InstLength-chopBWPos);
chopBW_t0= PulseHighFluxOffset+ModPulseLengthHighF/2.0 + chopBWPos/v_1;
chopBW_t1=  PulseHighFluxOffset+ModPulseLengthHighF/2.0 + chopBWPos/v_0;

chopBWOpen= 360.0/InstLength*(chopBWPos-chopPulseDist*1); //Here Jonas put a multiplier on the choppulsedist
chopBWOffset=(chopBW_t0+chopBW_t1)/2.0;
chopBWPhaseOffset=  (chopBWOffset)*14.0*360.0;

if (printMValues==1) {
	// Will print all coating values to a file if this is toggled on 
	FILE* fp = fopen("CoatingDistributions.txt", "w");
	fprintf(fp,"Coating Distributions. From moderator towards sample:\n");
	fprintf(fp,"m_horizontal , m_vertical , elementlength:\n");
	fprintf(fp,"NBOA:\n");
	for (i = 0 ; i < 13 ; i++){
		fprintf(fp,"%f , %f , %f\n",mValues6horizontalS[i],mValues6verticalS[i],elementLength6S[i]);
	}

	fprintf(fp,"\nCurved section:\n");
	fprintf(fp,"(%f,%f) , %f , %f\n",3.000000,3.500000,2.500000,18.0);
	
	fprintf(fp,"\nExpanding ellipse:\n");
	for (i = 0 ; i < 51 ; i++){
		fprintf(fp,"%f , %f , %f\n",mValues3horizontalS[i],mValues3verticalS[i],elementLength3S[i]);
	}
	
	fprintf(fp,"\nLong Straight Section\n");
	fprintf(fp,"%f , %f , %f\n",1.500000,1.000000,90.0);

	fprintf(fp,"\nFocusing Ellipse\n");
	for (i = 0 ; i < 41 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_1[i], mValues1vertical_part_1[i],elementLength1_part_1[i]);
	}
	fprintf(fp,"2 cm gap for divJaw 3\n");
	for (i = 0 ; i < 3 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_2[i], mValues1vertical_part_2[i],elementLength1_part_2[i]);
	}
	fprintf(fp,"2 cm gap for divJaw 2\n");
	for (i = 0 ; i < 2 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_3[i], mValues1vertical_part_3[i],elementLength1_part_3[i]);
	}
fprintf(fp,"2 cm gap for divJaw 1 \n");
	for (i = 0 ; i < 3 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_4[i], mValues1vertical_part_4[i],elementLength1_part_4[i]);
	}


fclose(fp);
}


printf("\n part 3 length: %f\n",DivSlit2Pos-DivSlit1Gap/2.0-DivSlit2Gap/2.0-DivSlit1Pos);
printf("\n part 4 length: %f\n",DivSlit1Pos-DivSlit1Gap/2.0-sample_dist);

}
#line 21317 "BIFROST.c"
#undef dphi
#undef phi
#undef TTA
#undef OMA
#undef printMValues
#undef makeVirtualSource
#undef print
#undef monigap_length
#undef discD
#undef PscOff
#undef Npulse
#undef FOCopen2
#undef FOCopen1
#undef BWopen
#undef DivSlit3_width
#undef DivSlit2_width
#undef DivSlit1_width
#undef DivSlit0_width
#undef chopBWPos
#undef sampleSizeY
#undef sampleSizeX
#undef chopPulseFrequencyOrder
#undef chopPulseOpening
#undef L_0
#undef E_0
#undef pin_holeX
#undef pin_holeY
#undef WaveMax
#undef WaveMin
#undef mcposaBIFROST
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname
  /* Computation of coordinate transformations. */
  {
    Coords mctc1, mctc2, mcLastComp;
    Rotation mctr1;
    double mcAccumulatedILength = 0;
    /* Initialize "last" component origin as (0,0,0) */
    mcLastComp = coords_set(0,0,0);

    mcDEBUG_INSTR()
  /* Component initializations. */
    /* Component Origin. */
  /* Setting parameters for component Origin. */
  SIG_MESSAGE("Origin (Init:SetPar)");
#line 39 "BIFROST.instr"
  if("NULL") strncpy(mccOrigin_profile, "NULL" ? "NULL" : "", 16384); else mccOrigin_profile[0]='\0';
#line 39 "BIFROST.instr"
  mccOrigin_percent = 10;
#line 39 "BIFROST.instr"
  mccOrigin_flag_save = 0;
#line 39 "BIFROST.instr"
  mccOrigin_minutes = 0;
#line 21372 "BIFROST.c"

  SIG_MESSAGE("Origin (Init:Place/Rotate)");
  rot_set_rotation(mcrotaOrigin,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21379 "BIFROST.c"
  rot_copy(mcrotrOrigin, mcrotaOrigin);
  mcposaOrigin = coords_set(
#line 685 "BIFROST.instr"
    0,
#line 685 "BIFROST.instr"
    0,
#line 685 "BIFROST.instr"
    0);
#line 21388 "BIFROST.c"
  mctc1 = coords_neg(mcposaOrigin);
  mcposrOrigin = rot_apply(mcrotaOrigin, mctc1);
  mcDEBUG_COMPONENT("Origin", mcposaOrigin, mcrotaOrigin)
  mccomp_posa[1] = mcposaOrigin;
  mccomp_posr[1] = mcposrOrigin;
  mcNCounter[1]  = mcPCounter[1] = mcP2Counter[1] = 0;
  mcAbsorbProp[1]= 0;
    /* Component ESS_source. */
  /* Setting parameters for component ESS_source. */
  SIG_MESSAGE("ESS_source (Init:SetPar)");
#line 714 "BIFROST.instr"
  if("W") strncpy(mccESS_source_sector, "W" ? "W" : "", 16384); else mccESS_source_sector[0]='\0';
#line 710 "BIFROST.instr"
  mccESS_source_beamline = 4;
#line 710 "BIFROST.instr"
  mccESS_source_yheight = 0.030000;
#line 714 "BIFROST.instr"
  mccESS_source_cold_frac = 0.500000;
#line 108 "BIFROST.instr"
  mccESS_source_target_index = 0;
#line 711 "BIFROST.instr"
  mccESS_source_dist = 1.903398;
#line 712 "BIFROST.instr"
  mccESS_source_focus_xw = 0.068797 + 2 * 0.01277;
#line 713 "BIFROST.instr"
  mccESS_source_focus_yh = 0.03472;
#line 715 "BIFROST.instr"
  mccESS_source_c_performance = 1.0;
#line 715 "BIFROST.instr"
  mccESS_source_t_performance = 1.0;
#line 714 "BIFROST.instr"
  mccESS_source_Lmin = mcipWaveMin;
#line 714 "BIFROST.instr"
  mccESS_source_Lmax = mcipWaveMax;
#line 715 "BIFROST.instr"
  mccESS_source_tmax_multiplier = 1.500000;
#line 715 "BIFROST.instr"
  mccESS_source_n_pulses = mcipNpulse;
#line 714 "BIFROST.instr"
  mccESS_source_acc_power = 5.0;
#line 109 "BIFROST.instr"
  mccESS_source_tfocus_dist = 0;
#line 109 "BIFROST.instr"
  mccESS_source_tfocus_time = 0;
#line 109 "BIFROST.instr"
  mccESS_source_tfocus_width = 0;
#line 21435 "BIFROST.c"

  SIG_MESSAGE("ESS_source (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 717 "BIFROST.instr"
    (0)*DEG2RAD,
#line 717 "BIFROST.instr"
    (0)*DEG2RAD,
#line 717 "BIFROST.instr"
    (0)*DEG2RAD);
#line 21445 "BIFROST.c"
  rot_mul(mctr1, mcrotaOrigin, mcrotaESS_source);
  rot_transpose(mcrotaOrigin, mctr1);
  rot_mul(mcrotaESS_source, mctr1, mcrotrESS_source);
  mctc1 = coords_set(
#line 716 "BIFROST.instr"
    0,
#line 716 "BIFROST.instr"
    0,
#line 716 "BIFROST.instr"
    0);
#line 21456 "BIFROST.c"
  rot_transpose(mcrotaOrigin, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaESS_source = coords_add(mcposaOrigin, mctc2);
  mctc1 = coords_sub(mcposaOrigin, mcposaESS_source);
  mcposrESS_source = rot_apply(mcrotaESS_source, mctc1);
  mcDEBUG_COMPONENT("ESS_source", mcposaESS_source, mcrotaESS_source)
  mccomp_posa[2] = mcposaESS_source;
  mccomp_posr[2] = mcposrESS_source;
  mcNCounter[2]  = mcPCounter[2] = mcP2Counter[2] = 0;
  mcAbsorbProp[2]= 0;
    /* Component StartOfGuide. */
  /* Setting parameters for component StartOfGuide. */
  SIG_MESSAGE("StartOfGuide (Init:SetPar)");

  SIG_MESSAGE("StartOfGuide (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 733 "BIFROST.instr"
    (0)*DEG2RAD,
#line 733 "BIFROST.instr"
    (-0.56)*DEG2RAD,
#line 733 "BIFROST.instr"
    (0)*DEG2RAD);
#line 21479 "BIFROST.c"
  rot_mul(mctr1, mcrotaOrigin, mcrotaStartOfGuide);
  rot_transpose(mcrotaESS_source, mctr1);
  rot_mul(mcrotaStartOfGuide, mctr1, mcrotrStartOfGuide);
  mctc1 = coords_set(
#line 732 "BIFROST.instr"
    0.01277,
#line 732 "BIFROST.instr"
    0.000000,
#line 732 "BIFROST.instr"
    1.903398 - u);
#line 21490 "BIFROST.c"
  rot_transpose(mcrotaOrigin, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaStartOfGuide = coords_add(mcposaOrigin, mctc2);
  mctc1 = coords_sub(mcposaESS_source, mcposaStartOfGuide);
  mcposrStartOfGuide = rot_apply(mcrotaStartOfGuide, mctc1);
  mcDEBUG_COMPONENT("StartOfGuide", mcposaStartOfGuide, mcrotaStartOfGuide)
  mccomp_posa[3] = mcposaStartOfGuide;
  mccomp_posr[3] = mcposrStartOfGuide;
  mcNCounter[3]  = mcPCounter[3] = mcP2Counter[3] = 0;
  mcAbsorbProp[3]= 0;
    /* Component NBOA. */
  /* Setting parameters for component NBOA. */
  SIG_MESSAGE("NBOA (Init:SetPar)");
#line 737 "BIFROST.instr"
  mccNBOA_l = 4.39553;
#line 738 "BIFROST.instr"
  mccNBOA_xwidth = 0.069634;
#line 738 "BIFROST.instr"
  mccNBOA_yheight = 0.04862;
#line 737 "BIFROST.instr"
  mccNBOA_linxw = 3.4578;
#line 737 "BIFROST.instr"
  mccNBOA_loutxw = 0.415155;
#line 737 "BIFROST.instr"
  mccNBOA_linyh = 1.36;
#line 737 "BIFROST.instr"
  mccNBOA_loutyh = 3.487681;
#line 165 "BIFROST.instr"
  mccNBOA_majorAxisxw = 0;
#line 165 "BIFROST.instr"
  mccNBOA_minorAxisxw = 0;
#line 166 "BIFROST.instr"
  mccNBOA_majorAxisyh = 0;
#line 166 "BIFROST.instr"
  mccNBOA_minorAxisyh = 0;
#line 167 "BIFROST.instr"
  mccNBOA_majorAxisoffsetxw = 0;
#line 168 "BIFROST.instr"
  mccNBOA_majorAxisoffsetyh = 0;
#line 738 "BIFROST.instr"
  if("mid") strncpy(mccNBOA_dimensionsAt, "mid" ? "mid" : "", 16384); else mccNBOA_dimensionsAt[0]='\0';
#line 170 "BIFROST.instr"
  if("ellipse") strncpy(mccNBOA_option, "ellipse" ? "ellipse" : "", 16384); else mccNBOA_option[0]='\0';
#line 739 "BIFROST.instr"
  mccNBOA_R0 = 0.990000;
#line 739 "BIFROST.instr"
  mccNBOA_Qc = 0.021700;
#line 739 "BIFROST.instr"
  mccNBOA_alpha = 3.100000;
#line 171 "BIFROST.instr"
  mccNBOA_m = 2;
#line 739 "BIFROST.instr"
  mccNBOA_W = 0.003000;
#line 172 "BIFROST.instr"
  mccNBOA_alpharight = -1;
#line 172 "BIFROST.instr"
  mccNBOA_mright = -1;
#line 173 "BIFROST.instr"
  mccNBOA_alphaleft = -1;
#line 173 "BIFROST.instr"
  mccNBOA_mleft = -1;
#line 174 "BIFROST.instr"
  mccNBOA_alphatop = -1;
#line 174 "BIFROST.instr"
  mccNBOA_mtop = -1;
#line 175 "BIFROST.instr"
  mccNBOA_alphabottom = -1;
#line 175 "BIFROST.instr"
  mccNBOA_mbottom = -1;
#line 176 "BIFROST.instr"
  if("on") strncpy(mccNBOA_verbose, "on" ? "on" : "", 16384); else mccNBOA_verbose[0]='\0';
#line 177 "BIFROST.instr"
  mccNBOA_enableGravity = 1.0;
#line 178 "BIFROST.instr"
  mccNBOA_curvature = 0;
#line 21566 "BIFROST.c"

  SIG_MESSAGE("NBOA (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21573 "BIFROST.c"
  rot_mul(mctr1, mcrotaStartOfGuide, mcrotaNBOA);
  rot_transpose(mcrotaStartOfGuide, mctr1);
  rot_mul(mcrotaNBOA, mctr1, mcrotrNBOA);
  mctc1 = coords_set(
#line 740 "BIFROST.instr"
    0,
#line 740 "BIFROST.instr"
    0,
#line 740 "BIFROST.instr"
    u);
#line 21584 "BIFROST.c"
  rot_transpose(mcrotaStartOfGuide, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaNBOA = coords_add(mcposaStartOfGuide, mctc2);
  mctc1 = coords_sub(mcposaStartOfGuide, mcposaNBOA);
  mcposrNBOA = rot_apply(mcrotaNBOA, mctc1);
  mcDEBUG_COMPONENT("NBOA", mcposaNBOA, mcrotaNBOA)
  mccomp_posa[4] = mcposaNBOA;
  mccomp_posr[4] = mcposrNBOA;
  mcNCounter[4]  = mcPCounter[4] = mcP2Counter[4] = 0;
  mcAbsorbProp[4]= 0;
    /* Component EndOfelement_6. */
  /* Setting parameters for component EndOfelement_6. */
  SIG_MESSAGE("EndOfelement_6 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21604 "BIFROST.c"
  rot_mul(mctr1, mcrotaNBOA, mcrotaEndOfelement_6);
  rot_transpose(mcrotaNBOA, mctr1);
  rot_mul(mcrotaEndOfelement_6, mctr1, mcrotrEndOfelement_6);
  mctc1 = coords_set(
#line 744 "BIFROST.instr"
    0,
#line 744 "BIFROST.instr"
    0,
#line 744 "BIFROST.instr"
    4.39553 + 2 * u);
#line 21615 "BIFROST.c"
  rot_transpose(mcrotaNBOA, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_6 = coords_add(mcposaNBOA, mctc2);
  mctc1 = coords_sub(mcposaNBOA, mcposaEndOfelement_6);
  mcposrEndOfelement_6 = rot_apply(mcrotaEndOfelement_6, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_6", mcposaEndOfelement_6, mcrotaEndOfelement_6)
  mccomp_posa[5] = mcposaEndOfelement_6;
  mccomp_posr[5] = mcposrEndOfelement_6;
  mcNCounter[5]  = mcPCounter[5] = mcP2Counter[5] = 0;
  mcAbsorbProp[5]= 0;
    /* Component L_monBeforePSC1. */
  /* Setting parameters for component L_monBeforePSC1. */
  SIG_MESSAGE("L_monBeforePSC1 (Init:SetPar)");
#line 750 "BIFROST.instr"
  if("L_monBeforePSC1.dat") strncpy(mccL_monBeforePSC1_filename, "L_monBeforePSC1.dat" ? "L_monBeforePSC1.dat" : "", 16384); else mccL_monBeforePSC1_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monBeforePSC1_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforePSC1_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforePSC1_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforePSC1_ymax = 0.05;
#line 750 "BIFROST.instr"
  mccL_monBeforePSC1_xwidth = 0.2;
#line 751 "BIFROST.instr"
  mccL_monBeforePSC1_yheight = 0.2;
#line 751 "BIFROST.instr"
  mccL_monBeforePSC1_Lmin = lambda_1 / 2;
#line 751 "BIFROST.instr"
  mccL_monBeforePSC1_Lmax = lambda_0 * 2;
#line 750 "BIFROST.instr"
  mccL_monBeforePSC1_restore_neutron = 1;
#line 21649 "BIFROST.c"

  SIG_MESSAGE("L_monBeforePSC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21656 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_6, mcrotaL_monBeforePSC1);
  rot_transpose(mcrotaEndOfelement_6, mctr1);
  rot_mul(mcrotaL_monBeforePSC1, mctr1, mcrotrL_monBeforePSC1);
  mctc1 = coords_set(
#line 752 "BIFROST.instr"
    0,
#line 752 "BIFROST.instr"
    0,
#line 752 "BIFROST.instr"
    u);
#line 21667 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monBeforePSC1 = coords_add(mcposaEndOfelement_6, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_6, mcposaL_monBeforePSC1);
  mcposrL_monBeforePSC1 = rot_apply(mcrotaL_monBeforePSC1, mctc1);
  mcDEBUG_COMPONENT("L_monBeforePSC1", mcposaL_monBeforePSC1, mcrotaL_monBeforePSC1)
  mccomp_posa[6] = mcposaL_monBeforePSC1;
  mccomp_posr[6] = mcposrL_monBeforePSC1;
  mcNCounter[6]  = mcPCounter[6] = mcP2Counter[6] = 0;
  mcAbsorbProp[6]= 0;
    /* Component ToFBeforerPSC1. */
  /* Setting parameters for component ToFBeforerPSC1. */
  SIG_MESSAGE("ToFBeforerPSC1 (Init:SetPar)");
#line 755 "BIFROST.instr"
  if("ToFBeforePSC1.dat") strncpy(mccToFBeforerPSC1_filename, "ToFBeforePSC1.dat" ? "ToFBeforePSC1.dat" : "", 16384); else mccToFBeforerPSC1_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFBeforerPSC1_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforerPSC1_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFBeforerPSC1_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforerPSC1_ymax = 0.05;
#line 755 "BIFROST.instr"
  mccToFBeforerPSC1_xwidth = 0.2;
#line 756 "BIFROST.instr"
  mccToFBeforerPSC1_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFBeforerPSC1_tmin = 0;
#line 756 "BIFROST.instr"
  mccToFBeforerPSC1_tmax = 2e4;
#line 47 "BIFROST.instr"
  mccToFBeforerPSC1_dt = 1.0;
#line 755 "BIFROST.instr"
  mccToFBeforerPSC1_restore_neutron = 1;
#line 21703 "BIFROST.c"

  SIG_MESSAGE("ToFBeforerPSC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21710 "BIFROST.c"
  rot_mul(mctr1, mcrotaL_monBeforePSC1, mcrotaToFBeforerPSC1);
  rot_transpose(mcrotaL_monBeforePSC1, mctr1);
  rot_mul(mcrotaToFBeforerPSC1, mctr1, mcrotrToFBeforerPSC1);
  mctc1 = coords_set(
#line 757 "BIFROST.instr"
    0,
#line 757 "BIFROST.instr"
    0,
#line 757 "BIFROST.instr"
    u);
#line 21721 "BIFROST.c"
  rot_transpose(mcrotaL_monBeforePSC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFBeforerPSC1 = coords_add(mcposaL_monBeforePSC1, mctc2);
  mctc1 = coords_sub(mcposaL_monBeforePSC1, mcposaToFBeforerPSC1);
  mcposrToFBeforerPSC1 = rot_apply(mcrotaToFBeforerPSC1, mctc1);
  mcDEBUG_COMPONENT("ToFBeforerPSC1", mcposaToFBeforerPSC1, mcrotaToFBeforerPSC1)
  mccomp_posa[7] = mcposaToFBeforerPSC1;
  mccomp_posr[7] = mcposrToFBeforerPSC1;
  mcNCounter[7]  = mcPCounter[7] = mcP2Counter[7] = 0;
  mcAbsorbProp[7]= 0;
    /* Component PSD_beforePulseShapping1. */
  /* Setting parameters for component PSD_beforePulseShapping1. */
  SIG_MESSAGE("PSD_beforePulseShapping1 (Init:SetPar)");
#line 760 "BIFROST.instr"
  if("PSD_beforePSC1.dat") strncpy(mccPSD_beforePulseShapping1_filename, "PSD_beforePSC1.dat" ? "PSD_beforePSC1.dat" : "", 16384); else mccPSD_beforePulseShapping1_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_beforePulseShapping1_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforePulseShapping1_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforePulseShapping1_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforePulseShapping1_ymax = 0.05;
#line 761 "BIFROST.instr"
  mccPSD_beforePulseShapping1_xwidth = 0.2;
#line 761 "BIFROST.instr"
  mccPSD_beforePulseShapping1_yheight = 0.2;
#line 760 "BIFROST.instr"
  mccPSD_beforePulseShapping1_restore_neutron = 1;
#line 21751 "BIFROST.c"

  SIG_MESSAGE("PSD_beforePulseShapping1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21758 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFBeforerPSC1, mcrotaPSD_beforePulseShapping1);
  rot_transpose(mcrotaToFBeforerPSC1, mctr1);
  rot_mul(mcrotaPSD_beforePulseShapping1, mctr1, mcrotrPSD_beforePulseShapping1);
  mctc1 = coords_set(
#line 762 "BIFROST.instr"
    0,
#line 762 "BIFROST.instr"
    0,
#line 762 "BIFROST.instr"
    u);
#line 21769 "BIFROST.c"
  rot_transpose(mcrotaToFBeforerPSC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_beforePulseShapping1 = coords_add(mcposaToFBeforerPSC1, mctc2);
  mctc1 = coords_sub(mcposaToFBeforerPSC1, mcposaPSD_beforePulseShapping1);
  mcposrPSD_beforePulseShapping1 = rot_apply(mcrotaPSD_beforePulseShapping1, mctc1);
  mcDEBUG_COMPONENT("PSD_beforePulseShapping1", mcposaPSD_beforePulseShapping1, mcrotaPSD_beforePulseShapping1)
  mccomp_posa[8] = mcposaPSD_beforePulseShapping1;
  mccomp_posr[8] = mcposrPSD_beforePulseShapping1;
  mcNCounter[8]  = mcPCounter[8] = mcP2Counter[8] = 0;
  mcAbsorbProp[8]= 0;
    /* Component TofLambdaBeforePSC. */
  /* Setting parameters for component TofLambdaBeforePSC. */
  SIG_MESSAGE("TofLambdaBeforePSC (Init:SetPar)");
#line 766 "BIFROST.instr"
  if("TofLambdaBeforePSC1.dat") strncpy(mccTofLambdaBeforePSC_filename, "TofLambdaBeforePSC1.dat" ? "TofLambdaBeforePSC1.dat" : "", 16384); else mccTofLambdaBeforePSC_filename[0]='\0';
#line 48 "BIFROST.instr"
  mccTofLambdaBeforePSC_xmin = -0.05;
#line 48 "BIFROST.instr"
  mccTofLambdaBeforePSC_xmax = 0.05;
#line 48 "BIFROST.instr"
  mccTofLambdaBeforePSC_ymin = -0.05;
#line 48 "BIFROST.instr"
  mccTofLambdaBeforePSC_ymax = 0.05;
#line 766 "BIFROST.instr"
  mccTofLambdaBeforePSC_xwidth = mcipsampleSizeY;
#line 767 "BIFROST.instr"
  mccTofLambdaBeforePSC_yheight = mcipsampleSizeY;
#line 767 "BIFROST.instr"
  mccTofLambdaBeforePSC_Lmin = lambda_0 * 0.5;
#line 767 "BIFROST.instr"
  mccTofLambdaBeforePSC_Lmax = lambda_1 * 2;
#line 766 "BIFROST.instr"
  mccTofLambdaBeforePSC_restore_neutron = 1;
#line 21803 "BIFROST.c"

  SIG_MESSAGE("TofLambdaBeforePSC (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21810 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_beforePulseShapping1, mcrotaTofLambdaBeforePSC);
  rot_transpose(mcrotaPSD_beforePulseShapping1, mctr1);
  rot_mul(mcrotaTofLambdaBeforePSC, mctr1, mcrotrTofLambdaBeforePSC);
  mctc1 = coords_set(
#line 768 "BIFROST.instr"
    0,
#line 768 "BIFROST.instr"
    0,
#line 768 "BIFROST.instr"
    u);
#line 21821 "BIFROST.c"
  rot_transpose(mcrotaPSD_beforePulseShapping1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaTofLambdaBeforePSC = coords_add(mcposaPSD_beforePulseShapping1, mctc2);
  mctc1 = coords_sub(mcposaPSD_beforePulseShapping1, mcposaTofLambdaBeforePSC);
  mcposrTofLambdaBeforePSC = rot_apply(mcrotaTofLambdaBeforePSC, mctc1);
  mcDEBUG_COMPONENT("TofLambdaBeforePSC", mcposaTofLambdaBeforePSC, mcrotaTofLambdaBeforePSC)
  mccomp_posa[9] = mcposaTofLambdaBeforePSC;
  mccomp_posr[9] = mcposrTofLambdaBeforePSC;
  mcNCounter[9]  = mcPCounter[9] = mcP2Counter[9] = 0;
  mcAbsorbProp[9]= 0;
    /* Component PulseShapingChopper. */
  /* Setting parameters for component PulseShapingChopper. */
  SIG_MESSAGE("PulseShapingChopper (Init:SetPar)");
#line 771 "BIFROST.instr"
  mccPulseShapingChopper_theta_0 = 170.0;
#line 771 "BIFROST.instr"
  mccPulseShapingChopper_radius = 0.35;
#line 771 "BIFROST.instr"
  mccPulseShapingChopper_yheight = 0.052;
#line 771 "BIFROST.instr"
  mccPulseShapingChopper_nu = 14.0 * mcipchopPulseFrequencyOrder;
#line 771 "BIFROST.instr"
  mccPulseShapingChopper_nslit = 1;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper_jitter = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper_delay = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper_isfirst = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper_n_pulse = 1;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper_abs_out = 1;
#line 772 "BIFROST.instr"
  mccPulseShapingChopper_phase = chopPulsePhaseOffset -0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper_xwidth = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper_verbose = 0;
#line 21861 "BIFROST.c"

  SIG_MESSAGE("PulseShapingChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21868 "BIFROST.c"
  rot_mul(mctr1, mcrotaTofLambdaBeforePSC, mcrotaPulseShapingChopper);
  rot_transpose(mcrotaTofLambdaBeforePSC, mctr1);
  rot_mul(mcrotaPulseShapingChopper, mctr1, mcrotrPulseShapingChopper);
  mctc1 = coords_set(
#line 773 "BIFROST.instr"
    0,
#line 773 "BIFROST.instr"
    0,
#line 773 "BIFROST.instr"
    mcipPscOff);
#line 21879 "BIFROST.c"
  rot_transpose(mcrotaTofLambdaBeforePSC, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPulseShapingChopper = coords_add(mcposaTofLambdaBeforePSC, mctc2);
  mctc1 = coords_sub(mcposaTofLambdaBeforePSC, mcposaPulseShapingChopper);
  mcposrPulseShapingChopper = rot_apply(mcrotaPulseShapingChopper, mctc1);
  mcDEBUG_COMPONENT("PulseShapingChopper", mcposaPulseShapingChopper, mcrotaPulseShapingChopper)
  mccomp_posa[10] = mcposaPulseShapingChopper;
  mccomp_posr[10] = mcposrPulseShapingChopper;
  mcNCounter[10]  = mcPCounter[10] = mcP2Counter[10] = 0;
  mcAbsorbProp[10]= 0;
    /* Component PSD_AfterPulseShapping1. */
  /* Setting parameters for component PSD_AfterPulseShapping1. */
  SIG_MESSAGE("PSD_AfterPulseShapping1 (Init:SetPar)");
#line 776 "BIFROST.instr"
  if("PSD_AfterPSC1.dat") strncpy(mccPSD_AfterPulseShapping1_filename, "PSD_AfterPSC1.dat" ? "PSD_AfterPSC1.dat" : "", 16384); else mccPSD_AfterPulseShapping1_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_AfterPulseShapping1_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_AfterPulseShapping1_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_AfterPulseShapping1_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_AfterPulseShapping1_ymax = 0.05;
#line 777 "BIFROST.instr"
  mccPSD_AfterPulseShapping1_xwidth = 0.2;
#line 777 "BIFROST.instr"
  mccPSD_AfterPulseShapping1_yheight = 0.2;
#line 776 "BIFROST.instr"
  mccPSD_AfterPulseShapping1_restore_neutron = 1;
#line 21909 "BIFROST.c"

  SIG_MESSAGE("PSD_AfterPulseShapping1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21916 "BIFROST.c"
  rot_mul(mctr1, mcrotaPulseShapingChopper, mcrotaPSD_AfterPulseShapping1);
  rot_transpose(mcrotaPulseShapingChopper, mctr1);
  rot_mul(mcrotaPSD_AfterPulseShapping1, mctr1, mcrotrPSD_AfterPulseShapping1);
  mctc1 = coords_set(
#line 778 "BIFROST.instr"
    0,
#line 778 "BIFROST.instr"
    0,
#line 778 "BIFROST.instr"
    u);
#line 21927 "BIFROST.c"
  rot_transpose(mcrotaPulseShapingChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_AfterPulseShapping1 = coords_add(mcposaPulseShapingChopper, mctc2);
  mctc1 = coords_sub(mcposaPulseShapingChopper, mcposaPSD_AfterPulseShapping1);
  mcposrPSD_AfterPulseShapping1 = rot_apply(mcrotaPSD_AfterPulseShapping1, mctc1);
  mcDEBUG_COMPONENT("PSD_AfterPulseShapping1", mcposaPSD_AfterPulseShapping1, mcrotaPSD_AfterPulseShapping1)
  mccomp_posa[11] = mcposaPSD_AfterPulseShapping1;
  mccomp_posr[11] = mcposrPSD_AfterPulseShapping1;
  mcNCounter[11]  = mcPCounter[11] = mcP2Counter[11] = 0;
  mcAbsorbProp[11]= 0;
    /* Component ToFInsidePSC. */
  /* Setting parameters for component ToFInsidePSC. */
  SIG_MESSAGE("ToFInsidePSC (Init:SetPar)");
#line 781 "BIFROST.instr"
  if("ToFInsidePSC.dat") strncpy(mccToFInsidePSC_filename, "ToFInsidePSC.dat" ? "ToFInsidePSC.dat" : "", 16384); else mccToFInsidePSC_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFInsidePSC_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFInsidePSC_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFInsidePSC_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFInsidePSC_ymax = 0.05;
#line 781 "BIFROST.instr"
  mccToFInsidePSC_xwidth = 0.2;
#line 782 "BIFROST.instr"
  mccToFInsidePSC_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFInsidePSC_tmin = 0;
#line 782 "BIFROST.instr"
  mccToFInsidePSC_tmax = 2e4;
#line 47 "BIFROST.instr"
  mccToFInsidePSC_dt = 1.0;
#line 781 "BIFROST.instr"
  mccToFInsidePSC_restore_neutron = 1;
#line 21963 "BIFROST.c"

  SIG_MESSAGE("ToFInsidePSC (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21970 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_AfterPulseShapping1, mcrotaToFInsidePSC);
  rot_transpose(mcrotaPSD_AfterPulseShapping1, mctr1);
  rot_mul(mcrotaToFInsidePSC, mctr1, mcrotrToFInsidePSC);
  mctc1 = coords_set(
#line 783 "BIFROST.instr"
    0,
#line 783 "BIFROST.instr"
    0,
#line 783 "BIFROST.instr"
    u);
#line 21981 "BIFROST.c"
  rot_transpose(mcrotaPSD_AfterPulseShapping1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFInsidePSC = coords_add(mcposaPSD_AfterPulseShapping1, mctc2);
  mctc1 = coords_sub(mcposaPSD_AfterPulseShapping1, mcposaToFInsidePSC);
  mcposrToFInsidePSC = rot_apply(mcrotaToFInsidePSC, mctc1);
  mcDEBUG_COMPONENT("ToFInsidePSC", mcposaToFInsidePSC, mcrotaToFInsidePSC)
  mccomp_posa[12] = mcposaToFInsidePSC;
  mccomp_posr[12] = mcposrToFInsidePSC;
  mcNCounter[12]  = mcPCounter[12] = mcP2Counter[12] = 0;
  mcAbsorbProp[12]= 0;
    /* Component PulseShapingChopper2. */
  /* Setting parameters for component PulseShapingChopper2. */
  SIG_MESSAGE("PulseShapingChopper2 (Init:SetPar)");
#line 786 "BIFROST.instr"
  mccPulseShapingChopper2_theta_0 = 170.0;
#line 786 "BIFROST.instr"
  mccPulseShapingChopper2_radius = 0.35;
#line 786 "BIFROST.instr"
  mccPulseShapingChopper2_yheight = 0.052;
#line 786 "BIFROST.instr"
  mccPulseShapingChopper2_nu = 14.0 * mcipchopPulseFrequencyOrder;
#line 786 "BIFROST.instr"
  mccPulseShapingChopper2_nslit = 1;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper2_jitter = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper2_delay = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper2_isfirst = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper2_n_pulse = 1;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper2_abs_out = 1;
#line 787 "BIFROST.instr"
  mccPulseShapingChopper2_phase = chopPulse2PhaseOffset + 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper2_xwidth = 0;
#line 56 "BIFROST.instr"
  mccPulseShapingChopper2_verbose = 0;
#line 22021 "BIFROST.c"

  SIG_MESSAGE("PulseShapingChopper2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22028 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFInsidePSC, mcrotaPulseShapingChopper2);
  rot_transpose(mcrotaToFInsidePSC, mctr1);
  rot_mul(mcrotaPulseShapingChopper2, mctr1, mcrotrPulseShapingChopper2);
  mctc1 = coords_set(
#line 788 "BIFROST.instr"
    0,
#line 788 "BIFROST.instr"
    0,
#line 788 "BIFROST.instr"
    mcipdiscD);
#line 22039 "BIFROST.c"
  rot_transpose(mcrotaToFInsidePSC, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPulseShapingChopper2 = coords_add(mcposaToFInsidePSC, mctc2);
  mctc1 = coords_sub(mcposaToFInsidePSC, mcposaPulseShapingChopper2);
  mcposrPulseShapingChopper2 = rot_apply(mcrotaPulseShapingChopper2, mctc1);
  mcDEBUG_COMPONENT("PulseShapingChopper2", mcposaPulseShapingChopper2, mcrotaPulseShapingChopper2)
  mccomp_posa[13] = mcposaPulseShapingChopper2;
  mccomp_posr[13] = mcposrPulseShapingChopper2;
  mcNCounter[13]  = mcPCounter[13] = mcP2Counter[13] = 0;
  mcAbsorbProp[13]= 0;
    /* Component TofLambdaAfterPSC2. */
  /* Setting parameters for component TofLambdaAfterPSC2. */
  SIG_MESSAGE("TofLambdaAfterPSC2 (Init:SetPar)");
#line 792 "BIFROST.instr"
  if("TofLambdaAfterPSC2.dat") strncpy(mccTofLambdaAfterPSC2_filename, "TofLambdaAfterPSC2.dat" ? "TofLambdaAfterPSC2.dat" : "", 16384); else mccTofLambdaAfterPSC2_filename[0]='\0';
#line 48 "BIFROST.instr"
  mccTofLambdaAfterPSC2_xmin = -0.05;
#line 48 "BIFROST.instr"
  mccTofLambdaAfterPSC2_xmax = 0.05;
#line 48 "BIFROST.instr"
  mccTofLambdaAfterPSC2_ymin = -0.05;
#line 48 "BIFROST.instr"
  mccTofLambdaAfterPSC2_ymax = 0.05;
#line 792 "BIFROST.instr"
  mccTofLambdaAfterPSC2_xwidth = mcipsampleSizeY;
#line 793 "BIFROST.instr"
  mccTofLambdaAfterPSC2_yheight = mcipsampleSizeY;
#line 793 "BIFROST.instr"
  mccTofLambdaAfterPSC2_Lmin = lambda_0 * 0.5;
#line 793 "BIFROST.instr"
  mccTofLambdaAfterPSC2_Lmax = lambda_1 * 2;
#line 792 "BIFROST.instr"
  mccTofLambdaAfterPSC2_restore_neutron = 1;
#line 22073 "BIFROST.c"

  SIG_MESSAGE("TofLambdaAfterPSC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22080 "BIFROST.c"
  rot_mul(mctr1, mcrotaPulseShapingChopper2, mcrotaTofLambdaAfterPSC2);
  rot_transpose(mcrotaPulseShapingChopper2, mctr1);
  rot_mul(mcrotaTofLambdaAfterPSC2, mctr1, mcrotrTofLambdaAfterPSC2);
  mctc1 = coords_set(
#line 794 "BIFROST.instr"
    0,
#line 794 "BIFROST.instr"
    0,
#line 794 "BIFROST.instr"
    u);
#line 22091 "BIFROST.c"
  rot_transpose(mcrotaPulseShapingChopper2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaTofLambdaAfterPSC2 = coords_add(mcposaPulseShapingChopper2, mctc2);
  mctc1 = coords_sub(mcposaPulseShapingChopper2, mcposaTofLambdaAfterPSC2);
  mcposrTofLambdaAfterPSC2 = rot_apply(mcrotaTofLambdaAfterPSC2, mctc1);
  mcDEBUG_COMPONENT("TofLambdaAfterPSC2", mcposaTofLambdaAfterPSC2, mcrotaTofLambdaAfterPSC2)
  mccomp_posa[14] = mcposaTofLambdaAfterPSC2;
  mccomp_posr[14] = mcposrTofLambdaAfterPSC2;
  mcNCounter[14]  = mcPCounter[14] = mcP2Counter[14] = 0;
  mcAbsorbProp[14]= 0;
    /* Component PSD_AfterPSC2. */
  /* Setting parameters for component PSD_AfterPSC2. */
  SIG_MESSAGE("PSD_AfterPSC2 (Init:SetPar)");
#line 797 "BIFROST.instr"
  if("PSD_AfterPSC2.dat") strncpy(mccPSD_AfterPSC2_filename, "PSD_AfterPSC2.dat" ? "PSD_AfterPSC2.dat" : "", 16384); else mccPSD_AfterPSC2_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_AfterPSC2_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_AfterPSC2_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_AfterPSC2_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_AfterPSC2_ymax = 0.05;
#line 798 "BIFROST.instr"
  mccPSD_AfterPSC2_xwidth = 0.2;
#line 798 "BIFROST.instr"
  mccPSD_AfterPSC2_yheight = 0.2;
#line 797 "BIFROST.instr"
  mccPSD_AfterPSC2_restore_neutron = 1;
#line 22121 "BIFROST.c"

  SIG_MESSAGE("PSD_AfterPSC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22128 "BIFROST.c"
  rot_mul(mctr1, mcrotaTofLambdaAfterPSC2, mcrotaPSD_AfterPSC2);
  rot_transpose(mcrotaTofLambdaAfterPSC2, mctr1);
  rot_mul(mcrotaPSD_AfterPSC2, mctr1, mcrotrPSD_AfterPSC2);
  mctc1 = coords_set(
#line 799 "BIFROST.instr"
    0,
#line 799 "BIFROST.instr"
    0,
#line 799 "BIFROST.instr"
    u);
#line 22139 "BIFROST.c"
  rot_transpose(mcrotaTofLambdaAfterPSC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_AfterPSC2 = coords_add(mcposaTofLambdaAfterPSC2, mctc2);
  mctc1 = coords_sub(mcposaTofLambdaAfterPSC2, mcposaPSD_AfterPSC2);
  mcposrPSD_AfterPSC2 = rot_apply(mcrotaPSD_AfterPSC2, mctc1);
  mcDEBUG_COMPONENT("PSD_AfterPSC2", mcposaPSD_AfterPSC2, mcrotaPSD_AfterPSC2)
  mccomp_posa[15] = mcposaPSD_AfterPSC2;
  mccomp_posr[15] = mcposrPSD_AfterPSC2;
  mcNCounter[15]  = mcPCounter[15] = mcP2Counter[15] = 0;
  mcAbsorbProp[15]= 0;
    /* Component ToFAfterPSC2. */
  /* Setting parameters for component ToFAfterPSC2. */
  SIG_MESSAGE("ToFAfterPSC2 (Init:SetPar)");
#line 802 "BIFROST.instr"
  if("ToFAfterPSC2.dat") strncpy(mccToFAfterPSC2_filename, "ToFAfterPSC2.dat" ? "ToFAfterPSC2.dat" : "", 16384); else mccToFAfterPSC2_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFAfterPSC2_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterPSC2_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFAfterPSC2_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterPSC2_ymax = 0.05;
#line 802 "BIFROST.instr"
  mccToFAfterPSC2_xwidth = 0.2;
#line 803 "BIFROST.instr"
  mccToFAfterPSC2_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFAfterPSC2_tmin = 0;
#line 803 "BIFROST.instr"
  mccToFAfterPSC2_tmax = 2e4;
#line 47 "BIFROST.instr"
  mccToFAfterPSC2_dt = 1.0;
#line 802 "BIFROST.instr"
  mccToFAfterPSC2_restore_neutron = 1;
#line 22175 "BIFROST.c"

  SIG_MESSAGE("ToFAfterPSC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22182 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_AfterPSC2, mcrotaToFAfterPSC2);
  rot_transpose(mcrotaPSD_AfterPSC2, mctr1);
  rot_mul(mcrotaToFAfterPSC2, mctr1, mcrotrToFAfterPSC2);
  mctc1 = coords_set(
#line 804 "BIFROST.instr"
    0,
#line 804 "BIFROST.instr"
    0,
#line 804 "BIFROST.instr"
    u);
#line 22193 "BIFROST.c"
  rot_transpose(mcrotaPSD_AfterPSC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFAfterPSC2 = coords_add(mcposaPSD_AfterPSC2, mctc2);
  mctc1 = coords_sub(mcposaPSD_AfterPSC2, mcposaToFAfterPSC2);
  mcposrToFAfterPSC2 = rot_apply(mcrotaToFAfterPSC2, mctc1);
  mcDEBUG_COMPONENT("ToFAfterPSC2", mcposaToFAfterPSC2, mcrotaToFAfterPSC2)
  mccomp_posa[16] = mcposaToFAfterPSC2;
  mccomp_posr[16] = mcposrToFAfterPSC2;
  mcNCounter[16]  = mcPCounter[16] = mcP2Counter[16] = 0;
  mcAbsorbProp[16]= 0;
    /* Component L_monAfterPSC2. */
  /* Setting parameters for component L_monAfterPSC2. */
  SIG_MESSAGE("L_monAfterPSC2 (Init:SetPar)");
#line 807 "BIFROST.instr"
  if("L_monAfterPSC2.dat") strncpy(mccL_monAfterPSC2_filename, "L_monAfterPSC2.dat" ? "L_monAfterPSC2.dat" : "", 16384); else mccL_monAfterPSC2_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monAfterPSC2_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterPSC2_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterPSC2_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterPSC2_ymax = 0.05;
#line 807 "BIFROST.instr"
  mccL_monAfterPSC2_xwidth = 0.2;
#line 808 "BIFROST.instr"
  mccL_monAfterPSC2_yheight = 0.2;
#line 808 "BIFROST.instr"
  mccL_monAfterPSC2_Lmin = lambda_1 / 2;
#line 808 "BIFROST.instr"
  mccL_monAfterPSC2_Lmax = lambda_0 * 2;
#line 807 "BIFROST.instr"
  mccL_monAfterPSC2_restore_neutron = 1;
#line 22227 "BIFROST.c"

  SIG_MESSAGE("L_monAfterPSC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22234 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFAfterPSC2, mcrotaL_monAfterPSC2);
  rot_transpose(mcrotaToFAfterPSC2, mctr1);
  rot_mul(mcrotaL_monAfterPSC2, mctr1, mcrotrL_monAfterPSC2);
  mctc1 = coords_set(
#line 809 "BIFROST.instr"
    0,
#line 809 "BIFROST.instr"
    0,
#line 809 "BIFROST.instr"
    u);
#line 22245 "BIFROST.c"
  rot_transpose(mcrotaToFAfterPSC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monAfterPSC2 = coords_add(mcposaToFAfterPSC2, mctc2);
  mctc1 = coords_sub(mcposaToFAfterPSC2, mcposaL_monAfterPSC2);
  mcposrL_monAfterPSC2 = rot_apply(mcrotaL_monAfterPSC2, mctc1);
  mcDEBUG_COMPONENT("L_monAfterPSC2", mcposaL_monAfterPSC2, mcrotaL_monAfterPSC2)
  mccomp_posa[17] = mcposaL_monAfterPSC2;
  mccomp_posr[17] = mcposrL_monAfterPSC2;
  mcNCounter[17]  = mcPCounter[17] = mcP2Counter[17] = 0;
  mcAbsorbProp[17]= 0;
    /* Component EndOfelement_5. */
  /* Setting parameters for component EndOfelement_5. */
  SIG_MESSAGE("EndOfelement_5 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22265 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_6, mcrotaEndOfelement_5);
  rot_transpose(mcrotaL_monAfterPSC2, mctr1);
  rot_mul(mcrotaEndOfelement_5, mctr1, mcrotrEndOfelement_5);
  mctc1 = coords_set(
#line 816 "BIFROST.instr"
    0,
#line 816 "BIFROST.instr"
    0,
#line 816 "BIFROST.instr"
    0.081707);
#line 22276 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_5 = coords_add(mcposaEndOfelement_6, mctc2);
  mctc1 = coords_sub(mcposaL_monAfterPSC2, mcposaEndOfelement_5);
  mcposrEndOfelement_5 = rot_apply(mcrotaEndOfelement_5, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_5", mcposaEndOfelement_5, mcrotaEndOfelement_5)
  mccomp_posa[18] = mcposaEndOfelement_5;
  mccomp_posr[18] = mcposrEndOfelement_5;
  mcNCounter[18]  = mcPCounter[18] = mcP2Counter[18] = 0;
  mcAbsorbProp[18]= 0;
    /* Component curved_guide_1_0. */
  /* Setting parameters for component curved_guide_1_0. */
  SIG_MESSAGE("curved_guide_1_0 (Init:SetPar)");
#line 826 "BIFROST.instr"
  mcccurved_guide_1_0_w1 = 0.029534;
#line 827 "BIFROST.instr"
  mcccurved_guide_1_0_h1 = 0.047514;
#line 826 "BIFROST.instr"
  mcccurved_guide_1_0_w2 = 0.029534;
#line 827 "BIFROST.instr"
  mcccurved_guide_1_0_h2 = 0.047514;
#line 825 "BIFROST.instr"
  mcccurved_guide_1_0_l = 0.5;
#line 828 "BIFROST.instr"
  mcccurved_guide_1_0_R0 = 0.990000;
#line 828 "BIFROST.instr"
  mcccurved_guide_1_0_Qc = 0.021700;
#line 829 "BIFROST.instr"
  mcccurved_guide_1_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_1_0_m = 1.0;
#line 829 "BIFROST.instr"
  mcccurved_guide_1_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_1_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_1_0_d = 0.0005;
#line 830 "BIFROST.instr"
  mcccurved_guide_1_0_mleft = 3.000000;
#line 830 "BIFROST.instr"
  mcccurved_guide_1_0_mright = 3.500000;
#line 831 "BIFROST.instr"
  mcccurved_guide_1_0_mtop = 2.500000;
#line 831 "BIFROST.instr"
  mcccurved_guide_1_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_1_0_nhslit = 1;
#line 825 "BIFROST.instr"
  mcccurved_guide_1_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_1_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_1_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_1_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_1_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_1_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_1_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_1_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_1_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_1_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_1_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_1_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_1_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_1_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_1_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_1_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_1_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_1_0_reflect[0]='\0';
#line 22358 "BIFROST.c"

  SIG_MESSAGE("curved_guide_1_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 833 "BIFROST.instr"
    (0)*DEG2RAD,
#line 833 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 833 "BIFROST.instr"
    (0)*DEG2RAD);
#line 22368 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_5, mcrotacurved_guide_1_0);
  rot_transpose(mcrotaEndOfelement_5, mctr1);
  rot_mul(mcrotacurved_guide_1_0, mctr1, mcrotrcurved_guide_1_0);
  mctc1 = coords_set(
#line 832 "BIFROST.instr"
    0,
#line 832 "BIFROST.instr"
    0,
#line 832 "BIFROST.instr"
    u);
#line 22379 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_1_0 = coords_add(mcposaEndOfelement_5, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_5, mcposacurved_guide_1_0);
  mcposrcurved_guide_1_0 = rot_apply(mcrotacurved_guide_1_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_1_0", mcposacurved_guide_1_0, mcrotacurved_guide_1_0)
  mccomp_posa[19] = mcposacurved_guide_1_0;
  mccomp_posr[19] = mcposrcurved_guide_1_0;
  mcNCounter[19]  = mcPCounter[19] = mcP2Counter[19] = 0;
  mcAbsorbProp[19]= 0;
    /* Component curved_guide_2_0. */
  /* Setting parameters for component curved_guide_2_0. */
  SIG_MESSAGE("curved_guide_2_0 (Init:SetPar)");
#line 837 "BIFROST.instr"
  mcccurved_guide_2_0_w1 = 0.029534;
#line 838 "BIFROST.instr"
  mcccurved_guide_2_0_h1 = 0.047514;
#line 837 "BIFROST.instr"
  mcccurved_guide_2_0_w2 = 0.029534;
#line 838 "BIFROST.instr"
  mcccurved_guide_2_0_h2 = 0.047514;
#line 836 "BIFROST.instr"
  mcccurved_guide_2_0_l = 0.5;
#line 839 "BIFROST.instr"
  mcccurved_guide_2_0_R0 = 0.990000;
#line 839 "BIFROST.instr"
  mcccurved_guide_2_0_Qc = 0.021700;
#line 840 "BIFROST.instr"
  mcccurved_guide_2_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_2_0_m = 1.0;
#line 840 "BIFROST.instr"
  mcccurved_guide_2_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_2_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_2_0_d = 0.0005;
#line 841 "BIFROST.instr"
  mcccurved_guide_2_0_mleft = 3.000000;
#line 841 "BIFROST.instr"
  mcccurved_guide_2_0_mright = 3.500000;
#line 842 "BIFROST.instr"
  mcccurved_guide_2_0_mtop = 2.500000;
#line 842 "BIFROST.instr"
  mcccurved_guide_2_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_2_0_nhslit = 1;
#line 836 "BIFROST.instr"
  mcccurved_guide_2_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_2_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_2_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_2_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_2_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_2_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_2_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_2_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_2_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_2_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_2_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_2_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_2_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_2_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_2_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_2_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_2_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_2_0_reflect[0]='\0';
#line 22461 "BIFROST.c"

  SIG_MESSAGE("curved_guide_2_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 844 "BIFROST.instr"
    (0)*DEG2RAD,
#line 844 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 844 "BIFROST.instr"
    (0)*DEG2RAD);
#line 22471 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_1_0, mcrotacurved_guide_2_0);
  rot_transpose(mcrotacurved_guide_1_0, mctr1);
  rot_mul(mcrotacurved_guide_2_0, mctr1, mcrotrcurved_guide_2_0);
  mctc1 = coords_set(
#line 843 "BIFROST.instr"
    7.57345916228e-10,
#line 843 "BIFROST.instr"
    0,
#line 843 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 22482 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_1_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_2_0 = coords_add(mcposacurved_guide_1_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_1_0, mcposacurved_guide_2_0);
  mcposrcurved_guide_2_0 = rot_apply(mcrotacurved_guide_2_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_2_0", mcposacurved_guide_2_0, mcrotacurved_guide_2_0)
  mccomp_posa[20] = mcposacurved_guide_2_0;
  mccomp_posr[20] = mcposrcurved_guide_2_0;
  mcNCounter[20]  = mcPCounter[20] = mcP2Counter[20] = 0;
  mcAbsorbProp[20]= 0;
    /* Component curved_guide_3_0. */
  /* Setting parameters for component curved_guide_3_0. */
  SIG_MESSAGE("curved_guide_3_0 (Init:SetPar)");
#line 848 "BIFROST.instr"
  mcccurved_guide_3_0_w1 = 0.029534;
#line 849 "BIFROST.instr"
  mcccurved_guide_3_0_h1 = 0.047514;
#line 848 "BIFROST.instr"
  mcccurved_guide_3_0_w2 = 0.029534;
#line 849 "BIFROST.instr"
  mcccurved_guide_3_0_h2 = 0.047514;
#line 847 "BIFROST.instr"
  mcccurved_guide_3_0_l = 0.5;
#line 850 "BIFROST.instr"
  mcccurved_guide_3_0_R0 = 0.990000;
#line 850 "BIFROST.instr"
  mcccurved_guide_3_0_Qc = 0.021700;
#line 851 "BIFROST.instr"
  mcccurved_guide_3_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_3_0_m = 1.0;
#line 851 "BIFROST.instr"
  mcccurved_guide_3_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_3_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_3_0_d = 0.0005;
#line 852 "BIFROST.instr"
  mcccurved_guide_3_0_mleft = 3.000000;
#line 852 "BIFROST.instr"
  mcccurved_guide_3_0_mright = 3.500000;
#line 853 "BIFROST.instr"
  mcccurved_guide_3_0_mtop = 2.500000;
#line 853 "BIFROST.instr"
  mcccurved_guide_3_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_3_0_nhslit = 1;
#line 847 "BIFROST.instr"
  mcccurved_guide_3_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_3_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_3_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_3_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_3_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_3_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_3_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_3_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_3_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_3_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_3_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_3_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_3_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_3_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_3_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_3_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_3_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_3_0_reflect[0]='\0';
#line 22564 "BIFROST.c"

  SIG_MESSAGE("curved_guide_3_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 855 "BIFROST.instr"
    (0)*DEG2RAD,
#line 855 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 855 "BIFROST.instr"
    (0)*DEG2RAD);
#line 22574 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_2_0, mcrotacurved_guide_3_0);
  rot_transpose(mcrotacurved_guide_2_0, mctr1);
  rot_mul(mcrotacurved_guide_3_0, mctr1, mcrotrcurved_guide_3_0);
  mctc1 = coords_set(
#line 854 "BIFROST.instr"
    7.57345916228e-10,
#line 854 "BIFROST.instr"
    0,
#line 854 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 22585 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_2_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_3_0 = coords_add(mcposacurved_guide_2_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_2_0, mcposacurved_guide_3_0);
  mcposrcurved_guide_3_0 = rot_apply(mcrotacurved_guide_3_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_3_0", mcposacurved_guide_3_0, mcrotacurved_guide_3_0)
  mccomp_posa[21] = mcposacurved_guide_3_0;
  mccomp_posr[21] = mcposrcurved_guide_3_0;
  mcNCounter[21]  = mcPCounter[21] = mcP2Counter[21] = 0;
  mcAbsorbProp[21]= 0;
    /* Component curved_guide_4_0. */
  /* Setting parameters for component curved_guide_4_0. */
  SIG_MESSAGE("curved_guide_4_0 (Init:SetPar)");
#line 860 "BIFROST.instr"
  mcccurved_guide_4_0_w1 = 0.029534;
#line 861 "BIFROST.instr"
  mcccurved_guide_4_0_h1 = 0.047514;
#line 860 "BIFROST.instr"
  mcccurved_guide_4_0_w2 = 0.029534;
#line 861 "BIFROST.instr"
  mcccurved_guide_4_0_h2 = 0.047514;
#line 859 "BIFROST.instr"
  mcccurved_guide_4_0_l = 0.5;
#line 862 "BIFROST.instr"
  mcccurved_guide_4_0_R0 = 0.990000;
#line 862 "BIFROST.instr"
  mcccurved_guide_4_0_Qc = 0.021700;
#line 863 "BIFROST.instr"
  mcccurved_guide_4_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_4_0_m = 1.0;
#line 863 "BIFROST.instr"
  mcccurved_guide_4_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_4_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_4_0_d = 0.0005;
#line 864 "BIFROST.instr"
  mcccurved_guide_4_0_mleft = 3.000000;
#line 864 "BIFROST.instr"
  mcccurved_guide_4_0_mright = 3.500000;
#line 865 "BIFROST.instr"
  mcccurved_guide_4_0_mtop = 2.500000;
#line 865 "BIFROST.instr"
  mcccurved_guide_4_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_4_0_nhslit = 1;
#line 859 "BIFROST.instr"
  mcccurved_guide_4_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_4_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_4_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_4_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_4_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_4_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_4_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_4_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_4_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_4_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_4_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_4_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_4_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_4_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_4_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_4_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_4_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_4_0_reflect[0]='\0';
#line 22667 "BIFROST.c"

  SIG_MESSAGE("curved_guide_4_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 867 "BIFROST.instr"
    (0)*DEG2RAD,
#line 867 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 867 "BIFROST.instr"
    (0)*DEG2RAD);
#line 22677 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_3_0, mcrotacurved_guide_4_0);
  rot_transpose(mcrotacurved_guide_3_0, mctr1);
  rot_mul(mcrotacurved_guide_4_0, mctr1, mcrotrcurved_guide_4_0);
  mctc1 = coords_set(
#line 866 "BIFROST.instr"
    7.57345916228e-10,
#line 866 "BIFROST.instr"
    0,
#line 866 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 22688 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_3_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_4_0 = coords_add(mcposacurved_guide_3_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_3_0, mcposacurved_guide_4_0);
  mcposrcurved_guide_4_0 = rot_apply(mcrotacurved_guide_4_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_4_0", mcposacurved_guide_4_0, mcrotacurved_guide_4_0)
  mccomp_posa[22] = mcposacurved_guide_4_0;
  mccomp_posr[22] = mcposrcurved_guide_4_0;
  mcNCounter[22]  = mcPCounter[22] = mcP2Counter[22] = 0;
  mcAbsorbProp[22]= 0;
    /* Component curved_guide_5_beforeChopper. */
  /* Setting parameters for component curved_guide_5_beforeChopper. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (Init:SetPar)");
#line 876 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_w1 = 0.029534;
#line 877 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_h1 = 0.047514;
#line 876 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_w2 = 0.029534;
#line 877 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_h2 = 0.047514;
#line 875 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_l = 0.13;
#line 878 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_R0 = 0.990000;
#line 878 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_Qc = 0.021700;
#line 879 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_m = 1.0;
#line 879 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_d = 0.0005;
#line 880 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_mleft = 3.000000;
#line 880 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_mright = 3.500000;
#line 881 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_mtop = 2.500000;
#line 881 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_nhslit = 1;
#line 875 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_5_beforeChopper_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_5_beforeChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_5_beforeChopper_reflect[0]='\0';
#line 22770 "BIFROST.c"

  SIG_MESSAGE("curved_guide_5_beforeChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 883 "BIFROST.instr"
    (0)*DEG2RAD,
#line 883 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 883 "BIFROST.instr"
    (0)*DEG2RAD);
#line 22780 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_4_0, mcrotacurved_guide_5_beforeChopper);
  rot_transpose(mcrotacurved_guide_4_0, mctr1);
  rot_mul(mcrotacurved_guide_5_beforeChopper, mctr1, mcrotrcurved_guide_5_beforeChopper);
  mctc1 = coords_set(
#line 882 "BIFROST.instr"
    7.57345916228e-10,
#line 882 "BIFROST.instr"
    0,
#line 882 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 22791 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_4_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_5_beforeChopper = coords_add(mcposacurved_guide_4_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_4_0, mcposacurved_guide_5_beforeChopper);
  mcposrcurved_guide_5_beforeChopper = rot_apply(mcrotacurved_guide_5_beforeChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_5_beforeChopper", mcposacurved_guide_5_beforeChopper, mcrotacurved_guide_5_beforeChopper)
  mccomp_posa[23] = mcposacurved_guide_5_beforeChopper;
  mccomp_posr[23] = mcposrcurved_guide_5_beforeChopper;
  mcNCounter[23]  = mcPCounter[23] = mcP2Counter[23] = 0;
  mcAbsorbProp[23]= 0;
    /* Component L_monBeforeFOC1. */
  /* Setting parameters for component L_monBeforeFOC1. */
  SIG_MESSAGE("L_monBeforeFOC1 (Init:SetPar)");
#line 887 "BIFROST.instr"
  if("L_monBeforeFOC1.dat") strncpy(mccL_monBeforeFOC1_filename, "L_monBeforeFOC1.dat" ? "L_monBeforeFOC1.dat" : "", 16384); else mccL_monBeforeFOC1_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC1_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC1_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC1_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC1_ymax = 0.05;
#line 887 "BIFROST.instr"
  mccL_monBeforeFOC1_xwidth = 0.2;
#line 888 "BIFROST.instr"
  mccL_monBeforeFOC1_yheight = 0.2;
#line 888 "BIFROST.instr"
  mccL_monBeforeFOC1_Lmin = lambda_0 / 2.0;
#line 888 "BIFROST.instr"
  mccL_monBeforeFOC1_Lmax = lambda_1 * 2.0;
#line 887 "BIFROST.instr"
  mccL_monBeforeFOC1_restore_neutron = 1;
#line 22825 "BIFROST.c"

  SIG_MESSAGE("L_monBeforeFOC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 890 "BIFROST.instr"
    (0)*DEG2RAD,
#line 890 "BIFROST.instr"
    (0)*DEG2RAD,
#line 890 "BIFROST.instr"
    (0)*DEG2RAD);
#line 22835 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_5_beforeChopper, mcrotaL_monBeforeFOC1);
  rot_transpose(mcrotacurved_guide_5_beforeChopper, mctr1);
  rot_mul(mcrotaL_monBeforeFOC1, mctr1, mcrotrL_monBeforeFOC1);
  mctc1 = coords_set(
#line 889 "BIFROST.instr"
    0,
#line 889 "BIFROST.instr"
    0,
#line 889 "BIFROST.instr"
    0.13 + u);
#line 22846 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_5_beforeChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monBeforeFOC1 = coords_add(mcposacurved_guide_5_beforeChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_5_beforeChopper, mcposaL_monBeforeFOC1);
  mcposrL_monBeforeFOC1 = rot_apply(mcrotaL_monBeforeFOC1, mctc1);
  mcDEBUG_COMPONENT("L_monBeforeFOC1", mcposaL_monBeforeFOC1, mcrotaL_monBeforeFOC1)
  mccomp_posa[24] = mcposaL_monBeforeFOC1;
  mccomp_posr[24] = mcposrL_monBeforeFOC1;
  mcNCounter[24]  = mcPCounter[24] = mcP2Counter[24] = 0;
  mcAbsorbProp[24]= 0;
    /* Component ToFBeforeFOC1. */
  /* Setting parameters for component ToFBeforeFOC1. */
  SIG_MESSAGE("ToFBeforeFOC1 (Init:SetPar)");
#line 893 "BIFROST.instr"
  if("ToFBeforeFOC1.dat") strncpy(mccToFBeforeFOC1_filename, "ToFBeforeFOC1.dat" ? "ToFBeforeFOC1.dat" : "", 16384); else mccToFBeforeFOC1_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFBeforeFOC1_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeFOC1_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeFOC1_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeFOC1_ymax = 0.05;
#line 893 "BIFROST.instr"
  mccToFBeforeFOC1_xwidth = 0.2;
#line 894 "BIFROST.instr"
  mccToFBeforeFOC1_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFBeforeFOC1_tmin = 0;
#line 894 "BIFROST.instr"
  mccToFBeforeFOC1_tmax = 2e4;
#line 47 "BIFROST.instr"
  mccToFBeforeFOC1_dt = 1.0;
#line 893 "BIFROST.instr"
  mccToFBeforeFOC1_restore_neutron = 1;
#line 22882 "BIFROST.c"

  SIG_MESSAGE("ToFBeforeFOC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22889 "BIFROST.c"
  rot_mul(mctr1, mcrotaL_monBeforeFOC1, mcrotaToFBeforeFOC1);
  rot_transpose(mcrotaL_monBeforeFOC1, mctr1);
  rot_mul(mcrotaToFBeforeFOC1, mctr1, mcrotrToFBeforeFOC1);
  mctc1 = coords_set(
#line 895 "BIFROST.instr"
    0,
#line 895 "BIFROST.instr"
    0,
#line 895 "BIFROST.instr"
    u);
#line 22900 "BIFROST.c"
  rot_transpose(mcrotaL_monBeforeFOC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFBeforeFOC1 = coords_add(mcposaL_monBeforeFOC1, mctc2);
  mctc1 = coords_sub(mcposaL_monBeforeFOC1, mcposaToFBeforeFOC1);
  mcposrToFBeforeFOC1 = rot_apply(mcrotaToFBeforeFOC1, mctc1);
  mcDEBUG_COMPONENT("ToFBeforeFOC1", mcposaToFBeforeFOC1, mcrotaToFBeforeFOC1)
  mccomp_posa[25] = mcposaToFBeforeFOC1;
  mccomp_posr[25] = mcposrToFBeforeFOC1;
  mcNCounter[25]  = mcPCounter[25] = mcP2Counter[25] = 0;
  mcAbsorbProp[25]= 0;
    /* Component PSD_beforeFOC1. */
  /* Setting parameters for component PSD_beforeFOC1. */
  SIG_MESSAGE("PSD_beforeFOC1 (Init:SetPar)");
#line 898 "BIFROST.instr"
  if("PSD_beforeFOC1.dat") strncpy(mccPSD_beforeFOC1_filename, "PSD_beforeFOC1.dat" ? "PSD_beforeFOC1.dat" : "", 16384); else mccPSD_beforeFOC1_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC1_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC1_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC1_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC1_ymax = 0.05;
#line 899 "BIFROST.instr"
  mccPSD_beforeFOC1_xwidth = 0.2;
#line 899 "BIFROST.instr"
  mccPSD_beforeFOC1_yheight = 0.2;
#line 898 "BIFROST.instr"
  mccPSD_beforeFOC1_restore_neutron = 1;
#line 22930 "BIFROST.c"

  SIG_MESSAGE("PSD_beforeFOC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22937 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFBeforeFOC1, mcrotaPSD_beforeFOC1);
  rot_transpose(mcrotaToFBeforeFOC1, mctr1);
  rot_mul(mcrotaPSD_beforeFOC1, mctr1, mcrotrPSD_beforeFOC1);
  mctc1 = coords_set(
#line 900 "BIFROST.instr"
    0,
#line 900 "BIFROST.instr"
    0,
#line 900 "BIFROST.instr"
    u);
#line 22948 "BIFROST.c"
  rot_transpose(mcrotaToFBeforeFOC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_beforeFOC1 = coords_add(mcposaToFBeforeFOC1, mctc2);
  mctc1 = coords_sub(mcposaToFBeforeFOC1, mcposaPSD_beforeFOC1);
  mcposrPSD_beforeFOC1 = rot_apply(mcrotaPSD_beforeFOC1, mctc1);
  mcDEBUG_COMPONENT("PSD_beforeFOC1", mcposaPSD_beforeFOC1, mcrotaPSD_beforeFOC1)
  mccomp_posa[26] = mcposaPSD_beforeFOC1;
  mccomp_posr[26] = mcposrPSD_beforeFOC1;
  mcNCounter[26]  = mcPCounter[26] = mcP2Counter[26] = 0;
  mcAbsorbProp[26]= 0;
    /* Component FOC1. */
  /* Setting parameters for component FOC1. */
  SIG_MESSAGE("FOC1 (Init:SetPar)");
#line 903 "BIFROST.instr"
  mccFOC1_theta_0 = mcipFOCopen1;
#line 903 "BIFROST.instr"
  mccFOC1_radius = 0.35;
#line 903 "BIFROST.instr"
  mccFOC1_yheight = 0.052;
#line 903 "BIFROST.instr"
  mccFOC1_nu = 14;
#line 903 "BIFROST.instr"
  mccFOC1_nslit = 1;
#line 56 "BIFROST.instr"
  mccFOC1_jitter = 0;
#line 56 "BIFROST.instr"
  mccFOC1_delay = 0;
#line 56 "BIFROST.instr"
  mccFOC1_isfirst = 0;
#line 56 "BIFROST.instr"
  mccFOC1_n_pulse = 1;
#line 56 "BIFROST.instr"
  mccFOC1_abs_out = 1;
#line 904 "BIFROST.instr"
  mccFOC1_phase = chopFrameOverlap1PhaseOffset;
#line 56 "BIFROST.instr"
  mccFOC1_xwidth = 0;
#line 56 "BIFROST.instr"
  mccFOC1_verbose = 0;
#line 22988 "BIFROST.c"

  SIG_MESSAGE("FOC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 906 "BIFROST.instr"
    (0)*DEG2RAD,
#line 906 "BIFROST.instr"
    (0)*DEG2RAD,
#line 906 "BIFROST.instr"
    (0)*DEG2RAD);
#line 22998 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_beforeFOC1, mcrotaFOC1);
  rot_transpose(mcrotaPSD_beforeFOC1, mctr1);
  rot_mul(mcrotaFOC1, mctr1, mcrotrFOC1);
  mctc1 = coords_set(
#line 905 "BIFROST.instr"
    0,
#line 905 "BIFROST.instr"
    0,
#line 905 "BIFROST.instr"
    0.02);
#line 23009 "BIFROST.c"
  rot_transpose(mcrotaPSD_beforeFOC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaFOC1 = coords_add(mcposaPSD_beforeFOC1, mctc2);
  mctc1 = coords_sub(mcposaPSD_beforeFOC1, mcposaFOC1);
  mcposrFOC1 = rot_apply(mcrotaFOC1, mctc1);
  mcDEBUG_COMPONENT("FOC1", mcposaFOC1, mcrotaFOC1)
  mccomp_posa[27] = mcposaFOC1;
  mccomp_posr[27] = mcposrFOC1;
  mcNCounter[27]  = mcPCounter[27] = mcP2Counter[27] = 0;
  mcAbsorbProp[27]= 0;
    /* Component PSD_afterFOC1. */
  /* Setting parameters for component PSD_afterFOC1. */
  SIG_MESSAGE("PSD_afterFOC1 (Init:SetPar)");
#line 909 "BIFROST.instr"
  if("PSD_afterFOC1.dat") strncpy(mccPSD_afterFOC1_filename, "PSD_afterFOC1.dat" ? "PSD_afterFOC1.dat" : "", 16384); else mccPSD_afterFOC1_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_afterFOC1_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_afterFOC1_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_afterFOC1_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_afterFOC1_ymax = 0.05;
#line 910 "BIFROST.instr"
  mccPSD_afterFOC1_xwidth = 0.2;
#line 910 "BIFROST.instr"
  mccPSD_afterFOC1_yheight = 0.2;
#line 909 "BIFROST.instr"
  mccPSD_afterFOC1_restore_neutron = 1;
#line 23039 "BIFROST.c"

  SIG_MESSAGE("PSD_afterFOC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23046 "BIFROST.c"
  rot_mul(mctr1, mcrotaFOC1, mcrotaPSD_afterFOC1);
  rot_transpose(mcrotaFOC1, mctr1);
  rot_mul(mcrotaPSD_afterFOC1, mctr1, mcrotrPSD_afterFOC1);
  mctc1 = coords_set(
#line 911 "BIFROST.instr"
    0,
#line 911 "BIFROST.instr"
    0,
#line 911 "BIFROST.instr"
    u);
#line 23057 "BIFROST.c"
  rot_transpose(mcrotaFOC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_afterFOC1 = coords_add(mcposaFOC1, mctc2);
  mctc1 = coords_sub(mcposaFOC1, mcposaPSD_afterFOC1);
  mcposrPSD_afterFOC1 = rot_apply(mcrotaPSD_afterFOC1, mctc1);
  mcDEBUG_COMPONENT("PSD_afterFOC1", mcposaPSD_afterFOC1, mcrotaPSD_afterFOC1)
  mccomp_posa[28] = mcposaPSD_afterFOC1;
  mccomp_posr[28] = mcposrPSD_afterFOC1;
  mcNCounter[28]  = mcPCounter[28] = mcP2Counter[28] = 0;
  mcAbsorbProp[28]= 0;
    /* Component ToFAfterFOC1. */
  /* Setting parameters for component ToFAfterFOC1. */
  SIG_MESSAGE("ToFAfterFOC1 (Init:SetPar)");
#line 914 "BIFROST.instr"
  if("ToFAfterFOC1.dat") strncpy(mccToFAfterFOC1_filename, "ToFAfterFOC1.dat" ? "ToFAfterFOC1.dat" : "", 16384); else mccToFAfterFOC1_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFAfterFOC1_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterFOC1_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFAfterFOC1_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterFOC1_ymax = 0.05;
#line 914 "BIFROST.instr"
  mccToFAfterFOC1_xwidth = 0.2;
#line 915 "BIFROST.instr"
  mccToFAfterFOC1_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFAfterFOC1_tmin = 0;
#line 915 "BIFROST.instr"
  mccToFAfterFOC1_tmax = 2e4;
#line 47 "BIFROST.instr"
  mccToFAfterFOC1_dt = 1.0;
#line 914 "BIFROST.instr"
  mccToFAfterFOC1_restore_neutron = 1;
#line 23093 "BIFROST.c"

  SIG_MESSAGE("ToFAfterFOC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23100 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_afterFOC1, mcrotaToFAfterFOC1);
  rot_transpose(mcrotaPSD_afterFOC1, mctr1);
  rot_mul(mcrotaToFAfterFOC1, mctr1, mcrotrToFAfterFOC1);
  mctc1 = coords_set(
#line 916 "BIFROST.instr"
    0,
#line 916 "BIFROST.instr"
    0,
#line 916 "BIFROST.instr"
    u);
#line 23111 "BIFROST.c"
  rot_transpose(mcrotaPSD_afterFOC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFAfterFOC1 = coords_add(mcposaPSD_afterFOC1, mctc2);
  mctc1 = coords_sub(mcposaPSD_afterFOC1, mcposaToFAfterFOC1);
  mcposrToFAfterFOC1 = rot_apply(mcrotaToFAfterFOC1, mctc1);
  mcDEBUG_COMPONENT("ToFAfterFOC1", mcposaToFAfterFOC1, mcrotaToFAfterFOC1)
  mccomp_posa[29] = mcposaToFAfterFOC1;
  mccomp_posr[29] = mcposrToFAfterFOC1;
  mcNCounter[29]  = mcPCounter[29] = mcP2Counter[29] = 0;
  mcAbsorbProp[29]= 0;
    /* Component L_monAfterFOC1. */
  /* Setting parameters for component L_monAfterFOC1. */
  SIG_MESSAGE("L_monAfterFOC1 (Init:SetPar)");
#line 919 "BIFROST.instr"
  if("L_monAfterFOC1.dat") strncpy(mccL_monAfterFOC1_filename, "L_monAfterFOC1.dat" ? "L_monAfterFOC1.dat" : "", 16384); else mccL_monAfterFOC1_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monAfterFOC1_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterFOC1_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterFOC1_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterFOC1_ymax = 0.05;
#line 919 "BIFROST.instr"
  mccL_monAfterFOC1_xwidth = 0.2;
#line 920 "BIFROST.instr"
  mccL_monAfterFOC1_yheight = 0.2;
#line 920 "BIFROST.instr"
  mccL_monAfterFOC1_Lmin = lambda_0 / 2.0;
#line 920 "BIFROST.instr"
  mccL_monAfterFOC1_Lmax = lambda_1 * 2.0;
#line 919 "BIFROST.instr"
  mccL_monAfterFOC1_restore_neutron = 1;
#line 23145 "BIFROST.c"

  SIG_MESSAGE("L_monAfterFOC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23152 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFAfterFOC1, mcrotaL_monAfterFOC1);
  rot_transpose(mcrotaToFAfterFOC1, mctr1);
  rot_mul(mcrotaL_monAfterFOC1, mctr1, mcrotrL_monAfterFOC1);
  mctc1 = coords_set(
#line 921 "BIFROST.instr"
    0,
#line 921 "BIFROST.instr"
    0,
#line 921 "BIFROST.instr"
    u);
#line 23163 "BIFROST.c"
  rot_transpose(mcrotaToFAfterFOC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monAfterFOC1 = coords_add(mcposaToFAfterFOC1, mctc2);
  mctc1 = coords_sub(mcposaToFAfterFOC1, mcposaL_monAfterFOC1);
  mcposrL_monAfterFOC1 = rot_apply(mcrotaL_monAfterFOC1, mctc1);
  mcDEBUG_COMPONENT("L_monAfterFOC1", mcposaL_monAfterFOC1, mcrotaL_monAfterFOC1)
  mccomp_posa[30] = mcposaL_monAfterFOC1;
  mccomp_posr[30] = mcposrL_monAfterFOC1;
  mcNCounter[30]  = mcPCounter[30] = mcP2Counter[30] = 0;
  mcAbsorbProp[30]= 0;
    /* Component curved_guide_5_afterChopper. */
  /* Setting parameters for component curved_guide_5_afterChopper. */
  SIG_MESSAGE("curved_guide_5_afterChopper (Init:SetPar)");
#line 926 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_w1 = 0.029534;
#line 927 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_h1 = 0.047514;
#line 926 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_w2 = 0.029534;
#line 927 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_h2 = 0.047514;
#line 925 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_l = 0.33;
#line 928 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_R0 = 0.990000;
#line 928 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_Qc = 0.021700;
#line 929 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_m = 1.0;
#line 929 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_d = 0.0005;
#line 930 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_mleft = 3.000000;
#line 930 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_mright = 3.500000;
#line 931 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_mtop = 2.500000;
#line 931 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_nhslit = 1;
#line 925 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_5_afterChopper_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_5_afterChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_5_afterChopper_reflect[0]='\0';
#line 23245 "BIFROST.c"

  SIG_MESSAGE("curved_guide_5_afterChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 933 "BIFROST.instr"
    (0)*DEG2RAD,
#line 933 "BIFROST.instr"
    (0)*DEG2RAD,
#line 933 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23255 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_5_beforeChopper, mcrotacurved_guide_5_afterChopper);
  rot_transpose(mcrotaL_monAfterFOC1, mctr1);
  rot_mul(mcrotacurved_guide_5_afterChopper, mctr1, mcrotrcurved_guide_5_afterChopper);
  mctc1 = coords_set(
#line 932 "BIFROST.instr"
    0,
#line 932 "BIFROST.instr"
    0,
#line 932 "BIFROST.instr"
    0.17);
#line 23266 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_5_beforeChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_5_afterChopper = coords_add(mcposacurved_guide_5_beforeChopper, mctc2);
  mctc1 = coords_sub(mcposaL_monAfterFOC1, mcposacurved_guide_5_afterChopper);
  mcposrcurved_guide_5_afterChopper = rot_apply(mcrotacurved_guide_5_afterChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_5_afterChopper", mcposacurved_guide_5_afterChopper, mcrotacurved_guide_5_afterChopper)
  mccomp_posa[31] = mcposacurved_guide_5_afterChopper;
  mccomp_posr[31] = mcposrcurved_guide_5_afterChopper;
  mcNCounter[31]  = mcPCounter[31] = mcP2Counter[31] = 0;
  mcAbsorbProp[31]= 0;
    /* Component curved_guide_6_0. */
  /* Setting parameters for component curved_guide_6_0. */
  SIG_MESSAGE("curved_guide_6_0 (Init:SetPar)");
#line 937 "BIFROST.instr"
  mcccurved_guide_6_0_w1 = 0.029534;
#line 938 "BIFROST.instr"
  mcccurved_guide_6_0_h1 = 0.047514;
#line 937 "BIFROST.instr"
  mcccurved_guide_6_0_w2 = 0.029534;
#line 938 "BIFROST.instr"
  mcccurved_guide_6_0_h2 = 0.047514;
#line 936 "BIFROST.instr"
  mcccurved_guide_6_0_l = 0.5;
#line 939 "BIFROST.instr"
  mcccurved_guide_6_0_R0 = 0.990000;
#line 939 "BIFROST.instr"
  mcccurved_guide_6_0_Qc = 0.021700;
#line 940 "BIFROST.instr"
  mcccurved_guide_6_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_6_0_m = 1.0;
#line 940 "BIFROST.instr"
  mcccurved_guide_6_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_6_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_6_0_d = 0.0005;
#line 941 "BIFROST.instr"
  mcccurved_guide_6_0_mleft = 3.000000;
#line 941 "BIFROST.instr"
  mcccurved_guide_6_0_mright = 3.500000;
#line 942 "BIFROST.instr"
  mcccurved_guide_6_0_mtop = 2.500000;
#line 942 "BIFROST.instr"
  mcccurved_guide_6_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_6_0_nhslit = 1;
#line 936 "BIFROST.instr"
  mcccurved_guide_6_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_6_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_6_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_6_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_6_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_6_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_6_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_6_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_6_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_6_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_6_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_6_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_6_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_6_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_6_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_6_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_6_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_6_0_reflect[0]='\0';
#line 23348 "BIFROST.c"

  SIG_MESSAGE("curved_guide_6_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 944 "BIFROST.instr"
    (0)*DEG2RAD,
#line 944 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 944 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23358 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_5_afterChopper, mcrotacurved_guide_6_0);
  rot_transpose(mcrotacurved_guide_5_afterChopper, mctr1);
  rot_mul(mcrotacurved_guide_6_0, mctr1, mcrotrcurved_guide_6_0);
  mctc1 = coords_set(
#line 943 "BIFROST.instr"
    7.57345916228e-10,
#line 943 "BIFROST.instr"
    0,
#line 943 "BIFROST.instr"
    0.33 + u);
#line 23369 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_5_afterChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_6_0 = coords_add(mcposacurved_guide_5_afterChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_5_afterChopper, mcposacurved_guide_6_0);
  mcposrcurved_guide_6_0 = rot_apply(mcrotacurved_guide_6_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_6_0", mcposacurved_guide_6_0, mcrotacurved_guide_6_0)
  mccomp_posa[32] = mcposacurved_guide_6_0;
  mccomp_posr[32] = mcposrcurved_guide_6_0;
  mcNCounter[32]  = mcPCounter[32] = mcP2Counter[32] = 0;
  mcAbsorbProp[32]= 0;
    /* Component curved_guide_7_0. */
  /* Setting parameters for component curved_guide_7_0. */
  SIG_MESSAGE("curved_guide_7_0 (Init:SetPar)");
#line 948 "BIFROST.instr"
  mcccurved_guide_7_0_w1 = 0.029534;
#line 949 "BIFROST.instr"
  mcccurved_guide_7_0_h1 = 0.047514;
#line 948 "BIFROST.instr"
  mcccurved_guide_7_0_w2 = 0.029534;
#line 949 "BIFROST.instr"
  mcccurved_guide_7_0_h2 = 0.047514;
#line 947 "BIFROST.instr"
  mcccurved_guide_7_0_l = 0.5;
#line 950 "BIFROST.instr"
  mcccurved_guide_7_0_R0 = 0.990000;
#line 950 "BIFROST.instr"
  mcccurved_guide_7_0_Qc = 0.021700;
#line 951 "BIFROST.instr"
  mcccurved_guide_7_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_7_0_m = 1.0;
#line 951 "BIFROST.instr"
  mcccurved_guide_7_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_7_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_7_0_d = 0.0005;
#line 952 "BIFROST.instr"
  mcccurved_guide_7_0_mleft = 3.000000;
#line 952 "BIFROST.instr"
  mcccurved_guide_7_0_mright = 3.500000;
#line 953 "BIFROST.instr"
  mcccurved_guide_7_0_mtop = 2.500000;
#line 953 "BIFROST.instr"
  mcccurved_guide_7_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_7_0_nhslit = 1;
#line 947 "BIFROST.instr"
  mcccurved_guide_7_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_7_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_7_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_7_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_7_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_7_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_7_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_7_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_7_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_7_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_7_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_7_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_7_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_7_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_7_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_7_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_7_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_7_0_reflect[0]='\0';
#line 23451 "BIFROST.c"

  SIG_MESSAGE("curved_guide_7_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 955 "BIFROST.instr"
    (0)*DEG2RAD,
#line 955 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 955 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23461 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_6_0, mcrotacurved_guide_7_0);
  rot_transpose(mcrotacurved_guide_6_0, mctr1);
  rot_mul(mcrotacurved_guide_7_0, mctr1, mcrotrcurved_guide_7_0);
  mctc1 = coords_set(
#line 954 "BIFROST.instr"
    7.57345916228e-10,
#line 954 "BIFROST.instr"
    0,
#line 954 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 23472 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_6_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_7_0 = coords_add(mcposacurved_guide_6_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_6_0, mcposacurved_guide_7_0);
  mcposrcurved_guide_7_0 = rot_apply(mcrotacurved_guide_7_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_7_0", mcposacurved_guide_7_0, mcrotacurved_guide_7_0)
  mccomp_posa[33] = mcposacurved_guide_7_0;
  mccomp_posr[33] = mcposrcurved_guide_7_0;
  mcNCounter[33]  = mcPCounter[33] = mcP2Counter[33] = 0;
  mcAbsorbProp[33]= 0;
    /* Component curved_guide_8_0. */
  /* Setting parameters for component curved_guide_8_0. */
  SIG_MESSAGE("curved_guide_8_0 (Init:SetPar)");
#line 959 "BIFROST.instr"
  mcccurved_guide_8_0_w1 = 0.029534;
#line 960 "BIFROST.instr"
  mcccurved_guide_8_0_h1 = 0.047514;
#line 959 "BIFROST.instr"
  mcccurved_guide_8_0_w2 = 0.029534;
#line 960 "BIFROST.instr"
  mcccurved_guide_8_0_h2 = 0.047514;
#line 958 "BIFROST.instr"
  mcccurved_guide_8_0_l = 0.5;
#line 961 "BIFROST.instr"
  mcccurved_guide_8_0_R0 = 0.990000;
#line 961 "BIFROST.instr"
  mcccurved_guide_8_0_Qc = 0.021700;
#line 962 "BIFROST.instr"
  mcccurved_guide_8_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_8_0_m = 1.0;
#line 962 "BIFROST.instr"
  mcccurved_guide_8_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_8_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_8_0_d = 0.0005;
#line 963 "BIFROST.instr"
  mcccurved_guide_8_0_mleft = 3.000000;
#line 963 "BIFROST.instr"
  mcccurved_guide_8_0_mright = 3.500000;
#line 964 "BIFROST.instr"
  mcccurved_guide_8_0_mtop = 2.500000;
#line 964 "BIFROST.instr"
  mcccurved_guide_8_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_8_0_nhslit = 1;
#line 958 "BIFROST.instr"
  mcccurved_guide_8_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_8_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_8_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_8_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_8_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_8_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_8_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_8_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_8_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_8_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_8_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_8_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_8_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_8_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_8_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_8_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_8_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_8_0_reflect[0]='\0';
#line 23554 "BIFROST.c"

  SIG_MESSAGE("curved_guide_8_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 966 "BIFROST.instr"
    (0)*DEG2RAD,
#line 966 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 966 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23564 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_7_0, mcrotacurved_guide_8_0);
  rot_transpose(mcrotacurved_guide_7_0, mctr1);
  rot_mul(mcrotacurved_guide_8_0, mctr1, mcrotrcurved_guide_8_0);
  mctc1 = coords_set(
#line 965 "BIFROST.instr"
    7.57345916228e-10,
#line 965 "BIFROST.instr"
    0,
#line 965 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 23575 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_7_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_8_0 = coords_add(mcposacurved_guide_7_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_7_0, mcposacurved_guide_8_0);
  mcposrcurved_guide_8_0 = rot_apply(mcrotacurved_guide_8_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_8_0", mcposacurved_guide_8_0, mcrotacurved_guide_8_0)
  mccomp_posa[34] = mcposacurved_guide_8_0;
  mccomp_posr[34] = mcposrcurved_guide_8_0;
  mcNCounter[34]  = mcPCounter[34] = mcP2Counter[34] = 0;
  mcAbsorbProp[34]= 0;
    /* Component curved_guide_9_0. */
  /* Setting parameters for component curved_guide_9_0. */
  SIG_MESSAGE("curved_guide_9_0 (Init:SetPar)");
#line 970 "BIFROST.instr"
  mcccurved_guide_9_0_w1 = 0.029534;
#line 971 "BIFROST.instr"
  mcccurved_guide_9_0_h1 = 0.047514;
#line 970 "BIFROST.instr"
  mcccurved_guide_9_0_w2 = 0.029534;
#line 971 "BIFROST.instr"
  mcccurved_guide_9_0_h2 = 0.047514;
#line 969 "BIFROST.instr"
  mcccurved_guide_9_0_l = 0.5;
#line 972 "BIFROST.instr"
  mcccurved_guide_9_0_R0 = 0.990000;
#line 972 "BIFROST.instr"
  mcccurved_guide_9_0_Qc = 0.021700;
#line 973 "BIFROST.instr"
  mcccurved_guide_9_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_9_0_m = 1.0;
#line 973 "BIFROST.instr"
  mcccurved_guide_9_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_9_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_9_0_d = 0.0005;
#line 974 "BIFROST.instr"
  mcccurved_guide_9_0_mleft = 3.000000;
#line 974 "BIFROST.instr"
  mcccurved_guide_9_0_mright = 3.500000;
#line 975 "BIFROST.instr"
  mcccurved_guide_9_0_mtop = 2.500000;
#line 975 "BIFROST.instr"
  mcccurved_guide_9_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_9_0_nhslit = 1;
#line 969 "BIFROST.instr"
  mcccurved_guide_9_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_9_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_9_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_9_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_9_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_9_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_9_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_9_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_9_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_9_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_9_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_9_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_9_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_9_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_9_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_9_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_9_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_9_0_reflect[0]='\0';
#line 23657 "BIFROST.c"

  SIG_MESSAGE("curved_guide_9_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 977 "BIFROST.instr"
    (0)*DEG2RAD,
#line 977 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 977 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23667 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_8_0, mcrotacurved_guide_9_0);
  rot_transpose(mcrotacurved_guide_8_0, mctr1);
  rot_mul(mcrotacurved_guide_9_0, mctr1, mcrotrcurved_guide_9_0);
  mctc1 = coords_set(
#line 976 "BIFROST.instr"
    7.57345916228e-10,
#line 976 "BIFROST.instr"
    0,
#line 976 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 23678 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_8_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_9_0 = coords_add(mcposacurved_guide_8_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_8_0, mcposacurved_guide_9_0);
  mcposrcurved_guide_9_0 = rot_apply(mcrotacurved_guide_9_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_9_0", mcposacurved_guide_9_0, mcrotacurved_guide_9_0)
  mccomp_posa[35] = mcposacurved_guide_9_0;
  mccomp_posr[35] = mcposrcurved_guide_9_0;
  mcNCounter[35]  = mcPCounter[35] = mcP2Counter[35] = 0;
  mcAbsorbProp[35]= 0;
    /* Component curved_guide_10_0. */
  /* Setting parameters for component curved_guide_10_0. */
  SIG_MESSAGE("curved_guide_10_0 (Init:SetPar)");
#line 981 "BIFROST.instr"
  mcccurved_guide_10_0_w1 = 0.029534;
#line 982 "BIFROST.instr"
  mcccurved_guide_10_0_h1 = 0.047514;
#line 981 "BIFROST.instr"
  mcccurved_guide_10_0_w2 = 0.029534;
#line 982 "BIFROST.instr"
  mcccurved_guide_10_0_h2 = 0.047514;
#line 980 "BIFROST.instr"
  mcccurved_guide_10_0_l = 0.5;
#line 983 "BIFROST.instr"
  mcccurved_guide_10_0_R0 = 0.990000;
#line 983 "BIFROST.instr"
  mcccurved_guide_10_0_Qc = 0.021700;
#line 984 "BIFROST.instr"
  mcccurved_guide_10_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_10_0_m = 1.0;
#line 984 "BIFROST.instr"
  mcccurved_guide_10_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_10_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_10_0_d = 0.0005;
#line 985 "BIFROST.instr"
  mcccurved_guide_10_0_mleft = 3.000000;
#line 985 "BIFROST.instr"
  mcccurved_guide_10_0_mright = 3.500000;
#line 986 "BIFROST.instr"
  mcccurved_guide_10_0_mtop = 2.500000;
#line 986 "BIFROST.instr"
  mcccurved_guide_10_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_10_0_nhslit = 1;
#line 980 "BIFROST.instr"
  mcccurved_guide_10_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_10_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_10_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_10_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_10_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_10_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_10_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_10_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_10_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_10_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_10_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_10_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_10_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_10_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_10_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_10_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_10_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_10_0_reflect[0]='\0';
#line 23760 "BIFROST.c"

  SIG_MESSAGE("curved_guide_10_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 988 "BIFROST.instr"
    (0)*DEG2RAD,
#line 988 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 988 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23770 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_9_0, mcrotacurved_guide_10_0);
  rot_transpose(mcrotacurved_guide_9_0, mctr1);
  rot_mul(mcrotacurved_guide_10_0, mctr1, mcrotrcurved_guide_10_0);
  mctc1 = coords_set(
#line 987 "BIFROST.instr"
    7.57345916228e-10,
#line 987 "BIFROST.instr"
    0,
#line 987 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 23781 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_9_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_10_0 = coords_add(mcposacurved_guide_9_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_9_0, mcposacurved_guide_10_0);
  mcposrcurved_guide_10_0 = rot_apply(mcrotacurved_guide_10_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_10_0", mcposacurved_guide_10_0, mcrotacurved_guide_10_0)
  mccomp_posa[36] = mcposacurved_guide_10_0;
  mccomp_posr[36] = mcposrcurved_guide_10_0;
  mcNCounter[36]  = mcPCounter[36] = mcP2Counter[36] = 0;
  mcAbsorbProp[36]= 0;
    /* Component curved_guide_11_0. */
  /* Setting parameters for component curved_guide_11_0. */
  SIG_MESSAGE("curved_guide_11_0 (Init:SetPar)");
#line 992 "BIFROST.instr"
  mcccurved_guide_11_0_w1 = 0.029534;
#line 993 "BIFROST.instr"
  mcccurved_guide_11_0_h1 = 0.047514;
#line 992 "BIFROST.instr"
  mcccurved_guide_11_0_w2 = 0.029534;
#line 993 "BIFROST.instr"
  mcccurved_guide_11_0_h2 = 0.047514;
#line 991 "BIFROST.instr"
  mcccurved_guide_11_0_l = 0.5;
#line 994 "BIFROST.instr"
  mcccurved_guide_11_0_R0 = 0.990000;
#line 994 "BIFROST.instr"
  mcccurved_guide_11_0_Qc = 0.021700;
#line 995 "BIFROST.instr"
  mcccurved_guide_11_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_11_0_m = 1.0;
#line 995 "BIFROST.instr"
  mcccurved_guide_11_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_11_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_11_0_d = 0.0005;
#line 996 "BIFROST.instr"
  mcccurved_guide_11_0_mleft = 3.000000;
#line 996 "BIFROST.instr"
  mcccurved_guide_11_0_mright = 3.500000;
#line 997 "BIFROST.instr"
  mcccurved_guide_11_0_mtop = 2.500000;
#line 997 "BIFROST.instr"
  mcccurved_guide_11_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_11_0_nhslit = 1;
#line 991 "BIFROST.instr"
  mcccurved_guide_11_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_11_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_11_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_11_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_11_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_11_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_11_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_11_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_11_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_11_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_11_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_11_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_11_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_11_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_11_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_11_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_11_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_11_0_reflect[0]='\0';
#line 23863 "BIFROST.c"

  SIG_MESSAGE("curved_guide_11_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 999 "BIFROST.instr"
    (0)*DEG2RAD,
#line 999 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 999 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23873 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_10_0, mcrotacurved_guide_11_0);
  rot_transpose(mcrotacurved_guide_10_0, mctr1);
  rot_mul(mcrotacurved_guide_11_0, mctr1, mcrotrcurved_guide_11_0);
  mctc1 = coords_set(
#line 998 "BIFROST.instr"
    7.57345916228e-10,
#line 998 "BIFROST.instr"
    0,
#line 998 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 23884 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_10_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_11_0 = coords_add(mcposacurved_guide_10_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_10_0, mcposacurved_guide_11_0);
  mcposrcurved_guide_11_0 = rot_apply(mcrotacurved_guide_11_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_11_0", mcposacurved_guide_11_0, mcrotacurved_guide_11_0)
  mccomp_posa[37] = mcposacurved_guide_11_0;
  mccomp_posr[37] = mcposrcurved_guide_11_0;
  mcNCounter[37]  = mcPCounter[37] = mcP2Counter[37] = 0;
  mcAbsorbProp[37]= 0;
    /* Component curved_guide_12_0. */
  /* Setting parameters for component curved_guide_12_0. */
  SIG_MESSAGE("curved_guide_12_0 (Init:SetPar)");
#line 1003 "BIFROST.instr"
  mcccurved_guide_12_0_w1 = 0.029534;
#line 1004 "BIFROST.instr"
  mcccurved_guide_12_0_h1 = 0.047514;
#line 1003 "BIFROST.instr"
  mcccurved_guide_12_0_w2 = 0.029534;
#line 1004 "BIFROST.instr"
  mcccurved_guide_12_0_h2 = 0.047514;
#line 1002 "BIFROST.instr"
  mcccurved_guide_12_0_l = 0.5;
#line 1005 "BIFROST.instr"
  mcccurved_guide_12_0_R0 = 0.990000;
#line 1005 "BIFROST.instr"
  mcccurved_guide_12_0_Qc = 0.021700;
#line 1006 "BIFROST.instr"
  mcccurved_guide_12_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_12_0_m = 1.0;
#line 1006 "BIFROST.instr"
  mcccurved_guide_12_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_12_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_12_0_d = 0.0005;
#line 1007 "BIFROST.instr"
  mcccurved_guide_12_0_mleft = 3.000000;
#line 1007 "BIFROST.instr"
  mcccurved_guide_12_0_mright = 3.500000;
#line 1008 "BIFROST.instr"
  mcccurved_guide_12_0_mtop = 2.500000;
#line 1008 "BIFROST.instr"
  mcccurved_guide_12_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_12_0_nhslit = 1;
#line 1002 "BIFROST.instr"
  mcccurved_guide_12_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_12_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_12_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_12_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_12_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_12_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_12_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_12_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_12_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_12_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_12_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_12_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_12_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_12_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_12_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_12_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_12_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_12_0_reflect[0]='\0';
#line 23966 "BIFROST.c"

  SIG_MESSAGE("curved_guide_12_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1010 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1010 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1010 "BIFROST.instr"
    (0)*DEG2RAD);
#line 23976 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_11_0, mcrotacurved_guide_12_0);
  rot_transpose(mcrotacurved_guide_11_0, mctr1);
  rot_mul(mcrotacurved_guide_12_0, mctr1, mcrotrcurved_guide_12_0);
  mctc1 = coords_set(
#line 1009 "BIFROST.instr"
    7.57345916228e-10,
#line 1009 "BIFROST.instr"
    0,
#line 1009 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 23987 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_11_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_12_0 = coords_add(mcposacurved_guide_11_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_11_0, mcposacurved_guide_12_0);
  mcposrcurved_guide_12_0 = rot_apply(mcrotacurved_guide_12_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_12_0", mcposacurved_guide_12_0, mcrotacurved_guide_12_0)
  mccomp_posa[38] = mcposacurved_guide_12_0;
  mccomp_posr[38] = mcposrcurved_guide_12_0;
  mcNCounter[38]  = mcPCounter[38] = mcP2Counter[38] = 0;
  mcAbsorbProp[38]= 0;
    /* Component curved_guide_13_0. */
  /* Setting parameters for component curved_guide_13_0. */
  SIG_MESSAGE("curved_guide_13_0 (Init:SetPar)");
#line 1014 "BIFROST.instr"
  mcccurved_guide_13_0_w1 = 0.029534;
#line 1015 "BIFROST.instr"
  mcccurved_guide_13_0_h1 = 0.047514;
#line 1014 "BIFROST.instr"
  mcccurved_guide_13_0_w2 = 0.029534;
#line 1015 "BIFROST.instr"
  mcccurved_guide_13_0_h2 = 0.047514;
#line 1013 "BIFROST.instr"
  mcccurved_guide_13_0_l = 0.5;
#line 1016 "BIFROST.instr"
  mcccurved_guide_13_0_R0 = 0.990000;
#line 1016 "BIFROST.instr"
  mcccurved_guide_13_0_Qc = 0.021700;
#line 1017 "BIFROST.instr"
  mcccurved_guide_13_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_13_0_m = 1.0;
#line 1017 "BIFROST.instr"
  mcccurved_guide_13_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_13_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_13_0_d = 0.0005;
#line 1018 "BIFROST.instr"
  mcccurved_guide_13_0_mleft = 3.000000;
#line 1018 "BIFROST.instr"
  mcccurved_guide_13_0_mright = 3.500000;
#line 1019 "BIFROST.instr"
  mcccurved_guide_13_0_mtop = 2.500000;
#line 1019 "BIFROST.instr"
  mcccurved_guide_13_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_13_0_nhslit = 1;
#line 1013 "BIFROST.instr"
  mcccurved_guide_13_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_13_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_13_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_13_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_13_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_13_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_13_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_13_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_13_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_13_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_13_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_13_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_13_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_13_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_13_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_13_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_13_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_13_0_reflect[0]='\0';
#line 24069 "BIFROST.c"

  SIG_MESSAGE("curved_guide_13_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1021 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1021 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1021 "BIFROST.instr"
    (0)*DEG2RAD);
#line 24079 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_12_0, mcrotacurved_guide_13_0);
  rot_transpose(mcrotacurved_guide_12_0, mctr1);
  rot_mul(mcrotacurved_guide_13_0, mctr1, mcrotrcurved_guide_13_0);
  mctc1 = coords_set(
#line 1020 "BIFROST.instr"
    7.57345916228e-10,
#line 1020 "BIFROST.instr"
    0,
#line 1020 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 24090 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_12_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_13_0 = coords_add(mcposacurved_guide_12_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_12_0, mcposacurved_guide_13_0);
  mcposrcurved_guide_13_0 = rot_apply(mcrotacurved_guide_13_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_13_0", mcposacurved_guide_13_0, mcrotacurved_guide_13_0)
  mccomp_posa[39] = mcposacurved_guide_13_0;
  mccomp_posr[39] = mcposrcurved_guide_13_0;
  mcNCounter[39]  = mcPCounter[39] = mcP2Counter[39] = 0;
  mcAbsorbProp[39]= 0;
    /* Component curved_guide_14_0. */
  /* Setting parameters for component curved_guide_14_0. */
  SIG_MESSAGE("curved_guide_14_0 (Init:SetPar)");
#line 1025 "BIFROST.instr"
  mcccurved_guide_14_0_w1 = 0.029534;
#line 1026 "BIFROST.instr"
  mcccurved_guide_14_0_h1 = 0.047514;
#line 1025 "BIFROST.instr"
  mcccurved_guide_14_0_w2 = 0.029534;
#line 1026 "BIFROST.instr"
  mcccurved_guide_14_0_h2 = 0.047514;
#line 1024 "BIFROST.instr"
  mcccurved_guide_14_0_l = 0.5;
#line 1027 "BIFROST.instr"
  mcccurved_guide_14_0_R0 = 0.990000;
#line 1027 "BIFROST.instr"
  mcccurved_guide_14_0_Qc = 0.021700;
#line 1028 "BIFROST.instr"
  mcccurved_guide_14_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_14_0_m = 1.0;
#line 1028 "BIFROST.instr"
  mcccurved_guide_14_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_14_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_14_0_d = 0.0005;
#line 1029 "BIFROST.instr"
  mcccurved_guide_14_0_mleft = 3.000000;
#line 1029 "BIFROST.instr"
  mcccurved_guide_14_0_mright = 3.500000;
#line 1030 "BIFROST.instr"
  mcccurved_guide_14_0_mtop = 2.500000;
#line 1030 "BIFROST.instr"
  mcccurved_guide_14_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_14_0_nhslit = 1;
#line 1024 "BIFROST.instr"
  mcccurved_guide_14_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_14_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_14_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_14_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_14_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_14_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_14_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_14_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_14_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_14_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_14_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_14_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_14_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_14_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_14_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_14_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_14_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_14_0_reflect[0]='\0';
#line 24172 "BIFROST.c"

  SIG_MESSAGE("curved_guide_14_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1032 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1032 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1032 "BIFROST.instr"
    (0)*DEG2RAD);
#line 24182 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_13_0, mcrotacurved_guide_14_0);
  rot_transpose(mcrotacurved_guide_13_0, mctr1);
  rot_mul(mcrotacurved_guide_14_0, mctr1, mcrotrcurved_guide_14_0);
  mctc1 = coords_set(
#line 1031 "BIFROST.instr"
    7.57345916228e-10,
#line 1031 "BIFROST.instr"
    0,
#line 1031 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 24193 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_13_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_14_0 = coords_add(mcposacurved_guide_13_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_13_0, mcposacurved_guide_14_0);
  mcposrcurved_guide_14_0 = rot_apply(mcrotacurved_guide_14_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_14_0", mcposacurved_guide_14_0, mcrotacurved_guide_14_0)
  mccomp_posa[40] = mcposacurved_guide_14_0;
  mccomp_posr[40] = mcposrcurved_guide_14_0;
  mcNCounter[40]  = mcPCounter[40] = mcP2Counter[40] = 0;
  mcAbsorbProp[40]= 0;
    /* Component curved_guide_15_0. */
  /* Setting parameters for component curved_guide_15_0. */
  SIG_MESSAGE("curved_guide_15_0 (Init:SetPar)");
#line 1036 "BIFROST.instr"
  mcccurved_guide_15_0_w1 = 0.029534;
#line 1037 "BIFROST.instr"
  mcccurved_guide_15_0_h1 = 0.047514;
#line 1036 "BIFROST.instr"
  mcccurved_guide_15_0_w2 = 0.029534;
#line 1037 "BIFROST.instr"
  mcccurved_guide_15_0_h2 = 0.047514;
#line 1035 "BIFROST.instr"
  mcccurved_guide_15_0_l = 0.5;
#line 1038 "BIFROST.instr"
  mcccurved_guide_15_0_R0 = 0.990000;
#line 1038 "BIFROST.instr"
  mcccurved_guide_15_0_Qc = 0.021700;
#line 1039 "BIFROST.instr"
  mcccurved_guide_15_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_15_0_m = 1.0;
#line 1039 "BIFROST.instr"
  mcccurved_guide_15_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_15_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_15_0_d = 0.0005;
#line 1040 "BIFROST.instr"
  mcccurved_guide_15_0_mleft = 3.000000;
#line 1040 "BIFROST.instr"
  mcccurved_guide_15_0_mright = 3.500000;
#line 1041 "BIFROST.instr"
  mcccurved_guide_15_0_mtop = 2.500000;
#line 1041 "BIFROST.instr"
  mcccurved_guide_15_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_15_0_nhslit = 1;
#line 1035 "BIFROST.instr"
  mcccurved_guide_15_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_15_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_15_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_15_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_15_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_15_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_15_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_15_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_15_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_15_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_15_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_15_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_15_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_15_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_15_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_15_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_15_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_15_0_reflect[0]='\0';
#line 24275 "BIFROST.c"

  SIG_MESSAGE("curved_guide_15_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1043 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1043 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1043 "BIFROST.instr"
    (0)*DEG2RAD);
#line 24285 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_14_0, mcrotacurved_guide_15_0);
  rot_transpose(mcrotacurved_guide_14_0, mctr1);
  rot_mul(mcrotacurved_guide_15_0, mctr1, mcrotrcurved_guide_15_0);
  mctc1 = coords_set(
#line 1042 "BIFROST.instr"
    7.57345916228e-10,
#line 1042 "BIFROST.instr"
    0,
#line 1042 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 24296 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_14_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_15_0 = coords_add(mcposacurved_guide_14_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_14_0, mcposacurved_guide_15_0);
  mcposrcurved_guide_15_0 = rot_apply(mcrotacurved_guide_15_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_15_0", mcposacurved_guide_15_0, mcrotacurved_guide_15_0)
  mccomp_posa[41] = mcposacurved_guide_15_0;
  mccomp_posr[41] = mcposrcurved_guide_15_0;
  mcNCounter[41]  = mcPCounter[41] = mcP2Counter[41] = 0;
  mcAbsorbProp[41]= 0;
    /* Component curved_guide_16_0. */
  /* Setting parameters for component curved_guide_16_0. */
  SIG_MESSAGE("curved_guide_16_0 (Init:SetPar)");
#line 1047 "BIFROST.instr"
  mcccurved_guide_16_0_w1 = 0.029534;
#line 1048 "BIFROST.instr"
  mcccurved_guide_16_0_h1 = 0.047514;
#line 1047 "BIFROST.instr"
  mcccurved_guide_16_0_w2 = 0.029534;
#line 1048 "BIFROST.instr"
  mcccurved_guide_16_0_h2 = 0.047514;
#line 1046 "BIFROST.instr"
  mcccurved_guide_16_0_l = 0.5;
#line 1049 "BIFROST.instr"
  mcccurved_guide_16_0_R0 = 0.990000;
#line 1049 "BIFROST.instr"
  mcccurved_guide_16_0_Qc = 0.021700;
#line 1050 "BIFROST.instr"
  mcccurved_guide_16_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_16_0_m = 1.0;
#line 1050 "BIFROST.instr"
  mcccurved_guide_16_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_16_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_16_0_d = 0.0005;
#line 1051 "BIFROST.instr"
  mcccurved_guide_16_0_mleft = 3.000000;
#line 1051 "BIFROST.instr"
  mcccurved_guide_16_0_mright = 3.500000;
#line 1052 "BIFROST.instr"
  mcccurved_guide_16_0_mtop = 2.500000;
#line 1052 "BIFROST.instr"
  mcccurved_guide_16_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_16_0_nhslit = 1;
#line 1046 "BIFROST.instr"
  mcccurved_guide_16_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_16_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_16_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_16_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_16_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_16_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_16_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_16_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_16_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_16_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_16_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_16_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_16_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_16_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_16_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_16_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_16_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_16_0_reflect[0]='\0';
#line 24378 "BIFROST.c"

  SIG_MESSAGE("curved_guide_16_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1054 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1054 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1054 "BIFROST.instr"
    (0)*DEG2RAD);
#line 24388 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_15_0, mcrotacurved_guide_16_0);
  rot_transpose(mcrotacurved_guide_15_0, mctr1);
  rot_mul(mcrotacurved_guide_16_0, mctr1, mcrotrcurved_guide_16_0);
  mctc1 = coords_set(
#line 1053 "BIFROST.instr"
    7.57345916228e-10,
#line 1053 "BIFROST.instr"
    0,
#line 1053 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 24399 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_15_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_16_0 = coords_add(mcposacurved_guide_15_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_15_0, mcposacurved_guide_16_0);
  mcposrcurved_guide_16_0 = rot_apply(mcrotacurved_guide_16_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_16_0", mcposacurved_guide_16_0, mcrotacurved_guide_16_0)
  mccomp_posa[42] = mcposacurved_guide_16_0;
  mccomp_posr[42] = mcposrcurved_guide_16_0;
  mcNCounter[42]  = mcPCounter[42] = mcP2Counter[42] = 0;
  mcAbsorbProp[42]= 0;
    /* Component curved_guide_17_0. */
  /* Setting parameters for component curved_guide_17_0. */
  SIG_MESSAGE("curved_guide_17_0 (Init:SetPar)");
#line 1058 "BIFROST.instr"
  mcccurved_guide_17_0_w1 = 0.029534;
#line 1059 "BIFROST.instr"
  mcccurved_guide_17_0_h1 = 0.047514;
#line 1058 "BIFROST.instr"
  mcccurved_guide_17_0_w2 = 0.029534;
#line 1059 "BIFROST.instr"
  mcccurved_guide_17_0_h2 = 0.047514;
#line 1057 "BIFROST.instr"
  mcccurved_guide_17_0_l = 0.5;
#line 1060 "BIFROST.instr"
  mcccurved_guide_17_0_R0 = 0.990000;
#line 1060 "BIFROST.instr"
  mcccurved_guide_17_0_Qc = 0.021700;
#line 1061 "BIFROST.instr"
  mcccurved_guide_17_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_17_0_m = 1.0;
#line 1061 "BIFROST.instr"
  mcccurved_guide_17_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_17_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_17_0_d = 0.0005;
#line 1062 "BIFROST.instr"
  mcccurved_guide_17_0_mleft = 3.000000;
#line 1062 "BIFROST.instr"
  mcccurved_guide_17_0_mright = 3.500000;
#line 1063 "BIFROST.instr"
  mcccurved_guide_17_0_mtop = 2.500000;
#line 1063 "BIFROST.instr"
  mcccurved_guide_17_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_17_0_nhslit = 1;
#line 1057 "BIFROST.instr"
  mcccurved_guide_17_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_17_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_17_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_17_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_17_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_17_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_17_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_17_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_17_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_17_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_17_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_17_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_17_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_17_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_17_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_17_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_17_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_17_0_reflect[0]='\0';
#line 24481 "BIFROST.c"

  SIG_MESSAGE("curved_guide_17_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1065 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1065 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1065 "BIFROST.instr"
    (0)*DEG2RAD);
#line 24491 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_16_0, mcrotacurved_guide_17_0);
  rot_transpose(mcrotacurved_guide_16_0, mctr1);
  rot_mul(mcrotacurved_guide_17_0, mctr1, mcrotrcurved_guide_17_0);
  mctc1 = coords_set(
#line 1064 "BIFROST.instr"
    7.57345916228e-10,
#line 1064 "BIFROST.instr"
    0,
#line 1064 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 24502 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_16_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_17_0 = coords_add(mcposacurved_guide_16_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_16_0, mcposacurved_guide_17_0);
  mcposrcurved_guide_17_0 = rot_apply(mcrotacurved_guide_17_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_17_0", mcposacurved_guide_17_0, mcrotacurved_guide_17_0)
  mccomp_posa[43] = mcposacurved_guide_17_0;
  mccomp_posr[43] = mcposrcurved_guide_17_0;
  mcNCounter[43]  = mcPCounter[43] = mcP2Counter[43] = 0;
  mcAbsorbProp[43]= 0;
    /* Component curved_guide_18_beforeChopper. */
  /* Setting parameters for component curved_guide_18_beforeChopper. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (Init:SetPar)");
#line 1074 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_w1 = 0.029534;
#line 1075 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_h1 = 0.047514;
#line 1074 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_w2 = 0.029534;
#line 1075 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_h2 = 0.047514;
#line 1073 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_l = 0.07;
#line 1076 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_R0 = 0.990000;
#line 1076 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_Qc = 0.021700;
#line 1077 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_m = 1.0;
#line 1077 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_d = 0.0005;
#line 1078 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_mleft = 3.000000;
#line 1078 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_mright = 3.500000;
#line 1079 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_mtop = 2.500000;
#line 1079 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_nhslit = 1;
#line 1073 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_18_beforeChopper_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_18_beforeChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_18_beforeChopper_reflect[0]='\0';
#line 24584 "BIFROST.c"

  SIG_MESSAGE("curved_guide_18_beforeChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1081 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1081 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1081 "BIFROST.instr"
    (0)*DEG2RAD);
#line 24594 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_17_0, mcrotacurved_guide_18_beforeChopper);
  rot_transpose(mcrotacurved_guide_17_0, mctr1);
  rot_mul(mcrotacurved_guide_18_beforeChopper, mctr1, mcrotrcurved_guide_18_beforeChopper);
  mctc1 = coords_set(
#line 1080 "BIFROST.instr"
    7.57345916228e-10,
#line 1080 "BIFROST.instr"
    0,
#line 1080 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 24605 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_17_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_18_beforeChopper = coords_add(mcposacurved_guide_17_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_17_0, mcposacurved_guide_18_beforeChopper);
  mcposrcurved_guide_18_beforeChopper = rot_apply(mcrotacurved_guide_18_beforeChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_18_beforeChopper", mcposacurved_guide_18_beforeChopper, mcrotacurved_guide_18_beforeChopper)
  mccomp_posa[44] = mcposacurved_guide_18_beforeChopper;
  mccomp_posr[44] = mcposrcurved_guide_18_beforeChopper;
  mcNCounter[44]  = mcPCounter[44] = mcP2Counter[44] = 0;
  mcAbsorbProp[44]= 0;
    /* Component L_monBeforeFOC2. */
  /* Setting parameters for component L_monBeforeFOC2. */
  SIG_MESSAGE("L_monBeforeFOC2 (Init:SetPar)");
#line 1085 "BIFROST.instr"
  if("L_monBeforeFOC2.dat") strncpy(mccL_monBeforeFOC2_filename, "L_monBeforeFOC2.dat" ? "L_monBeforeFOC2.dat" : "", 16384); else mccL_monBeforeFOC2_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC2_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC2_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC2_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeFOC2_ymax = 0.05;
#line 1085 "BIFROST.instr"
  mccL_monBeforeFOC2_xwidth = 0.2;
#line 1086 "BIFROST.instr"
  mccL_monBeforeFOC2_yheight = 0.2;
#line 1086 "BIFROST.instr"
  mccL_monBeforeFOC2_Lmin = lambda_0 / 2.0;
#line 1086 "BIFROST.instr"
  mccL_monBeforeFOC2_Lmax = lambda_1 * 2.0;
#line 1085 "BIFROST.instr"
  mccL_monBeforeFOC2_restore_neutron = 1;
#line 24639 "BIFROST.c"

  SIG_MESSAGE("L_monBeforeFOC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1088 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1088 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1088 "BIFROST.instr"
    (0)*DEG2RAD);
#line 24649 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_18_beforeChopper, mcrotaL_monBeforeFOC2);
  rot_transpose(mcrotacurved_guide_18_beforeChopper, mctr1);
  rot_mul(mcrotaL_monBeforeFOC2, mctr1, mcrotrL_monBeforeFOC2);
  mctc1 = coords_set(
#line 1087 "BIFROST.instr"
    0,
#line 1087 "BIFROST.instr"
    0,
#line 1087 "BIFROST.instr"
    0.07 + u);
#line 24660 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_18_beforeChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monBeforeFOC2 = coords_add(mcposacurved_guide_18_beforeChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_18_beforeChopper, mcposaL_monBeforeFOC2);
  mcposrL_monBeforeFOC2 = rot_apply(mcrotaL_monBeforeFOC2, mctc1);
  mcDEBUG_COMPONENT("L_monBeforeFOC2", mcposaL_monBeforeFOC2, mcrotaL_monBeforeFOC2)
  mccomp_posa[45] = mcposaL_monBeforeFOC2;
  mccomp_posr[45] = mcposrL_monBeforeFOC2;
  mcNCounter[45]  = mcPCounter[45] = mcP2Counter[45] = 0;
  mcAbsorbProp[45]= 0;
    /* Component ToFBeforeFOC2. */
  /* Setting parameters for component ToFBeforeFOC2. */
  SIG_MESSAGE("ToFBeforeFOC2 (Init:SetPar)");
#line 1091 "BIFROST.instr"
  if("ToFBeforeFOC2.dat") strncpy(mccToFBeforeFOC2_filename, "ToFBeforeFOC2.dat" ? "ToFBeforeFOC2.dat" : "", 16384); else mccToFBeforeFOC2_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFBeforeFOC2_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeFOC2_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeFOC2_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeFOC2_ymax = 0.05;
#line 1091 "BIFROST.instr"
  mccToFBeforeFOC2_xwidth = 0.2;
#line 1092 "BIFROST.instr"
  mccToFBeforeFOC2_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFBeforeFOC2_tmin = 0;
#line 1092 "BIFROST.instr"
  mccToFBeforeFOC2_tmax = 2e4;
#line 47 "BIFROST.instr"
  mccToFBeforeFOC2_dt = 1.0;
#line 1091 "BIFROST.instr"
  mccToFBeforeFOC2_restore_neutron = 1;
#line 24696 "BIFROST.c"

  SIG_MESSAGE("ToFBeforeFOC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24703 "BIFROST.c"
  rot_mul(mctr1, mcrotaL_monBeforeFOC2, mcrotaToFBeforeFOC2);
  rot_transpose(mcrotaL_monBeforeFOC2, mctr1);
  rot_mul(mcrotaToFBeforeFOC2, mctr1, mcrotrToFBeforeFOC2);
  mctc1 = coords_set(
#line 1093 "BIFROST.instr"
    0,
#line 1093 "BIFROST.instr"
    0,
#line 1093 "BIFROST.instr"
    u);
#line 24714 "BIFROST.c"
  rot_transpose(mcrotaL_monBeforeFOC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFBeforeFOC2 = coords_add(mcposaL_monBeforeFOC2, mctc2);
  mctc1 = coords_sub(mcposaL_monBeforeFOC2, mcposaToFBeforeFOC2);
  mcposrToFBeforeFOC2 = rot_apply(mcrotaToFBeforeFOC2, mctc1);
  mcDEBUG_COMPONENT("ToFBeforeFOC2", mcposaToFBeforeFOC2, mcrotaToFBeforeFOC2)
  mccomp_posa[46] = mcposaToFBeforeFOC2;
  mccomp_posr[46] = mcposrToFBeforeFOC2;
  mcNCounter[46]  = mcPCounter[46] = mcP2Counter[46] = 0;
  mcAbsorbProp[46]= 0;
    /* Component PSD_beforeFOC2. */
  /* Setting parameters for component PSD_beforeFOC2. */
  SIG_MESSAGE("PSD_beforeFOC2 (Init:SetPar)");
#line 1096 "BIFROST.instr"
  if("PSD_beforeFOC2.dat") strncpy(mccPSD_beforeFOC2_filename, "PSD_beforeFOC2.dat" ? "PSD_beforeFOC2.dat" : "", 16384); else mccPSD_beforeFOC2_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC2_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC2_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC2_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_beforeFOC2_ymax = 0.05;
#line 1097 "BIFROST.instr"
  mccPSD_beforeFOC2_xwidth = 0.2;
#line 1097 "BIFROST.instr"
  mccPSD_beforeFOC2_yheight = 0.2;
#line 1096 "BIFROST.instr"
  mccPSD_beforeFOC2_restore_neutron = 1;
#line 24744 "BIFROST.c"

  SIG_MESSAGE("PSD_beforeFOC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24751 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFBeforeFOC2, mcrotaPSD_beforeFOC2);
  rot_transpose(mcrotaToFBeforeFOC2, mctr1);
  rot_mul(mcrotaPSD_beforeFOC2, mctr1, mcrotrPSD_beforeFOC2);
  mctc1 = coords_set(
#line 1098 "BIFROST.instr"
    0,
#line 1098 "BIFROST.instr"
    0,
#line 1098 "BIFROST.instr"
    u);
#line 24762 "BIFROST.c"
  rot_transpose(mcrotaToFBeforeFOC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_beforeFOC2 = coords_add(mcposaToFBeforeFOC2, mctc2);
  mctc1 = coords_sub(mcposaToFBeforeFOC2, mcposaPSD_beforeFOC2);
  mcposrPSD_beforeFOC2 = rot_apply(mcrotaPSD_beforeFOC2, mctc1);
  mcDEBUG_COMPONENT("PSD_beforeFOC2", mcposaPSD_beforeFOC2, mcrotaPSD_beforeFOC2)
  mccomp_posa[47] = mcposaPSD_beforeFOC2;
  mccomp_posr[47] = mcposrPSD_beforeFOC2;
  mcNCounter[47]  = mcPCounter[47] = mcP2Counter[47] = 0;
  mcAbsorbProp[47]= 0;
    /* Component FOC2. */
  /* Setting parameters for component FOC2. */
  SIG_MESSAGE("FOC2 (Init:SetPar)");
#line 1101 "BIFROST.instr"
  mccFOC2_theta_0 = mcipFOCopen2;
#line 1101 "BIFROST.instr"
  mccFOC2_radius = 0.35;
#line 1101 "BIFROST.instr"
  mccFOC2_yheight = 0.052;
#line 1101 "BIFROST.instr"
  mccFOC2_nu = 14;
#line 1101 "BIFROST.instr"
  mccFOC2_nslit = 1;
#line 56 "BIFROST.instr"
  mccFOC2_jitter = 0;
#line 56 "BIFROST.instr"
  mccFOC2_delay = 0;
#line 56 "BIFROST.instr"
  mccFOC2_isfirst = 0;
#line 56 "BIFROST.instr"
  mccFOC2_n_pulse = 1;
#line 56 "BIFROST.instr"
  mccFOC2_abs_out = 1;
#line 1102 "BIFROST.instr"
  mccFOC2_phase = chopFrameOverlap2PhaseOffset;
#line 56 "BIFROST.instr"
  mccFOC2_xwidth = 0;
#line 56 "BIFROST.instr"
  mccFOC2_verbose = 0;
#line 24802 "BIFROST.c"

  SIG_MESSAGE("FOC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1104 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1104 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1104 "BIFROST.instr"
    (u)*DEG2RAD);
#line 24812 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_beforeFOC2, mcrotaFOC2);
  rot_transpose(mcrotaPSD_beforeFOC2, mctr1);
  rot_mul(mcrotaFOC2, mctr1, mcrotrFOC2);
  mctc1 = coords_set(
#line 1103 "BIFROST.instr"
    0,
#line 1103 "BIFROST.instr"
    0,
#line 1103 "BIFROST.instr"
    0.02);
#line 24823 "BIFROST.c"
  rot_transpose(mcrotaPSD_beforeFOC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaFOC2 = coords_add(mcposaPSD_beforeFOC2, mctc2);
  mctc1 = coords_sub(mcposaPSD_beforeFOC2, mcposaFOC2);
  mcposrFOC2 = rot_apply(mcrotaFOC2, mctc1);
  mcDEBUG_COMPONENT("FOC2", mcposaFOC2, mcrotaFOC2)
  mccomp_posa[48] = mcposaFOC2;
  mccomp_posr[48] = mcposrFOC2;
  mcNCounter[48]  = mcPCounter[48] = mcP2Counter[48] = 0;
  mcAbsorbProp[48]= 0;
    /* Component PSD_afterFOC2. */
  /* Setting parameters for component PSD_afterFOC2. */
  SIG_MESSAGE("PSD_afterFOC2 (Init:SetPar)");
#line 1107 "BIFROST.instr"
  if("PSD_afterFOC2.dat") strncpy(mccPSD_afterFOC2_filename, "PSD_afterFOC2.dat" ? "PSD_afterFOC2.dat" : "", 16384); else mccPSD_afterFOC2_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_afterFOC2_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_afterFOC2_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_afterFOC2_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_afterFOC2_ymax = 0.05;
#line 1108 "BIFROST.instr"
  mccPSD_afterFOC2_xwidth = 0.2;
#line 1108 "BIFROST.instr"
  mccPSD_afterFOC2_yheight = 0.2;
#line 1107 "BIFROST.instr"
  mccPSD_afterFOC2_restore_neutron = 1;
#line 24853 "BIFROST.c"

  SIG_MESSAGE("PSD_afterFOC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24860 "BIFROST.c"
  rot_mul(mctr1, mcrotaFOC2, mcrotaPSD_afterFOC2);
  rot_transpose(mcrotaFOC2, mctr1);
  rot_mul(mcrotaPSD_afterFOC2, mctr1, mcrotrPSD_afterFOC2);
  mctc1 = coords_set(
#line 1109 "BIFROST.instr"
    0,
#line 1109 "BIFROST.instr"
    0,
#line 1109 "BIFROST.instr"
    u);
#line 24871 "BIFROST.c"
  rot_transpose(mcrotaFOC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_afterFOC2 = coords_add(mcposaFOC2, mctc2);
  mctc1 = coords_sub(mcposaFOC2, mcposaPSD_afterFOC2);
  mcposrPSD_afterFOC2 = rot_apply(mcrotaPSD_afterFOC2, mctc1);
  mcDEBUG_COMPONENT("PSD_afterFOC2", mcposaPSD_afterFOC2, mcrotaPSD_afterFOC2)
  mccomp_posa[49] = mcposaPSD_afterFOC2;
  mccomp_posr[49] = mcposrPSD_afterFOC2;
  mcNCounter[49]  = mcPCounter[49] = mcP2Counter[49] = 0;
  mcAbsorbProp[49]= 0;
    /* Component ToFAfterFOC2. */
  /* Setting parameters for component ToFAfterFOC2. */
  SIG_MESSAGE("ToFAfterFOC2 (Init:SetPar)");
#line 1112 "BIFROST.instr"
  if("ToFAfterFOC2.dat") strncpy(mccToFAfterFOC2_filename, "ToFAfterFOC2.dat" ? "ToFAfterFOC2.dat" : "", 16384); else mccToFAfterFOC2_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFAfterFOC2_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterFOC2_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFAfterFOC2_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterFOC2_ymax = 0.05;
#line 1112 "BIFROST.instr"
  mccToFAfterFOC2_xwidth = 0.2;
#line 1113 "BIFROST.instr"
  mccToFAfterFOC2_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFAfterFOC2_tmin = 0;
#line 1113 "BIFROST.instr"
  mccToFAfterFOC2_tmax = 2e4;
#line 47 "BIFROST.instr"
  mccToFAfterFOC2_dt = 1.0;
#line 1112 "BIFROST.instr"
  mccToFAfterFOC2_restore_neutron = 1;
#line 24907 "BIFROST.c"

  SIG_MESSAGE("ToFAfterFOC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24914 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_afterFOC2, mcrotaToFAfterFOC2);
  rot_transpose(mcrotaPSD_afterFOC2, mctr1);
  rot_mul(mcrotaToFAfterFOC2, mctr1, mcrotrToFAfterFOC2);
  mctc1 = coords_set(
#line 1114 "BIFROST.instr"
    0,
#line 1114 "BIFROST.instr"
    0,
#line 1114 "BIFROST.instr"
    u);
#line 24925 "BIFROST.c"
  rot_transpose(mcrotaPSD_afterFOC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFAfterFOC2 = coords_add(mcposaPSD_afterFOC2, mctc2);
  mctc1 = coords_sub(mcposaPSD_afterFOC2, mcposaToFAfterFOC2);
  mcposrToFAfterFOC2 = rot_apply(mcrotaToFAfterFOC2, mctc1);
  mcDEBUG_COMPONENT("ToFAfterFOC2", mcposaToFAfterFOC2, mcrotaToFAfterFOC2)
  mccomp_posa[50] = mcposaToFAfterFOC2;
  mccomp_posr[50] = mcposrToFAfterFOC2;
  mcNCounter[50]  = mcPCounter[50] = mcP2Counter[50] = 0;
  mcAbsorbProp[50]= 0;
    /* Component L_monAfterFOC2. */
  /* Setting parameters for component L_monAfterFOC2. */
  SIG_MESSAGE("L_monAfterFOC2 (Init:SetPar)");
#line 1117 "BIFROST.instr"
  if("L_monAfterFOC2.dat") strncpy(mccL_monAfterFOC2_filename, "L_monAfterFOC2.dat" ? "L_monAfterFOC2.dat" : "", 16384); else mccL_monAfterFOC2_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monAfterFOC2_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterFOC2_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterFOC2_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterFOC2_ymax = 0.05;
#line 1117 "BIFROST.instr"
  mccL_monAfterFOC2_xwidth = 0.2;
#line 1118 "BIFROST.instr"
  mccL_monAfterFOC2_yheight = 0.2;
#line 1118 "BIFROST.instr"
  mccL_monAfterFOC2_Lmin = lambda_0 / 2.0;
#line 1118 "BIFROST.instr"
  mccL_monAfterFOC2_Lmax = lambda_1 * 2.0;
#line 1117 "BIFROST.instr"
  mccL_monAfterFOC2_restore_neutron = 1;
#line 24959 "BIFROST.c"

  SIG_MESSAGE("L_monAfterFOC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24966 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFAfterFOC2, mcrotaL_monAfterFOC2);
  rot_transpose(mcrotaToFAfterFOC2, mctr1);
  rot_mul(mcrotaL_monAfterFOC2, mctr1, mcrotrL_monAfterFOC2);
  mctc1 = coords_set(
#line 1119 "BIFROST.instr"
    0,
#line 1119 "BIFROST.instr"
    0,
#line 1119 "BIFROST.instr"
    u);
#line 24977 "BIFROST.c"
  rot_transpose(mcrotaToFAfterFOC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monAfterFOC2 = coords_add(mcposaToFAfterFOC2, mctc2);
  mctc1 = coords_sub(mcposaToFAfterFOC2, mcposaL_monAfterFOC2);
  mcposrL_monAfterFOC2 = rot_apply(mcrotaL_monAfterFOC2, mctc1);
  mcDEBUG_COMPONENT("L_monAfterFOC2", mcposaL_monAfterFOC2, mcrotaL_monAfterFOC2)
  mccomp_posa[51] = mcposaL_monAfterFOC2;
  mccomp_posr[51] = mcposrL_monAfterFOC2;
  mcNCounter[51]  = mcPCounter[51] = mcP2Counter[51] = 0;
  mcAbsorbProp[51]= 0;
    /* Component curved_guide_18_afterChopper. */
  /* Setting parameters for component curved_guide_18_afterChopper. */
  SIG_MESSAGE("curved_guide_18_afterChopper (Init:SetPar)");
#line 1124 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_w1 = 0.029534;
#line 1125 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_h1 = 0.047514;
#line 1124 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_w2 = 0.029534;
#line 1125 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_h2 = 0.047514;
#line 1123 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_l = 0.39;
#line 1126 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_R0 = 0.990000;
#line 1126 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_Qc = 0.021700;
#line 1127 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_m = 1.0;
#line 1127 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_d = 0.0005;
#line 1128 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_mleft = 3.000000;
#line 1128 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_mright = 3.500000;
#line 1129 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_mtop = 2.500000;
#line 1129 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_nhslit = 1;
#line 1123 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_18_afterChopper_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_18_afterChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_18_afterChopper_reflect[0]='\0';
#line 25059 "BIFROST.c"

  SIG_MESSAGE("curved_guide_18_afterChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1131 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1131 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1131 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25069 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_18_beforeChopper, mcrotacurved_guide_18_afterChopper);
  rot_transpose(mcrotaL_monAfterFOC2, mctr1);
  rot_mul(mcrotacurved_guide_18_afterChopper, mctr1, mcrotrcurved_guide_18_afterChopper);
  mctc1 = coords_set(
#line 1130 "BIFROST.instr"
    0,
#line 1130 "BIFROST.instr"
    0,
#line 1130 "BIFROST.instr"
    0.11);
#line 25080 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_18_beforeChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_18_afterChopper = coords_add(mcposacurved_guide_18_beforeChopper, mctc2);
  mctc1 = coords_sub(mcposaL_monAfterFOC2, mcposacurved_guide_18_afterChopper);
  mcposrcurved_guide_18_afterChopper = rot_apply(mcrotacurved_guide_18_afterChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_18_afterChopper", mcposacurved_guide_18_afterChopper, mcrotacurved_guide_18_afterChopper)
  mccomp_posa[52] = mcposacurved_guide_18_afterChopper;
  mccomp_posr[52] = mcposrcurved_guide_18_afterChopper;
  mcNCounter[52]  = mcPCounter[52] = mcP2Counter[52] = 0;
  mcAbsorbProp[52]= 0;
    /* Component curved_guide_19_0. */
  /* Setting parameters for component curved_guide_19_0. */
  SIG_MESSAGE("curved_guide_19_0 (Init:SetPar)");
#line 1135 "BIFROST.instr"
  mcccurved_guide_19_0_w1 = 0.029534;
#line 1136 "BIFROST.instr"
  mcccurved_guide_19_0_h1 = 0.047514;
#line 1135 "BIFROST.instr"
  mcccurved_guide_19_0_w2 = 0.029534;
#line 1136 "BIFROST.instr"
  mcccurved_guide_19_0_h2 = 0.047514;
#line 1134 "BIFROST.instr"
  mcccurved_guide_19_0_l = 0.5;
#line 1137 "BIFROST.instr"
  mcccurved_guide_19_0_R0 = 0.990000;
#line 1137 "BIFROST.instr"
  mcccurved_guide_19_0_Qc = 0.021700;
#line 1138 "BIFROST.instr"
  mcccurved_guide_19_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_19_0_m = 1.0;
#line 1138 "BIFROST.instr"
  mcccurved_guide_19_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_19_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_19_0_d = 0.0005;
#line 1139 "BIFROST.instr"
  mcccurved_guide_19_0_mleft = 3.000000;
#line 1139 "BIFROST.instr"
  mcccurved_guide_19_0_mright = 3.500000;
#line 1140 "BIFROST.instr"
  mcccurved_guide_19_0_mtop = 2.500000;
#line 1140 "BIFROST.instr"
  mcccurved_guide_19_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_19_0_nhslit = 1;
#line 1134 "BIFROST.instr"
  mcccurved_guide_19_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_19_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_19_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_19_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_19_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_19_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_19_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_19_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_19_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_19_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_19_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_19_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_19_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_19_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_19_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_19_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_19_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_19_0_reflect[0]='\0';
#line 25162 "BIFROST.c"

  SIG_MESSAGE("curved_guide_19_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1142 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1142 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1142 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25172 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_18_afterChopper, mcrotacurved_guide_19_0);
  rot_transpose(mcrotacurved_guide_18_afterChopper, mctr1);
  rot_mul(mcrotacurved_guide_19_0, mctr1, mcrotrcurved_guide_19_0);
  mctc1 = coords_set(
#line 1141 "BIFROST.instr"
    7.57345916228e-10,
#line 1141 "BIFROST.instr"
    0,
#line 1141 "BIFROST.instr"
    0.39 + u);
#line 25183 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_18_afterChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_19_0 = coords_add(mcposacurved_guide_18_afterChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_18_afterChopper, mcposacurved_guide_19_0);
  mcposrcurved_guide_19_0 = rot_apply(mcrotacurved_guide_19_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_19_0", mcposacurved_guide_19_0, mcrotacurved_guide_19_0)
  mccomp_posa[53] = mcposacurved_guide_19_0;
  mccomp_posr[53] = mcposrcurved_guide_19_0;
  mcNCounter[53]  = mcPCounter[53] = mcP2Counter[53] = 0;
  mcAbsorbProp[53]= 0;
    /* Component curved_guide_20_0. */
  /* Setting parameters for component curved_guide_20_0. */
  SIG_MESSAGE("curved_guide_20_0 (Init:SetPar)");
#line 1146 "BIFROST.instr"
  mcccurved_guide_20_0_w1 = 0.029534;
#line 1147 "BIFROST.instr"
  mcccurved_guide_20_0_h1 = 0.047514;
#line 1146 "BIFROST.instr"
  mcccurved_guide_20_0_w2 = 0.029534;
#line 1147 "BIFROST.instr"
  mcccurved_guide_20_0_h2 = 0.047514;
#line 1145 "BIFROST.instr"
  mcccurved_guide_20_0_l = 0.5;
#line 1148 "BIFROST.instr"
  mcccurved_guide_20_0_R0 = 0.990000;
#line 1148 "BIFROST.instr"
  mcccurved_guide_20_0_Qc = 0.021700;
#line 1149 "BIFROST.instr"
  mcccurved_guide_20_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_20_0_m = 1.0;
#line 1149 "BIFROST.instr"
  mcccurved_guide_20_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_20_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_20_0_d = 0.0005;
#line 1150 "BIFROST.instr"
  mcccurved_guide_20_0_mleft = 3.000000;
#line 1150 "BIFROST.instr"
  mcccurved_guide_20_0_mright = 3.500000;
#line 1151 "BIFROST.instr"
  mcccurved_guide_20_0_mtop = 2.500000;
#line 1151 "BIFROST.instr"
  mcccurved_guide_20_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_20_0_nhslit = 1;
#line 1145 "BIFROST.instr"
  mcccurved_guide_20_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_20_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_20_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_20_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_20_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_20_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_20_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_20_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_20_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_20_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_20_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_20_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_20_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_20_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_20_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_20_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_20_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_20_0_reflect[0]='\0';
#line 25265 "BIFROST.c"

  SIG_MESSAGE("curved_guide_20_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1153 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1153 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1153 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25275 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_19_0, mcrotacurved_guide_20_0);
  rot_transpose(mcrotacurved_guide_19_0, mctr1);
  rot_mul(mcrotacurved_guide_20_0, mctr1, mcrotrcurved_guide_20_0);
  mctc1 = coords_set(
#line 1152 "BIFROST.instr"
    7.57345916228e-10,
#line 1152 "BIFROST.instr"
    0,
#line 1152 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 25286 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_19_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_20_0 = coords_add(mcposacurved_guide_19_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_19_0, mcposacurved_guide_20_0);
  mcposrcurved_guide_20_0 = rot_apply(mcrotacurved_guide_20_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_20_0", mcposacurved_guide_20_0, mcrotacurved_guide_20_0)
  mccomp_posa[54] = mcposacurved_guide_20_0;
  mccomp_posr[54] = mcposrcurved_guide_20_0;
  mcNCounter[54]  = mcPCounter[54] = mcP2Counter[54] = 0;
  mcAbsorbProp[54]= 0;
    /* Component curved_guide_21_0. */
  /* Setting parameters for component curved_guide_21_0. */
  SIG_MESSAGE("curved_guide_21_0 (Init:SetPar)");
#line 1157 "BIFROST.instr"
  mcccurved_guide_21_0_w1 = 0.029534;
#line 1158 "BIFROST.instr"
  mcccurved_guide_21_0_h1 = 0.047514;
#line 1157 "BIFROST.instr"
  mcccurved_guide_21_0_w2 = 0.029534;
#line 1158 "BIFROST.instr"
  mcccurved_guide_21_0_h2 = 0.047514;
#line 1156 "BIFROST.instr"
  mcccurved_guide_21_0_l = 0.5;
#line 1159 "BIFROST.instr"
  mcccurved_guide_21_0_R0 = 0.990000;
#line 1159 "BIFROST.instr"
  mcccurved_guide_21_0_Qc = 0.021700;
#line 1160 "BIFROST.instr"
  mcccurved_guide_21_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_21_0_m = 1.0;
#line 1160 "BIFROST.instr"
  mcccurved_guide_21_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_21_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_21_0_d = 0.0005;
#line 1161 "BIFROST.instr"
  mcccurved_guide_21_0_mleft = 3.000000;
#line 1161 "BIFROST.instr"
  mcccurved_guide_21_0_mright = 3.500000;
#line 1162 "BIFROST.instr"
  mcccurved_guide_21_0_mtop = 2.500000;
#line 1162 "BIFROST.instr"
  mcccurved_guide_21_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_21_0_nhslit = 1;
#line 1156 "BIFROST.instr"
  mcccurved_guide_21_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_21_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_21_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_21_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_21_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_21_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_21_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_21_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_21_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_21_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_21_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_21_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_21_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_21_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_21_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_21_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_21_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_21_0_reflect[0]='\0';
#line 25368 "BIFROST.c"

  SIG_MESSAGE("curved_guide_21_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1164 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1164 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1164 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25378 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_20_0, mcrotacurved_guide_21_0);
  rot_transpose(mcrotacurved_guide_20_0, mctr1);
  rot_mul(mcrotacurved_guide_21_0, mctr1, mcrotrcurved_guide_21_0);
  mctc1 = coords_set(
#line 1163 "BIFROST.instr"
    7.57345916228e-10,
#line 1163 "BIFROST.instr"
    0,
#line 1163 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 25389 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_20_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_21_0 = coords_add(mcposacurved_guide_20_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_20_0, mcposacurved_guide_21_0);
  mcposrcurved_guide_21_0 = rot_apply(mcrotacurved_guide_21_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_21_0", mcposacurved_guide_21_0, mcrotacurved_guide_21_0)
  mccomp_posa[55] = mcposacurved_guide_21_0;
  mccomp_posr[55] = mcposrcurved_guide_21_0;
  mcNCounter[55]  = mcPCounter[55] = mcP2Counter[55] = 0;
  mcAbsorbProp[55]= 0;
    /* Component curved_guide_22_0. */
  /* Setting parameters for component curved_guide_22_0. */
  SIG_MESSAGE("curved_guide_22_0 (Init:SetPar)");
#line 1168 "BIFROST.instr"
  mcccurved_guide_22_0_w1 = 0.029534;
#line 1169 "BIFROST.instr"
  mcccurved_guide_22_0_h1 = 0.047514;
#line 1168 "BIFROST.instr"
  mcccurved_guide_22_0_w2 = 0.029534;
#line 1169 "BIFROST.instr"
  mcccurved_guide_22_0_h2 = 0.047514;
#line 1167 "BIFROST.instr"
  mcccurved_guide_22_0_l = 0.5;
#line 1170 "BIFROST.instr"
  mcccurved_guide_22_0_R0 = 0.990000;
#line 1170 "BIFROST.instr"
  mcccurved_guide_22_0_Qc = 0.021700;
#line 1171 "BIFROST.instr"
  mcccurved_guide_22_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_22_0_m = 1.0;
#line 1171 "BIFROST.instr"
  mcccurved_guide_22_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_22_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_22_0_d = 0.0005;
#line 1172 "BIFROST.instr"
  mcccurved_guide_22_0_mleft = 3.000000;
#line 1172 "BIFROST.instr"
  mcccurved_guide_22_0_mright = 3.500000;
#line 1173 "BIFROST.instr"
  mcccurved_guide_22_0_mtop = 2.500000;
#line 1173 "BIFROST.instr"
  mcccurved_guide_22_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_22_0_nhslit = 1;
#line 1167 "BIFROST.instr"
  mcccurved_guide_22_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_22_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_22_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_22_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_22_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_22_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_22_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_22_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_22_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_22_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_22_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_22_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_22_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_22_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_22_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_22_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_22_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_22_0_reflect[0]='\0';
#line 25471 "BIFROST.c"

  SIG_MESSAGE("curved_guide_22_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1175 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1175 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1175 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25481 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_21_0, mcrotacurved_guide_22_0);
  rot_transpose(mcrotacurved_guide_21_0, mctr1);
  rot_mul(mcrotacurved_guide_22_0, mctr1, mcrotrcurved_guide_22_0);
  mctc1 = coords_set(
#line 1174 "BIFROST.instr"
    7.57345916228e-10,
#line 1174 "BIFROST.instr"
    0,
#line 1174 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 25492 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_21_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_22_0 = coords_add(mcposacurved_guide_21_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_21_0, mcposacurved_guide_22_0);
  mcposrcurved_guide_22_0 = rot_apply(mcrotacurved_guide_22_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_22_0", mcposacurved_guide_22_0, mcrotacurved_guide_22_0)
  mccomp_posa[56] = mcposacurved_guide_22_0;
  mccomp_posr[56] = mcposrcurved_guide_22_0;
  mcNCounter[56]  = mcPCounter[56] = mcP2Counter[56] = 0;
  mcAbsorbProp[56]= 0;
    /* Component curved_guide_23_0. */
  /* Setting parameters for component curved_guide_23_0. */
  SIG_MESSAGE("curved_guide_23_0 (Init:SetPar)");
#line 1179 "BIFROST.instr"
  mcccurved_guide_23_0_w1 = 0.029534;
#line 1180 "BIFROST.instr"
  mcccurved_guide_23_0_h1 = 0.047514;
#line 1179 "BIFROST.instr"
  mcccurved_guide_23_0_w2 = 0.029534;
#line 1180 "BIFROST.instr"
  mcccurved_guide_23_0_h2 = 0.047514;
#line 1178 "BIFROST.instr"
  mcccurved_guide_23_0_l = 0.5;
#line 1181 "BIFROST.instr"
  mcccurved_guide_23_0_R0 = 0.990000;
#line 1181 "BIFROST.instr"
  mcccurved_guide_23_0_Qc = 0.021700;
#line 1182 "BIFROST.instr"
  mcccurved_guide_23_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_23_0_m = 1.0;
#line 1182 "BIFROST.instr"
  mcccurved_guide_23_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_23_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_23_0_d = 0.0005;
#line 1183 "BIFROST.instr"
  mcccurved_guide_23_0_mleft = 3.000000;
#line 1183 "BIFROST.instr"
  mcccurved_guide_23_0_mright = 3.500000;
#line 1184 "BIFROST.instr"
  mcccurved_guide_23_0_mtop = 2.500000;
#line 1184 "BIFROST.instr"
  mcccurved_guide_23_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_23_0_nhslit = 1;
#line 1178 "BIFROST.instr"
  mcccurved_guide_23_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_23_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_23_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_23_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_23_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_23_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_23_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_23_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_23_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_23_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_23_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_23_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_23_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_23_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_23_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_23_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_23_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_23_0_reflect[0]='\0';
#line 25574 "BIFROST.c"

  SIG_MESSAGE("curved_guide_23_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1186 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1186 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1186 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25584 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_22_0, mcrotacurved_guide_23_0);
  rot_transpose(mcrotacurved_guide_22_0, mctr1);
  rot_mul(mcrotacurved_guide_23_0, mctr1, mcrotrcurved_guide_23_0);
  mctc1 = coords_set(
#line 1185 "BIFROST.instr"
    7.57345916228e-10,
#line 1185 "BIFROST.instr"
    0,
#line 1185 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 25595 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_22_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_23_0 = coords_add(mcposacurved_guide_22_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_22_0, mcposacurved_guide_23_0);
  mcposrcurved_guide_23_0 = rot_apply(mcrotacurved_guide_23_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_23_0", mcposacurved_guide_23_0, mcrotacurved_guide_23_0)
  mccomp_posa[57] = mcposacurved_guide_23_0;
  mccomp_posr[57] = mcposrcurved_guide_23_0;
  mcNCounter[57]  = mcPCounter[57] = mcP2Counter[57] = 0;
  mcAbsorbProp[57]= 0;
    /* Component curved_guide_24_0. */
  /* Setting parameters for component curved_guide_24_0. */
  SIG_MESSAGE("curved_guide_24_0 (Init:SetPar)");
#line 1190 "BIFROST.instr"
  mcccurved_guide_24_0_w1 = 0.029534;
#line 1191 "BIFROST.instr"
  mcccurved_guide_24_0_h1 = 0.047514;
#line 1190 "BIFROST.instr"
  mcccurved_guide_24_0_w2 = 0.029534;
#line 1191 "BIFROST.instr"
  mcccurved_guide_24_0_h2 = 0.047514;
#line 1189 "BIFROST.instr"
  mcccurved_guide_24_0_l = 0.5;
#line 1192 "BIFROST.instr"
  mcccurved_guide_24_0_R0 = 0.990000;
#line 1192 "BIFROST.instr"
  mcccurved_guide_24_0_Qc = 0.021700;
#line 1193 "BIFROST.instr"
  mcccurved_guide_24_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_24_0_m = 1.0;
#line 1193 "BIFROST.instr"
  mcccurved_guide_24_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_24_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_24_0_d = 0.0005;
#line 1194 "BIFROST.instr"
  mcccurved_guide_24_0_mleft = 3.000000;
#line 1194 "BIFROST.instr"
  mcccurved_guide_24_0_mright = 3.500000;
#line 1195 "BIFROST.instr"
  mcccurved_guide_24_0_mtop = 2.500000;
#line 1195 "BIFROST.instr"
  mcccurved_guide_24_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_24_0_nhslit = 1;
#line 1189 "BIFROST.instr"
  mcccurved_guide_24_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_24_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_24_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_24_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_24_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_24_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_24_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_24_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_24_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_24_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_24_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_24_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_24_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_24_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_24_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_24_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_24_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_24_0_reflect[0]='\0';
#line 25677 "BIFROST.c"

  SIG_MESSAGE("curved_guide_24_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1197 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1197 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1197 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25687 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_23_0, mcrotacurved_guide_24_0);
  rot_transpose(mcrotacurved_guide_23_0, mctr1);
  rot_mul(mcrotacurved_guide_24_0, mctr1, mcrotrcurved_guide_24_0);
  mctc1 = coords_set(
#line 1196 "BIFROST.instr"
    7.57345916228e-10,
#line 1196 "BIFROST.instr"
    0,
#line 1196 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 25698 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_23_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_24_0 = coords_add(mcposacurved_guide_23_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_23_0, mcposacurved_guide_24_0);
  mcposrcurved_guide_24_0 = rot_apply(mcrotacurved_guide_24_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_24_0", mcposacurved_guide_24_0, mcrotacurved_guide_24_0)
  mccomp_posa[58] = mcposacurved_guide_24_0;
  mccomp_posr[58] = mcposrcurved_guide_24_0;
  mcNCounter[58]  = mcPCounter[58] = mcP2Counter[58] = 0;
  mcAbsorbProp[58]= 0;
    /* Component curved_guide_25_0. */
  /* Setting parameters for component curved_guide_25_0. */
  SIG_MESSAGE("curved_guide_25_0 (Init:SetPar)");
#line 1201 "BIFROST.instr"
  mcccurved_guide_25_0_w1 = 0.029534;
#line 1202 "BIFROST.instr"
  mcccurved_guide_25_0_h1 = 0.047514;
#line 1201 "BIFROST.instr"
  mcccurved_guide_25_0_w2 = 0.029534;
#line 1202 "BIFROST.instr"
  mcccurved_guide_25_0_h2 = 0.047514;
#line 1200 "BIFROST.instr"
  mcccurved_guide_25_0_l = 0.5;
#line 1203 "BIFROST.instr"
  mcccurved_guide_25_0_R0 = 0.990000;
#line 1203 "BIFROST.instr"
  mcccurved_guide_25_0_Qc = 0.021700;
#line 1204 "BIFROST.instr"
  mcccurved_guide_25_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_25_0_m = 1.0;
#line 1204 "BIFROST.instr"
  mcccurved_guide_25_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_25_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_25_0_d = 0.0005;
#line 1205 "BIFROST.instr"
  mcccurved_guide_25_0_mleft = 3.000000;
#line 1205 "BIFROST.instr"
  mcccurved_guide_25_0_mright = 3.500000;
#line 1206 "BIFROST.instr"
  mcccurved_guide_25_0_mtop = 2.500000;
#line 1206 "BIFROST.instr"
  mcccurved_guide_25_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_25_0_nhslit = 1;
#line 1200 "BIFROST.instr"
  mcccurved_guide_25_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_25_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_25_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_25_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_25_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_25_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_25_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_25_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_25_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_25_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_25_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_25_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_25_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_25_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_25_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_25_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_25_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_25_0_reflect[0]='\0';
#line 25780 "BIFROST.c"

  SIG_MESSAGE("curved_guide_25_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1208 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1208 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1208 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25790 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_24_0, mcrotacurved_guide_25_0);
  rot_transpose(mcrotacurved_guide_24_0, mctr1);
  rot_mul(mcrotacurved_guide_25_0, mctr1, mcrotrcurved_guide_25_0);
  mctc1 = coords_set(
#line 1207 "BIFROST.instr"
    7.57345916228e-10,
#line 1207 "BIFROST.instr"
    0,
#line 1207 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 25801 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_24_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_25_0 = coords_add(mcposacurved_guide_24_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_24_0, mcposacurved_guide_25_0);
  mcposrcurved_guide_25_0 = rot_apply(mcrotacurved_guide_25_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_25_0", mcposacurved_guide_25_0, mcrotacurved_guide_25_0)
  mccomp_posa[59] = mcposacurved_guide_25_0;
  mccomp_posr[59] = mcposrcurved_guide_25_0;
  mcNCounter[59]  = mcPCounter[59] = mcP2Counter[59] = 0;
  mcAbsorbProp[59]= 0;
    /* Component curved_guide_26_0. */
  /* Setting parameters for component curved_guide_26_0. */
  SIG_MESSAGE("curved_guide_26_0 (Init:SetPar)");
#line 1212 "BIFROST.instr"
  mcccurved_guide_26_0_w1 = 0.029534;
#line 1213 "BIFROST.instr"
  mcccurved_guide_26_0_h1 = 0.047514;
#line 1212 "BIFROST.instr"
  mcccurved_guide_26_0_w2 = 0.029534;
#line 1213 "BIFROST.instr"
  mcccurved_guide_26_0_h2 = 0.047514;
#line 1211 "BIFROST.instr"
  mcccurved_guide_26_0_l = 0.5;
#line 1214 "BIFROST.instr"
  mcccurved_guide_26_0_R0 = 0.990000;
#line 1214 "BIFROST.instr"
  mcccurved_guide_26_0_Qc = 0.021700;
#line 1215 "BIFROST.instr"
  mcccurved_guide_26_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_26_0_m = 1.0;
#line 1215 "BIFROST.instr"
  mcccurved_guide_26_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_26_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_26_0_d = 0.0005;
#line 1216 "BIFROST.instr"
  mcccurved_guide_26_0_mleft = 3.000000;
#line 1216 "BIFROST.instr"
  mcccurved_guide_26_0_mright = 3.500000;
#line 1217 "BIFROST.instr"
  mcccurved_guide_26_0_mtop = 2.500000;
#line 1217 "BIFROST.instr"
  mcccurved_guide_26_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_26_0_nhslit = 1;
#line 1211 "BIFROST.instr"
  mcccurved_guide_26_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_26_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_26_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_26_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_26_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_26_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_26_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_26_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_26_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_26_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_26_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_26_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_26_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_26_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_26_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_26_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_26_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_26_0_reflect[0]='\0';
#line 25883 "BIFROST.c"

  SIG_MESSAGE("curved_guide_26_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1219 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1219 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1219 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25893 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_25_0, mcrotacurved_guide_26_0);
  rot_transpose(mcrotacurved_guide_25_0, mctr1);
  rot_mul(mcrotacurved_guide_26_0, mctr1, mcrotrcurved_guide_26_0);
  mctc1 = coords_set(
#line 1218 "BIFROST.instr"
    7.57345916228e-10,
#line 1218 "BIFROST.instr"
    0,
#line 1218 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 25904 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_25_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_26_0 = coords_add(mcposacurved_guide_25_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_25_0, mcposacurved_guide_26_0);
  mcposrcurved_guide_26_0 = rot_apply(mcrotacurved_guide_26_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_26_0", mcposacurved_guide_26_0, mcrotacurved_guide_26_0)
  mccomp_posa[60] = mcposacurved_guide_26_0;
  mccomp_posr[60] = mcposrcurved_guide_26_0;
  mcNCounter[60]  = mcPCounter[60] = mcP2Counter[60] = 0;
  mcAbsorbProp[60]= 0;
    /* Component curved_guide_27_0. */
  /* Setting parameters for component curved_guide_27_0. */
  SIG_MESSAGE("curved_guide_27_0 (Init:SetPar)");
#line 1223 "BIFROST.instr"
  mcccurved_guide_27_0_w1 = 0.029534;
#line 1224 "BIFROST.instr"
  mcccurved_guide_27_0_h1 = 0.047514;
#line 1223 "BIFROST.instr"
  mcccurved_guide_27_0_w2 = 0.029534;
#line 1224 "BIFROST.instr"
  mcccurved_guide_27_0_h2 = 0.047514;
#line 1222 "BIFROST.instr"
  mcccurved_guide_27_0_l = 0.5;
#line 1225 "BIFROST.instr"
  mcccurved_guide_27_0_R0 = 0.990000;
#line 1225 "BIFROST.instr"
  mcccurved_guide_27_0_Qc = 0.021700;
#line 1226 "BIFROST.instr"
  mcccurved_guide_27_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_27_0_m = 1.0;
#line 1226 "BIFROST.instr"
  mcccurved_guide_27_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_27_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_27_0_d = 0.0005;
#line 1227 "BIFROST.instr"
  mcccurved_guide_27_0_mleft = 3.000000;
#line 1227 "BIFROST.instr"
  mcccurved_guide_27_0_mright = 3.500000;
#line 1228 "BIFROST.instr"
  mcccurved_guide_27_0_mtop = 2.500000;
#line 1228 "BIFROST.instr"
  mcccurved_guide_27_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_27_0_nhslit = 1;
#line 1222 "BIFROST.instr"
  mcccurved_guide_27_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_27_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_27_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_27_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_27_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_27_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_27_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_27_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_27_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_27_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_27_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_27_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_27_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_27_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_27_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_27_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_27_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_27_0_reflect[0]='\0';
#line 25986 "BIFROST.c"

  SIG_MESSAGE("curved_guide_27_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1230 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1230 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1230 "BIFROST.instr"
    (0)*DEG2RAD);
#line 25996 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_26_0, mcrotacurved_guide_27_0);
  rot_transpose(mcrotacurved_guide_26_0, mctr1);
  rot_mul(mcrotacurved_guide_27_0, mctr1, mcrotrcurved_guide_27_0);
  mctc1 = coords_set(
#line 1229 "BIFROST.instr"
    7.57345916228e-10,
#line 1229 "BIFROST.instr"
    0,
#line 1229 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26007 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_26_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_27_0 = coords_add(mcposacurved_guide_26_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_26_0, mcposacurved_guide_27_0);
  mcposrcurved_guide_27_0 = rot_apply(mcrotacurved_guide_27_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_27_0", mcposacurved_guide_27_0, mcrotacurved_guide_27_0)
  mccomp_posa[61] = mcposacurved_guide_27_0;
  mccomp_posr[61] = mcposrcurved_guide_27_0;
  mcNCounter[61]  = mcPCounter[61] = mcP2Counter[61] = 0;
  mcAbsorbProp[61]= 0;
    /* Component curved_guide_28_0. */
  /* Setting parameters for component curved_guide_28_0. */
  SIG_MESSAGE("curved_guide_28_0 (Init:SetPar)");
#line 1234 "BIFROST.instr"
  mcccurved_guide_28_0_w1 = 0.029534;
#line 1235 "BIFROST.instr"
  mcccurved_guide_28_0_h1 = 0.047514;
#line 1234 "BIFROST.instr"
  mcccurved_guide_28_0_w2 = 0.029534;
#line 1235 "BIFROST.instr"
  mcccurved_guide_28_0_h2 = 0.047514;
#line 1233 "BIFROST.instr"
  mcccurved_guide_28_0_l = 0.5;
#line 1236 "BIFROST.instr"
  mcccurved_guide_28_0_R0 = 0.990000;
#line 1236 "BIFROST.instr"
  mcccurved_guide_28_0_Qc = 0.021700;
#line 1237 "BIFROST.instr"
  mcccurved_guide_28_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_28_0_m = 1.0;
#line 1237 "BIFROST.instr"
  mcccurved_guide_28_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_28_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_28_0_d = 0.0005;
#line 1238 "BIFROST.instr"
  mcccurved_guide_28_0_mleft = 3.000000;
#line 1238 "BIFROST.instr"
  mcccurved_guide_28_0_mright = 3.500000;
#line 1239 "BIFROST.instr"
  mcccurved_guide_28_0_mtop = 2.500000;
#line 1239 "BIFROST.instr"
  mcccurved_guide_28_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_28_0_nhslit = 1;
#line 1233 "BIFROST.instr"
  mcccurved_guide_28_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_28_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_28_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_28_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_28_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_28_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_28_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_28_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_28_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_28_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_28_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_28_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_28_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_28_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_28_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_28_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_28_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_28_0_reflect[0]='\0';
#line 26089 "BIFROST.c"

  SIG_MESSAGE("curved_guide_28_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1241 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1241 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1241 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26099 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_27_0, mcrotacurved_guide_28_0);
  rot_transpose(mcrotacurved_guide_27_0, mctr1);
  rot_mul(mcrotacurved_guide_28_0, mctr1, mcrotrcurved_guide_28_0);
  mctc1 = coords_set(
#line 1240 "BIFROST.instr"
    7.57345916228e-10,
#line 1240 "BIFROST.instr"
    0,
#line 1240 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26110 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_27_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_28_0 = coords_add(mcposacurved_guide_27_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_27_0, mcposacurved_guide_28_0);
  mcposrcurved_guide_28_0 = rot_apply(mcrotacurved_guide_28_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_28_0", mcposacurved_guide_28_0, mcrotacurved_guide_28_0)
  mccomp_posa[62] = mcposacurved_guide_28_0;
  mccomp_posr[62] = mcposrcurved_guide_28_0;
  mcNCounter[62]  = mcPCounter[62] = mcP2Counter[62] = 0;
  mcAbsorbProp[62]= 0;
    /* Component curved_guide_29_0. */
  /* Setting parameters for component curved_guide_29_0. */
  SIG_MESSAGE("curved_guide_29_0 (Init:SetPar)");
#line 1245 "BIFROST.instr"
  mcccurved_guide_29_0_w1 = 0.029534;
#line 1246 "BIFROST.instr"
  mcccurved_guide_29_0_h1 = 0.047514;
#line 1245 "BIFROST.instr"
  mcccurved_guide_29_0_w2 = 0.029534;
#line 1246 "BIFROST.instr"
  mcccurved_guide_29_0_h2 = 0.047514;
#line 1244 "BIFROST.instr"
  mcccurved_guide_29_0_l = 0.5;
#line 1247 "BIFROST.instr"
  mcccurved_guide_29_0_R0 = 0.990000;
#line 1247 "BIFROST.instr"
  mcccurved_guide_29_0_Qc = 0.021700;
#line 1248 "BIFROST.instr"
  mcccurved_guide_29_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_29_0_m = 1.0;
#line 1248 "BIFROST.instr"
  mcccurved_guide_29_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_29_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_29_0_d = 0.0005;
#line 1249 "BIFROST.instr"
  mcccurved_guide_29_0_mleft = 3.000000;
#line 1249 "BIFROST.instr"
  mcccurved_guide_29_0_mright = 3.500000;
#line 1250 "BIFROST.instr"
  mcccurved_guide_29_0_mtop = 2.500000;
#line 1250 "BIFROST.instr"
  mcccurved_guide_29_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_29_0_nhslit = 1;
#line 1244 "BIFROST.instr"
  mcccurved_guide_29_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_29_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_29_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_29_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_29_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_29_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_29_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_29_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_29_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_29_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_29_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_29_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_29_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_29_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_29_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_29_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_29_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_29_0_reflect[0]='\0';
#line 26192 "BIFROST.c"

  SIG_MESSAGE("curved_guide_29_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1252 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1252 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1252 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26202 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_28_0, mcrotacurved_guide_29_0);
  rot_transpose(mcrotacurved_guide_28_0, mctr1);
  rot_mul(mcrotacurved_guide_29_0, mctr1, mcrotrcurved_guide_29_0);
  mctc1 = coords_set(
#line 1251 "BIFROST.instr"
    7.57345916228e-10,
#line 1251 "BIFROST.instr"
    0,
#line 1251 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26213 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_28_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_29_0 = coords_add(mcposacurved_guide_28_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_28_0, mcposacurved_guide_29_0);
  mcposrcurved_guide_29_0 = rot_apply(mcrotacurved_guide_29_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_29_0", mcposacurved_guide_29_0, mcrotacurved_guide_29_0)
  mccomp_posa[63] = mcposacurved_guide_29_0;
  mccomp_posr[63] = mcposrcurved_guide_29_0;
  mcNCounter[63]  = mcPCounter[63] = mcP2Counter[63] = 0;
  mcAbsorbProp[63]= 0;
    /* Component curved_guide_30_0. */
  /* Setting parameters for component curved_guide_30_0. */
  SIG_MESSAGE("curved_guide_30_0 (Init:SetPar)");
#line 1256 "BIFROST.instr"
  mcccurved_guide_30_0_w1 = 0.029534;
#line 1257 "BIFROST.instr"
  mcccurved_guide_30_0_h1 = 0.047514;
#line 1256 "BIFROST.instr"
  mcccurved_guide_30_0_w2 = 0.029534;
#line 1257 "BIFROST.instr"
  mcccurved_guide_30_0_h2 = 0.047514;
#line 1255 "BIFROST.instr"
  mcccurved_guide_30_0_l = 0.5;
#line 1258 "BIFROST.instr"
  mcccurved_guide_30_0_R0 = 0.990000;
#line 1258 "BIFROST.instr"
  mcccurved_guide_30_0_Qc = 0.021700;
#line 1259 "BIFROST.instr"
  mcccurved_guide_30_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_30_0_m = 1.0;
#line 1259 "BIFROST.instr"
  mcccurved_guide_30_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_30_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_30_0_d = 0.0005;
#line 1260 "BIFROST.instr"
  mcccurved_guide_30_0_mleft = 3.000000;
#line 1260 "BIFROST.instr"
  mcccurved_guide_30_0_mright = 3.500000;
#line 1261 "BIFROST.instr"
  mcccurved_guide_30_0_mtop = 2.500000;
#line 1261 "BIFROST.instr"
  mcccurved_guide_30_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_30_0_nhslit = 1;
#line 1255 "BIFROST.instr"
  mcccurved_guide_30_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_30_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_30_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_30_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_30_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_30_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_30_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_30_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_30_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_30_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_30_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_30_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_30_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_30_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_30_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_30_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_30_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_30_0_reflect[0]='\0';
#line 26295 "BIFROST.c"

  SIG_MESSAGE("curved_guide_30_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1263 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1263 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1263 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26305 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_29_0, mcrotacurved_guide_30_0);
  rot_transpose(mcrotacurved_guide_29_0, mctr1);
  rot_mul(mcrotacurved_guide_30_0, mctr1, mcrotrcurved_guide_30_0);
  mctc1 = coords_set(
#line 1262 "BIFROST.instr"
    7.57345916228e-10,
#line 1262 "BIFROST.instr"
    0,
#line 1262 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26316 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_29_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_30_0 = coords_add(mcposacurved_guide_29_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_29_0, mcposacurved_guide_30_0);
  mcposrcurved_guide_30_0 = rot_apply(mcrotacurved_guide_30_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_30_0", mcposacurved_guide_30_0, mcrotacurved_guide_30_0)
  mccomp_posa[64] = mcposacurved_guide_30_0;
  mccomp_posr[64] = mcposrcurved_guide_30_0;
  mcNCounter[64]  = mcPCounter[64] = mcP2Counter[64] = 0;
  mcAbsorbProp[64]= 0;
    /* Component curved_guide_31_0. */
  /* Setting parameters for component curved_guide_31_0. */
  SIG_MESSAGE("curved_guide_31_0 (Init:SetPar)");
#line 1267 "BIFROST.instr"
  mcccurved_guide_31_0_w1 = 0.029534;
#line 1268 "BIFROST.instr"
  mcccurved_guide_31_0_h1 = 0.047514;
#line 1267 "BIFROST.instr"
  mcccurved_guide_31_0_w2 = 0.029534;
#line 1268 "BIFROST.instr"
  mcccurved_guide_31_0_h2 = 0.047514;
#line 1266 "BIFROST.instr"
  mcccurved_guide_31_0_l = 0.5;
#line 1269 "BIFROST.instr"
  mcccurved_guide_31_0_R0 = 0.990000;
#line 1269 "BIFROST.instr"
  mcccurved_guide_31_0_Qc = 0.021700;
#line 1270 "BIFROST.instr"
  mcccurved_guide_31_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_31_0_m = 1.0;
#line 1270 "BIFROST.instr"
  mcccurved_guide_31_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_31_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_31_0_d = 0.0005;
#line 1271 "BIFROST.instr"
  mcccurved_guide_31_0_mleft = 3.000000;
#line 1271 "BIFROST.instr"
  mcccurved_guide_31_0_mright = 3.500000;
#line 1272 "BIFROST.instr"
  mcccurved_guide_31_0_mtop = 2.500000;
#line 1272 "BIFROST.instr"
  mcccurved_guide_31_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_31_0_nhslit = 1;
#line 1266 "BIFROST.instr"
  mcccurved_guide_31_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_31_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_31_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_31_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_31_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_31_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_31_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_31_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_31_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_31_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_31_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_31_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_31_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_31_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_31_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_31_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_31_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_31_0_reflect[0]='\0';
#line 26398 "BIFROST.c"

  SIG_MESSAGE("curved_guide_31_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1274 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1274 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1274 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26408 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_30_0, mcrotacurved_guide_31_0);
  rot_transpose(mcrotacurved_guide_30_0, mctr1);
  rot_mul(mcrotacurved_guide_31_0, mctr1, mcrotrcurved_guide_31_0);
  mctc1 = coords_set(
#line 1273 "BIFROST.instr"
    7.57345916228e-10,
#line 1273 "BIFROST.instr"
    0,
#line 1273 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26419 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_30_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_31_0 = coords_add(mcposacurved_guide_30_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_30_0, mcposacurved_guide_31_0);
  mcposrcurved_guide_31_0 = rot_apply(mcrotacurved_guide_31_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_31_0", mcposacurved_guide_31_0, mcrotacurved_guide_31_0)
  mccomp_posa[65] = mcposacurved_guide_31_0;
  mccomp_posr[65] = mcposrcurved_guide_31_0;
  mcNCounter[65]  = mcPCounter[65] = mcP2Counter[65] = 0;
  mcAbsorbProp[65]= 0;
    /* Component curved_guide_32_0. */
  /* Setting parameters for component curved_guide_32_0. */
  SIG_MESSAGE("curved_guide_32_0 (Init:SetPar)");
#line 1278 "BIFROST.instr"
  mcccurved_guide_32_0_w1 = 0.029534;
#line 1279 "BIFROST.instr"
  mcccurved_guide_32_0_h1 = 0.047514;
#line 1278 "BIFROST.instr"
  mcccurved_guide_32_0_w2 = 0.029534;
#line 1279 "BIFROST.instr"
  mcccurved_guide_32_0_h2 = 0.047514;
#line 1277 "BIFROST.instr"
  mcccurved_guide_32_0_l = 0.5;
#line 1280 "BIFROST.instr"
  mcccurved_guide_32_0_R0 = 0.990000;
#line 1280 "BIFROST.instr"
  mcccurved_guide_32_0_Qc = 0.021700;
#line 1281 "BIFROST.instr"
  mcccurved_guide_32_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_32_0_m = 1.0;
#line 1281 "BIFROST.instr"
  mcccurved_guide_32_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_32_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_32_0_d = 0.0005;
#line 1282 "BIFROST.instr"
  mcccurved_guide_32_0_mleft = 3.000000;
#line 1282 "BIFROST.instr"
  mcccurved_guide_32_0_mright = 3.500000;
#line 1283 "BIFROST.instr"
  mcccurved_guide_32_0_mtop = 2.500000;
#line 1283 "BIFROST.instr"
  mcccurved_guide_32_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_32_0_nhslit = 1;
#line 1277 "BIFROST.instr"
  mcccurved_guide_32_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_32_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_32_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_32_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_32_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_32_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_32_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_32_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_32_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_32_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_32_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_32_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_32_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_32_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_32_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_32_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_32_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_32_0_reflect[0]='\0';
#line 26501 "BIFROST.c"

  SIG_MESSAGE("curved_guide_32_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1285 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1285 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1285 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26511 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_31_0, mcrotacurved_guide_32_0);
  rot_transpose(mcrotacurved_guide_31_0, mctr1);
  rot_mul(mcrotacurved_guide_32_0, mctr1, mcrotrcurved_guide_32_0);
  mctc1 = coords_set(
#line 1284 "BIFROST.instr"
    7.57345916228e-10,
#line 1284 "BIFROST.instr"
    0,
#line 1284 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26522 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_31_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_32_0 = coords_add(mcposacurved_guide_31_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_31_0, mcposacurved_guide_32_0);
  mcposrcurved_guide_32_0 = rot_apply(mcrotacurved_guide_32_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_32_0", mcposacurved_guide_32_0, mcrotacurved_guide_32_0)
  mccomp_posa[66] = mcposacurved_guide_32_0;
  mccomp_posr[66] = mcposrcurved_guide_32_0;
  mcNCounter[66]  = mcPCounter[66] = mcP2Counter[66] = 0;
  mcAbsorbProp[66]= 0;
    /* Component curved_guide_33_0. */
  /* Setting parameters for component curved_guide_33_0. */
  SIG_MESSAGE("curved_guide_33_0 (Init:SetPar)");
#line 1289 "BIFROST.instr"
  mcccurved_guide_33_0_w1 = 0.029534;
#line 1290 "BIFROST.instr"
  mcccurved_guide_33_0_h1 = 0.047514;
#line 1289 "BIFROST.instr"
  mcccurved_guide_33_0_w2 = 0.029534;
#line 1290 "BIFROST.instr"
  mcccurved_guide_33_0_h2 = 0.047514;
#line 1288 "BIFROST.instr"
  mcccurved_guide_33_0_l = 0.5;
#line 1291 "BIFROST.instr"
  mcccurved_guide_33_0_R0 = 0.990000;
#line 1291 "BIFROST.instr"
  mcccurved_guide_33_0_Qc = 0.021700;
#line 1292 "BIFROST.instr"
  mcccurved_guide_33_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_33_0_m = 1.0;
#line 1292 "BIFROST.instr"
  mcccurved_guide_33_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_33_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_33_0_d = 0.0005;
#line 1293 "BIFROST.instr"
  mcccurved_guide_33_0_mleft = 3.000000;
#line 1293 "BIFROST.instr"
  mcccurved_guide_33_0_mright = 3.500000;
#line 1294 "BIFROST.instr"
  mcccurved_guide_33_0_mtop = 2.500000;
#line 1294 "BIFROST.instr"
  mcccurved_guide_33_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_33_0_nhslit = 1;
#line 1288 "BIFROST.instr"
  mcccurved_guide_33_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_33_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_33_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_33_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_33_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_33_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_33_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_33_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_33_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_33_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_33_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_33_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_33_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_33_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_33_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_33_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_33_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_33_0_reflect[0]='\0';
#line 26604 "BIFROST.c"

  SIG_MESSAGE("curved_guide_33_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1296 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1296 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1296 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26614 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_32_0, mcrotacurved_guide_33_0);
  rot_transpose(mcrotacurved_guide_32_0, mctr1);
  rot_mul(mcrotacurved_guide_33_0, mctr1, mcrotrcurved_guide_33_0);
  mctc1 = coords_set(
#line 1295 "BIFROST.instr"
    7.57345916228e-10,
#line 1295 "BIFROST.instr"
    0,
#line 1295 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26625 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_32_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_33_0 = coords_add(mcposacurved_guide_32_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_32_0, mcposacurved_guide_33_0);
  mcposrcurved_guide_33_0 = rot_apply(mcrotacurved_guide_33_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_33_0", mcposacurved_guide_33_0, mcrotacurved_guide_33_0)
  mccomp_posa[67] = mcposacurved_guide_33_0;
  mccomp_posr[67] = mcposrcurved_guide_33_0;
  mcNCounter[67]  = mcPCounter[67] = mcP2Counter[67] = 0;
  mcAbsorbProp[67]= 0;
    /* Component curved_guide_34_0. */
  /* Setting parameters for component curved_guide_34_0. */
  SIG_MESSAGE("curved_guide_34_0 (Init:SetPar)");
#line 1300 "BIFROST.instr"
  mcccurved_guide_34_0_w1 = 0.029534;
#line 1301 "BIFROST.instr"
  mcccurved_guide_34_0_h1 = 0.047514;
#line 1300 "BIFROST.instr"
  mcccurved_guide_34_0_w2 = 0.029534;
#line 1301 "BIFROST.instr"
  mcccurved_guide_34_0_h2 = 0.047514;
#line 1299 "BIFROST.instr"
  mcccurved_guide_34_0_l = 0.5;
#line 1302 "BIFROST.instr"
  mcccurved_guide_34_0_R0 = 0.990000;
#line 1302 "BIFROST.instr"
  mcccurved_guide_34_0_Qc = 0.021700;
#line 1303 "BIFROST.instr"
  mcccurved_guide_34_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_34_0_m = 1.0;
#line 1303 "BIFROST.instr"
  mcccurved_guide_34_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_34_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_34_0_d = 0.0005;
#line 1304 "BIFROST.instr"
  mcccurved_guide_34_0_mleft = 3.000000;
#line 1304 "BIFROST.instr"
  mcccurved_guide_34_0_mright = 3.500000;
#line 1305 "BIFROST.instr"
  mcccurved_guide_34_0_mtop = 2.500000;
#line 1305 "BIFROST.instr"
  mcccurved_guide_34_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_34_0_nhslit = 1;
#line 1299 "BIFROST.instr"
  mcccurved_guide_34_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_34_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_34_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_34_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_34_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_34_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_34_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_34_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_34_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_34_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_34_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_34_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_34_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_34_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_34_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_34_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_34_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_34_0_reflect[0]='\0';
#line 26707 "BIFROST.c"

  SIG_MESSAGE("curved_guide_34_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1307 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1307 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1307 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26717 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_33_0, mcrotacurved_guide_34_0);
  rot_transpose(mcrotacurved_guide_33_0, mctr1);
  rot_mul(mcrotacurved_guide_34_0, mctr1, mcrotrcurved_guide_34_0);
  mctc1 = coords_set(
#line 1306 "BIFROST.instr"
    7.57345916228e-10,
#line 1306 "BIFROST.instr"
    0,
#line 1306 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26728 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_33_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_34_0 = coords_add(mcposacurved_guide_33_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_33_0, mcposacurved_guide_34_0);
  mcposrcurved_guide_34_0 = rot_apply(mcrotacurved_guide_34_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_34_0", mcposacurved_guide_34_0, mcrotacurved_guide_34_0)
  mccomp_posa[68] = mcposacurved_guide_34_0;
  mccomp_posr[68] = mcposrcurved_guide_34_0;
  mcNCounter[68]  = mcPCounter[68] = mcP2Counter[68] = 0;
  mcAbsorbProp[68]= 0;
    /* Component curved_guide_35_0. */
  /* Setting parameters for component curved_guide_35_0. */
  SIG_MESSAGE("curved_guide_35_0 (Init:SetPar)");
#line 1311 "BIFROST.instr"
  mcccurved_guide_35_0_w1 = 0.029534;
#line 1312 "BIFROST.instr"
  mcccurved_guide_35_0_h1 = 0.047514;
#line 1311 "BIFROST.instr"
  mcccurved_guide_35_0_w2 = 0.029534;
#line 1312 "BIFROST.instr"
  mcccurved_guide_35_0_h2 = 0.047514;
#line 1310 "BIFROST.instr"
  mcccurved_guide_35_0_l = 0.5;
#line 1313 "BIFROST.instr"
  mcccurved_guide_35_0_R0 = 0.990000;
#line 1313 "BIFROST.instr"
  mcccurved_guide_35_0_Qc = 0.021700;
#line 1314 "BIFROST.instr"
  mcccurved_guide_35_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_35_0_m = 1.0;
#line 1314 "BIFROST.instr"
  mcccurved_guide_35_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_35_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_35_0_d = 0.0005;
#line 1315 "BIFROST.instr"
  mcccurved_guide_35_0_mleft = 3.000000;
#line 1315 "BIFROST.instr"
  mcccurved_guide_35_0_mright = 3.500000;
#line 1316 "BIFROST.instr"
  mcccurved_guide_35_0_mtop = 2.500000;
#line 1316 "BIFROST.instr"
  mcccurved_guide_35_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_35_0_nhslit = 1;
#line 1310 "BIFROST.instr"
  mcccurved_guide_35_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_35_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_35_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_35_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_35_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_35_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_35_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_35_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_35_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_35_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_35_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_35_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_35_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_35_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_35_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_35_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_35_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_35_0_reflect[0]='\0';
#line 26810 "BIFROST.c"

  SIG_MESSAGE("curved_guide_35_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1318 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1318 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1318 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26820 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_34_0, mcrotacurved_guide_35_0);
  rot_transpose(mcrotacurved_guide_34_0, mctr1);
  rot_mul(mcrotacurved_guide_35_0, mctr1, mcrotrcurved_guide_35_0);
  mctc1 = coords_set(
#line 1317 "BIFROST.instr"
    7.57345916228e-10,
#line 1317 "BIFROST.instr"
    0,
#line 1317 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26831 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_34_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_35_0 = coords_add(mcposacurved_guide_34_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_34_0, mcposacurved_guide_35_0);
  mcposrcurved_guide_35_0 = rot_apply(mcrotacurved_guide_35_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_35_0", mcposacurved_guide_35_0, mcrotacurved_guide_35_0)
  mccomp_posa[69] = mcposacurved_guide_35_0;
  mccomp_posr[69] = mcposrcurved_guide_35_0;
  mcNCounter[69]  = mcPCounter[69] = mcP2Counter[69] = 0;
  mcAbsorbProp[69]= 0;
    /* Component curved_guide_36_0. */
  /* Setting parameters for component curved_guide_36_0. */
  SIG_MESSAGE("curved_guide_36_0 (Init:SetPar)");
#line 1323 "BIFROST.instr"
  mcccurved_guide_36_0_w1 = 0.029534;
#line 1324 "BIFROST.instr"
  mcccurved_guide_36_0_h1 = 0.047514;
#line 1323 "BIFROST.instr"
  mcccurved_guide_36_0_w2 = 0.029534;
#line 1324 "BIFROST.instr"
  mcccurved_guide_36_0_h2 = 0.047514;
#line 1322 "BIFROST.instr"
  mcccurved_guide_36_0_l = 0.495689131828;
#line 1325 "BIFROST.instr"
  mcccurved_guide_36_0_R0 = 0.990000;
#line 1325 "BIFROST.instr"
  mcccurved_guide_36_0_Qc = 0.021700;
#line 1326 "BIFROST.instr"
  mcccurved_guide_36_0_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mcccurved_guide_36_0_m = 1.0;
#line 1326 "BIFROST.instr"
  mcccurved_guide_36_0_W = 0.003000;
#line 114 "BIFROST.instr"
  mcccurved_guide_36_0_nslit = 1;
#line 114 "BIFROST.instr"
  mcccurved_guide_36_0_d = 0.0005;
#line 1327 "BIFROST.instr"
  mcccurved_guide_36_0_mleft = 3.000000;
#line 1327 "BIFROST.instr"
  mcccurved_guide_36_0_mright = 3.500000;
#line 1328 "BIFROST.instr"
  mcccurved_guide_36_0_mtop = 2.500000;
#line 1328 "BIFROST.instr"
  mcccurved_guide_36_0_mbottom = 2.500000;
#line 115 "BIFROST.instr"
  mcccurved_guide_36_0_nhslit = 1;
#line 1322 "BIFROST.instr"
  mcccurved_guide_36_0_G = -9.82;
#line 116 "BIFROST.instr"
  mcccurved_guide_36_0_aleft = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_36_0_aright = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_36_0_atop = -1;
#line 116 "BIFROST.instr"
  mcccurved_guide_36_0_abottom = -1;
#line 117 "BIFROST.instr"
  mcccurved_guide_36_0_wavy = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_36_0_wavy_z = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_36_0_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mcccurved_guide_36_0_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_36_0_chamfers = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_36_0_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_36_0_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_36_0_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mcccurved_guide_36_0_nelements = 1;
#line 119 "BIFROST.instr"
  mcccurved_guide_36_0_nu = 0;
#line 119 "BIFROST.instr"
  mcccurved_guide_36_0_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mcccurved_guide_36_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_36_0_reflect[0]='\0';
#line 26913 "BIFROST.c"

  SIG_MESSAGE("curved_guide_36_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1330 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1330 "BIFROST.instr"
    (benderAngle)*DEG2RAD,
#line 1330 "BIFROST.instr"
    (0)*DEG2RAD);
#line 26923 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_35_0, mcrotacurved_guide_36_0);
  rot_transpose(mcrotacurved_guide_35_0, mctr1);
  rot_mul(mcrotacurved_guide_36_0, mctr1, mcrotrcurved_guide_36_0);
  mctc1 = coords_set(
#line 1329 "BIFROST.instr"
    7.57345916228e-10,
#line 1329 "BIFROST.instr"
    0,
#line 1329 "BIFROST.instr"
    0.500 + u + 6e-5);
#line 26934 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_35_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_36_0 = coords_add(mcposacurved_guide_35_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_35_0, mcposacurved_guide_36_0);
  mcposrcurved_guide_36_0 = rot_apply(mcrotacurved_guide_36_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_36_0", mcposacurved_guide_36_0, mcrotacurved_guide_36_0)
  mccomp_posa[70] = mcposacurved_guide_36_0;
  mccomp_posr[70] = mcposrcurved_guide_36_0;
  mcNCounter[70]  = mcPCounter[70] = mcP2Counter[70] = 0;
  mcAbsorbProp[70]= 0;
    /* Component EndOfelement_4. */
  /* Setting parameters for component EndOfelement_4. */
  SIG_MESSAGE("EndOfelement_4 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26954 "BIFROST.c"
  rot_mul(mctr1, mcrotacurved_guide_36_0, mcrotaEndOfelement_4);
  rot_transpose(mcrotacurved_guide_36_0, mctr1);
  rot_mul(mcrotaEndOfelement_4, mctr1, mcrotrEndOfelement_4);
  mctc1 = coords_set(
#line 1335 "BIFROST.instr"
    7.57345916228e-10,
#line 1335 "BIFROST.instr"
    0,
#line 1335 "BIFROST.instr"
    0.495689132 + u);
#line 26965 "BIFROST.c"
  rot_transpose(mcrotacurved_guide_36_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_4 = coords_add(mcposacurved_guide_36_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_36_0, mcposaEndOfelement_4);
  mcposrEndOfelement_4 = rot_apply(mcrotaEndOfelement_4, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_4", mcposaEndOfelement_4, mcrotaEndOfelement_4)
  mccomp_posa[71] = mcposaEndOfelement_4;
  mccomp_posr[71] = mcposrEndOfelement_4;
  mcNCounter[71]  = mcPCounter[71] = mcP2Counter[71] = 0;
  mcAbsorbProp[71]= 0;
    /* Component elliptical_guide_gravity3. */
  /* Setting parameters for component elliptical_guide_gravity3. */
  SIG_MESSAGE("elliptical_guide_gravity3 (Init:SetPar)");
#line 1340 "BIFROST.instr"
  mccelliptical_guide_gravity3_l = 24.928800;
#line 1341 "BIFROST.instr"
  mccelliptical_guide_gravity3_xwidth = 0.060000;
#line 1341 "BIFROST.instr"
  mccelliptical_guide_gravity3_yheight = 0.090000;
#line 1340 "BIFROST.instr"
  mccelliptical_guide_gravity3_linxw = 3.709727;
#line 1340 "BIFROST.instr"
  mccelliptical_guide_gravity3_loutxw = 28.638527;
#line 1340 "BIFROST.instr"
  mccelliptical_guide_gravity3_linyh = 4.423828;
#line 1340 "BIFROST.instr"
  mccelliptical_guide_gravity3_loutyh = 29.352628;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity3_majorAxisxw = 0;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity3_minorAxisxw = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity3_majorAxisyh = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity3_minorAxisyh = 0;
#line 167 "BIFROST.instr"
  mccelliptical_guide_gravity3_majorAxisoffsetxw = 0;
#line 168 "BIFROST.instr"
  mccelliptical_guide_gravity3_majorAxisoffsetyh = 0;
#line 1341 "BIFROST.instr"
  if("mid") strncpy(mccelliptical_guide_gravity3_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity3_dimensionsAt[0]='\0';
#line 170 "BIFROST.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity3_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity3_option[0]='\0';
#line 1342 "BIFROST.instr"
  mccelliptical_guide_gravity3_R0 = 0.990000;
#line 1342 "BIFROST.instr"
  mccelliptical_guide_gravity3_Qc = 0.021700;
#line 1342 "BIFROST.instr"
  mccelliptical_guide_gravity3_alpha = 3.100000;
#line 171 "BIFROST.instr"
  mccelliptical_guide_gravity3_m = 2;
#line 1342 "BIFROST.instr"
  mccelliptical_guide_gravity3_W = 0.003000;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity3_alpharight = -1;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity3_mright = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity3_alphaleft = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity3_mleft = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity3_alphatop = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity3_mtop = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity3_alphabottom = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity3_mbottom = -1;
#line 176 "BIFROST.instr"
  if("on") strncpy(mccelliptical_guide_gravity3_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity3_verbose[0]='\0';
#line 177 "BIFROST.instr"
  mccelliptical_guide_gravity3_enableGravity = 1.0;
#line 178 "BIFROST.instr"
  mccelliptical_guide_gravity3_curvature = 0;
#line 27041 "BIFROST.c"

  SIG_MESSAGE("elliptical_guide_gravity3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1344 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1344 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1344 "BIFROST.instr"
    (0)*DEG2RAD);
#line 27051 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_4, mcrotaelliptical_guide_gravity3);
  rot_transpose(mcrotaEndOfelement_4, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity3, mctr1, mcrotrelliptical_guide_gravity3);
  mctc1 = coords_set(
#line 1343 "BIFROST.instr"
    0,
#line 1343 "BIFROST.instr"
    0,
#line 1343 "BIFROST.instr"
    u);
#line 27062 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity3 = coords_add(mcposaEndOfelement_4, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_4, mcposaelliptical_guide_gravity3);
  mcposrelliptical_guide_gravity3 = rot_apply(mcrotaelliptical_guide_gravity3, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity3", mcposaelliptical_guide_gravity3, mcrotaelliptical_guide_gravity3)
  mccomp_posa[72] = mcposaelliptical_guide_gravity3;
  mccomp_posr[72] = mcposrelliptical_guide_gravity3;
  mcNCounter[72]  = mcPCounter[72] = mcP2Counter[72] = 0;
  mcAbsorbProp[72]= 0;
    /* Component EndOfelement_3. */
  /* Setting parameters for component EndOfelement_3. */
  SIG_MESSAGE("EndOfelement_3 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27082 "BIFROST.c"
  rot_mul(mctr1, mcrotaelliptical_guide_gravity3, mcrotaEndOfelement_3);
  rot_transpose(mcrotaelliptical_guide_gravity3, mctr1);
  rot_mul(mcrotaEndOfelement_3, mctr1, mcrotrEndOfelement_3);
  mctc1 = coords_set(
#line 1347 "BIFROST.instr"
    0,
#line 1347 "BIFROST.instr"
    0,
#line 1347 "BIFROST.instr"
    24.928800 + u);
#line 27093 "BIFROST.c"
  rot_transpose(mcrotaelliptical_guide_gravity3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_3 = coords_add(mcposaelliptical_guide_gravity3, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity3, mcposaEndOfelement_3);
  mcposrEndOfelement_3 = rot_apply(mcrotaEndOfelement_3, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_3", mcposaEndOfelement_3, mcrotaEndOfelement_3)
  mccomp_posa[73] = mcposaEndOfelement_3;
  mccomp_posr[73] = mcposrEndOfelement_3;
  mcNCounter[73]  = mcPCounter[73] = mcP2Counter[73] = 0;
  mcAbsorbProp[73]= 0;
    /* Component straight_guide_2_1. */
  /* Setting parameters for component straight_guide_2_1. */
  SIG_MESSAGE("straight_guide_2_1 (Init:SetPar)");
#line 1355 "BIFROST.instr"
  mccstraight_guide_2_1_w1 = 0.060000;
#line 1356 "BIFROST.instr"
  mccstraight_guide_2_1_h1 = 0.090000;
#line 1355 "BIFROST.instr"
  mccstraight_guide_2_1_w2 = 0.060000;
#line 1356 "BIFROST.instr"
  mccstraight_guide_2_1_h2 = 0.090000;
#line 1354 "BIFROST.instr"
  mccstraight_guide_2_1_l = mcipchopBWPos - startXposition_straight - BW_chopGap / 2;
#line 1357 "BIFROST.instr"
  mccstraight_guide_2_1_R0 = 0.990000;
#line 1357 "BIFROST.instr"
  mccstraight_guide_2_1_Qc = 0.021700;
#line 1358 "BIFROST.instr"
  mccstraight_guide_2_1_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mccstraight_guide_2_1_m = 1.0;
#line 1358 "BIFROST.instr"
  mccstraight_guide_2_1_W = 0.003000;
#line 114 "BIFROST.instr"
  mccstraight_guide_2_1_nslit = 1;
#line 114 "BIFROST.instr"
  mccstraight_guide_2_1_d = 0.0005;
#line 1359 "BIFROST.instr"
  mccstraight_guide_2_1_mleft = 1.500000;
#line 1359 "BIFROST.instr"
  mccstraight_guide_2_1_mright = 1.500000;
#line 1360 "BIFROST.instr"
  mccstraight_guide_2_1_mtop = 1.000000;
#line 1360 "BIFROST.instr"
  mccstraight_guide_2_1_mbottom = 1.000000;
#line 115 "BIFROST.instr"
  mccstraight_guide_2_1_nhslit = 1;
#line 1354 "BIFROST.instr"
  mccstraight_guide_2_1_G = -9.82;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_1_aleft = -1;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_1_aright = -1;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_1_atop = -1;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_1_abottom = -1;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_1_wavy = 0;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_1_wavy_z = 0;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_1_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_1_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_1_chamfers = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_1_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_1_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_1_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_1_nelements = 1;
#line 119 "BIFROST.instr"
  mccstraight_guide_2_1_nu = 0;
#line 119 "BIFROST.instr"
  mccstraight_guide_2_1_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mccstraight_guide_2_1_reflect, "NULL" ? "NULL" : "", 16384); else mccstraight_guide_2_1_reflect[0]='\0';
#line 27175 "BIFROST.c"

  SIG_MESSAGE("straight_guide_2_1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1362 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1362 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1362 "BIFROST.instr"
    (0)*DEG2RAD);
#line 27185 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_3, mcrotastraight_guide_2_1);
  rot_transpose(mcrotaEndOfelement_3, mctr1);
  rot_mul(mcrotastraight_guide_2_1, mctr1, mcrotrstraight_guide_2_1);
  mctc1 = coords_set(
#line 1361 "BIFROST.instr"
    0,
#line 1361 "BIFROST.instr"
    0,
#line 1361 "BIFROST.instr"
    u);
#line 27196 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposastraight_guide_2_1 = coords_add(mcposaEndOfelement_3, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_3, mcposastraight_guide_2_1);
  mcposrstraight_guide_2_1 = rot_apply(mcrotastraight_guide_2_1, mctc1);
  mcDEBUG_COMPONENT("straight_guide_2_1", mcposastraight_guide_2_1, mcrotastraight_guide_2_1)
  mccomp_posa[74] = mcposastraight_guide_2_1;
  mccomp_posr[74] = mcposrstraight_guide_2_1;
  mcNCounter[74]  = mcPCounter[74] = mcP2Counter[74] = 0;
  mcAbsorbProp[74]= 0;
    /* Component L_monBeforeBWC. */
  /* Setting parameters for component L_monBeforeBWC. */
  SIG_MESSAGE("L_monBeforeBWC (Init:SetPar)");
#line 1366 "BIFROST.instr"
  if("L_monBeforeBWC.dat") strncpy(mccL_monBeforeBWC_filename, "L_monBeforeBWC.dat" ? "L_monBeforeBWC.dat" : "", 16384); else mccL_monBeforeBWC_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monBeforeBWC_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeBWC_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeBWC_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monBeforeBWC_ymax = 0.05;
#line 1366 "BIFROST.instr"
  mccL_monBeforeBWC_xwidth = 0.2;
#line 1367 "BIFROST.instr"
  mccL_monBeforeBWC_yheight = 0.2;
#line 1367 "BIFROST.instr"
  mccL_monBeforeBWC_Lmin = lambda_0 / 2.0;
#line 1367 "BIFROST.instr"
  mccL_monBeforeBWC_Lmax = lambda_1 * 2.0;
#line 1366 "BIFROST.instr"
  mccL_monBeforeBWC_restore_neutron = 1;
#line 27230 "BIFROST.c"

  SIG_MESSAGE("L_monBeforeBWC (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27237 "BIFROST.c"
  rot_mul(mctr1, mcrotastraight_guide_2_1, mcrotaL_monBeforeBWC);
  rot_transpose(mcrotastraight_guide_2_1, mctr1);
  rot_mul(mcrotaL_monBeforeBWC, mctr1, mcrotrL_monBeforeBWC);
  mctc1 = coords_set(
#line 1368 "BIFROST.instr"
    0,
#line 1368 "BIFROST.instr"
    0,
#line 1368 "BIFROST.instr"
    mcipchopBWPos - startXposition_straight - BW_chopGap / 2 + u);
#line 27248 "BIFROST.c"
  rot_transpose(mcrotastraight_guide_2_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monBeforeBWC = coords_add(mcposastraight_guide_2_1, mctc2);
  mctc1 = coords_sub(mcposastraight_guide_2_1, mcposaL_monBeforeBWC);
  mcposrL_monBeforeBWC = rot_apply(mcrotaL_monBeforeBWC, mctc1);
  mcDEBUG_COMPONENT("L_monBeforeBWC", mcposaL_monBeforeBWC, mcrotaL_monBeforeBWC)
  mccomp_posa[75] = mcposaL_monBeforeBWC;
  mccomp_posr[75] = mcposrL_monBeforeBWC;
  mcNCounter[75]  = mcPCounter[75] = mcP2Counter[75] = 0;
  mcAbsorbProp[75]= 0;
    /* Component ToFBeforeBWC. */
  /* Setting parameters for component ToFBeforeBWC. */
  SIG_MESSAGE("ToFBeforeBWC (Init:SetPar)");
#line 1371 "BIFROST.instr"
  if("ToFBeforeBWC.dat") strncpy(mccToFBeforeBWC_filename, "ToFBeforeBWC.dat" ? "ToFBeforeBWC.dat" : "", 16384); else mccToFBeforeBWC_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFBeforeBWC_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeBWC_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeBWC_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFBeforeBWC_ymax = 0.05;
#line 1371 "BIFROST.instr"
  mccToFBeforeBWC_xwidth = 0.2;
#line 1372 "BIFROST.instr"
  mccToFBeforeBWC_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFBeforeBWC_tmin = 0;
#line 1372 "BIFROST.instr"
  mccToFBeforeBWC_tmax = 5.5 * 72.0 * 1e6 / v_0;
#line 47 "BIFROST.instr"
  mccToFBeforeBWC_dt = 1.0;
#line 1371 "BIFROST.instr"
  mccToFBeforeBWC_restore_neutron = 1;
#line 27284 "BIFROST.c"

  SIG_MESSAGE("ToFBeforeBWC (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27291 "BIFROST.c"
  rot_mul(mctr1, mcrotaL_monBeforeBWC, mcrotaToFBeforeBWC);
  rot_transpose(mcrotaL_monBeforeBWC, mctr1);
  rot_mul(mcrotaToFBeforeBWC, mctr1, mcrotrToFBeforeBWC);
  mctc1 = coords_set(
#line 1373 "BIFROST.instr"
    0,
#line 1373 "BIFROST.instr"
    0,
#line 1373 "BIFROST.instr"
    u);
#line 27302 "BIFROST.c"
  rot_transpose(mcrotaL_monBeforeBWC, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFBeforeBWC = coords_add(mcposaL_monBeforeBWC, mctc2);
  mctc1 = coords_sub(mcposaL_monBeforeBWC, mcposaToFBeforeBWC);
  mcposrToFBeforeBWC = rot_apply(mcrotaToFBeforeBWC, mctc1);
  mcDEBUG_COMPONENT("ToFBeforeBWC", mcposaToFBeforeBWC, mcrotaToFBeforeBWC)
  mccomp_posa[76] = mcposaToFBeforeBWC;
  mccomp_posr[76] = mcposrToFBeforeBWC;
  mcNCounter[76]  = mcPCounter[76] = mcP2Counter[76] = 0;
  mcAbsorbProp[76]= 0;
    /* Component BWC1. */
  /* Setting parameters for component BWC1. */
  SIG_MESSAGE("BWC1 (Init:SetPar)");
#line 1376 "BIFROST.instr"
  mccBWC1_theta_0 = mcipBWopen;
#line 1376 "BIFROST.instr"
  mccBWC1_radius = 0.35;
#line 1376 "BIFROST.instr"
  mccBWC1_yheight = 0.086;
#line 1376 "BIFROST.instr"
  mccBWC1_nu = 14;
#line 1376 "BIFROST.instr"
  mccBWC1_nslit = 1;
#line 56 "BIFROST.instr"
  mccBWC1_jitter = 0;
#line 1377 "BIFROST.instr"
  mccBWC1_delay = chopBWOffset;
#line 56 "BIFROST.instr"
  mccBWC1_isfirst = 0;
#line 56 "BIFROST.instr"
  mccBWC1_n_pulse = 1;
#line 56 "BIFROST.instr"
  mccBWC1_abs_out = 1;
#line 56 "BIFROST.instr"
  mccBWC1_phase = 0;
#line 56 "BIFROST.instr"
  mccBWC1_xwidth = 0;
#line 56 "BIFROST.instr"
  mccBWC1_verbose = 0;
#line 27342 "BIFROST.c"

  SIG_MESSAGE("BWC1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27349 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFBeforeBWC, mcrotaBWC1);
  rot_transpose(mcrotaToFBeforeBWC, mctr1);
  rot_mul(mcrotaBWC1, mctr1, mcrotrBWC1);
  mctc1 = coords_set(
#line 1379 "BIFROST.instr"
    0,
#line 1379 "BIFROST.instr"
    0,
#line 1379 "BIFROST.instr"
    BW_chopGap / 2 + u);
#line 27360 "BIFROST.c"
  rot_transpose(mcrotaToFBeforeBWC, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBWC1 = coords_add(mcposaToFBeforeBWC, mctc2);
  mctc1 = coords_sub(mcposaToFBeforeBWC, mcposaBWC1);
  mcposrBWC1 = rot_apply(mcrotaBWC1, mctc1);
  mcDEBUG_COMPONENT("BWC1", mcposaBWC1, mcrotaBWC1)
  mccomp_posa[77] = mcposaBWC1;
  mccomp_posr[77] = mcposrBWC1;
  mcNCounter[77]  = mcPCounter[77] = mcP2Counter[77] = 0;
  mcAbsorbProp[77]= 0;
    /* Component BWC2. */
  /* Setting parameters for component BWC2. */
  SIG_MESSAGE("BWC2 (Init:SetPar)");
#line 1382 "BIFROST.instr"
  mccBWC2_theta_0 = mcipBWopen;
#line 1382 "BIFROST.instr"
  mccBWC2_radius = 0.35;
#line 1382 "BIFROST.instr"
  mccBWC2_yheight = 0.086;
#line 1382 "BIFROST.instr"
  mccBWC2_nu = -14;
#line 1382 "BIFROST.instr"
  mccBWC2_nslit = 1;
#line 56 "BIFROST.instr"
  mccBWC2_jitter = 0;
#line 1383 "BIFROST.instr"
  mccBWC2_delay = chopBWOffset;
#line 56 "BIFROST.instr"
  mccBWC2_isfirst = 0;
#line 56 "BIFROST.instr"
  mccBWC2_n_pulse = 1;
#line 56 "BIFROST.instr"
  mccBWC2_abs_out = 1;
#line 56 "BIFROST.instr"
  mccBWC2_phase = 0;
#line 56 "BIFROST.instr"
  mccBWC2_xwidth = 0;
#line 56 "BIFROST.instr"
  mccBWC2_verbose = 0;
#line 27400 "BIFROST.c"

  SIG_MESSAGE("BWC2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27407 "BIFROST.c"
  rot_mul(mctr1, mcrotaBWC1, mcrotaBWC2);
  rot_transpose(mcrotaBWC1, mctr1);
  rot_mul(mcrotaBWC2, mctr1, mcrotrBWC2);
  mctc1 = coords_set(
#line 1385 "BIFROST.instr"
    0,
#line 1385 "BIFROST.instr"
    0,
#line 1385 "BIFROST.instr"
    u);
#line 27418 "BIFROST.c"
  rot_transpose(mcrotaBWC1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBWC2 = coords_add(mcposaBWC1, mctc2);
  mctc1 = coords_sub(mcposaBWC1, mcposaBWC2);
  mcposrBWC2 = rot_apply(mcrotaBWC2, mctc1);
  mcDEBUG_COMPONENT("BWC2", mcposaBWC2, mcrotaBWC2)
  mccomp_posa[78] = mcposaBWC2;
  mccomp_posr[78] = mcposrBWC2;
  mcNCounter[78]  = mcPCounter[78] = mcP2Counter[78] = 0;
  mcAbsorbProp[78]= 0;
    /* Component ToFAfterBWC. */
  /* Setting parameters for component ToFAfterBWC. */
  SIG_MESSAGE("ToFAfterBWC (Init:SetPar)");
#line 1388 "BIFROST.instr"
  if("ToFAfterBWC.dat") strncpy(mccToFAfterBWC_filename, "ToFAfterBWC.dat" ? "ToFAfterBWC.dat" : "", 16384); else mccToFAfterBWC_filename[0]='\0';
#line 46 "BIFROST.instr"
  mccToFAfterBWC_xmin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterBWC_xmax = 0.05;
#line 46 "BIFROST.instr"
  mccToFAfterBWC_ymin = -0.05;
#line 46 "BIFROST.instr"
  mccToFAfterBWC_ymax = 0.05;
#line 1388 "BIFROST.instr"
  mccToFAfterBWC_xwidth = 0.2;
#line 1389 "BIFROST.instr"
  mccToFAfterBWC_yheight = 0.2;
#line 47 "BIFROST.instr"
  mccToFAfterBWC_tmin = 0;
#line 1389 "BIFROST.instr"
  mccToFAfterBWC_tmax = 5.5 * 72.0 * 1.0e6 / v_0;
#line 47 "BIFROST.instr"
  mccToFAfterBWC_dt = 1.0;
#line 1388 "BIFROST.instr"
  mccToFAfterBWC_restore_neutron = 1;
#line 27454 "BIFROST.c"

  SIG_MESSAGE("ToFAfterBWC (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27461 "BIFROST.c"
  rot_mul(mctr1, mcrotaBWC2, mcrotaToFAfterBWC);
  rot_transpose(mcrotaBWC2, mctr1);
  rot_mul(mcrotaToFAfterBWC, mctr1, mcrotrToFAfterBWC);
  mctc1 = coords_set(
#line 1390 "BIFROST.instr"
    0,
#line 1390 "BIFROST.instr"
    0,
#line 1390 "BIFROST.instr"
    u);
#line 27472 "BIFROST.c"
  rot_transpose(mcrotaBWC2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaToFAfterBWC = coords_add(mcposaBWC2, mctc2);
  mctc1 = coords_sub(mcposaBWC2, mcposaToFAfterBWC);
  mcposrToFAfterBWC = rot_apply(mcrotaToFAfterBWC, mctc1);
  mcDEBUG_COMPONENT("ToFAfterBWC", mcposaToFAfterBWC, mcrotaToFAfterBWC)
  mccomp_posa[79] = mcposaToFAfterBWC;
  mccomp_posr[79] = mcposrToFAfterBWC;
  mcNCounter[79]  = mcPCounter[79] = mcP2Counter[79] = 0;
  mcAbsorbProp[79]= 0;
    /* Component L_monAfterBWC. */
  /* Setting parameters for component L_monAfterBWC. */
  SIG_MESSAGE("L_monAfterBWC (Init:SetPar)");
#line 1393 "BIFROST.instr"
  if("L_monAfterBWC.dat") strncpy(mccL_monAfterBWC_filename, "L_monAfterBWC.dat" ? "L_monAfterBWC.dat" : "", 16384); else mccL_monAfterBWC_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccL_monAfterBWC_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterBWC_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterBWC_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccL_monAfterBWC_ymax = 0.05;
#line 1393 "BIFROST.instr"
  mccL_monAfterBWC_xwidth = 0.2;
#line 1394 "BIFROST.instr"
  mccL_monAfterBWC_yheight = 0.2;
#line 1394 "BIFROST.instr"
  mccL_monAfterBWC_Lmin = lambda_0 / 2.0;
#line 1394 "BIFROST.instr"
  mccL_monAfterBWC_Lmax = lambda_1 * 2.0;
#line 1393 "BIFROST.instr"
  mccL_monAfterBWC_restore_neutron = 1;
#line 27506 "BIFROST.c"

  SIG_MESSAGE("L_monAfterBWC (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27513 "BIFROST.c"
  rot_mul(mctr1, mcrotaToFAfterBWC, mcrotaL_monAfterBWC);
  rot_transpose(mcrotaToFAfterBWC, mctr1);
  rot_mul(mcrotaL_monAfterBWC, mctr1, mcrotrL_monAfterBWC);
  mctc1 = coords_set(
#line 1395 "BIFROST.instr"
    0,
#line 1395 "BIFROST.instr"
    0,
#line 1395 "BIFROST.instr"
    u);
#line 27524 "BIFROST.c"
  rot_transpose(mcrotaToFAfterBWC, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaL_monAfterBWC = coords_add(mcposaToFAfterBWC, mctc2);
  mctc1 = coords_sub(mcposaToFAfterBWC, mcposaL_monAfterBWC);
  mcposrL_monAfterBWC = rot_apply(mcrotaL_monAfterBWC, mctc1);
  mcDEBUG_COMPONENT("L_monAfterBWC", mcposaL_monAfterBWC, mcrotaL_monAfterBWC)
  mccomp_posa[80] = mcposaL_monAfterBWC;
  mccomp_posr[80] = mcposrL_monAfterBWC;
  mcNCounter[80]  = mcPCounter[80] = mcP2Counter[80] = 0;
  mcAbsorbProp[80]= 0;
    /* Component straight_guide_2_2. */
  /* Setting parameters for component straight_guide_2_2. */
  SIG_MESSAGE("straight_guide_2_2 (Init:SetPar)");
#line 1398 "BIFROST.instr"
  mccstraight_guide_2_2_w1 = 0.060000;
#line 1399 "BIFROST.instr"
  mccstraight_guide_2_2_h1 = 0.090000;
#line 1398 "BIFROST.instr"
  mccstraight_guide_2_2_w2 = 0.060000;
#line 1399 "BIFROST.instr"
  mccstraight_guide_2_2_h2 = 0.090000;
#line 1397 "BIFROST.instr"
  mccstraight_guide_2_2_l = length2 - mcipchopBWPos + startXposition_straight - BW_chopGap / 2;
#line 1400 "BIFROST.instr"
  mccstraight_guide_2_2_R0 = 0.990000;
#line 1400 "BIFROST.instr"
  mccstraight_guide_2_2_Qc = 0.021700;
#line 1401 "BIFROST.instr"
  mccstraight_guide_2_2_alpha = 3.100000;
#line 114 "BIFROST.instr"
  mccstraight_guide_2_2_m = 1.0;
#line 1401 "BIFROST.instr"
  mccstraight_guide_2_2_W = 0.003000;
#line 114 "BIFROST.instr"
  mccstraight_guide_2_2_nslit = 1;
#line 114 "BIFROST.instr"
  mccstraight_guide_2_2_d = 0.0005;
#line 1402 "BIFROST.instr"
  mccstraight_guide_2_2_mleft = 1.500000;
#line 1402 "BIFROST.instr"
  mccstraight_guide_2_2_mright = 1.500000;
#line 1403 "BIFROST.instr"
  mccstraight_guide_2_2_mtop = 1.000000;
#line 1403 "BIFROST.instr"
  mccstraight_guide_2_2_mbottom = 1.000000;
#line 115 "BIFROST.instr"
  mccstraight_guide_2_2_nhslit = 1;
#line 1397 "BIFROST.instr"
  mccstraight_guide_2_2_G = -9.82;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_2_aleft = -1;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_2_aright = -1;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_2_atop = -1;
#line 116 "BIFROST.instr"
  mccstraight_guide_2_2_abottom = -1;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_2_wavy = 0;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_2_wavy_z = 0;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_2_wavy_tb = 0;
#line 117 "BIFROST.instr"
  mccstraight_guide_2_2_wavy_lr = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_2_chamfers = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_2_chamfers_z = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_2_chamfers_lr = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_2_chamfers_tb = 0;
#line 118 "BIFROST.instr"
  mccstraight_guide_2_2_nelements = 1;
#line 119 "BIFROST.instr"
  mccstraight_guide_2_2_nu = 0;
#line 119 "BIFROST.instr"
  mccstraight_guide_2_2_phase = 0;
#line 119 "BIFROST.instr"
  if("NULL") strncpy(mccstraight_guide_2_2_reflect, "NULL" ? "NULL" : "", 16384); else mccstraight_guide_2_2_reflect[0]='\0';
#line 27606 "BIFROST.c"

  SIG_MESSAGE("straight_guide_2_2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1405 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1405 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1405 "BIFROST.instr"
    (0)*DEG2RAD);
#line 27616 "BIFROST.c"
  rot_mul(mctr1, mcrotaL_monAfterBWC, mcrotastraight_guide_2_2);
  rot_transpose(mcrotaL_monAfterBWC, mctr1);
  rot_mul(mcrotastraight_guide_2_2, mctr1, mcrotrstraight_guide_2_2);
  mctc1 = coords_set(
#line 1404 "BIFROST.instr"
    0,
#line 1404 "BIFROST.instr"
    0,
#line 1404 "BIFROST.instr"
    BW_chopGap / 2);
#line 27627 "BIFROST.c"
  rot_transpose(mcrotaL_monAfterBWC, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposastraight_guide_2_2 = coords_add(mcposaL_monAfterBWC, mctc2);
  mctc1 = coords_sub(mcposaL_monAfterBWC, mcposastraight_guide_2_2);
  mcposrstraight_guide_2_2 = rot_apply(mcrotastraight_guide_2_2, mctc1);
  mcDEBUG_COMPONENT("straight_guide_2_2", mcposastraight_guide_2_2, mcrotastraight_guide_2_2)
  mccomp_posa[81] = mcposastraight_guide_2_2;
  mccomp_posr[81] = mcposrstraight_guide_2_2;
  mcNCounter[81]  = mcPCounter[81] = mcP2Counter[81] = 0;
  mcAbsorbProp[81]= 0;
    /* Component EndOfelement_2. */
  /* Setting parameters for component EndOfelement_2. */
  SIG_MESSAGE("EndOfelement_2 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27647 "BIFROST.c"
  rot_mul(mctr1, mcrotastraight_guide_2_2, mcrotaEndOfelement_2);
  rot_transpose(mcrotastraight_guide_2_2, mctr1);
  rot_mul(mcrotaEndOfelement_2, mctr1, mcrotrEndOfelement_2);
  mctc1 = coords_set(
#line 1409 "BIFROST.instr"
    0,
#line 1409 "BIFROST.instr"
    0,
#line 1409 "BIFROST.instr"
    length2 - mcipchopBWPos + startXposition_straight - BW_chopGap / 2 + u);
#line 27658 "BIFROST.c"
  rot_transpose(mcrotastraight_guide_2_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_2 = coords_add(mcposastraight_guide_2_2, mctc2);
  mctc1 = coords_sub(mcposastraight_guide_2_2, mcposaEndOfelement_2);
  mcposrEndOfelement_2 = rot_apply(mcrotaEndOfelement_2, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_2", mcposaEndOfelement_2, mcrotaEndOfelement_2)
  mccomp_posa[82] = mcposaEndOfelement_2;
  mccomp_posr[82] = mcposrEndOfelement_2;
  mcNCounter[82]  = mcPCounter[82] = mcP2Counter[82] = 0;
  mcAbsorbProp[82]= 0;
    /* Component elliptical_guide_gravity1_1. */
  /* Setting parameters for component elliptical_guide_gravity1_1. */
  SIG_MESSAGE("elliptical_guide_gravity1_1 (Init:SetPar)");
#line 1417 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_l = length1 - DivSlit3Pos - DivSlit3Gap / 2.0 + sample_dist;
#line 1420 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_xwidth = 2 * smallaxis_x1;
#line 1420 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_yheight = 2 * smallaxis_y1;
#line 1417 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_linxw = Linx1;
#line 1418 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_loutxw = Loutx1 + DivSlit3Pos + DivSlit3Gap / 2.0 - sample_dist;
#line 1418 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_linyh = Liny1;
#line 1419 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_loutyh = Louty1 + DivSlit3Pos + DivSlit3Gap / 2.0 - sample_dist;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_majorAxisxw = 0;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_minorAxisxw = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_majorAxisyh = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_minorAxisyh = 0;
#line 167 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_majorAxisoffsetxw = 0;
#line 168 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_majorAxisoffsetyh = 0;
#line 1420 "BIFROST.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_1_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_1_dimensionsAt[0]='\0';
#line 170 "BIFROST.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_1_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_1_option[0]='\0';
#line 1421 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_R0 = 0.990000;
#line 1421 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_Qc = 0.021700;
#line 1421 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_alpha = 3.100000;
#line 171 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_m = 2;
#line 1421 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_W = 0.003000;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_alpharight = -1;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_mright = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_alphaleft = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_mleft = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_alphatop = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_mtop = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_alphabottom = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_mbottom = -1;
#line 176 "BIFROST.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_1_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_1_verbose[0]='\0';
#line 177 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_enableGravity = 1.0;
#line 178 "BIFROST.instr"
  mccelliptical_guide_gravity1_1_curvature = 0;
#line 27734 "BIFROST.c"

  SIG_MESSAGE("elliptical_guide_gravity1_1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1423 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1423 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1423 "BIFROST.instr"
    (0)*DEG2RAD);
#line 27744 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaelliptical_guide_gravity1_1);
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_1, mctr1, mcrotrelliptical_guide_gravity1_1);
  mctc1 = coords_set(
#line 1422 "BIFROST.instr"
    0,
#line 1422 "BIFROST.instr"
    0,
#line 1422 "BIFROST.instr"
    u);
#line 27755 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_1 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_2, mcposaelliptical_guide_gravity1_1);
  mcposrelliptical_guide_gravity1_1 = rot_apply(mcrotaelliptical_guide_gravity1_1, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_1", mcposaelliptical_guide_gravity1_1, mcrotaelliptical_guide_gravity1_1)
  mccomp_posa[83] = mcposaelliptical_guide_gravity1_1;
  mccomp_posr[83] = mcposrelliptical_guide_gravity1_1;
  mcNCounter[83]  = mcPCounter[83] = mcP2Counter[83] = 0;
  mcAbsorbProp[83]= 0;
    /* Component DiwJaw3. */
  /* Setting parameters for component DiwJaw3. */
  SIG_MESSAGE("DiwJaw3 (Init:SetPar)");
#line 43 "BIFROST.instr"
  mccDiwJaw3_xmin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw3_xmax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw3_ymin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw3_ymax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw3_radius = 0;
#line 1426 "BIFROST.instr"
  mccDiwJaw3_xwidth = mcipDivSlit3_width;
#line 1426 "BIFROST.instr"
  mccDiwJaw3_yheight = 1;
#line 27783 "BIFROST.c"

  SIG_MESSAGE("DiwJaw3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27790 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw3);
  rot_transpose(mcrotaelliptical_guide_gravity1_1, mctr1);
  rot_mul(mcrotaDiwJaw3, mctr1, mcrotrDiwJaw3);
  mctc1 = coords_set(
#line 1427 "BIFROST.instr"
    0,
#line 1427 "BIFROST.instr"
    0,
#line 1427 "BIFROST.instr"
    2 * u + length1 - ( DivSlit3Pos - sample_dist ));
#line 27801 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw3 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_1, mcposaDiwJaw3);
  mcposrDiwJaw3 = rot_apply(mcrotaDiwJaw3, mctc1);
  mcDEBUG_COMPONENT("DiwJaw3", mcposaDiwJaw3, mcrotaDiwJaw3)
  mccomp_posa[84] = mcposaDiwJaw3;
  mccomp_posr[84] = mcposrDiwJaw3;
  mcNCounter[84]  = mcPCounter[84] = mcP2Counter[84] = 0;
  mcAbsorbProp[84]= 0;
    /* Component elliptical_guide_gravity1_2. */
  /* Setting parameters for component elliptical_guide_gravity1_2. */
  SIG_MESSAGE("elliptical_guide_gravity1_2 (Init:SetPar)");
#line 1430 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_l = DivSlit3Pos - DivSlit2Gap / 2.0 - DivSlit3Gap / 2.0 - DivSlit2Pos;
#line 1433 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_xwidth = 2 * smallaxis_x1;
#line 1433 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_yheight = 2 * smallaxis_y1;
#line 1430 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_linxw = Linx1 + length1 - ( DivSlit3Pos - DivSlit3Gap / 2.0 - sample_dist );
#line 1431 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_loutxw = Loutx1 + DivSlit2Pos + DivSlit2Gap / 2.0 - sample_dist;
#line 1431 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_linyh = Liny1 + length1 - ( DivSlit3Pos - DivSlit3Gap / 2.0 - sample_dist );
#line 1432 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_loutyh = Louty1 + DivSlit2Pos + DivSlit2Gap / 2.0 - sample_dist;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_majorAxisxw = 0;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_minorAxisxw = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_majorAxisyh = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_minorAxisyh = 0;
#line 167 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_majorAxisoffsetxw = 0;
#line 168 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_majorAxisoffsetyh = 0;
#line 1433 "BIFROST.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_2_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_2_dimensionsAt[0]='\0';
#line 170 "BIFROST.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_2_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_2_option[0]='\0';
#line 1434 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_R0 = 0.990000;
#line 1434 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_Qc = 0.021700;
#line 1434 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_alpha = 3.100000;
#line 171 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_m = 2;
#line 1434 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_W = 0.003000;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_alpharight = -1;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_mright = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_alphaleft = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_mleft = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_alphatop = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_mtop = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_alphabottom = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_mbottom = -1;
#line 176 "BIFROST.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_2_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_2_verbose[0]='\0';
#line 177 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_enableGravity = 1.0;
#line 178 "BIFROST.instr"
  mccelliptical_guide_gravity1_2_curvature = 0;
#line 27877 "BIFROST.c"

  SIG_MESSAGE("elliptical_guide_gravity1_2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1436 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1436 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1436 "BIFROST.instr"
    (0)*DEG2RAD);
#line 27887 "BIFROST.c"
  rot_mul(mctr1, mcrotaDiwJaw3, mcrotaelliptical_guide_gravity1_2);
  rot_transpose(mcrotaDiwJaw3, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_2, mctr1, mcrotrelliptical_guide_gravity1_2);
  mctc1 = coords_set(
#line 1435 "BIFROST.instr"
    0,
#line 1435 "BIFROST.instr"
    0,
#line 1435 "BIFROST.instr"
    3 * u + length1 - ( DivSlit3Pos - DivSlit3Gap / 2.0 - sample_dist ));
#line 27898 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_2 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw3, mcposaelliptical_guide_gravity1_2);
  mcposrelliptical_guide_gravity1_2 = rot_apply(mcrotaelliptical_guide_gravity1_2, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_2", mcposaelliptical_guide_gravity1_2, mcrotaelliptical_guide_gravity1_2)
  mccomp_posa[85] = mcposaelliptical_guide_gravity1_2;
  mccomp_posr[85] = mcposrelliptical_guide_gravity1_2;
  mcNCounter[85]  = mcPCounter[85] = mcP2Counter[85] = 0;
  mcAbsorbProp[85]= 0;
    /* Component DiwJaw2. */
  /* Setting parameters for component DiwJaw2. */
  SIG_MESSAGE("DiwJaw2 (Init:SetPar)");
#line 43 "BIFROST.instr"
  mccDiwJaw2_xmin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw2_xmax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw2_ymin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw2_ymax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw2_radius = 0;
#line 1439 "BIFROST.instr"
  mccDiwJaw2_xwidth = mcipDivSlit2_width;
#line 1439 "BIFROST.instr"
  mccDiwJaw2_yheight = 1;
#line 27926 "BIFROST.c"

  SIG_MESSAGE("DiwJaw2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27933 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw2);
  rot_transpose(mcrotaelliptical_guide_gravity1_2, mctr1);
  rot_mul(mcrotaDiwJaw2, mctr1, mcrotrDiwJaw2);
  mctc1 = coords_set(
#line 1440 "BIFROST.instr"
    0,
#line 1440 "BIFROST.instr"
    0,
#line 1440 "BIFROST.instr"
    u + length1 - ( DivSlit2Pos - sample_dist ));
#line 27944 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw2 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_2, mcposaDiwJaw2);
  mcposrDiwJaw2 = rot_apply(mcrotaDiwJaw2, mctc1);
  mcDEBUG_COMPONENT("DiwJaw2", mcposaDiwJaw2, mcrotaDiwJaw2)
  mccomp_posa[86] = mcposaDiwJaw2;
  mccomp_posr[86] = mcposrDiwJaw2;
  mcNCounter[86]  = mcPCounter[86] = mcP2Counter[86] = 0;
  mcAbsorbProp[86]= 0;
    /* Component elliptical_guide_gravity1_3. */
  /* Setting parameters for component elliptical_guide_gravity1_3. */
  SIG_MESSAGE("elliptical_guide_gravity1_3 (Init:SetPar)");
#line 1443 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_l = DivSlit2Pos - DivSlit1Gap / 2.0 - DivSlit2Gap / 2.0 - DivSlit1Pos;
#line 1446 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_xwidth = 2 * smallaxis_x1;
#line 1446 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_yheight = 2 * smallaxis_y1;
#line 1443 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_linxw = Linx1 + length1 - ( DivSlit2Pos - DivSlit2Gap / 2.0 - sample_dist );
#line 1444 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_loutxw = Loutx1 + DivSlit1Pos + DivSlit1Gap / 2.0 - sample_dist;
#line 1444 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_linyh = Liny1 + length1 - ( DivSlit2Pos - DivSlit2Gap / 2.0 - sample_dist );
#line 1445 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_loutyh = Louty1 + DivSlit1Pos + DivSlit1Gap / 2.0 - sample_dist;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_majorAxisxw = 0;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_minorAxisxw = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_majorAxisyh = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_minorAxisyh = 0;
#line 167 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_majorAxisoffsetxw = 0;
#line 168 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_majorAxisoffsetyh = 0;
#line 1446 "BIFROST.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_3_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_3_dimensionsAt[0]='\0';
#line 170 "BIFROST.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_3_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_3_option[0]='\0';
#line 1447 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_R0 = 0.990000;
#line 1447 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_Qc = 0.021700;
#line 1447 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_alpha = 3.100000;
#line 171 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_m = 2;
#line 1447 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_W = 0.003000;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_alpharight = -1;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_mright = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_alphaleft = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_mleft = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_alphatop = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_mtop = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_alphabottom = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_mbottom = -1;
#line 176 "BIFROST.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_3_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_3_verbose[0]='\0';
#line 177 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_enableGravity = 1.0;
#line 178 "BIFROST.instr"
  mccelliptical_guide_gravity1_3_curvature = 0;
#line 28020 "BIFROST.c"

  SIG_MESSAGE("elliptical_guide_gravity1_3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1449 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1449 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1449 "BIFROST.instr"
    (0)*DEG2RAD);
#line 28030 "BIFROST.c"
  rot_mul(mctr1, mcrotaDiwJaw2, mcrotaelliptical_guide_gravity1_3);
  rot_transpose(mcrotaDiwJaw2, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_3, mctr1, mcrotrelliptical_guide_gravity1_3);
  mctc1 = coords_set(
#line 1448 "BIFROST.instr"
    0,
#line 1448 "BIFROST.instr"
    0,
#line 1448 "BIFROST.instr"
    4 * u + length1 - ( DivSlit2Pos - DivSlit2Gap / 2.0 - sample_dist ));
#line 28041 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_3 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw2, mcposaelliptical_guide_gravity1_3);
  mcposrelliptical_guide_gravity1_3 = rot_apply(mcrotaelliptical_guide_gravity1_3, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_3", mcposaelliptical_guide_gravity1_3, mcrotaelliptical_guide_gravity1_3)
  mccomp_posa[87] = mcposaelliptical_guide_gravity1_3;
  mccomp_posr[87] = mcposrelliptical_guide_gravity1_3;
  mcNCounter[87]  = mcPCounter[87] = mcP2Counter[87] = 0;
  mcAbsorbProp[87]= 0;
    /* Component DiwJaw1. */
  /* Setting parameters for component DiwJaw1. */
  SIG_MESSAGE("DiwJaw1 (Init:SetPar)");
#line 43 "BIFROST.instr"
  mccDiwJaw1_xmin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw1_xmax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw1_ymin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw1_ymax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw1_radius = 0;
#line 1452 "BIFROST.instr"
  mccDiwJaw1_xwidth = mcipDivSlit1_width;
#line 1452 "BIFROST.instr"
  mccDiwJaw1_yheight = 1;
#line 28069 "BIFROST.c"

  SIG_MESSAGE("DiwJaw1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28076 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw1);
  rot_transpose(mcrotaelliptical_guide_gravity1_3, mctr1);
  rot_mul(mcrotaDiwJaw1, mctr1, mcrotrDiwJaw1);
  mctc1 = coords_set(
#line 1453 "BIFROST.instr"
    0,
#line 1453 "BIFROST.instr"
    0,
#line 1453 "BIFROST.instr"
    5 * u + length1 - ( DivSlit1Pos - sample_dist ));
#line 28087 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw1 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_3, mcposaDiwJaw1);
  mcposrDiwJaw1 = rot_apply(mcrotaDiwJaw1, mctc1);
  mcDEBUG_COMPONENT("DiwJaw1", mcposaDiwJaw1, mcrotaDiwJaw1)
  mccomp_posa[88] = mcposaDiwJaw1;
  mccomp_posr[88] = mcposrDiwJaw1;
  mcNCounter[88]  = mcPCounter[88] = mcP2Counter[88] = 0;
  mcAbsorbProp[88]= 0;
    /* Component elliptical_guide_gravity1_4. */
  /* Setting parameters for component elliptical_guide_gravity1_4. */
  SIG_MESSAGE("elliptical_guide_gravity1_4 (Init:SetPar)");
#line 1456 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_l = DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist;
#line 1458 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_xwidth = 2 * smallaxis_x1;
#line 1458 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_yheight = 2 * smallaxis_y1;
#line 1456 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_linxw = Linx1 + length1 - ( DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist );
#line 1457 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_loutxw = Loutx1;
#line 1457 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_linyh = Liny1 + length1 - ( DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist );
#line 1457 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_loutyh = Louty1;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_majorAxisxw = 0;
#line 165 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_minorAxisxw = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_majorAxisyh = 0;
#line 166 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_minorAxisyh = 0;
#line 167 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_majorAxisoffsetxw = 0;
#line 168 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_majorAxisoffsetyh = 0;
#line 1458 "BIFROST.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_4_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_4_dimensionsAt[0]='\0';
#line 170 "BIFROST.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_4_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_4_option[0]='\0';
#line 1459 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_R0 = 0.990000;
#line 1459 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_Qc = 0.021700;
#line 1459 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_alpha = 3.100000;
#line 171 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_m = 2;
#line 1459 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_W = 0.003000;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_alpharight = -1;
#line 172 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_mright = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_alphaleft = -1;
#line 173 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_mleft = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_alphatop = -1;
#line 174 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_mtop = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_alphabottom = -1;
#line 175 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_mbottom = -1;
#line 176 "BIFROST.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_4_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_4_verbose[0]='\0';
#line 177 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_enableGravity = 1.0;
#line 178 "BIFROST.instr"
  mccelliptical_guide_gravity1_4_curvature = 0;
#line 28163 "BIFROST.c"

  SIG_MESSAGE("elliptical_guide_gravity1_4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1461 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1461 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1461 "BIFROST.instr"
    (0)*DEG2RAD);
#line 28173 "BIFROST.c"
  rot_mul(mctr1, mcrotaDiwJaw1, mcrotaelliptical_guide_gravity1_4);
  rot_transpose(mcrotaDiwJaw1, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_4, mctr1, mcrotrelliptical_guide_gravity1_4);
  mctc1 = coords_set(
#line 1460 "BIFROST.instr"
    0,
#line 1460 "BIFROST.instr"
    0,
#line 1460 "BIFROST.instr"
    6 * u + length1 - ( DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist ));
#line 28184 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_4 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw1, mcposaelliptical_guide_gravity1_4);
  mcposrelliptical_guide_gravity1_4 = rot_apply(mcrotaelliptical_guide_gravity1_4, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_4", mcposaelliptical_guide_gravity1_4, mcrotaelliptical_guide_gravity1_4)
  mccomp_posa[89] = mcposaelliptical_guide_gravity1_4;
  mccomp_posr[89] = mcposrelliptical_guide_gravity1_4;
  mcNCounter[89]  = mcPCounter[89] = mcP2Counter[89] = 0;
  mcAbsorbProp[89]= 0;
    /* Component EndOfelement_1. */
  /* Setting parameters for component EndOfelement_1. */
  SIG_MESSAGE("EndOfelement_1 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28204 "BIFROST.c"
  rot_mul(mctr1, mcrotaelliptical_guide_gravity1_4, mcrotaEndOfelement_1);
  rot_transpose(mcrotaelliptical_guide_gravity1_4, mctr1);
  rot_mul(mcrotaEndOfelement_1, mctr1, mcrotrEndOfelement_1);
  mctc1 = coords_set(
#line 1464 "BIFROST.instr"
    0,
#line 1464 "BIFROST.instr"
    0,
#line 1464 "BIFROST.instr"
    DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist + u);
#line 28215 "BIFROST.c"
  rot_transpose(mcrotaelliptical_guide_gravity1_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_1 = coords_add(mcposaelliptical_guide_gravity1_4, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_4, mcposaEndOfelement_1);
  mcposrEndOfelement_1 = rot_apply(mcrotaEndOfelement_1, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_1", mcposaEndOfelement_1, mcrotaEndOfelement_1)
  mccomp_posa[90] = mcposaEndOfelement_1;
  mccomp_posr[90] = mcposrEndOfelement_1;
  mcNCounter[90]  = mcPCounter[90] = mcP2Counter[90] = 0;
  mcAbsorbProp[90]= 0;
    /* Component VirtualOutput. */
  /* Setting parameters for component VirtualOutput. */
  SIG_MESSAGE("VirtualOutput (Init:SetPar)");
#line 1467 "BIFROST.instr"
  if("VirtualOutput_endOfGuide.dat") strncpy(mccVirtualOutput_filename, "VirtualOutput_endOfGuide.dat" ? "VirtualOutput_endOfGuide.dat" : "", 16384); else mccVirtualOutput_filename[0]='\0';
#line 61 "BIFROST.instr"
  mccVirtualOutput_bufsize = 0;
#line 28233 "BIFROST.c"

  SIG_MESSAGE("VirtualOutput (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28240 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_1, mcrotaVirtualOutput);
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  rot_mul(mcrotaVirtualOutput, mctr1, mcrotrVirtualOutput);
  mctc1 = coords_set(
#line 1468 "BIFROST.instr"
    0,
#line 1468 "BIFROST.instr"
    0,
#line 1468 "BIFROST.instr"
    u);
#line 28251 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaVirtualOutput = coords_add(mcposaEndOfelement_1, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_1, mcposaVirtualOutput);
  mcposrVirtualOutput = rot_apply(mcrotaVirtualOutput, mctc1);
  mcDEBUG_COMPONENT("VirtualOutput", mcposaVirtualOutput, mcrotaVirtualOutput)
  mccomp_posa[91] = mcposaVirtualOutput;
  mccomp_posr[91] = mcposrVirtualOutput;
  mcNCounter[91]  = mcPCounter[91] = mcP2Counter[91] = 0;
  mcAbsorbProp[91]= 0;
    /* Component DiwJaw0. */
  /* Setting parameters for component DiwJaw0. */
  SIG_MESSAGE("DiwJaw0 (Init:SetPar)");
#line 43 "BIFROST.instr"
  mccDiwJaw0_xmin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw0_xmax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw0_ymin = -0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw0_ymax = 0.01;
#line 43 "BIFROST.instr"
  mccDiwJaw0_radius = 0;
#line 1472 "BIFROST.instr"
  mccDiwJaw0_xwidth = mcipDivSlit0_width;
#line 1472 "BIFROST.instr"
  mccDiwJaw0_yheight = 1;
#line 28279 "BIFROST.c"

  SIG_MESSAGE("DiwJaw0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28286 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw0);
  rot_transpose(mcrotaVirtualOutput, mctr1);
  rot_mul(mcrotaDiwJaw0, mctr1, mcrotrDiwJaw0);
  mctc1 = coords_set(
#line 1473 "BIFROST.instr"
    0,
#line 1473 "BIFROST.instr"
    0,
#line 1473 "BIFROST.instr"
    7 * u + length1 + DivSlit0Gap / 2.0);
#line 28297 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw0 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaVirtualOutput, mcposaDiwJaw0);
  mcposrDiwJaw0 = rot_apply(mcrotaDiwJaw0, mctc1);
  mcDEBUG_COMPONENT("DiwJaw0", mcposaDiwJaw0, mcrotaDiwJaw0)
  mccomp_posa[92] = mcposaDiwJaw0;
  mccomp_posr[92] = mcposrDiwJaw0;
  mcNCounter[92]  = mcPCounter[92] = mcP2Counter[92] = 0;
  mcAbsorbProp[92]= 0;
    /* Component Lmon_guide_end. */
  /* Setting parameters for component Lmon_guide_end. */
  SIG_MESSAGE("Lmon_guide_end (Init:SetPar)");
#line 1478 "BIFROST.instr"
  if("Lmon_guide_end") strncpy(mccLmon_guide_end_filename, "Lmon_guide_end" ? "Lmon_guide_end" : "", 16384); else mccLmon_guide_end_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccLmon_guide_end_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccLmon_guide_end_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccLmon_guide_end_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccLmon_guide_end_ymax = 0.05;
#line 1478 "BIFROST.instr"
  mccLmon_guide_end_xwidth = 0.027704;
#line 1479 "BIFROST.instr"
  mccLmon_guide_end_yheight = 0.027704;
#line 1479 "BIFROST.instr"
  mccLmon_guide_end_Lmin = 0.100000;
#line 1479 "BIFROST.instr"
  mccLmon_guide_end_Lmax = 8.000000;
#line 1478 "BIFROST.instr"
  mccLmon_guide_end_restore_neutron = 1;
#line 28331 "BIFROST.c"

  SIG_MESSAGE("Lmon_guide_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28338 "BIFROST.c"
  rot_mul(mctr1, mcrotaDiwJaw0, mcrotaLmon_guide_end);
  rot_transpose(mcrotaDiwJaw0, mctr1);
  rot_mul(mcrotaLmon_guide_end, mctr1, mcrotrLmon_guide_end);
  mctc1 = coords_set(
#line 1480 "BIFROST.instr"
    0,
#line 1480 "BIFROST.instr"
    0,
#line 1480 "BIFROST.instr"
    u);
#line 28349 "BIFROST.c"
  rot_transpose(mcrotaDiwJaw0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaLmon_guide_end = coords_add(mcposaDiwJaw0, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw0, mcposaLmon_guide_end);
  mcposrLmon_guide_end = rot_apply(mcrotaLmon_guide_end, mctc1);
  mcDEBUG_COMPONENT("Lmon_guide_end", mcposaLmon_guide_end, mcrotaLmon_guide_end)
  mccomp_posa[93] = mcposaLmon_guide_end;
  mccomp_posr[93] = mcposrLmon_guide_end;
  mcNCounter[93]  = mcPCounter[93] = mcP2Counter[93] = 0;
  mcAbsorbProp[93]= 0;
    /* Component Div2d_sample_B. */
  /* Setting parameters for component Div2d_sample_B. */
  SIG_MESSAGE("Div2d_sample_B (Init:SetPar)");
#line 1485 "BIFROST.instr"
  if("Div2d_sample_B") strncpy(mccDiv2d_sample_B_filename, "Div2d_sample_B" ? "Div2d_sample_B" : "", 16384); else mccDiv2d_sample_B_filename[0]='\0';
#line 54 "BIFROST.instr"
  mccDiv2d_sample_B_xmin = -0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_B_xmax = 0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_B_ymin = -0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_B_ymax = 0.05;
#line 1485 "BIFROST.instr"
  mccDiv2d_sample_B_xwidth = mcipsampleSizeX;
#line 1486 "BIFROST.instr"
  mccDiv2d_sample_B_yheight = mcipsampleSizeY;
#line 1486 "BIFROST.instr"
  mccDiv2d_sample_B_maxdiv_h = 0.750000;
#line 1486 "BIFROST.instr"
  mccDiv2d_sample_B_maxdiv_v = 0.750000;
#line 1486 "BIFROST.instr"
  mccDiv2d_sample_B_restore_neutron = 1;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_B_nx = 0;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_B_ny = 0;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_B_nz = 1;
#line 28389 "BIFROST.c"

  SIG_MESSAGE("Div2d_sample_B (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28396 "BIFROST.c"
  rot_mul(mctr1, mcrotaEndOfelement_1, mcrotaDiv2d_sample_B);
  rot_transpose(mcrotaLmon_guide_end, mctr1);
  rot_mul(mcrotaDiv2d_sample_B, mctr1, mcrotrDiv2d_sample_B);
  mctc1 = coords_set(
#line 1487 "BIFROST.instr"
    0,
#line 1487 "BIFROST.instr"
    0,
#line 1487 "BIFROST.instr"
    0.580000);
#line 28407 "BIFROST.c"
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiv2d_sample_B = coords_add(mcposaEndOfelement_1, mctc2);
  mctc1 = coords_sub(mcposaLmon_guide_end, mcposaDiv2d_sample_B);
  mcposrDiv2d_sample_B = rot_apply(mcrotaDiv2d_sample_B, mctc1);
  mcDEBUG_COMPONENT("Div2d_sample_B", mcposaDiv2d_sample_B, mcrotaDiv2d_sample_B)
  mccomp_posa[94] = mcposaDiv2d_sample_B;
  mccomp_posr[94] = mcposrDiv2d_sample_B;
  mcNCounter[94]  = mcPCounter[94] = mcP2Counter[94] = 0;
  mcAbsorbProp[94]= 0;
    /* Component Div2d_sample. */
  /* Setting parameters for component Div2d_sample. */
  SIG_MESSAGE("Div2d_sample (Init:SetPar)");
#line 1496 "BIFROST.instr"
  if("Div2d_sample") strncpy(mccDiv2d_sample_filename, "Div2d_sample" ? "Div2d_sample" : "", 16384); else mccDiv2d_sample_filename[0]='\0';
#line 54 "BIFROST.instr"
  mccDiv2d_sample_xmin = -0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_xmax = 0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_ymin = -0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_ymax = 0.05;
#line 1496 "BIFROST.instr"
  mccDiv2d_sample_xwidth = mcipsampleSizeX;
#line 1497 "BIFROST.instr"
  mccDiv2d_sample_yheight = mcipsampleSizeY;
#line 1497 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_h = 2.250000;
#line 1497 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_v = 2.250000;
#line 1496 "BIFROST.instr"
  mccDiv2d_sample_restore_neutron = 1;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_nx = 0;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_ny = 0;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_nz = 1;
#line 28447 "BIFROST.c"

  SIG_MESSAGE("Div2d_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28454 "BIFROST.c"
  rot_mul(mctr1, mcrotaDiv2d_sample_B, mcrotaDiv2d_sample);
  rot_transpose(mcrotaDiv2d_sample_B, mctr1);
  rot_mul(mcrotaDiv2d_sample, mctr1, mcrotrDiv2d_sample);
  mctc1 = coords_set(
#line 1498 "BIFROST.instr"
    0,
#line 1498 "BIFROST.instr"
    0,
#line 1498 "BIFROST.instr"
    u);
#line 28465 "BIFROST.c"
  rot_transpose(mcrotaDiv2d_sample_B, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiv2d_sample = coords_add(mcposaDiv2d_sample_B, mctc2);
  mctc1 = coords_sub(mcposaDiv2d_sample_B, mcposaDiv2d_sample);
  mcposrDiv2d_sample = rot_apply(mcrotaDiv2d_sample, mctc1);
  mcDEBUG_COMPONENT("Div2d_sample", mcposaDiv2d_sample, mcrotaDiv2d_sample)
  mccomp_posa[95] = mcposaDiv2d_sample;
  mccomp_posr[95] = mcposrDiv2d_sample;
  mcNCounter[95]  = mcPCounter[95] = mcP2Counter[95] = 0;
  mcAbsorbProp[95]= 0;
    /* Component PSD_sample. */
  /* Setting parameters for component PSD_sample. */
  SIG_MESSAGE("PSD_sample (Init:SetPar)");
#line 1501 "BIFROST.instr"
  if("PSD_sample") strncpy(mccPSD_sample_filename, "PSD_sample" ? "PSD_sample" : "", 16384); else mccPSD_sample_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_sample_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_sample_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_sample_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_sample_ymax = 0.05;
#line 1502 "BIFROST.instr"
  mccPSD_sample_xwidth = 3 * mcipsampleSizeX;
#line 1502 "BIFROST.instr"
  mccPSD_sample_yheight = 3 * mcipsampleSizeY;
#line 1501 "BIFROST.instr"
  mccPSD_sample_restore_neutron = 1;
#line 28495 "BIFROST.c"

  SIG_MESSAGE("PSD_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28502 "BIFROST.c"
  rot_mul(mctr1, mcrotaDiv2d_sample, mcrotaPSD_sample);
  rot_transpose(mcrotaDiv2d_sample, mctr1);
  rot_mul(mcrotaPSD_sample, mctr1, mcrotrPSD_sample);
  mctc1 = coords_set(
#line 1503 "BIFROST.instr"
    0,
#line 1503 "BIFROST.instr"
    0,
#line 1503 "BIFROST.instr"
    u);
#line 28513 "BIFROST.c"
  rot_transpose(mcrotaDiv2d_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_sample = coords_add(mcposaDiv2d_sample, mctc2);
  mctc1 = coords_sub(mcposaDiv2d_sample, mcposaPSD_sample);
  mcposrPSD_sample = rot_apply(mcrotaPSD_sample, mctc1);
  mcDEBUG_COMPONENT("PSD_sample", mcposaPSD_sample, mcrotaPSD_sample)
  mccomp_posa[96] = mcposaPSD_sample;
  mccomp_posr[96] = mcposrPSD_sample;
  mcNCounter[96]  = mcPCounter[96] = mcP2Counter[96] = 0;
  mcAbsorbProp[96]= 0;
    /* Component HPSD_sample. */
  /* Setting parameters for component HPSD_sample. */
  SIG_MESSAGE("HPSD_sample (Init:SetPar)");
#line 1506 "BIFROST.instr"
  if("HPSD_sample") strncpy(mccHPSD_sample_filename, "HPSD_sample" ? "HPSD_sample" : "", 16384); else mccHPSD_sample_filename[0]='\0';
#line 45 "BIFROST.instr"
  mccHPSD_sample_xmin = -0.05;
#line 45 "BIFROST.instr"
  mccHPSD_sample_xmax = 0.05;
#line 45 "BIFROST.instr"
  mccHPSD_sample_ymin = -0.05;
#line 45 "BIFROST.instr"
  mccHPSD_sample_ymax = 0.05;
#line 1506 "BIFROST.instr"
  mccHPSD_sample_xwidth = 4 * mcipsampleSizeX;
#line 1506 "BIFROST.instr"
  mccHPSD_sample_yheight = mcipsampleSizeY;
#line 1506 "BIFROST.instr"
  mccHPSD_sample_restore_neutron = 1;
#line 28543 "BIFROST.c"

  SIG_MESSAGE("HPSD_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28550 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_sample, mcrotaHPSD_sample);
  rot_transpose(mcrotaPSD_sample, mctr1);
  rot_mul(mcrotaHPSD_sample, mctr1, mcrotrHPSD_sample);
  mctc1 = coords_set(
#line 1507 "BIFROST.instr"
    0,
#line 1507 "BIFROST.instr"
    0,
#line 1507 "BIFROST.instr"
    u);
#line 28561 "BIFROST.c"
  rot_transpose(mcrotaPSD_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaHPSD_sample = coords_add(mcposaPSD_sample, mctc2);
  mctc1 = coords_sub(mcposaPSD_sample, mcposaHPSD_sample);
  mcposrHPSD_sample = rot_apply(mcrotaHPSD_sample, mctc1);
  mcDEBUG_COMPONENT("HPSD_sample", mcposaHPSD_sample, mcrotaHPSD_sample)
  mccomp_posa[97] = mcposaHPSD_sample;
  mccomp_posr[97] = mcposrHPSD_sample;
  mcNCounter[97]  = mcPCounter[97] = mcP2Counter[97] = 0;
  mcAbsorbProp[97]= 0;
    /* Component VPSD_sample. */
  /* Setting parameters for component VPSD_sample. */
  SIG_MESSAGE("VPSD_sample (Init:SetPar)");
#line 46 "BIFROST.instr"
  mccVPSD_sample_xmin = 0;
#line 46 "BIFROST.instr"
  mccVPSD_sample_xmax = 0;
#line 46 "BIFROST.instr"
  mccVPSD_sample_ymin = 0;
#line 46 "BIFROST.instr"
  mccVPSD_sample_ymax = 0;
#line 1510 "BIFROST.instr"
  mccVPSD_sample_xwidth = mcipsampleSizeX;
#line 1510 "BIFROST.instr"
  mccVPSD_sample_yheight = 4 * mcipsampleSizeY;
#line 1510 "BIFROST.instr"
  mccVPSD_sample_restore_neutron = 1;
#line 28589 "BIFROST.c"

  SIG_MESSAGE("VPSD_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28596 "BIFROST.c"
  rot_mul(mctr1, mcrotaHPSD_sample, mcrotaVPSD_sample);
  rot_transpose(mcrotaHPSD_sample, mctr1);
  rot_mul(mcrotaVPSD_sample, mctr1, mcrotrVPSD_sample);
  mctc1 = coords_set(
#line 1511 "BIFROST.instr"
    0,
#line 1511 "BIFROST.instr"
    0,
#line 1511 "BIFROST.instr"
    u);
#line 28607 "BIFROST.c"
  rot_transpose(mcrotaHPSD_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaVPSD_sample = coords_add(mcposaHPSD_sample, mctc2);
  mctc1 = coords_sub(mcposaHPSD_sample, mcposaVPSD_sample);
  mcposrVPSD_sample = rot_apply(mcrotaVPSD_sample, mctc1);
  mcDEBUG_COMPONENT("VPSD_sample", mcposaVPSD_sample, mcrotaVPSD_sample)
  mccomp_posa[98] = mcposaVPSD_sample;
  mccomp_posr[98] = mcposrVPSD_sample;
  mcNCounter[98]  = mcPCounter[98] = mcP2Counter[98] = 0;
  mcAbsorbProp[98]= 0;
    /* Component Hdiv_sample. */
  /* Setting parameters for component Hdiv_sample. */
  SIG_MESSAGE("Hdiv_sample (Init:SetPar)");
#line 1514 "BIFROST.instr"
  if("Hdiv_sample") strncpy(mccHdiv_sample_filename, "Hdiv_sample" ? "Hdiv_sample" : "", 16384); else mccHdiv_sample_filename[0]='\0';
#line 50 "BIFROST.instr"
  mccHdiv_sample_xmin = -0.05;
#line 50 "BIFROST.instr"
  mccHdiv_sample_xmax = 0.05;
#line 50 "BIFROST.instr"
  mccHdiv_sample_ymin = -0.05;
#line 50 "BIFROST.instr"
  mccHdiv_sample_ymax = 0.05;
#line 1514 "BIFROST.instr"
  mccHdiv_sample_xwidth = mcipsampleSizeX;
#line 1515 "BIFROST.instr"
  mccHdiv_sample_yheight = mcipsampleSizeY;
#line 1515 "BIFROST.instr"
  mccHdiv_sample_h_maxdiv = 2.250000;
#line 1515 "BIFROST.instr"
  mccHdiv_sample_restore_neutron = 1;
#line 28639 "BIFROST.c"

  SIG_MESSAGE("Hdiv_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28646 "BIFROST.c"
  rot_mul(mctr1, mcrotaVPSD_sample, mcrotaHdiv_sample);
  rot_transpose(mcrotaVPSD_sample, mctr1);
  rot_mul(mcrotaHdiv_sample, mctr1, mcrotrHdiv_sample);
  mctc1 = coords_set(
#line 1516 "BIFROST.instr"
    0,
#line 1516 "BIFROST.instr"
    0,
#line 1516 "BIFROST.instr"
    u);
#line 28657 "BIFROST.c"
  rot_transpose(mcrotaVPSD_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaHdiv_sample = coords_add(mcposaVPSD_sample, mctc2);
  mctc1 = coords_sub(mcposaVPSD_sample, mcposaHdiv_sample);
  mcposrHdiv_sample = rot_apply(mcrotaHdiv_sample, mctc1);
  mcDEBUG_COMPONENT("Hdiv_sample", mcposaHdiv_sample, mcrotaHdiv_sample)
  mccomp_posa[99] = mcposaHdiv_sample;
  mccomp_posr[99] = mcposrHdiv_sample;
  mcNCounter[99]  = mcPCounter[99] = mcP2Counter[99] = 0;
  mcAbsorbProp[99]= 0;
    /* Component Vdiv_sample. */
  /* Setting parameters for component Vdiv_sample. */
  SIG_MESSAGE("Vdiv_sample (Init:SetPar)");
#line 53 "BIFROST.instr"
  mccVdiv_sample_xmin = 0;
#line 53 "BIFROST.instr"
  mccVdiv_sample_xmax = 0;
#line 53 "BIFROST.instr"
  mccVdiv_sample_ymin = 0;
#line 53 "BIFROST.instr"
  mccVdiv_sample_ymax = 0;
#line 1519 "BIFROST.instr"
  mccVdiv_sample_xwidth = mcipsampleSizeX;
#line 1520 "BIFROST.instr"
  mccVdiv_sample_yheight = mcipsampleSizeY;
#line 1520 "BIFROST.instr"
  mccVdiv_sample_v_maxdiv = 2.250000;
#line 28685 "BIFROST.c"

  SIG_MESSAGE("Vdiv_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28692 "BIFROST.c"
  rot_mul(mctr1, mcrotaHdiv_sample, mcrotaVdiv_sample);
  rot_transpose(mcrotaHdiv_sample, mctr1);
  rot_mul(mcrotaVdiv_sample, mctr1, mcrotrVdiv_sample);
  mctc1 = coords_set(
#line 1521 "BIFROST.instr"
    0,
#line 1521 "BIFROST.instr"
    0,
#line 1521 "BIFROST.instr"
    u);
#line 28703 "BIFROST.c"
  rot_transpose(mcrotaHdiv_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaVdiv_sample = coords_add(mcposaHdiv_sample, mctc2);
  mctc1 = coords_sub(mcposaHdiv_sample, mcposaVdiv_sample);
  mcposrVdiv_sample = rot_apply(mcrotaVdiv_sample, mctc1);
  mcDEBUG_COMPONENT("Vdiv_sample", mcposaVdiv_sample, mcrotaVdiv_sample)
  mccomp_posa[100] = mcposaVdiv_sample;
  mccomp_posr[100] = mcposrVdiv_sample;
  mcNCounter[100]  = mcPCounter[100] = mcP2Counter[100] = 0;
  mcAbsorbProp[100]= 0;
    /* Component acceptance_x_divx. */
  /* Setting parameters for component acceptance_x_divx. */
  SIG_MESSAGE("acceptance_x_divx (Init:SetPar)");
#line 1524 "BIFROST.instr"
  if("acceptance_x_divx") strncpy(mccacceptance_x_divx_filename, "acceptance_x_divx" ? "acceptance_x_divx" : "", 16384); else mccacceptance_x_divx_filename[0]='\0';
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_xmin = -0.05;
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_xmax = 0.05;
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_ymin = -0.05;
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_ymax = 0.05;
#line 1525 "BIFROST.instr"
  mccacceptance_x_divx_xwidth = 2 * mcipsampleSizeX;
#line 1525 "BIFROST.instr"
  mccacceptance_x_divx_yheight = mcipsampleSizeY;
#line 1525 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_h = 1.500000;
#line 1525 "BIFROST.instr"
  mccacceptance_x_divx_restore_neutron = 1;
#line 55 "BIFROST.instr"
  mccacceptance_x_divx_nx = 0;
#line 55 "BIFROST.instr"
  mccacceptance_x_divx_ny = 0;
#line 55 "BIFROST.instr"
  mccacceptance_x_divx_nz = 1;
#line 28741 "BIFROST.c"

  SIG_MESSAGE("acceptance_x_divx (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28748 "BIFROST.c"
  rot_mul(mctr1, mcrotaVdiv_sample, mcrotaacceptance_x_divx);
  rot_transpose(mcrotaVdiv_sample, mctr1);
  rot_mul(mcrotaacceptance_x_divx, mctr1, mcrotracceptance_x_divx);
  mctc1 = coords_set(
#line 1526 "BIFROST.instr"
    0,
#line 1526 "BIFROST.instr"
    0,
#line 1526 "BIFROST.instr"
    u);
#line 28759 "BIFROST.c"
  rot_transpose(mcrotaVdiv_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaacceptance_x_divx = coords_add(mcposaVdiv_sample, mctc2);
  mctc1 = coords_sub(mcposaVdiv_sample, mcposaacceptance_x_divx);
  mcposracceptance_x_divx = rot_apply(mcrotaacceptance_x_divx, mctc1);
  mcDEBUG_COMPONENT("acceptance_x_divx", mcposaacceptance_x_divx, mcrotaacceptance_x_divx)
  mccomp_posa[101] = mcposaacceptance_x_divx;
  mccomp_posr[101] = mcposracceptance_x_divx;
  mcNCounter[101]  = mcPCounter[101] = mcP2Counter[101] = 0;
  mcAbsorbProp[101]= 0;
    /* Component acceptance_y_divy. */
  /* Setting parameters for component acceptance_y_divy. */
  SIG_MESSAGE("acceptance_y_divy (Init:SetPar)");
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_xmin = 0;
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_xmax = 0;
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_ymin = 0;
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_ymax = 0;
#line 1530 "BIFROST.instr"
  mccacceptance_y_divy_xwidth = mcipsampleSizeX;
#line 1530 "BIFROST.instr"
  mccacceptance_y_divy_yheight = 2 * mcipsampleSizeY;
#line 1530 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv = 1.500000;
#line 28787 "BIFROST.c"

  SIG_MESSAGE("acceptance_y_divy (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28794 "BIFROST.c"
  rot_mul(mctr1, mcrotaacceptance_x_divx, mcrotaacceptance_y_divy);
  rot_transpose(mcrotaacceptance_x_divx, mctr1);
  rot_mul(mcrotaacceptance_y_divy, mctr1, mcrotracceptance_y_divy);
  mctc1 = coords_set(
#line 1531 "BIFROST.instr"
    0,
#line 1531 "BIFROST.instr"
    0,
#line 1531 "BIFROST.instr"
    u);
#line 28805 "BIFROST.c"
  rot_transpose(mcrotaacceptance_x_divx, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaacceptance_y_divy = coords_add(mcposaacceptance_x_divx, mctc2);
  mctc1 = coords_sub(mcposaacceptance_x_divx, mcposaacceptance_y_divy);
  mcposracceptance_y_divy = rot_apply(mcrotaacceptance_y_divy, mctc1);
  mcDEBUG_COMPONENT("acceptance_y_divy", mcposaacceptance_y_divy, mcrotaacceptance_y_divy)
  mccomp_posa[102] = mcposaacceptance_y_divy;
  mccomp_posr[102] = mcposracceptance_y_divy;
  mcNCounter[102]  = mcPCounter[102] = mcP2Counter[102] = 0;
  mcAbsorbProp[102]= 0;
    /* Component Lmon_sample_B. */
  /* Setting parameters for component Lmon_sample_B. */
  SIG_MESSAGE("Lmon_sample_B (Init:SetPar)");
#line 1534 "BIFROST.instr"
  if("Lmon_sample_B") strncpy(mccLmon_sample_B_filename, "Lmon_sample_B" ? "Lmon_sample_B" : "", 16384); else mccLmon_sample_B_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccLmon_sample_B_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccLmon_sample_B_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccLmon_sample_B_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccLmon_sample_B_ymax = 0.05;
#line 1534 "BIFROST.instr"
  mccLmon_sample_B_xwidth = 0.010000;
#line 1535 "BIFROST.instr"
  mccLmon_sample_B_yheight = 0.010000;
#line 1535 "BIFROST.instr"
  mccLmon_sample_B_Lmin = mcipsampleSizeY;
#line 1535 "BIFROST.instr"
  mccLmon_sample_B_Lmax = 8.000000;
#line 1534 "BIFROST.instr"
  mccLmon_sample_B_restore_neutron = 1;
#line 28839 "BIFROST.c"

  SIG_MESSAGE("Lmon_sample_B (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28846 "BIFROST.c"
  rot_mul(mctr1, mcrotaacceptance_y_divy, mcrotaLmon_sample_B);
  rot_transpose(mcrotaacceptance_y_divy, mctr1);
  rot_mul(mcrotaLmon_sample_B, mctr1, mcrotrLmon_sample_B);
  mctc1 = coords_set(
#line 1536 "BIFROST.instr"
    0,
#line 1536 "BIFROST.instr"
    0,
#line 1536 "BIFROST.instr"
    u);
#line 28857 "BIFROST.c"
  rot_transpose(mcrotaacceptance_y_divy, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaLmon_sample_B = coords_add(mcposaacceptance_y_divy, mctc2);
  mctc1 = coords_sub(mcposaacceptance_y_divy, mcposaLmon_sample_B);
  mcposrLmon_sample_B = rot_apply(mcrotaLmon_sample_B, mctc1);
  mcDEBUG_COMPONENT("Lmon_sample_B", mcposaLmon_sample_B, mcrotaLmon_sample_B)
  mccomp_posa[103] = mcposaLmon_sample_B;
  mccomp_posr[103] = mcposrLmon_sample_B;
  mcNCounter[103]  = mcPCounter[103] = mcP2Counter[103] = 0;
  mcAbsorbProp[103]= 0;
    /* Component Div2d_sample_maxdiv. */
  /* Setting parameters for component Div2d_sample_maxdiv. */
  SIG_MESSAGE("Div2d_sample_maxdiv (Init:SetPar)");
#line 1539 "BIFROST.instr"
  if("Div2d_sample_maxdiv") strncpy(mccDiv2d_sample_maxdiv_filename, "Div2d_sample_maxdiv" ? "Div2d_sample_maxdiv" : "", 16384); else mccDiv2d_sample_maxdiv_filename[0]='\0';
#line 54 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_xmin = -0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_xmax = 0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_ymin = -0.05;
#line 54 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_ymax = 0.05;
#line 1539 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_xwidth = mcipsampleSizeX;
#line 1540 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_yheight = mcipsampleSizeY;
#line 1540 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_maxdiv_h = 2.250000;
#line 1540 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_maxdiv_v = 2.250000;
#line 1539 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_restore_neutron = 1;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_nx = 0;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_ny = 0;
#line 55 "BIFROST.instr"
  mccDiv2d_sample_maxdiv_nz = 1;
#line 28897 "BIFROST.c"

  SIG_MESSAGE("Div2d_sample_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28904 "BIFROST.c"
  rot_mul(mctr1, mcrotaLmon_sample_B, mcrotaDiv2d_sample_maxdiv);
  rot_transpose(mcrotaLmon_sample_B, mctr1);
  rot_mul(mcrotaDiv2d_sample_maxdiv, mctr1, mcrotrDiv2d_sample_maxdiv);
  mctc1 = coords_set(
#line 1541 "BIFROST.instr"
    0,
#line 1541 "BIFROST.instr"
    0,
#line 1541 "BIFROST.instr"
    u);
#line 28915 "BIFROST.c"
  rot_transpose(mcrotaLmon_sample_B, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiv2d_sample_maxdiv = coords_add(mcposaLmon_sample_B, mctc2);
  mctc1 = coords_sub(mcposaLmon_sample_B, mcposaDiv2d_sample_maxdiv);
  mcposrDiv2d_sample_maxdiv = rot_apply(mcrotaDiv2d_sample_maxdiv, mctc1);
  mcDEBUG_COMPONENT("Div2d_sample_maxdiv", mcposaDiv2d_sample_maxdiv, mcrotaDiv2d_sample_maxdiv)
  mccomp_posa[104] = mcposaDiv2d_sample_maxdiv;
  mccomp_posr[104] = mcposrDiv2d_sample_maxdiv;
  mcNCounter[104]  = mcPCounter[104] = mcP2Counter[104] = 0;
  mcAbsorbProp[104]= 0;
    /* Component PSD_sample_maxdiv. */
  /* Setting parameters for component PSD_sample_maxdiv. */
  SIG_MESSAGE("PSD_sample_maxdiv (Init:SetPar)");
#line 1544 "BIFROST.instr"
  if("PSD_sample_maxdiv") strncpy(mccPSD_sample_maxdiv_filename, "PSD_sample_maxdiv" ? "PSD_sample_maxdiv" : "", 16384); else mccPSD_sample_maxdiv_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccPSD_sample_maxdiv_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_sample_maxdiv_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccPSD_sample_maxdiv_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccPSD_sample_maxdiv_ymax = 0.05;
#line 1545 "BIFROST.instr"
  mccPSD_sample_maxdiv_xwidth = 3 * mcipsampleSizeX;
#line 1545 "BIFROST.instr"
  mccPSD_sample_maxdiv_yheight = 3 * mcipsampleSizeY;
#line 1544 "BIFROST.instr"
  mccPSD_sample_maxdiv_restore_neutron = 1;
#line 28945 "BIFROST.c"

  SIG_MESSAGE("PSD_sample_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28952 "BIFROST.c"
  rot_mul(mctr1, mcrotaDiv2d_sample_maxdiv, mcrotaPSD_sample_maxdiv);
  rot_transpose(mcrotaDiv2d_sample_maxdiv, mctr1);
  rot_mul(mcrotaPSD_sample_maxdiv, mctr1, mcrotrPSD_sample_maxdiv);
  mctc1 = coords_set(
#line 1546 "BIFROST.instr"
    0,
#line 1546 "BIFROST.instr"
    0,
#line 1546 "BIFROST.instr"
    u);
#line 28963 "BIFROST.c"
  rot_transpose(mcrotaDiv2d_sample_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_sample_maxdiv = coords_add(mcposaDiv2d_sample_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaDiv2d_sample_maxdiv, mcposaPSD_sample_maxdiv);
  mcposrPSD_sample_maxdiv = rot_apply(mcrotaPSD_sample_maxdiv, mctc1);
  mcDEBUG_COMPONENT("PSD_sample_maxdiv", mcposaPSD_sample_maxdiv, mcrotaPSD_sample_maxdiv)
  mccomp_posa[105] = mcposaPSD_sample_maxdiv;
  mccomp_posr[105] = mcposrPSD_sample_maxdiv;
  mcNCounter[105]  = mcPCounter[105] = mcP2Counter[105] = 0;
  mcAbsorbProp[105]= 0;
    /* Component HPSD_sample_maxdiv. */
  /* Setting parameters for component HPSD_sample_maxdiv. */
  SIG_MESSAGE("HPSD_sample_maxdiv (Init:SetPar)");
#line 1549 "BIFROST.instr"
  if("HPSD_sample_maxdiv") strncpy(mccHPSD_sample_maxdiv_filename, "HPSD_sample_maxdiv" ? "HPSD_sample_maxdiv" : "", 16384); else mccHPSD_sample_maxdiv_filename[0]='\0';
#line 45 "BIFROST.instr"
  mccHPSD_sample_maxdiv_xmin = -0.05;
#line 45 "BIFROST.instr"
  mccHPSD_sample_maxdiv_xmax = 0.05;
#line 45 "BIFROST.instr"
  mccHPSD_sample_maxdiv_ymin = -0.05;
#line 45 "BIFROST.instr"
  mccHPSD_sample_maxdiv_ymax = 0.05;
#line 1549 "BIFROST.instr"
  mccHPSD_sample_maxdiv_xwidth = 4 * mcipsampleSizeX;
#line 1549 "BIFROST.instr"
  mccHPSD_sample_maxdiv_yheight = mcipsampleSizeY;
#line 1549 "BIFROST.instr"
  mccHPSD_sample_maxdiv_restore_neutron = 1;
#line 28993 "BIFROST.c"

  SIG_MESSAGE("HPSD_sample_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29000 "BIFROST.c"
  rot_mul(mctr1, mcrotaPSD_sample_maxdiv, mcrotaHPSD_sample_maxdiv);
  rot_transpose(mcrotaPSD_sample_maxdiv, mctr1);
  rot_mul(mcrotaHPSD_sample_maxdiv, mctr1, mcrotrHPSD_sample_maxdiv);
  mctc1 = coords_set(
#line 1551 "BIFROST.instr"
    0,
#line 1551 "BIFROST.instr"
    0,
#line 1551 "BIFROST.instr"
    u);
#line 29011 "BIFROST.c"
  rot_transpose(mcrotaPSD_sample_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaHPSD_sample_maxdiv = coords_add(mcposaPSD_sample_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaPSD_sample_maxdiv, mcposaHPSD_sample_maxdiv);
  mcposrHPSD_sample_maxdiv = rot_apply(mcrotaHPSD_sample_maxdiv, mctc1);
  mcDEBUG_COMPONENT("HPSD_sample_maxdiv", mcposaHPSD_sample_maxdiv, mcrotaHPSD_sample_maxdiv)
  mccomp_posa[106] = mcposaHPSD_sample_maxdiv;
  mccomp_posr[106] = mcposrHPSD_sample_maxdiv;
  mcNCounter[106]  = mcPCounter[106] = mcP2Counter[106] = 0;
  mcAbsorbProp[106]= 0;
    /* Component VPSD_sample_maxdiv. */
  /* Setting parameters for component VPSD_sample_maxdiv. */
  SIG_MESSAGE("VPSD_sample_maxdiv (Init:SetPar)");
#line 46 "BIFROST.instr"
  mccVPSD_sample_maxdiv_xmin = 0;
#line 46 "BIFROST.instr"
  mccVPSD_sample_maxdiv_xmax = 0;
#line 46 "BIFROST.instr"
  mccVPSD_sample_maxdiv_ymin = 0;
#line 46 "BIFROST.instr"
  mccVPSD_sample_maxdiv_ymax = 0;
#line 1554 "BIFROST.instr"
  mccVPSD_sample_maxdiv_xwidth = mcipsampleSizeX;
#line 1554 "BIFROST.instr"
  mccVPSD_sample_maxdiv_yheight = 4 * mcipsampleSizeY;
#line 1554 "BIFROST.instr"
  mccVPSD_sample_maxdiv_restore_neutron = 1;
#line 29039 "BIFROST.c"

  SIG_MESSAGE("VPSD_sample_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29046 "BIFROST.c"
  rot_mul(mctr1, mcrotaHPSD_sample_maxdiv, mcrotaVPSD_sample_maxdiv);
  rot_transpose(mcrotaHPSD_sample_maxdiv, mctr1);
  rot_mul(mcrotaVPSD_sample_maxdiv, mctr1, mcrotrVPSD_sample_maxdiv);
  mctc1 = coords_set(
#line 1556 "BIFROST.instr"
    0,
#line 1556 "BIFROST.instr"
    0,
#line 1556 "BIFROST.instr"
    u);
#line 29057 "BIFROST.c"
  rot_transpose(mcrotaHPSD_sample_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaVPSD_sample_maxdiv = coords_add(mcposaHPSD_sample_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaHPSD_sample_maxdiv, mcposaVPSD_sample_maxdiv);
  mcposrVPSD_sample_maxdiv = rot_apply(mcrotaVPSD_sample_maxdiv, mctc1);
  mcDEBUG_COMPONENT("VPSD_sample_maxdiv", mcposaVPSD_sample_maxdiv, mcrotaVPSD_sample_maxdiv)
  mccomp_posa[107] = mcposaVPSD_sample_maxdiv;
  mccomp_posr[107] = mcposrVPSD_sample_maxdiv;
  mcNCounter[107]  = mcPCounter[107] = mcP2Counter[107] = 0;
  mcAbsorbProp[107]= 0;
    /* Component Hdiv_sample_maxdiv. */
  /* Setting parameters for component Hdiv_sample_maxdiv. */
  SIG_MESSAGE("Hdiv_sample_maxdiv (Init:SetPar)");
#line 1559 "BIFROST.instr"
  if("Hdiv_sample_maxdiv") strncpy(mccHdiv_sample_maxdiv_filename, "Hdiv_sample_maxdiv" ? "Hdiv_sample_maxdiv" : "", 16384); else mccHdiv_sample_maxdiv_filename[0]='\0';
#line 50 "BIFROST.instr"
  mccHdiv_sample_maxdiv_xmin = -0.05;
#line 50 "BIFROST.instr"
  mccHdiv_sample_maxdiv_xmax = 0.05;
#line 50 "BIFROST.instr"
  mccHdiv_sample_maxdiv_ymin = -0.05;
#line 50 "BIFROST.instr"
  mccHdiv_sample_maxdiv_ymax = 0.05;
#line 1559 "BIFROST.instr"
  mccHdiv_sample_maxdiv_xwidth = mcipsampleSizeX;
#line 1560 "BIFROST.instr"
  mccHdiv_sample_maxdiv_yheight = mcipsampleSizeY;
#line 1560 "BIFROST.instr"
  mccHdiv_sample_maxdiv_h_maxdiv = 2.250000;
#line 1559 "BIFROST.instr"
  mccHdiv_sample_maxdiv_restore_neutron = 1;
#line 29089 "BIFROST.c"

  SIG_MESSAGE("Hdiv_sample_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29096 "BIFROST.c"
  rot_mul(mctr1, mcrotaVPSD_sample_maxdiv, mcrotaHdiv_sample_maxdiv);
  rot_transpose(mcrotaVPSD_sample_maxdiv, mctr1);
  rot_mul(mcrotaHdiv_sample_maxdiv, mctr1, mcrotrHdiv_sample_maxdiv);
  mctc1 = coords_set(
#line 1561 "BIFROST.instr"
    0,
#line 1561 "BIFROST.instr"
    0,
#line 1561 "BIFROST.instr"
    u);
#line 29107 "BIFROST.c"
  rot_transpose(mcrotaVPSD_sample_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaHdiv_sample_maxdiv = coords_add(mcposaVPSD_sample_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaVPSD_sample_maxdiv, mcposaHdiv_sample_maxdiv);
  mcposrHdiv_sample_maxdiv = rot_apply(mcrotaHdiv_sample_maxdiv, mctc1);
  mcDEBUG_COMPONENT("Hdiv_sample_maxdiv", mcposaHdiv_sample_maxdiv, mcrotaHdiv_sample_maxdiv)
  mccomp_posa[108] = mcposaHdiv_sample_maxdiv;
  mccomp_posr[108] = mcposrHdiv_sample_maxdiv;
  mcNCounter[108]  = mcPCounter[108] = mcP2Counter[108] = 0;
  mcAbsorbProp[108]= 0;
    /* Component Vdiv_sample_maxdiv. */
  /* Setting parameters for component Vdiv_sample_maxdiv. */
  SIG_MESSAGE("Vdiv_sample_maxdiv (Init:SetPar)");
#line 53 "BIFROST.instr"
  mccVdiv_sample_maxdiv_xmin = 0;
#line 53 "BIFROST.instr"
  mccVdiv_sample_maxdiv_xmax = 0;
#line 53 "BIFROST.instr"
  mccVdiv_sample_maxdiv_ymin = 0;
#line 53 "BIFROST.instr"
  mccVdiv_sample_maxdiv_ymax = 0;
#line 1564 "BIFROST.instr"
  mccVdiv_sample_maxdiv_xwidth = mcipsampleSizeX;
#line 1565 "BIFROST.instr"
  mccVdiv_sample_maxdiv_yheight = mcipsampleSizeY;
#line 1565 "BIFROST.instr"
  mccVdiv_sample_maxdiv_v_maxdiv = 2.250000;
#line 29135 "BIFROST.c"

  SIG_MESSAGE("Vdiv_sample_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29142 "BIFROST.c"
  rot_mul(mctr1, mcrotaHdiv_sample_maxdiv, mcrotaVdiv_sample_maxdiv);
  rot_transpose(mcrotaHdiv_sample_maxdiv, mctr1);
  rot_mul(mcrotaVdiv_sample_maxdiv, mctr1, mcrotrVdiv_sample_maxdiv);
  mctc1 = coords_set(
#line 1566 "BIFROST.instr"
    0,
#line 1566 "BIFROST.instr"
    0,
#line 1566 "BIFROST.instr"
    u);
#line 29153 "BIFROST.c"
  rot_transpose(mcrotaHdiv_sample_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaVdiv_sample_maxdiv = coords_add(mcposaHdiv_sample_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaHdiv_sample_maxdiv, mcposaVdiv_sample_maxdiv);
  mcposrVdiv_sample_maxdiv = rot_apply(mcrotaVdiv_sample_maxdiv, mctc1);
  mcDEBUG_COMPONENT("Vdiv_sample_maxdiv", mcposaVdiv_sample_maxdiv, mcrotaVdiv_sample_maxdiv)
  mccomp_posa[109] = mcposaVdiv_sample_maxdiv;
  mccomp_posr[109] = mcposrVdiv_sample_maxdiv;
  mcNCounter[109]  = mcPCounter[109] = mcP2Counter[109] = 0;
  mcAbsorbProp[109]= 0;
    /* Component acceptance_x_divx_maxdiv. */
  /* Setting parameters for component acceptance_x_divx_maxdiv. */
  SIG_MESSAGE("acceptance_x_divx_maxdiv (Init:SetPar)");
#line 1569 "BIFROST.instr"
  if("acceptance_x_divx_maxdiv") strncpy(mccacceptance_x_divx_maxdiv_filename, "acceptance_x_divx_maxdiv" ? "acceptance_x_divx_maxdiv" : "", 16384); else mccacceptance_x_divx_maxdiv_filename[0]='\0';
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_xmin = -0.05;
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_xmax = 0.05;
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_ymin = -0.05;
#line 54 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_ymax = 0.05;
#line 1570 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_xwidth = 2 * mcipsampleSizeX;
#line 1570 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_yheight = mcipsampleSizeY;
#line 1570 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_maxdiv_h = 1.500000;
#line 1569 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_restore_neutron = 1;
#line 55 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_nx = 0;
#line 55 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_ny = 0;
#line 55 "BIFROST.instr"
  mccacceptance_x_divx_maxdiv_nz = 1;
#line 29191 "BIFROST.c"

  SIG_MESSAGE("acceptance_x_divx_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29198 "BIFROST.c"
  rot_mul(mctr1, mcrotaVdiv_sample_maxdiv, mcrotaacceptance_x_divx_maxdiv);
  rot_transpose(mcrotaVdiv_sample_maxdiv, mctr1);
  rot_mul(mcrotaacceptance_x_divx_maxdiv, mctr1, mcrotracceptance_x_divx_maxdiv);
  mctc1 = coords_set(
#line 1571 "BIFROST.instr"
    0,
#line 1571 "BIFROST.instr"
    0,
#line 1571 "BIFROST.instr"
    u);
#line 29209 "BIFROST.c"
  rot_transpose(mcrotaVdiv_sample_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaacceptance_x_divx_maxdiv = coords_add(mcposaVdiv_sample_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaVdiv_sample_maxdiv, mcposaacceptance_x_divx_maxdiv);
  mcposracceptance_x_divx_maxdiv = rot_apply(mcrotaacceptance_x_divx_maxdiv, mctc1);
  mcDEBUG_COMPONENT("acceptance_x_divx_maxdiv", mcposaacceptance_x_divx_maxdiv, mcrotaacceptance_x_divx_maxdiv)
  mccomp_posa[110] = mcposaacceptance_x_divx_maxdiv;
  mccomp_posr[110] = mcposracceptance_x_divx_maxdiv;
  mcNCounter[110]  = mcPCounter[110] = mcP2Counter[110] = 0;
  mcAbsorbProp[110]= 0;
    /* Component acceptance_y_divy_maxdiv. */
  /* Setting parameters for component acceptance_y_divy_maxdiv. */
  SIG_MESSAGE("acceptance_y_divy_maxdiv (Init:SetPar)");
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv_xmin = 0;
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv_xmax = 0;
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv_ymin = 0;
#line 53 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv_ymax = 0;
#line 1575 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv_xwidth = mcipsampleSizeX;
#line 1575 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv_yheight = 2 * mcipsampleSizeY;
#line 1575 "BIFROST.instr"
  mccacceptance_y_divy_maxdiv_maxdiv = 1.500000;
#line 29237 "BIFROST.c"

  SIG_MESSAGE("acceptance_y_divy_maxdiv (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29244 "BIFROST.c"
  rot_mul(mctr1, mcrotaacceptance_x_divx_maxdiv, mcrotaacceptance_y_divy_maxdiv);
  rot_transpose(mcrotaacceptance_x_divx_maxdiv, mctr1);
  rot_mul(mcrotaacceptance_y_divy_maxdiv, mctr1, mcrotracceptance_y_divy_maxdiv);
  mctc1 = coords_set(
#line 1576 "BIFROST.instr"
    0,
#line 1576 "BIFROST.instr"
    0,
#line 1576 "BIFROST.instr"
    u);
#line 29255 "BIFROST.c"
  rot_transpose(mcrotaacceptance_x_divx_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaacceptance_y_divy_maxdiv = coords_add(mcposaacceptance_x_divx_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaacceptance_x_divx_maxdiv, mcposaacceptance_y_divy_maxdiv);
  mcposracceptance_y_divy_maxdiv = rot_apply(mcrotaacceptance_y_divy_maxdiv, mctc1);
  mcDEBUG_COMPONENT("acceptance_y_divy_maxdiv", mcposaacceptance_y_divy_maxdiv, mcrotaacceptance_y_divy_maxdiv)
  mccomp_posa[111] = mcposaacceptance_y_divy_maxdiv;
  mccomp_posr[111] = mcposracceptance_y_divy_maxdiv;
  mcNCounter[111]  = mcPCounter[111] = mcP2Counter[111] = 0;
  mcAbsorbProp[111]= 0;
    /* Component Lmon_sample. */
  /* Setting parameters for component Lmon_sample. */
  SIG_MESSAGE("Lmon_sample (Init:SetPar)");
#line 1579 "BIFROST.instr"
  if("Lmon_sample") strncpy(mccLmon_sample_filename, "Lmon_sample" ? "Lmon_sample" : "", 16384); else mccLmon_sample_filename[0]='\0';
#line 49 "BIFROST.instr"
  mccLmon_sample_xmin = -0.05;
#line 49 "BIFROST.instr"
  mccLmon_sample_xmax = 0.05;
#line 49 "BIFROST.instr"
  mccLmon_sample_ymin = -0.05;
#line 49 "BIFROST.instr"
  mccLmon_sample_ymax = 0.05;
#line 1579 "BIFROST.instr"
  mccLmon_sample_xwidth = mcipsampleSizeX;
#line 1580 "BIFROST.instr"
  mccLmon_sample_yheight = mcipsampleSizeY;
#line 1580 "BIFROST.instr"
  mccLmon_sample_Lmin = 2;
#line 1580 "BIFROST.instr"
  mccLmon_sample_Lmax = 6;
#line 1579 "BIFROST.instr"
  mccLmon_sample_restore_neutron = 1;
#line 29289 "BIFROST.c"

  SIG_MESSAGE("Lmon_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29296 "BIFROST.c"
  rot_mul(mctr1, mcrotaacceptance_y_divy_maxdiv, mcrotaLmon_sample);
  rot_transpose(mcrotaacceptance_y_divy_maxdiv, mctr1);
  rot_mul(mcrotaLmon_sample, mctr1, mcrotrLmon_sample);
  mctc1 = coords_set(
#line 1581 "BIFROST.instr"
    0,
#line 1581 "BIFROST.instr"
    0,
#line 1581 "BIFROST.instr"
    u);
#line 29307 "BIFROST.c"
  rot_transpose(mcrotaacceptance_y_divy_maxdiv, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaLmon_sample = coords_add(mcposaacceptance_y_divy_maxdiv, mctc2);
  mctc1 = coords_sub(mcposaacceptance_y_divy_maxdiv, mcposaLmon_sample);
  mcposrLmon_sample = rot_apply(mcrotaLmon_sample, mctc1);
  mcDEBUG_COMPONENT("Lmon_sample", mcposaLmon_sample, mcrotaLmon_sample)
  mccomp_posa[112] = mcposaLmon_sample;
  mccomp_posr[112] = mcposrLmon_sample;
  mcNCounter[112]  = mcPCounter[112] = mcP2Counter[112] = 0;
  mcAbsorbProp[112]= 0;
    /* Component v_sample. */
  /* Setting parameters for component v_sample. */
  SIG_MESSAGE("v_sample (Init:SetPar)");
#line 1585 "BIFROST.instr"
  mccv_sample_radius = 0.005;
#line 1586 "BIFROST.instr"
  mccv_sample_thickness = 0.002;
#line 1587 "BIFROST.instr"
  mccv_sample_zdepth = 0.01;
#line 91 "BIFROST.instr"
  mccv_sample_Vc = 13.827;
#line 91 "BIFROST.instr"
  mccv_sample_sigma_abs = 5.08;
#line 91 "BIFROST.instr"
  mccv_sample_sigma_inc = 5.08;
#line 92 "BIFROST.instr"
  mccv_sample_radius_i = 0;
#line 92 "BIFROST.instr"
  mccv_sample_radius_o = 0;
#line 92 "BIFROST.instr"
  mccv_sample_h = 0;
#line 92 "BIFROST.instr"
  mccv_sample_focus_r = 0;
#line 92 "BIFROST.instr"
  mccv_sample_pack = 1;
#line 92 "BIFROST.instr"
  mccv_sample_frac = 1;
#line 92 "BIFROST.instr"
  mccv_sample_f_QE = 0;
#line 92 "BIFROST.instr"
  mccv_sample_gamma = 0;
#line 93 "BIFROST.instr"
  mccv_sample_target_x = 0;
#line 93 "BIFROST.instr"
  mccv_sample_target_y = 0;
#line 93 "BIFROST.instr"
  mccv_sample_target_z = 0;
#line 1588 "BIFROST.instr"
  mccv_sample_focus_xw = 0.05;
#line 1589 "BIFROST.instr"
  mccv_sample_focus_yh = 0.1;
#line 94 "BIFROST.instr"
  mccv_sample_focus_aw = 0;
#line 94 "BIFROST.instr"
  mccv_sample_focus_ah = 0;
#line 94 "BIFROST.instr"
  mccv_sample_xwidth = 0;
#line 94 "BIFROST.instr"
  mccv_sample_yheight = 0;
#line 94 "BIFROST.instr"
  mccv_sample_zthick = 0;
#line 94 "BIFROST.instr"
  mccv_sample_rad_sphere = 0;
#line 94 "BIFROST.instr"
  mccv_sample_sig_a = 0;
#line 94 "BIFROST.instr"
  mccv_sample_sig_i = 0;
#line 94 "BIFROST.instr"
  mccv_sample_V0 = 0;
#line 94 "BIFROST.instr"
  mccv_sample_target_index = 0;
#line 94 "BIFROST.instr"
  mccv_sample_multiples = 1;
#line 29381 "BIFROST.c"

  SIG_MESSAGE("v_sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29388 "BIFROST.c"
  rot_mul(mctr1, mcrotaLmon_sample, mcrotav_sample);
  rot_transpose(mcrotaLmon_sample, mctr1);
  rot_mul(mcrotav_sample, mctr1, mcrotrv_sample);
  mctc1 = coords_set(
#line 1590 "BIFROST.instr"
    0,
#line 1590 "BIFROST.instr"
    0,
#line 1590 "BIFROST.instr"
    1);
#line 29399 "BIFROST.c"
  rot_transpose(mcrotaLmon_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposav_sample = coords_add(mcposaLmon_sample, mctc2);
  mctc1 = coords_sub(mcposaLmon_sample, mcposav_sample);
  mcposrv_sample = rot_apply(mcrotav_sample, mctc1);
  mcDEBUG_COMPONENT("v_sample", mcposav_sample, mcrotav_sample)
  mccomp_posa[113] = mcposav_sample;
  mccomp_posr[113] = mcposrv_sample;
  mcNCounter[113]  = mcPCounter[113] = mcP2Counter[113] = 0;
  mcAbsorbProp[113]= 0;
    /* Component Mono_Cradle. */
  /* Setting parameters for component Mono_Cradle. */
  SIG_MESSAGE("Mono_Cradle (Init:SetPar)");

  SIG_MESSAGE("Mono_Cradle (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1594 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1594 "BIFROST.instr"
    (mcipOMA)*DEG2RAD,
#line 1594 "BIFROST.instr"
    (0)*DEG2RAD);
#line 29422 "BIFROST.c"
  rot_mul(mctr1, mcrotav_sample, mcrotaMono_Cradle);
  rot_transpose(mcrotav_sample, mctr1);
  rot_mul(mcrotaMono_Cradle, mctr1, mcrotrMono_Cradle);
  mctc1 = coords_set(
#line 1594 "BIFROST.instr"
    0.0,
#line 1594 "BIFROST.instr"
    0.0,
#line 1594 "BIFROST.instr"
    1.2);
#line 29433 "BIFROST.c"
  rot_transpose(mcrotav_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaMono_Cradle = coords_add(mcposav_sample, mctc2);
  mctc1 = coords_sub(mcposav_sample, mcposaMono_Cradle);
  mcposrMono_Cradle = rot_apply(mcrotaMono_Cradle, mctc1);
  mcDEBUG_COMPONENT("Mono_Cradle", mcposaMono_Cradle, mcrotaMono_Cradle)
  mccomp_posa[114] = mcposaMono_Cradle;
  mccomp_posr[114] = mcposrMono_Cradle;
  mcNCounter[114]  = mcPCounter[114] = mcP2Counter[114] = 0;
  mcAbsorbProp[114]= 0;
    /* Component XY_ARM. */
  /* Setting parameters for component XY_ARM. */
  SIG_MESSAGE("XY_ARM (Init:SetPar)");

  SIG_MESSAGE("XY_ARM (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29453 "BIFROST.c"
  rot_mul(mctr1, mcrotav_sample, mcrotaXY_ARM);
  rot_transpose(mcrotaMono_Cradle, mctr1);
  rot_mul(mcrotaXY_ARM, mctr1, mcrotrXY_ARM);
  mctc1 = coords_set(
#line 1597 "BIFROST.instr"
    0.0,
#line 1597 "BIFROST.instr"
    0.0,
#line 1597 "BIFROST.instr"
    1.2);
#line 29464 "BIFROST.c"
  rot_transpose(mcrotav_sample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaXY_ARM = coords_add(mcposav_sample, mctc2);
  mctc1 = coords_sub(mcposaMono_Cradle, mcposaXY_ARM);
  mcposrXY_ARM = rot_apply(mcrotaXY_ARM, mctc1);
  mcDEBUG_COMPONENT("XY_ARM", mcposaXY_ARM, mcrotaXY_ARM)
  mccomp_posa[115] = mcposaXY_ARM;
  mccomp_posr[115] = mcposrXY_ARM;
  mcNCounter[115]  = mcPCounter[115] = mcP2Counter[115] = 0;
  mcAbsorbProp[115]= 0;
    /* Component monochromator_flat. */
  /* Setting parameters for component monochromator_flat. */
  SIG_MESSAGE("monochromator_flat (Init:SetPar)");
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator_flat_reflect, "NULL" ? "NULL" : "", 16384); else mccmonochromator_flat_reflect[0]='\0';
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator_flat_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator_flat_transmit[0]='\0';
#line 1602 "BIFROST.instr"
  mccmonochromator_flat_zwidth = wi;
#line 1603 "BIFROST.instr"
  mccmonochromator_flat_yheight = 0.231;
#line 101 "BIFROST.instr"
  mccmonochromator_flat_gap = 0.0005;
#line 1604 "BIFROST.instr"
  mccmonochromator_flat_NH = 1;
#line 1605 "BIFROST.instr"
  mccmonochromator_flat_NV = 1;
#line 1600 "BIFROST.instr"
  mccmonochromator_flat_mosaich = 60;
#line 1601 "BIFROST.instr"
  mccmonochromator_flat_mosaicv = 60;
#line 1606 "BIFROST.instr"
  mccmonochromator_flat_r0 = 0.7;
#line 101 "BIFROST.instr"
  mccmonochromator_flat_t0 = 1.0;
#line 101 "BIFROST.instr"
  mccmonochromator_flat_Q = 1.8734;
#line 102 "BIFROST.instr"
  mccmonochromator_flat_RV = 0;
#line 102 "BIFROST.instr"
  mccmonochromator_flat_RH = 0;
#line 1607 "BIFROST.instr"
  mccmonochromator_flat_DM = DM;
#line 102 "BIFROST.instr"
  mccmonochromator_flat_mosaic = 0;
#line 102 "BIFROST.instr"
  mccmonochromator_flat_width = 0;
#line 102 "BIFROST.instr"
  mccmonochromator_flat_height = 0;
#line 102 "BIFROST.instr"
  mccmonochromator_flat_verbose = 0;
#line 102 "BIFROST.instr"
  mccmonochromator_flat_order = 0;
#line 29518 "BIFROST.c"

  SIG_MESSAGE("monochromator_flat (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29525 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Cradle, mcrotamonochromator_flat);
  rot_transpose(mcrotaXY_ARM, mctr1);
  rot_mul(mcrotamonochromator_flat, mctr1, mcrotrmonochromator_flat);
  mctc1 = coords_set(
#line 1608 "BIFROST.instr"
    0,
#line 1608 "BIFROST.instr"
    0,
#line 1608 "BIFROST.instr"
    0);
#line 29536 "BIFROST.c"
  rot_transpose(mcrotaMono_Cradle, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator_flat = coords_add(mcposaMono_Cradle, mctc2);
  mctc1 = coords_sub(mcposaXY_ARM, mcposamonochromator_flat);
  mcposrmonochromator_flat = rot_apply(mcrotamonochromator_flat, mctc1);
  mcDEBUG_COMPONENT("monochromator_flat", mcposamonochromator_flat, mcrotamonochromator_flat)
  mccomp_posa[116] = mcposamonochromator_flat;
  mccomp_posr[116] = mcposrmonochromator_flat;
  mcNCounter[116]  = mcPCounter[116] = mcP2Counter[116] = 0;
  mcAbsorbProp[116]= 0;
    /* Component monochromator2. */
  /* Setting parameters for component monochromator2. */
  SIG_MESSAGE("monochromator2 (Init:SetPar)");
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator2_reflect, "NULL" ? "NULL" : "", 16384); else mccmonochromator2_reflect[0]='\0';
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator2_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator2_transmit[0]='\0';
#line 1615 "BIFROST.instr"
  mccmonochromator2_zwidth = wi;
#line 1616 "BIFROST.instr"
  mccmonochromator2_yheight = 0.231;
#line 101 "BIFROST.instr"
  mccmonochromator2_gap = 0.0005;
#line 1617 "BIFROST.instr"
  mccmonochromator2_NH = 1;
#line 1618 "BIFROST.instr"
  mccmonochromator2_NV = 1;
#line 1613 "BIFROST.instr"
  mccmonochromator2_mosaich = 60;
#line 1614 "BIFROST.instr"
  mccmonochromator2_mosaicv = 60;
#line 1619 "BIFROST.instr"
  mccmonochromator2_r0 = 0.7;
#line 101 "BIFROST.instr"
  mccmonochromator2_t0 = 1.0;
#line 101 "BIFROST.instr"
  mccmonochromator2_Q = 1.8734;
#line 102 "BIFROST.instr"
  mccmonochromator2_RV = 0;
#line 102 "BIFROST.instr"
  mccmonochromator2_RH = 0;
#line 1620 "BIFROST.instr"
  mccmonochromator2_DM = DM;
#line 102 "BIFROST.instr"
  mccmonochromator2_mosaic = 0;
#line 102 "BIFROST.instr"
  mccmonochromator2_width = 0;
#line 102 "BIFROST.instr"
  mccmonochromator2_height = 0;
#line 102 "BIFROST.instr"
  mccmonochromator2_verbose = 0;
#line 102 "BIFROST.instr"
  mccmonochromator2_order = 0;
#line 29590 "BIFROST.c"

  SIG_MESSAGE("monochromator2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1621 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1621 "BIFROST.instr"
    (- mcipdphi)*DEG2RAD,
#line 1621 "BIFROST.instr"
    (0)*DEG2RAD);
#line 29600 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Cradle, mcrotamonochromator2);
  rot_transpose(mcrotamonochromator_flat, mctr1);
  rot_mul(mcrotamonochromator2, mctr1, mcrotrmonochromator2);
  mctc1 = coords_set(
#line 1621 "BIFROST.instr"
    -0.008906,
#line 1621 "BIFROST.instr"
    0,
#line 1621 "BIFROST.instr"
    -0.0104);
#line 29611 "BIFROST.c"
  rot_transpose(mcrotaXY_ARM, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator2 = coords_add(mcposaXY_ARM, mctc2);
  mctc1 = coords_sub(mcposamonochromator_flat, mcposamonochromator2);
  mcposrmonochromator2 = rot_apply(mcrotamonochromator2, mctc1);
  mcDEBUG_COMPONENT("monochromator2", mcposamonochromator2, mcrotamonochromator2)
  mccomp_posa[117] = mcposamonochromator2;
  mccomp_posr[117] = mcposrmonochromator2;
  mcNCounter[117]  = mcPCounter[117] = mcP2Counter[117] = 0;
  mcAbsorbProp[117]= 0;
    /* Component monochromator3. */
  /* Setting parameters for component monochromator3. */
  SIG_MESSAGE("monochromator3 (Init:SetPar)");
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator3_reflect, "NULL" ? "NULL" : "", 16384); else mccmonochromator3_reflect[0]='\0';
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator3_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator3_transmit[0]='\0';
#line 1626 "BIFROST.instr"
  mccmonochromator3_zwidth = wi;
#line 1627 "BIFROST.instr"
  mccmonochromator3_yheight = 0.231;
#line 101 "BIFROST.instr"
  mccmonochromator3_gap = 0.0005;
#line 1628 "BIFROST.instr"
  mccmonochromator3_NH = 1;
#line 1629 "BIFROST.instr"
  mccmonochromator3_NV = 1;
#line 1624 "BIFROST.instr"
  mccmonochromator3_mosaich = 60;
#line 1625 "BIFROST.instr"
  mccmonochromator3_mosaicv = 60;
#line 1630 "BIFROST.instr"
  mccmonochromator3_r0 = 0.7;
#line 101 "BIFROST.instr"
  mccmonochromator3_t0 = 1.0;
#line 101 "BIFROST.instr"
  mccmonochromator3_Q = 1.8734;
#line 102 "BIFROST.instr"
  mccmonochromator3_RV = 0;
#line 102 "BIFROST.instr"
  mccmonochromator3_RH = 0;
#line 1631 "BIFROST.instr"
  mccmonochromator3_DM = DM;
#line 102 "BIFROST.instr"
  mccmonochromator3_mosaic = 0;
#line 102 "BIFROST.instr"
  mccmonochromator3_width = 0;
#line 102 "BIFROST.instr"
  mccmonochromator3_height = 0;
#line 102 "BIFROST.instr"
  mccmonochromator3_verbose = 0;
#line 102 "BIFROST.instr"
  mccmonochromator3_order = 0;
#line 29665 "BIFROST.c"

  SIG_MESSAGE("monochromator3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1632 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1632 "BIFROST.instr"
    (-2 * mcipdphi)*DEG2RAD,
#line 1632 "BIFROST.instr"
    (0)*DEG2RAD);
#line 29675 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Cradle, mcrotamonochromator3);
  rot_transpose(mcrotamonochromator2, mctr1);
  rot_mul(mcrotamonochromator3, mctr1, mcrotrmonochromator3);
  mctc1 = coords_set(
#line 1632 "BIFROST.instr"
    -0.017655,
#line 1632 "BIFROST.instr"
    0,
#line 1632 "BIFROST.instr"
    -0.020935);
#line 29686 "BIFROST.c"
  rot_transpose(mcrotaXY_ARM, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator3 = coords_add(mcposaXY_ARM, mctc2);
  mctc1 = coords_sub(mcposamonochromator2, mcposamonochromator3);
  mcposrmonochromator3 = rot_apply(mcrotamonochromator3, mctc1);
  mcDEBUG_COMPONENT("monochromator3", mcposamonochromator3, mcrotamonochromator3)
  mccomp_posa[118] = mcposamonochromator3;
  mccomp_posr[118] = mcposrmonochromator3;
  mcNCounter[118]  = mcPCounter[118] = mcP2Counter[118] = 0;
  mcAbsorbProp[118]= 0;
    /* Component monochromator4. */
  /* Setting parameters for component monochromator4. */
  SIG_MESSAGE("monochromator4 (Init:SetPar)");
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator4_reflect, "NULL" ? "NULL" : "", 16384); else mccmonochromator4_reflect[0]='\0';
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator4_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator4_transmit[0]='\0';
#line 1637 "BIFROST.instr"
  mccmonochromator4_zwidth = wi;
#line 1638 "BIFROST.instr"
  mccmonochromator4_yheight = 0.231;
#line 101 "BIFROST.instr"
  mccmonochromator4_gap = 0.0005;
#line 1639 "BIFROST.instr"
  mccmonochromator4_NH = 1;
#line 1640 "BIFROST.instr"
  mccmonochromator4_NV = 1;
#line 1635 "BIFROST.instr"
  mccmonochromator4_mosaich = 60;
#line 1636 "BIFROST.instr"
  mccmonochromator4_mosaicv = 60;
#line 1641 "BIFROST.instr"
  mccmonochromator4_r0 = 0.7;
#line 101 "BIFROST.instr"
  mccmonochromator4_t0 = 1.0;
#line 101 "BIFROST.instr"
  mccmonochromator4_Q = 1.8734;
#line 102 "BIFROST.instr"
  mccmonochromator4_RV = 0;
#line 102 "BIFROST.instr"
  mccmonochromator4_RH = 0;
#line 1642 "BIFROST.instr"
  mccmonochromator4_DM = DM;
#line 102 "BIFROST.instr"
  mccmonochromator4_mosaic = 0;
#line 102 "BIFROST.instr"
  mccmonochromator4_width = 0;
#line 102 "BIFROST.instr"
  mccmonochromator4_height = 0;
#line 102 "BIFROST.instr"
  mccmonochromator4_verbose = 0;
#line 102 "BIFROST.instr"
  mccmonochromator4_order = 0;
#line 29740 "BIFROST.c"

  SIG_MESSAGE("monochromator4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1643 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1643 "BIFROST.instr"
    (-3 * mcipdphi)*DEG2RAD,
#line 1643 "BIFROST.instr"
    (0)*DEG2RAD);
#line 29750 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Cradle, mcrotamonochromator4);
  rot_transpose(mcrotamonochromator3, mctr1);
  rot_mul(mcrotamonochromator4, mctr1, mcrotrmonochromator4);
  mctc1 = coords_set(
#line 1643 "BIFROST.instr"
    -0.026246,
#line 1643 "BIFROST.instr"
    0,
#line 1643 "BIFROST.instr"
    -0.031598);
#line 29761 "BIFROST.c"
  rot_transpose(mcrotaXY_ARM, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator4 = coords_add(mcposaXY_ARM, mctc2);
  mctc1 = coords_sub(mcposamonochromator3, mcposamonochromator4);
  mcposrmonochromator4 = rot_apply(mcrotamonochromator4, mctc1);
  mcDEBUG_COMPONENT("monochromator4", mcposamonochromator4, mcrotamonochromator4)
  mccomp_posa[119] = mcposamonochromator4;
  mccomp_posr[119] = mcposrmonochromator4;
  mcNCounter[119]  = mcPCounter[119] = mcP2Counter[119] = 0;
  mcAbsorbProp[119]= 0;
    /* Component monochromator5. */
  /* Setting parameters for component monochromator5. */
  SIG_MESSAGE("monochromator5 (Init:SetPar)");
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator5_reflect, "NULL" ? "NULL" : "", 16384); else mccmonochromator5_reflect[0]='\0';
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator5_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator5_transmit[0]='\0';
#line 1648 "BIFROST.instr"
  mccmonochromator5_zwidth = wi;
#line 1649 "BIFROST.instr"
  mccmonochromator5_yheight = 0.231;
#line 101 "BIFROST.instr"
  mccmonochromator5_gap = 0.0005;
#line 1650 "BIFROST.instr"
  mccmonochromator5_NH = 1;
#line 1651 "BIFROST.instr"
  mccmonochromator5_NV = 1;
#line 1646 "BIFROST.instr"
  mccmonochromator5_mosaich = 60;
#line 1647 "BIFROST.instr"
  mccmonochromator5_mosaicv = 60;
#line 1652 "BIFROST.instr"
  mccmonochromator5_r0 = 0.7;
#line 101 "BIFROST.instr"
  mccmonochromator5_t0 = 1.0;
#line 101 "BIFROST.instr"
  mccmonochromator5_Q = 1.8734;
#line 102 "BIFROST.instr"
  mccmonochromator5_RV = 0;
#line 102 "BIFROST.instr"
  mccmonochromator5_RH = 0;
#line 1653 "BIFROST.instr"
  mccmonochromator5_DM = DM;
#line 102 "BIFROST.instr"
  mccmonochromator5_mosaic = 0;
#line 102 "BIFROST.instr"
  mccmonochromator5_width = 0;
#line 102 "BIFROST.instr"
  mccmonochromator5_height = 0;
#line 102 "BIFROST.instr"
  mccmonochromator5_verbose = 0;
#line 102 "BIFROST.instr"
  mccmonochromator5_order = 0;
#line 29815 "BIFROST.c"

  SIG_MESSAGE("monochromator5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1654 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1654 "BIFROST.instr"
    (mcipdphi)*DEG2RAD,
#line 1654 "BIFROST.instr"
    (0)*DEG2RAD);
#line 29825 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Cradle, mcrotamonochromator5);
  rot_transpose(mcrotamonochromator4, mctr1);
  rot_mul(mcrotamonochromator5, mctr1, mcrotrmonochromator5);
  mctc1 = coords_set(
#line 1654 "BIFROST.instr"
    0.009061,
#line 1654 "BIFROST.instr"
    0,
#line 1654 "BIFROST.instr"
    0.010267);
#line 29836 "BIFROST.c"
  rot_transpose(mcrotaXY_ARM, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator5 = coords_add(mcposaXY_ARM, mctc2);
  mctc1 = coords_sub(mcposamonochromator4, mcposamonochromator5);
  mcposrmonochromator5 = rot_apply(mcrotamonochromator5, mctc1);
  mcDEBUG_COMPONENT("monochromator5", mcposamonochromator5, mcrotamonochromator5)
  mccomp_posa[120] = mcposamonochromator5;
  mccomp_posr[120] = mcposrmonochromator5;
  mcNCounter[120]  = mcPCounter[120] = mcP2Counter[120] = 0;
  mcAbsorbProp[120]= 0;
    /* Component monochromator6. */
  /* Setting parameters for component monochromator6. */
  SIG_MESSAGE("monochromator6 (Init:SetPar)");
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator6_reflect, "NULL" ? "NULL" : "", 16384); else mccmonochromator6_reflect[0]='\0';
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator6_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator6_transmit[0]='\0';
#line 1659 "BIFROST.instr"
  mccmonochromator6_zwidth = wi;
#line 1660 "BIFROST.instr"
  mccmonochromator6_yheight = 0.231;
#line 101 "BIFROST.instr"
  mccmonochromator6_gap = 0.0005;
#line 1661 "BIFROST.instr"
  mccmonochromator6_NH = 1;
#line 1662 "BIFROST.instr"
  mccmonochromator6_NV = 1;
#line 1657 "BIFROST.instr"
  mccmonochromator6_mosaich = 60;
#line 1658 "BIFROST.instr"
  mccmonochromator6_mosaicv = 60;
#line 1663 "BIFROST.instr"
  mccmonochromator6_r0 = 0.7;
#line 101 "BIFROST.instr"
  mccmonochromator6_t0 = 1.0;
#line 101 "BIFROST.instr"
  mccmonochromator6_Q = 1.8734;
#line 102 "BIFROST.instr"
  mccmonochromator6_RV = 0;
#line 102 "BIFROST.instr"
  mccmonochromator6_RH = 0;
#line 1664 "BIFROST.instr"
  mccmonochromator6_DM = DM;
#line 102 "BIFROST.instr"
  mccmonochromator6_mosaic = 0;
#line 102 "BIFROST.instr"
  mccmonochromator6_width = 0;
#line 102 "BIFROST.instr"
  mccmonochromator6_height = 0;
#line 102 "BIFROST.instr"
  mccmonochromator6_verbose = 0;
#line 102 "BIFROST.instr"
  mccmonochromator6_order = 0;
#line 29890 "BIFROST.c"

  SIG_MESSAGE("monochromator6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1665 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1665 "BIFROST.instr"
    (2 * mcipdphi)*DEG2RAD,
#line 1665 "BIFROST.instr"
    (0)*DEG2RAD);
#line 29900 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Cradle, mcrotamonochromator6);
  rot_transpose(mcrotamonochromator5, mctr1);
  rot_mul(mcrotamonochromator6, mctr1, mcrotrmonochromator6);
  mctc1 = coords_set(
#line 1665 "BIFROST.instr"
    0.018274,
#line 1665 "BIFROST.instr"
    0,
#line 1665 "BIFROST.instr"
    0.020397);
#line 29911 "BIFROST.c"
  rot_transpose(mcrotaXY_ARM, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator6 = coords_add(mcposaXY_ARM, mctc2);
  mctc1 = coords_sub(mcposamonochromator5, mcposamonochromator6);
  mcposrmonochromator6 = rot_apply(mcrotamonochromator6, mctc1);
  mcDEBUG_COMPONENT("monochromator6", mcposamonochromator6, mcrotamonochromator6)
  mccomp_posa[121] = mcposamonochromator6;
  mccomp_posr[121] = mcposrmonochromator6;
  mcNCounter[121]  = mcPCounter[121] = mcP2Counter[121] = 0;
  mcAbsorbProp[121]= 0;
    /* Component monochromator7. */
  /* Setting parameters for component monochromator7. */
  SIG_MESSAGE("monochromator7 (Init:SetPar)");
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator7_reflect, "NULL" ? "NULL" : "", 16384); else mccmonochromator7_reflect[0]='\0';
#line 99 "BIFROST.instr"
  if("NULL") strncpy(mccmonochromator7_transmit, "NULL" ? "NULL" : "", 16384); else mccmonochromator7_transmit[0]='\0';
#line 1670 "BIFROST.instr"
  mccmonochromator7_zwidth = wi;
#line 1671 "BIFROST.instr"
  mccmonochromator7_yheight = 0.231;
#line 101 "BIFROST.instr"
  mccmonochromator7_gap = 0.0005;
#line 1672 "BIFROST.instr"
  mccmonochromator7_NH = 1;
#line 1673 "BIFROST.instr"
  mccmonochromator7_NV = 1;
#line 1668 "BIFROST.instr"
  mccmonochromator7_mosaich = 60;
#line 1669 "BIFROST.instr"
  mccmonochromator7_mosaicv = 60;
#line 1674 "BIFROST.instr"
  mccmonochromator7_r0 = 0.7;
#line 101 "BIFROST.instr"
  mccmonochromator7_t0 = 1.0;
#line 101 "BIFROST.instr"
  mccmonochromator7_Q = 1.8734;
#line 102 "BIFROST.instr"
  mccmonochromator7_RV = 0;
#line 102 "BIFROST.instr"
  mccmonochromator7_RH = 0;
#line 1675 "BIFROST.instr"
  mccmonochromator7_DM = DM;
#line 102 "BIFROST.instr"
  mccmonochromator7_mosaic = 0;
#line 102 "BIFROST.instr"
  mccmonochromator7_width = 0;
#line 102 "BIFROST.instr"
  mccmonochromator7_height = 0;
#line 102 "BIFROST.instr"
  mccmonochromator7_verbose = 0;
#line 102 "BIFROST.instr"
  mccmonochromator7_order = 0;
#line 29965 "BIFROST.c"

  SIG_MESSAGE("monochromator7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1676 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1676 "BIFROST.instr"
    (3 * mcipdphi)*DEG2RAD,
#line 1676 "BIFROST.instr"
    (0)*DEG2RAD);
#line 29975 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Cradle, mcrotamonochromator7);
  rot_transpose(mcrotamonochromator6, mctr1);
  rot_mul(mcrotamonochromator7, mctr1, mcrotrmonochromator7);
  mctc1 = coords_set(
#line 1676 "BIFROST.instr"
    0.027638,
#line 1676 "BIFROST.instr"
    0,
#line 1676 "BIFROST.instr"
    0.030387);
#line 29986 "BIFROST.c"
  rot_transpose(mcrotaXY_ARM, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamonochromator7 = coords_add(mcposaXY_ARM, mctc2);
  mctc1 = coords_sub(mcposamonochromator6, mcposamonochromator7);
  mcposrmonochromator7 = rot_apply(mcrotamonochromator7, mctc1);
  mcDEBUG_COMPONENT("monochromator7", mcposamonochromator7, mcrotamonochromator7)
  mccomp_posa[122] = mcposamonochromator7;
  mccomp_posr[122] = mcposrmonochromator7;
  mcNCounter[122]  = mcPCounter[122] = mcP2Counter[122] = 0;
  mcAbsorbProp[122]= 0;
    /* Component Mono_Out. */
  /* Setting parameters for component Mono_Out. */
  SIG_MESSAGE("Mono_Out (Init:SetPar)");

  SIG_MESSAGE("Mono_Out (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1687 "BIFROST.instr"
    (0)*DEG2RAD,
#line 1687 "BIFROST.instr"
    (mcipTTA)*DEG2RAD,
#line 1687 "BIFROST.instr"
    (0)*DEG2RAD);
#line 30009 "BIFROST.c"
  rot_mul(mctr1, mcrotav_sample, mcrotaMono_Out);
  rot_transpose(mcrotamonochromator7, mctr1);
  rot_mul(mcrotaMono_Out, mctr1, mcrotrMono_Out);
  mctc1 = coords_set(
#line 1687 "BIFROST.instr"
    0,
#line 1687 "BIFROST.instr"
    0,
#line 1687 "BIFROST.instr"
    0);
#line 30020 "BIFROST.c"
  rot_transpose(mcrotaMono_Cradle, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaMono_Out = coords_add(mcposaMono_Cradle, mctc2);
  mctc1 = coords_sub(mcposamonochromator7, mcposaMono_Out);
  mcposrMono_Out = rot_apply(mcrotaMono_Out, mctc1);
  mcDEBUG_COMPONENT("Mono_Out", mcposaMono_Out, mcrotaMono_Out)
  mccomp_posa[123] = mcposaMono_Out;
  mccomp_posr[123] = mcposrMono_Out;
  mcNCounter[123]  = mcPCounter[123] = mcP2Counter[123] = 0;
  mcAbsorbProp[123]= 0;
    /* Component psd_monitor. */
  /* Setting parameters for component psd_monitor. */
  SIG_MESSAGE("psd_monitor (Init:SetPar)");
#line 1692 "BIFROST.instr"
  if("test_fil_analyser") strncpy(mccpsd_monitor_filename, "test_fil_analyser" ? "test_fil_analyser" : "", 16384); else mccpsd_monitor_filename[0]='\0';
#line 1693 "BIFROST.instr"
  mccpsd_monitor_xmin = -0.1;
#line 1694 "BIFROST.instr"
  mccpsd_monitor_xmax = 0.1;
#line 1695 "BIFROST.instr"
  mccpsd_monitor_ymin = -0.1;
#line 1696 "BIFROST.instr"
  mccpsd_monitor_ymax = 0.1;
#line 49 "BIFROST.instr"
  mccpsd_monitor_xwidth = 0;
#line 49 "BIFROST.instr"
  mccpsd_monitor_yheight = 0;
#line 49 "BIFROST.instr"
  mccpsd_monitor_restore_neutron = 0;
#line 30050 "BIFROST.c"

  SIG_MESSAGE("psd_monitor (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30057 "BIFROST.c"
  rot_mul(mctr1, mcrotaMono_Out, mcrotapsd_monitor);
  rot_transpose(mcrotaMono_Out, mctr1);
  rot_mul(mcrotapsd_monitor, mctr1, mcrotrpsd_monitor);
  mctc1 = coords_set(
#line 1697 "BIFROST.instr"
    0,
#line 1697 "BIFROST.instr"
    0,
#line 1697 "BIFROST.instr"
    1);
#line 30068 "BIFROST.c"
  rot_transpose(mcrotaMono_Out, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposapsd_monitor = coords_add(mcposaMono_Out, mctc2);
  mctc1 = coords_sub(mcposaMono_Out, mcposapsd_monitor);
  mcposrpsd_monitor = rot_apply(mcrotapsd_monitor, mctc1);
  mcDEBUG_COMPONENT("psd_monitor", mcposapsd_monitor, mcrotapsd_monitor)
  mccomp_posa[124] = mcposapsd_monitor;
  mccomp_posr[124] = mcposrpsd_monitor;
  mcNCounter[124]  = mcPCounter[124] = mcP2Counter[124] = 0;
  mcAbsorbProp[124]= 0;
    /* Component e_monitor. */
  /* Setting parameters for component e_monitor. */
  SIG_MESSAGE("e_monitor (Init:SetPar)");
#line 1700 "BIFROST.instr"
  if("test_fil_analyser_E") strncpy(mcce_monitor_filename, "test_fil_analyser_E" ? "test_fil_analyser_E" : "", 16384); else mcce_monitor_filename[0]='\0';
#line 52 "BIFROST.instr"
  mcce_monitor_xmin = -0.05;
#line 52 "BIFROST.instr"
  mcce_monitor_xmax = 0.05;
#line 52 "BIFROST.instr"
  mcce_monitor_ymin = -0.05;
#line 52 "BIFROST.instr"
  mcce_monitor_ymax = 0.05;
#line 1701 "BIFROST.instr"
  mcce_monitor_xwidth = 0.2;
#line 1702 "BIFROST.instr"
  mcce_monitor_yheight = 0.2;
#line 1704 "BIFROST.instr"
  mcce_monitor_Emin = 5 -0.5;
#line 1705 "BIFROST.instr"
  mcce_monitor_Emax = 5 + 0.5;
#line 53 "BIFROST.instr"
  mcce_monitor_restore_neutron = 0;
#line 30102 "BIFROST.c"

  SIG_MESSAGE("e_monitor (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30109 "BIFROST.c"
  rot_mul(mctr1, mcrotapsd_monitor, mcrotae_monitor);
  rot_transpose(mcrotapsd_monitor, mctr1);
  rot_mul(mcrotae_monitor, mctr1, mcrotre_monitor);
  mctc1 = coords_set(
#line 1706 "BIFROST.instr"
    0,
#line 1706 "BIFROST.instr"
    0,
#line 1706 "BIFROST.instr"
    0);
#line 30120 "BIFROST.c"
  rot_transpose(mcrotapsd_monitor, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposae_monitor = coords_add(mcposapsd_monitor, mctc2);
  mctc1 = coords_sub(mcposapsd_monitor, mcposae_monitor);
  mcposre_monitor = rot_apply(mcrotae_monitor, mctc1);
  mcDEBUG_COMPONENT("e_monitor", mcposae_monitor, mcrotae_monitor)
  mccomp_posa[125] = mcposae_monitor;
  mccomp_posr[125] = mcposre_monitor;
  mcNCounter[125]  = mcPCounter[125] = mcP2Counter[125] = 0;
  mcAbsorbProp[125]= 0;
  /* Component initializations. */
  /* Initializations for component Origin. */
  SIG_MESSAGE("Origin (Init)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
#define profile mccOrigin_profile
#define percent mccOrigin_percent
#define flag_save mccOrigin_flag_save
#define minutes mccOrigin_minutes
#line 57 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\misc\\Progress_bar.comp"
{
IntermediateCnts=0;
StartTime=0;
EndTime=0;
CurrentTime=0;

fprintf(stdout, "[%s] Initialize\n", mcinstrument_name);
  if (percent*mcget_ncount()/100 < 1e5) {
    percent=1e5*100.0/mcget_ncount();
  }
}
#line 30157 "BIFROST.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ESS_source. */
  SIG_MESSAGE("ESS_source (Init)");
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
#define sector mccESS_source_sector
#define beamline mccESS_source_beamline
#define yheight mccESS_source_yheight
#define cold_frac mccESS_source_cold_frac
#define target_index mccESS_source_target_index
#define dist mccESS_source_dist
#define focus_xw mccESS_source_focus_xw
#define focus_yh mccESS_source_focus_yh
#define c_performance mccESS_source_c_performance
#define t_performance mccESS_source_t_performance
#define Lmin mccESS_source_Lmin
#define Lmax mccESS_source_Lmax
#define tmax_multiplier mccESS_source_tmax_multiplier
#define n_pulses mccESS_source_n_pulses
#define acc_power mccESS_source_acc_power
#define tfocus_dist mccESS_source_tfocus_dist
#define tfocus_time mccESS_source_tfocus_time
#define tfocus_width mccESS_source_tfocus_width
#line 202 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\ESS_butterfly.comp"
{
  if (beamline<4) {
    wfrac_cold=1.0;
    wfrac_thermal=(1-0.072);
  } else {
    wfrac_cold=1.0;
    wfrac_thermal=1.0;
  }

  /* Centering-parameters, which sector are we in? */
  if (strcasestr(sector,"N")) {
    cx = 0.117; cz=0.0; sign_bl_angle=1;
    orientation_angle = BeamlinesN[beamline-1];
    Beamlines = BeamlinesN;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    ColdWidths = ColdWidthNE;
    ThermalWidths = ThermalWidthNE;
    ColdScalars = ColdScalarsN;
    ThermalScalars = ThermalScalarsN;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=-(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0;   
    isleft=1;
  } else if (strcasestr(sector,"W")) {
    cx = 0.0; cz=0.0; sign_bl_angle=-1;
    orientation_angle = BeamlinesW[beamline-1]; 
    Beamlines = BeamlinesW;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    ColdWidths = ColdWidthSW;
    ThermalWidths = ThermalWidthSW;
    ColdScalars = ColdScalarsW;
    ThermalScalars = ThermalScalarsW;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=-((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0;    
    isleft=-1;
  } else if (strcasestr(sector,"S")) {
    cx = 0.0; cz=-0.185; sign_bl_angle=1;
    orientation_angle = BeamlinesS[beamline-1]; 
    Beamlines = BeamlinesS;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    //printf("cosines are %g %g internal angle %g\n",cos_thermal,cos_cold,fabs(internal_angle));
    ColdWidths = ColdWidthSW;
    ThermalWidths = ThermalWidthSW;
    ColdScalars = ColdScalarsS;
    ThermalScalars = ThermalScalarsS;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=-((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0;    
    isleft=-1;
  } else if (strcasestr(sector,"E")) {
    cx = 0.117; cz=-0.185; sign_bl_angle=-1;
    orientation_angle = BeamlinesE[beamline-1]; 
    Beamlines = BeamlinesE;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    ColdWidths = ColdWidthNE;
    ThermalWidths = ThermalWidthNE;
    ColdScalars = ColdScalarsE;
    ThermalScalars = ThermalScalarsE;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=-(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0; 
    isleft=1;
  } else {
    fprintf(stderr,"%s: Sector %s is undefined, please use N, W, S or E!\n", NAME_CURRENT_COMP,sector);
    exit(-1);
  }
  if (beamline > jmax || beamline <= 0 ) {
    fprintf(stderr,"%s: beamline no %i is undefined in sector %s, please use 1 <= beamline <= %i\n", NAME_CURRENT_COMP, beamline, sector, jmax);
    exit(-1);
  }

  printf("%s: Setting up for sector %s, beamline %i, global orientation angle is %g, internal angle %g\n", NAME_CURRENT_COMP, sector,beamline,orientation_angle,modextras.beamportangle);
  if (c_performance <= 0) {
    fprintf(stderr,"%s: Cold performance scalar of %g is not allowed. Please select 0 < c_performance\n", NAME_CURRENT_COMP, c_performance);
    exit(-1);
  }
  if (t_performance <= 0) {
    fprintf(stderr,"%s: Thermal performance scalar of %g is not allowed. Please select 0 < t_performance\n", NAME_CURRENT_COMP, t_performance);
    exit(-1);
  }
  if (Lmin>=Lmax || Lmin <= 0 || Lmax < 0) {
    fprintf(stderr,"%s: Unmeaningful definition of wavelength range!\nPlease select Lmin, Lmax > 0 and Lmax > Lmin.\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(-1);
  }
  /* Figure out where to aim */
  if (target_index && !dist)
  {
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &tx, &ty, &tz);
    dist=sqrt(tx*tx+ty*ty+tz*tz);
  } else if (!target_index && !dist) {
    fprintf(stderr,"%s: Please choose to set either the dist parameter or specify a target_index.\nExit\n", NAME_CURRENT_COMP);
    exit(-1);
  } else {
    tx=0; ty=0; tz=dist;
  }
  printf("%s: Focusing at rectagle sized %g x %g \n  - positioned at location (x,y,z)=(%g m, %g m, %g m) \n", NAME_CURRENT_COMP, focus_xw, focus_yh, tx, ty, tz);
  if (target_index) {
    printf(" ( from target_index %i -> distance %g )\n", target_index, dist);
  } else {
    printf(" ( from dist parameter -> distance %g )\n", dist);
  }
  printf("%s: Cold and Thermal brilliance performance multiplicators are c_performance=%g and t_performance=%g\n", NAME_CURRENT_COMP, c_performance, t_performance);
  
  /* Calculate orientation matrix for the display and calculations */
  r11 = cos(DEG2RAD*orientation_angle);
  r12 = -sin(DEG2RAD*orientation_angle);
  r21 = sin(DEG2RAD*orientation_angle);
  r22 = cos(DEG2RAD*orientation_angle);
  
  /* Rotated corrdinates of the emission areas */
  rC1_x = r11*C1_z + r12*C1_x;
  rC1_z = r21*C1_z + r22*C1_x;
  rC2_x = r11*C2_z + r12*C2_x;
  rC2_z = r21*C2_z + r22*C2_x;
  rC3_x = r11*C3_z + r12*C3_x;
  rC3_z = r21*C3_z + r22*C3_x;
  rT1_x = r11*T1_z + r12*T1_x;
  rT1_z = r21*T1_z + r22*T1_x;
  rT2_x = r11*T2_z + r12*T2_x;
  rT2_z = r21*T2_z + r22*T2_x;
  rT3_x = r11*T3_z + r12*T3_x;
  rT3_z = r21*T3_z + r22*T3_x;
  /* Moderator half-height */
  delta_y = yheight/2.0;
  /* Other moderator parms */
  modextras.height_c=yheight;
  modextras.Width_c=0.1;
  modextras.Width_t=0.18;
  modextras.height_t=yheight;
  modextras.tmultiplier=tmax_multiplier;
  modextras.extractionangle=120;
  /* "Measured" moderator widths in cm scale */
  modextras.Mwidth_c=100.0*ColdWidths[beamline-1]/cos_cold; //Should it be one or the other here?
  modextras.Mwidth_t=(100.0*ThermalWidths[beamline-1]+0.7)/cos_thermal;
  if (tfocus_width && tfocus_time && tfocus_dist) {
    printf("%s: Using time focusing: Directing neutrons to this time-window:\n   tfocus_width (%g s) wide at tfocus_time (%g s), tfocus_dist (%g m) downstream\n",NAME_CURRENT_COMP, tfocus_width, tfocus_time, tfocus_dist);
  } else if (!tfocus_width && !tfocus_time && !tfocus_dist) {
    printf("%s: NOT using time focusing\n",NAME_CURRENT_COMP);
  } else {
    fprintf(stderr,"%s: Unmeaningful combination tfocus_width (%g s), tfocus_time (%g s) and tfocus_dist (%g m): \n    All must be either==0 (no time focusing) or !=0 (time focusing)\n ERROR - Exiting\n",
	    NAME_CURRENT_COMP, tfocus_width, tfocus_time, tfocus_dist);
    exit(-1);
  }

  /* Specify brilliance fct.'s */
  cold_bril=ESS_2015_Schoenfeldt_cold;
  thermal_bril=ESS_2015_Schoenfeldt_thermal;
  l_range = Lmax-Lmin;
  /* Weight multipliers */
  w_mult=acc_power/5;
  w_stat=1.0/mcget_ncount();
  w_geom_c  = 0.072*yheight*1.0e4;     /* source area correction */
  w_geom_t  = 0.108*yheight*1.0e4;
  w_mult *= l_range;            /* wavelength range correction */
  n_pulses=(double)floor(n_pulses);
  if (n_pulses == 0) n_pulses=1;
}
#line 30491 "BIFROST.c"
#undef tfocus_width
#undef tfocus_time
#undef tfocus_dist
#undef acc_power
#undef n_pulses
#undef tmax_multiplier
#undef Lmax
#undef Lmin
#undef t_performance
#undef c_performance
#undef focus_yh
#undef focus_xw
#undef dist
#undef target_index
#undef cold_frac
#undef yheight
#undef beamline
#undef sector
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component StartOfGuide. */
  SIG_MESSAGE("StartOfGuide (Init)");

  /* Initializations for component NBOA. */
  SIG_MESSAGE("NBOA (Init)");
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
#define l mccNBOA_l
#define xwidth mccNBOA_xwidth
#define yheight mccNBOA_yheight
#define linxw mccNBOA_linxw
#define loutxw mccNBOA_loutxw
#define linyh mccNBOA_linyh
#define loutyh mccNBOA_loutyh
#define majorAxisxw mccNBOA_majorAxisxw
#define minorAxisxw mccNBOA_minorAxisxw
#define majorAxisyh mccNBOA_majorAxisyh
#define minorAxisyh mccNBOA_minorAxisyh
#define majorAxisoffsetxw mccNBOA_majorAxisoffsetxw
#define majorAxisoffsetyh mccNBOA_majorAxisoffsetyh
#define dimensionsAt mccNBOA_dimensionsAt
#define option mccNBOA_option
#define R0 mccNBOA_R0
#define Qc mccNBOA_Qc
#define alpha mccNBOA_alpha
#define m mccNBOA_m
#define W mccNBOA_W
#define alpharight mccNBOA_alpharight
#define mright mccNBOA_mright
#define alphaleft mccNBOA_alphaleft
#define mleft mccNBOA_mleft
#define alphatop mccNBOA_alphatop
#define mtop mccNBOA_mtop
#define alphabottom mccNBOA_alphabottom
#define mbottom mccNBOA_mbottom
#define verbose mccNBOA_verbose
#define enableGravity mccNBOA_enableGravity
#define curvature mccNBOA_curvature
#line 817 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 31227 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_6. */
  SIG_MESSAGE("EndOfelement_6 (Init)");

  /* Initializations for component L_monBeforePSC1. */
  SIG_MESSAGE("L_monBeforePSC1 (Init)");
#define mccompcurname  L_monBeforePSC1
#define mccompcurtype  L_monitor
#define mccompcurindex 6
#define nL mccL_monBeforePSC1_nL
#define L_N mccL_monBeforePSC1_L_N
#define L_p mccL_monBeforePSC1_L_p
#define L_p2 mccL_monBeforePSC1_L_p2
#define filename mccL_monBeforePSC1_filename
#define xmin mccL_monBeforePSC1_xmin
#define xmax mccL_monBeforePSC1_xmax
#define ymin mccL_monBeforePSC1_ymin
#define ymax mccL_monBeforePSC1_ymax
#define xwidth mccL_monBeforePSC1_xwidth
#define yheight mccL_monBeforePSC1_yheight
#define Lmin mccL_monBeforePSC1_Lmin
#define Lmax mccL_monBeforePSC1_Lmax
#define restore_neutron mccL_monBeforePSC1_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 31321 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFBeforerPSC1. */
  SIG_MESSAGE("ToFBeforerPSC1 (Init)");
#define mccompcurname  ToFBeforerPSC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 7
#define nt mccToFBeforerPSC1_nt
#define TOF_N mccToFBeforerPSC1_TOF_N
#define TOF_p mccToFBeforerPSC1_TOF_p
#define TOF_p2 mccToFBeforerPSC1_TOF_p2
#define t_min mccToFBeforerPSC1_t_min
#define t_max mccToFBeforerPSC1_t_max
#define delta_t mccToFBeforerPSC1_delta_t
#define filename mccToFBeforerPSC1_filename
#define xmin mccToFBeforerPSC1_xmin
#define xmax mccToFBeforerPSC1_xmax
#define ymin mccToFBeforerPSC1_ymin
#define ymax mccToFBeforerPSC1_ymax
#define xwidth mccToFBeforerPSC1_xwidth
#define yheight mccToFBeforerPSC1_yheight
#define tmin mccToFBeforerPSC1_tmin
#define tmax mccToFBeforerPSC1_tmax
#define dt mccToFBeforerPSC1_dt
#define restore_neutron mccToFBeforerPSC1_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 31396 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_beforePulseShapping1. */
  SIG_MESSAGE("PSD_beforePulseShapping1 (Init)");
#define mccompcurname  PSD_beforePulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 8
#define nx mccPSD_beforePulseShapping1_nx
#define ny mccPSD_beforePulseShapping1_ny
#define PSD_N mccPSD_beforePulseShapping1_PSD_N
#define PSD_p mccPSD_beforePulseShapping1_PSD_p
#define PSD_p2 mccPSD_beforePulseShapping1_PSD_p2
#define filename mccPSD_beforePulseShapping1_filename
#define xmin mccPSD_beforePulseShapping1_xmin
#define xmax mccPSD_beforePulseShapping1_xmax
#define ymin mccPSD_beforePulseShapping1_ymin
#define ymax mccPSD_beforePulseShapping1_ymax
#define xwidth mccPSD_beforePulseShapping1_xwidth
#define yheight mccPSD_beforePulseShapping1_yheight
#define restore_neutron mccPSD_beforePulseShapping1_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 31459 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component TofLambdaBeforePSC. */
  SIG_MESSAGE("TofLambdaBeforePSC (Init)");
#define mccompcurname  TofLambdaBeforePSC
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 9
#define nL mccTofLambdaBeforePSC_nL
#define nt mccTofLambdaBeforePSC_nt
#define tmin mccTofLambdaBeforePSC_tmin
#define tmax mccTofLambdaBeforePSC_tmax
#define tt_0 mccTofLambdaBeforePSC_tt_0
#define tt_1 mccTofLambdaBeforePSC_tt_1
#define TOFL_N mccTofLambdaBeforePSC_TOFL_N
#define TOFL_p mccTofLambdaBeforePSC_TOFL_p
#define TOFL_p2 mccTofLambdaBeforePSC_TOFL_p2
#define filename mccTofLambdaBeforePSC_filename
#define xmin mccTofLambdaBeforePSC_xmin
#define xmax mccTofLambdaBeforePSC_xmax
#define ymin mccTofLambdaBeforePSC_ymin
#define ymax mccTofLambdaBeforePSC_ymax
#define xwidth mccTofLambdaBeforePSC_xwidth
#define yheight mccTofLambdaBeforePSC_yheight
#define Lmin mccTofLambdaBeforePSC_Lmin
#define Lmax mccTofLambdaBeforePSC_Lmax
#define restore_neutron mccTofLambdaBeforePSC_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOFlambda_monitor: %s: Null detection area !\n"
                   "ERROR              (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    tt_0 = tmin*1e-6;
    tt_1 = tmax*1e-6;
    for (i=0; i<nL; i++)
     for (j=0; j<nt; j++)
     {
      TOFL_N[j][i] = 0;
      TOFL_p[j][i] = 0;
      TOFL_p2[j][i] = 0;
     }
}
#line 31525 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PulseShapingChopper. */
  SIG_MESSAGE("PulseShapingChopper (Init)");
#define mccompcurname  PulseShapingChopper
#define mccompcurtype  DiskChopper
#define mccompcurindex 10
#define Tg mccPulseShapingChopper_Tg
#define To mccPulseShapingChopper_To
#define delta_y mccPulseShapingChopper_delta_y
#define height mccPulseShapingChopper_height
#define omega mccPulseShapingChopper_omega
#define theta_0 mccPulseShapingChopper_theta_0
#define radius mccPulseShapingChopper_radius
#define yheight mccPulseShapingChopper_yheight
#define nu mccPulseShapingChopper_nu
#define nslit mccPulseShapingChopper_nslit
#define jitter mccPulseShapingChopper_jitter
#define delay mccPulseShapingChopper_delay
#define isfirst mccPulseShapingChopper_isfirst
#define n_pulse mccPulseShapingChopper_n_pulse
#define abs_out mccPulseShapingChopper_abs_out
#define phase mccPulseShapingChopper_phase
#define xwidth mccPulseShapingChopper_xwidth
#define verbose mccPulseShapingChopper_verbose
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 31634 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_AfterPulseShapping1. */
  SIG_MESSAGE("PSD_AfterPulseShapping1 (Init)");
#define mccompcurname  PSD_AfterPulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 11
#define nx mccPSD_AfterPulseShapping1_nx
#define ny mccPSD_AfterPulseShapping1_ny
#define PSD_N mccPSD_AfterPulseShapping1_PSD_N
#define PSD_p mccPSD_AfterPulseShapping1_PSD_p
#define PSD_p2 mccPSD_AfterPulseShapping1_PSD_p2
#define filename mccPSD_AfterPulseShapping1_filename
#define xmin mccPSD_AfterPulseShapping1_xmin
#define xmax mccPSD_AfterPulseShapping1_xmax
#define ymin mccPSD_AfterPulseShapping1_ymin
#define ymax mccPSD_AfterPulseShapping1_ymax
#define xwidth mccPSD_AfterPulseShapping1_xwidth
#define yheight mccPSD_AfterPulseShapping1_yheight
#define restore_neutron mccPSD_AfterPulseShapping1_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 31697 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFInsidePSC. */
  SIG_MESSAGE("ToFInsidePSC (Init)");
#define mccompcurname  ToFInsidePSC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 12
#define nt mccToFInsidePSC_nt
#define TOF_N mccToFInsidePSC_TOF_N
#define TOF_p mccToFInsidePSC_TOF_p
#define TOF_p2 mccToFInsidePSC_TOF_p2
#define t_min mccToFInsidePSC_t_min
#define t_max mccToFInsidePSC_t_max
#define delta_t mccToFInsidePSC_delta_t
#define filename mccToFInsidePSC_filename
#define xmin mccToFInsidePSC_xmin
#define xmax mccToFInsidePSC_xmax
#define ymin mccToFInsidePSC_ymin
#define ymax mccToFInsidePSC_ymax
#define xwidth mccToFInsidePSC_xwidth
#define yheight mccToFInsidePSC_yheight
#define tmin mccToFInsidePSC_tmin
#define tmax mccToFInsidePSC_tmax
#define dt mccToFInsidePSC_dt
#define restore_neutron mccToFInsidePSC_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 31771 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PulseShapingChopper2. */
  SIG_MESSAGE("PulseShapingChopper2 (Init)");
#define mccompcurname  PulseShapingChopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 13
#define Tg mccPulseShapingChopper2_Tg
#define To mccPulseShapingChopper2_To
#define delta_y mccPulseShapingChopper2_delta_y
#define height mccPulseShapingChopper2_height
#define omega mccPulseShapingChopper2_omega
#define theta_0 mccPulseShapingChopper2_theta_0
#define radius mccPulseShapingChopper2_radius
#define yheight mccPulseShapingChopper2_yheight
#define nu mccPulseShapingChopper2_nu
#define nslit mccPulseShapingChopper2_nslit
#define jitter mccPulseShapingChopper2_jitter
#define delay mccPulseShapingChopper2_delay
#define isfirst mccPulseShapingChopper2_isfirst
#define n_pulse mccPulseShapingChopper2_n_pulse
#define abs_out mccPulseShapingChopper2_abs_out
#define phase mccPulseShapingChopper2_phase
#define xwidth mccPulseShapingChopper2_xwidth
#define verbose mccPulseShapingChopper2_verbose
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 31879 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component TofLambdaAfterPSC2. */
  SIG_MESSAGE("TofLambdaAfterPSC2 (Init)");
#define mccompcurname  TofLambdaAfterPSC2
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 14
#define nL mccTofLambdaAfterPSC2_nL
#define nt mccTofLambdaAfterPSC2_nt
#define tmin mccTofLambdaAfterPSC2_tmin
#define tmax mccTofLambdaAfterPSC2_tmax
#define tt_0 mccTofLambdaAfterPSC2_tt_0
#define tt_1 mccTofLambdaAfterPSC2_tt_1
#define TOFL_N mccTofLambdaAfterPSC2_TOFL_N
#define TOFL_p mccTofLambdaAfterPSC2_TOFL_p
#define TOFL_p2 mccTofLambdaAfterPSC2_TOFL_p2
#define filename mccTofLambdaAfterPSC2_filename
#define xmin mccTofLambdaAfterPSC2_xmin
#define xmax mccTofLambdaAfterPSC2_xmax
#define ymin mccTofLambdaAfterPSC2_ymin
#define ymax mccTofLambdaAfterPSC2_ymax
#define xwidth mccTofLambdaAfterPSC2_xwidth
#define yheight mccTofLambdaAfterPSC2_yheight
#define Lmin mccTofLambdaAfterPSC2_Lmin
#define Lmax mccTofLambdaAfterPSC2_Lmax
#define restore_neutron mccTofLambdaAfterPSC2_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOFlambda_monitor: %s: Null detection area !\n"
                   "ERROR              (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    tt_0 = tmin*1e-6;
    tt_1 = tmax*1e-6;
    for (i=0; i<nL; i++)
     for (j=0; j<nt; j++)
     {
      TOFL_N[j][i] = 0;
      TOFL_p[j][i] = 0;
      TOFL_p2[j][i] = 0;
     }
}
#line 31950 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_AfterPSC2. */
  SIG_MESSAGE("PSD_AfterPSC2 (Init)");
#define mccompcurname  PSD_AfterPSC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 15
#define nx mccPSD_AfterPSC2_nx
#define ny mccPSD_AfterPSC2_ny
#define PSD_N mccPSD_AfterPSC2_PSD_N
#define PSD_p mccPSD_AfterPSC2_PSD_p
#define PSD_p2 mccPSD_AfterPSC2_PSD_p2
#define filename mccPSD_AfterPSC2_filename
#define xmin mccPSD_AfterPSC2_xmin
#define xmax mccPSD_AfterPSC2_xmax
#define ymin mccPSD_AfterPSC2_ymin
#define ymax mccPSD_AfterPSC2_ymax
#define xwidth mccPSD_AfterPSC2_xwidth
#define yheight mccPSD_AfterPSC2_yheight
#define restore_neutron mccPSD_AfterPSC2_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 32014 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFAfterPSC2. */
  SIG_MESSAGE("ToFAfterPSC2 (Init)");
#define mccompcurname  ToFAfterPSC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 16
#define nt mccToFAfterPSC2_nt
#define TOF_N mccToFAfterPSC2_TOF_N
#define TOF_p mccToFAfterPSC2_TOF_p
#define TOF_p2 mccToFAfterPSC2_TOF_p2
#define t_min mccToFAfterPSC2_t_min
#define t_max mccToFAfterPSC2_t_max
#define delta_t mccToFAfterPSC2_delta_t
#define filename mccToFAfterPSC2_filename
#define xmin mccToFAfterPSC2_xmin
#define xmax mccToFAfterPSC2_xmax
#define ymin mccToFAfterPSC2_ymin
#define ymax mccToFAfterPSC2_ymax
#define xwidth mccToFAfterPSC2_xwidth
#define yheight mccToFAfterPSC2_yheight
#define tmin mccToFAfterPSC2_tmin
#define tmax mccToFAfterPSC2_tmax
#define dt mccToFAfterPSC2_dt
#define restore_neutron mccToFAfterPSC2_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 32088 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component L_monAfterPSC2. */
  SIG_MESSAGE("L_monAfterPSC2 (Init)");
#define mccompcurname  L_monAfterPSC2
#define mccompcurtype  L_monitor
#define mccompcurindex 17
#define nL mccL_monAfterPSC2_nL
#define L_N mccL_monAfterPSC2_L_N
#define L_p mccL_monAfterPSC2_L_p
#define L_p2 mccL_monAfterPSC2_L_p2
#define filename mccL_monAfterPSC2_filename
#define xmin mccL_monAfterPSC2_xmin
#define xmax mccL_monAfterPSC2_xmax
#define ymin mccL_monAfterPSC2_ymin
#define ymax mccL_monAfterPSC2_ymax
#define xwidth mccL_monAfterPSC2_xwidth
#define yheight mccL_monAfterPSC2_yheight
#define Lmin mccL_monAfterPSC2_Lmin
#define Lmax mccL_monAfterPSC2_Lmax
#define restore_neutron mccL_monAfterPSC2_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 32151 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_5. */
  SIG_MESSAGE("EndOfelement_5 (Init)");

  /* Initializations for component curved_guide_1_0. */
  SIG_MESSAGE("curved_guide_1_0 (Init)");
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
#define w1 mcccurved_guide_1_0_w1
#define h1 mcccurved_guide_1_0_h1
#define w2 mcccurved_guide_1_0_w2
#define h2 mcccurved_guide_1_0_h2
#define l mcccurved_guide_1_0_l
#define R0 mcccurved_guide_1_0_R0
#define Qc mcccurved_guide_1_0_Qc
#define alpha mcccurved_guide_1_0_alpha
#define m mcccurved_guide_1_0_m
#define W mcccurved_guide_1_0_W
#define nslit mcccurved_guide_1_0_nslit
#define d mcccurved_guide_1_0_d
#define mleft mcccurved_guide_1_0_mleft
#define mright mcccurved_guide_1_0_mright
#define mtop mcccurved_guide_1_0_mtop
#define mbottom mcccurved_guide_1_0_mbottom
#define nhslit mcccurved_guide_1_0_nhslit
#define G mcccurved_guide_1_0_G
#define aleft mcccurved_guide_1_0_aleft
#define aright mcccurved_guide_1_0_aright
#define atop mcccurved_guide_1_0_atop
#define abottom mcccurved_guide_1_0_abottom
#define wavy mcccurved_guide_1_0_wavy
#define wavy_z mcccurved_guide_1_0_wavy_z
#define wavy_tb mcccurved_guide_1_0_wavy_tb
#define wavy_lr mcccurved_guide_1_0_wavy_lr
#define chamfers mcccurved_guide_1_0_chamfers
#define chamfers_z mcccurved_guide_1_0_chamfers_z
#define chamfers_lr mcccurved_guide_1_0_chamfers_lr
#define chamfers_tb mcccurved_guide_1_0_chamfers_tb
#define nelements mcccurved_guide_1_0_nelements
#define nu mcccurved_guide_1_0_nu
#define phase mcccurved_guide_1_0_phase
#define reflect mcccurved_guide_1_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32266 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_2_0. */
  SIG_MESSAGE("curved_guide_2_0 (Init)");
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
#define w1 mcccurved_guide_2_0_w1
#define h1 mcccurved_guide_2_0_h1
#define w2 mcccurved_guide_2_0_w2
#define h2 mcccurved_guide_2_0_h2
#define l mcccurved_guide_2_0_l
#define R0 mcccurved_guide_2_0_R0
#define Qc mcccurved_guide_2_0_Qc
#define alpha mcccurved_guide_2_0_alpha
#define m mcccurved_guide_2_0_m
#define W mcccurved_guide_2_0_W
#define nslit mcccurved_guide_2_0_nslit
#define d mcccurved_guide_2_0_d
#define mleft mcccurved_guide_2_0_mleft
#define mright mcccurved_guide_2_0_mright
#define mtop mcccurved_guide_2_0_mtop
#define mbottom mcccurved_guide_2_0_mbottom
#define nhslit mcccurved_guide_2_0_nhslit
#define G mcccurved_guide_2_0_G
#define aleft mcccurved_guide_2_0_aleft
#define aright mcccurved_guide_2_0_aright
#define atop mcccurved_guide_2_0_atop
#define abottom mcccurved_guide_2_0_abottom
#define wavy mcccurved_guide_2_0_wavy
#define wavy_z mcccurved_guide_2_0_wavy_z
#define wavy_tb mcccurved_guide_2_0_wavy_tb
#define wavy_lr mcccurved_guide_2_0_wavy_lr
#define chamfers mcccurved_guide_2_0_chamfers
#define chamfers_z mcccurved_guide_2_0_chamfers_z
#define chamfers_lr mcccurved_guide_2_0_chamfers_lr
#define chamfers_tb mcccurved_guide_2_0_chamfers_tb
#define nelements mcccurved_guide_2_0_nelements
#define nu mcccurved_guide_2_0_nu
#define phase mcccurved_guide_2_0_phase
#define reflect mcccurved_guide_2_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32400 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_3_0. */
  SIG_MESSAGE("curved_guide_3_0 (Init)");
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
#define w1 mcccurved_guide_3_0_w1
#define h1 mcccurved_guide_3_0_h1
#define w2 mcccurved_guide_3_0_w2
#define h2 mcccurved_guide_3_0_h2
#define l mcccurved_guide_3_0_l
#define R0 mcccurved_guide_3_0_R0
#define Qc mcccurved_guide_3_0_Qc
#define alpha mcccurved_guide_3_0_alpha
#define m mcccurved_guide_3_0_m
#define W mcccurved_guide_3_0_W
#define nslit mcccurved_guide_3_0_nslit
#define d mcccurved_guide_3_0_d
#define mleft mcccurved_guide_3_0_mleft
#define mright mcccurved_guide_3_0_mright
#define mtop mcccurved_guide_3_0_mtop
#define mbottom mcccurved_guide_3_0_mbottom
#define nhslit mcccurved_guide_3_0_nhslit
#define G mcccurved_guide_3_0_G
#define aleft mcccurved_guide_3_0_aleft
#define aright mcccurved_guide_3_0_aright
#define atop mcccurved_guide_3_0_atop
#define abottom mcccurved_guide_3_0_abottom
#define wavy mcccurved_guide_3_0_wavy
#define wavy_z mcccurved_guide_3_0_wavy_z
#define wavy_tb mcccurved_guide_3_0_wavy_tb
#define wavy_lr mcccurved_guide_3_0_wavy_lr
#define chamfers mcccurved_guide_3_0_chamfers
#define chamfers_z mcccurved_guide_3_0_chamfers_z
#define chamfers_lr mcccurved_guide_3_0_chamfers_lr
#define chamfers_tb mcccurved_guide_3_0_chamfers_tb
#define nelements mcccurved_guide_3_0_nelements
#define nu mcccurved_guide_3_0_nu
#define phase mcccurved_guide_3_0_phase
#define reflect mcccurved_guide_3_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32534 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_4_0. */
  SIG_MESSAGE("curved_guide_4_0 (Init)");
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
#define w1 mcccurved_guide_4_0_w1
#define h1 mcccurved_guide_4_0_h1
#define w2 mcccurved_guide_4_0_w2
#define h2 mcccurved_guide_4_0_h2
#define l mcccurved_guide_4_0_l
#define R0 mcccurved_guide_4_0_R0
#define Qc mcccurved_guide_4_0_Qc
#define alpha mcccurved_guide_4_0_alpha
#define m mcccurved_guide_4_0_m
#define W mcccurved_guide_4_0_W
#define nslit mcccurved_guide_4_0_nslit
#define d mcccurved_guide_4_0_d
#define mleft mcccurved_guide_4_0_mleft
#define mright mcccurved_guide_4_0_mright
#define mtop mcccurved_guide_4_0_mtop
#define mbottom mcccurved_guide_4_0_mbottom
#define nhslit mcccurved_guide_4_0_nhslit
#define G mcccurved_guide_4_0_G
#define aleft mcccurved_guide_4_0_aleft
#define aright mcccurved_guide_4_0_aright
#define atop mcccurved_guide_4_0_atop
#define abottom mcccurved_guide_4_0_abottom
#define wavy mcccurved_guide_4_0_wavy
#define wavy_z mcccurved_guide_4_0_wavy_z
#define wavy_tb mcccurved_guide_4_0_wavy_tb
#define wavy_lr mcccurved_guide_4_0_wavy_lr
#define chamfers mcccurved_guide_4_0_chamfers
#define chamfers_z mcccurved_guide_4_0_chamfers_z
#define chamfers_lr mcccurved_guide_4_0_chamfers_lr
#define chamfers_tb mcccurved_guide_4_0_chamfers_tb
#define nelements mcccurved_guide_4_0_nelements
#define nu mcccurved_guide_4_0_nu
#define phase mcccurved_guide_4_0_phase
#define reflect mcccurved_guide_4_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32668 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_5_beforeChopper. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (Init)");
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
#define w1 mcccurved_guide_5_beforeChopper_w1
#define h1 mcccurved_guide_5_beforeChopper_h1
#define w2 mcccurved_guide_5_beforeChopper_w2
#define h2 mcccurved_guide_5_beforeChopper_h2
#define l mcccurved_guide_5_beforeChopper_l
#define R0 mcccurved_guide_5_beforeChopper_R0
#define Qc mcccurved_guide_5_beforeChopper_Qc
#define alpha mcccurved_guide_5_beforeChopper_alpha
#define m mcccurved_guide_5_beforeChopper_m
#define W mcccurved_guide_5_beforeChopper_W
#define nslit mcccurved_guide_5_beforeChopper_nslit
#define d mcccurved_guide_5_beforeChopper_d
#define mleft mcccurved_guide_5_beforeChopper_mleft
#define mright mcccurved_guide_5_beforeChopper_mright
#define mtop mcccurved_guide_5_beforeChopper_mtop
#define mbottom mcccurved_guide_5_beforeChopper_mbottom
#define nhslit mcccurved_guide_5_beforeChopper_nhslit
#define G mcccurved_guide_5_beforeChopper_G
#define aleft mcccurved_guide_5_beforeChopper_aleft
#define aright mcccurved_guide_5_beforeChopper_aright
#define atop mcccurved_guide_5_beforeChopper_atop
#define abottom mcccurved_guide_5_beforeChopper_abottom
#define wavy mcccurved_guide_5_beforeChopper_wavy
#define wavy_z mcccurved_guide_5_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_5_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_5_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_5_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_5_beforeChopper_nelements
#define nu mcccurved_guide_5_beforeChopper_nu
#define phase mcccurved_guide_5_beforeChopper_phase
#define reflect mcccurved_guide_5_beforeChopper_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32802 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component L_monBeforeFOC1. */
  SIG_MESSAGE("L_monBeforeFOC1 (Init)");
#define mccompcurname  L_monBeforeFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccL_monBeforeFOC1_nL
#define L_N mccL_monBeforeFOC1_L_N
#define L_p mccL_monBeforeFOC1_L_p
#define L_p2 mccL_monBeforeFOC1_L_p2
#define filename mccL_monBeforeFOC1_filename
#define xmin mccL_monBeforeFOC1_xmin
#define xmax mccL_monBeforeFOC1_xmax
#define ymin mccL_monBeforeFOC1_ymin
#define ymax mccL_monBeforeFOC1_ymax
#define xwidth mccL_monBeforeFOC1_xwidth
#define yheight mccL_monBeforeFOC1_yheight
#define Lmin mccL_monBeforeFOC1_Lmin
#define Lmax mccL_monBeforeFOC1_Lmax
#define restore_neutron mccL_monBeforeFOC1_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 32883 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFBeforeFOC1. */
  SIG_MESSAGE("ToFBeforeFOC1 (Init)");
#define mccompcurname  ToFBeforeFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 25
#define nt mccToFBeforeFOC1_nt
#define TOF_N mccToFBeforeFOC1_TOF_N
#define TOF_p mccToFBeforeFOC1_TOF_p
#define TOF_p2 mccToFBeforeFOC1_TOF_p2
#define t_min mccToFBeforeFOC1_t_min
#define t_max mccToFBeforeFOC1_t_max
#define delta_t mccToFBeforeFOC1_delta_t
#define filename mccToFBeforeFOC1_filename
#define xmin mccToFBeforeFOC1_xmin
#define xmax mccToFBeforeFOC1_xmax
#define ymin mccToFBeforeFOC1_ymin
#define ymax mccToFBeforeFOC1_ymax
#define xwidth mccToFBeforeFOC1_xwidth
#define yheight mccToFBeforeFOC1_yheight
#define tmin mccToFBeforeFOC1_tmin
#define tmax mccToFBeforeFOC1_tmax
#define dt mccToFBeforeFOC1_dt
#define restore_neutron mccToFBeforeFOC1_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 32958 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_beforeFOC1. */
  SIG_MESSAGE("PSD_beforeFOC1 (Init)");
#define mccompcurname  PSD_beforeFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 26
#define nx mccPSD_beforeFOC1_nx
#define ny mccPSD_beforeFOC1_ny
#define PSD_N mccPSD_beforeFOC1_PSD_N
#define PSD_p mccPSD_beforeFOC1_PSD_p
#define PSD_p2 mccPSD_beforeFOC1_PSD_p2
#define filename mccPSD_beforeFOC1_filename
#define xmin mccPSD_beforeFOC1_xmin
#define xmax mccPSD_beforeFOC1_xmax
#define ymin mccPSD_beforeFOC1_ymin
#define ymax mccPSD_beforeFOC1_ymax
#define xwidth mccPSD_beforeFOC1_xwidth
#define yheight mccPSD_beforeFOC1_yheight
#define restore_neutron mccPSD_beforeFOC1_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 33021 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component FOC1. */
  SIG_MESSAGE("FOC1 (Init)");
#define mccompcurname  FOC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 27
#define Tg mccFOC1_Tg
#define To mccFOC1_To
#define delta_y mccFOC1_delta_y
#define height mccFOC1_height
#define omega mccFOC1_omega
#define theta_0 mccFOC1_theta_0
#define radius mccFOC1_radius
#define yheight mccFOC1_yheight
#define nu mccFOC1_nu
#define nslit mccFOC1_nslit
#define jitter mccFOC1_jitter
#define delay mccFOC1_delay
#define isfirst mccFOC1_isfirst
#define n_pulse mccFOC1_n_pulse
#define abs_out mccFOC1_abs_out
#define phase mccFOC1_phase
#define xwidth mccFOC1_xwidth
#define verbose mccFOC1_verbose
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 33124 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_afterFOC1. */
  SIG_MESSAGE("PSD_afterFOC1 (Init)");
#define mccompcurname  PSD_afterFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 28
#define nx mccPSD_afterFOC1_nx
#define ny mccPSD_afterFOC1_ny
#define PSD_N mccPSD_afterFOC1_PSD_N
#define PSD_p mccPSD_afterFOC1_PSD_p
#define PSD_p2 mccPSD_afterFOC1_PSD_p2
#define filename mccPSD_afterFOC1_filename
#define xmin mccPSD_afterFOC1_xmin
#define xmax mccPSD_afterFOC1_xmax
#define ymin mccPSD_afterFOC1_ymin
#define ymax mccPSD_afterFOC1_ymax
#define xwidth mccPSD_afterFOC1_xwidth
#define yheight mccPSD_afterFOC1_yheight
#define restore_neutron mccPSD_afterFOC1_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 33187 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFAfterFOC1. */
  SIG_MESSAGE("ToFAfterFOC1 (Init)");
#define mccompcurname  ToFAfterFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 29
#define nt mccToFAfterFOC1_nt
#define TOF_N mccToFAfterFOC1_TOF_N
#define TOF_p mccToFAfterFOC1_TOF_p
#define TOF_p2 mccToFAfterFOC1_TOF_p2
#define t_min mccToFAfterFOC1_t_min
#define t_max mccToFAfterFOC1_t_max
#define delta_t mccToFAfterFOC1_delta_t
#define filename mccToFAfterFOC1_filename
#define xmin mccToFAfterFOC1_xmin
#define xmax mccToFAfterFOC1_xmax
#define ymin mccToFAfterFOC1_ymin
#define ymax mccToFAfterFOC1_ymax
#define xwidth mccToFAfterFOC1_xwidth
#define yheight mccToFAfterFOC1_yheight
#define tmin mccToFAfterFOC1_tmin
#define tmax mccToFAfterFOC1_tmax
#define dt mccToFAfterFOC1_dt
#define restore_neutron mccToFAfterFOC1_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 33261 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component L_monAfterFOC1. */
  SIG_MESSAGE("L_monAfterFOC1 (Init)");
#define mccompcurname  L_monAfterFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 30
#define nL mccL_monAfterFOC1_nL
#define L_N mccL_monAfterFOC1_L_N
#define L_p mccL_monAfterFOC1_L_p
#define L_p2 mccL_monAfterFOC1_L_p2
#define filename mccL_monAfterFOC1_filename
#define xmin mccL_monAfterFOC1_xmin
#define xmax mccL_monAfterFOC1_xmax
#define ymin mccL_monAfterFOC1_ymin
#define ymax mccL_monAfterFOC1_ymax
#define xwidth mccL_monAfterFOC1_xwidth
#define yheight mccL_monAfterFOC1_yheight
#define Lmin mccL_monAfterFOC1_Lmin
#define Lmax mccL_monAfterFOC1_Lmax
#define restore_neutron mccL_monAfterFOC1_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 33324 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_5_afterChopper. */
  SIG_MESSAGE("curved_guide_5_afterChopper (Init)");
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
#define w1 mcccurved_guide_5_afterChopper_w1
#define h1 mcccurved_guide_5_afterChopper_h1
#define w2 mcccurved_guide_5_afterChopper_w2
#define h2 mcccurved_guide_5_afterChopper_h2
#define l mcccurved_guide_5_afterChopper_l
#define R0 mcccurved_guide_5_afterChopper_R0
#define Qc mcccurved_guide_5_afterChopper_Qc
#define alpha mcccurved_guide_5_afterChopper_alpha
#define m mcccurved_guide_5_afterChopper_m
#define W mcccurved_guide_5_afterChopper_W
#define nslit mcccurved_guide_5_afterChopper_nslit
#define d mcccurved_guide_5_afterChopper_d
#define mleft mcccurved_guide_5_afterChopper_mleft
#define mright mcccurved_guide_5_afterChopper_mright
#define mtop mcccurved_guide_5_afterChopper_mtop
#define mbottom mcccurved_guide_5_afterChopper_mbottom
#define nhslit mcccurved_guide_5_afterChopper_nhslit
#define G mcccurved_guide_5_afterChopper_G
#define aleft mcccurved_guide_5_afterChopper_aleft
#define aright mcccurved_guide_5_afterChopper_aright
#define atop mcccurved_guide_5_afterChopper_atop
#define abottom mcccurved_guide_5_afterChopper_abottom
#define wavy mcccurved_guide_5_afterChopper_wavy
#define wavy_z mcccurved_guide_5_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_5_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_afterChopper_wavy_lr
#define chamfers mcccurved_guide_5_afterChopper_chamfers
#define chamfers_z mcccurved_guide_5_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_afterChopper_chamfers_tb
#define nelements mcccurved_guide_5_afterChopper_nelements
#define nu mcccurved_guide_5_afterChopper_nu
#define phase mcccurved_guide_5_afterChopper_phase
#define reflect mcccurved_guide_5_afterChopper_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33436 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_6_0. */
  SIG_MESSAGE("curved_guide_6_0 (Init)");
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
#define w1 mcccurved_guide_6_0_w1
#define h1 mcccurved_guide_6_0_h1
#define w2 mcccurved_guide_6_0_w2
#define h2 mcccurved_guide_6_0_h2
#define l mcccurved_guide_6_0_l
#define R0 mcccurved_guide_6_0_R0
#define Qc mcccurved_guide_6_0_Qc
#define alpha mcccurved_guide_6_0_alpha
#define m mcccurved_guide_6_0_m
#define W mcccurved_guide_6_0_W
#define nslit mcccurved_guide_6_0_nslit
#define d mcccurved_guide_6_0_d
#define mleft mcccurved_guide_6_0_mleft
#define mright mcccurved_guide_6_0_mright
#define mtop mcccurved_guide_6_0_mtop
#define mbottom mcccurved_guide_6_0_mbottom
#define nhslit mcccurved_guide_6_0_nhslit
#define G mcccurved_guide_6_0_G
#define aleft mcccurved_guide_6_0_aleft
#define aright mcccurved_guide_6_0_aright
#define atop mcccurved_guide_6_0_atop
#define abottom mcccurved_guide_6_0_abottom
#define wavy mcccurved_guide_6_0_wavy
#define wavy_z mcccurved_guide_6_0_wavy_z
#define wavy_tb mcccurved_guide_6_0_wavy_tb
#define wavy_lr mcccurved_guide_6_0_wavy_lr
#define chamfers mcccurved_guide_6_0_chamfers
#define chamfers_z mcccurved_guide_6_0_chamfers_z
#define chamfers_lr mcccurved_guide_6_0_chamfers_lr
#define chamfers_tb mcccurved_guide_6_0_chamfers_tb
#define nelements mcccurved_guide_6_0_nelements
#define nu mcccurved_guide_6_0_nu
#define phase mcccurved_guide_6_0_phase
#define reflect mcccurved_guide_6_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33570 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_7_0. */
  SIG_MESSAGE("curved_guide_7_0 (Init)");
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
#define w1 mcccurved_guide_7_0_w1
#define h1 mcccurved_guide_7_0_h1
#define w2 mcccurved_guide_7_0_w2
#define h2 mcccurved_guide_7_0_h2
#define l mcccurved_guide_7_0_l
#define R0 mcccurved_guide_7_0_R0
#define Qc mcccurved_guide_7_0_Qc
#define alpha mcccurved_guide_7_0_alpha
#define m mcccurved_guide_7_0_m
#define W mcccurved_guide_7_0_W
#define nslit mcccurved_guide_7_0_nslit
#define d mcccurved_guide_7_0_d
#define mleft mcccurved_guide_7_0_mleft
#define mright mcccurved_guide_7_0_mright
#define mtop mcccurved_guide_7_0_mtop
#define mbottom mcccurved_guide_7_0_mbottom
#define nhslit mcccurved_guide_7_0_nhslit
#define G mcccurved_guide_7_0_G
#define aleft mcccurved_guide_7_0_aleft
#define aright mcccurved_guide_7_0_aright
#define atop mcccurved_guide_7_0_atop
#define abottom mcccurved_guide_7_0_abottom
#define wavy mcccurved_guide_7_0_wavy
#define wavy_z mcccurved_guide_7_0_wavy_z
#define wavy_tb mcccurved_guide_7_0_wavy_tb
#define wavy_lr mcccurved_guide_7_0_wavy_lr
#define chamfers mcccurved_guide_7_0_chamfers
#define chamfers_z mcccurved_guide_7_0_chamfers_z
#define chamfers_lr mcccurved_guide_7_0_chamfers_lr
#define chamfers_tb mcccurved_guide_7_0_chamfers_tb
#define nelements mcccurved_guide_7_0_nelements
#define nu mcccurved_guide_7_0_nu
#define phase mcccurved_guide_7_0_phase
#define reflect mcccurved_guide_7_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33704 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_8_0. */
  SIG_MESSAGE("curved_guide_8_0 (Init)");
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
#define w1 mcccurved_guide_8_0_w1
#define h1 mcccurved_guide_8_0_h1
#define w2 mcccurved_guide_8_0_w2
#define h2 mcccurved_guide_8_0_h2
#define l mcccurved_guide_8_0_l
#define R0 mcccurved_guide_8_0_R0
#define Qc mcccurved_guide_8_0_Qc
#define alpha mcccurved_guide_8_0_alpha
#define m mcccurved_guide_8_0_m
#define W mcccurved_guide_8_0_W
#define nslit mcccurved_guide_8_0_nslit
#define d mcccurved_guide_8_0_d
#define mleft mcccurved_guide_8_0_mleft
#define mright mcccurved_guide_8_0_mright
#define mtop mcccurved_guide_8_0_mtop
#define mbottom mcccurved_guide_8_0_mbottom
#define nhslit mcccurved_guide_8_0_nhslit
#define G mcccurved_guide_8_0_G
#define aleft mcccurved_guide_8_0_aleft
#define aright mcccurved_guide_8_0_aright
#define atop mcccurved_guide_8_0_atop
#define abottom mcccurved_guide_8_0_abottom
#define wavy mcccurved_guide_8_0_wavy
#define wavy_z mcccurved_guide_8_0_wavy_z
#define wavy_tb mcccurved_guide_8_0_wavy_tb
#define wavy_lr mcccurved_guide_8_0_wavy_lr
#define chamfers mcccurved_guide_8_0_chamfers
#define chamfers_z mcccurved_guide_8_0_chamfers_z
#define chamfers_lr mcccurved_guide_8_0_chamfers_lr
#define chamfers_tb mcccurved_guide_8_0_chamfers_tb
#define nelements mcccurved_guide_8_0_nelements
#define nu mcccurved_guide_8_0_nu
#define phase mcccurved_guide_8_0_phase
#define reflect mcccurved_guide_8_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33838 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_9_0. */
  SIG_MESSAGE("curved_guide_9_0 (Init)");
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
#define w1 mcccurved_guide_9_0_w1
#define h1 mcccurved_guide_9_0_h1
#define w2 mcccurved_guide_9_0_w2
#define h2 mcccurved_guide_9_0_h2
#define l mcccurved_guide_9_0_l
#define R0 mcccurved_guide_9_0_R0
#define Qc mcccurved_guide_9_0_Qc
#define alpha mcccurved_guide_9_0_alpha
#define m mcccurved_guide_9_0_m
#define W mcccurved_guide_9_0_W
#define nslit mcccurved_guide_9_0_nslit
#define d mcccurved_guide_9_0_d
#define mleft mcccurved_guide_9_0_mleft
#define mright mcccurved_guide_9_0_mright
#define mtop mcccurved_guide_9_0_mtop
#define mbottom mcccurved_guide_9_0_mbottom
#define nhslit mcccurved_guide_9_0_nhslit
#define G mcccurved_guide_9_0_G
#define aleft mcccurved_guide_9_0_aleft
#define aright mcccurved_guide_9_0_aright
#define atop mcccurved_guide_9_0_atop
#define abottom mcccurved_guide_9_0_abottom
#define wavy mcccurved_guide_9_0_wavy
#define wavy_z mcccurved_guide_9_0_wavy_z
#define wavy_tb mcccurved_guide_9_0_wavy_tb
#define wavy_lr mcccurved_guide_9_0_wavy_lr
#define chamfers mcccurved_guide_9_0_chamfers
#define chamfers_z mcccurved_guide_9_0_chamfers_z
#define chamfers_lr mcccurved_guide_9_0_chamfers_lr
#define chamfers_tb mcccurved_guide_9_0_chamfers_tb
#define nelements mcccurved_guide_9_0_nelements
#define nu mcccurved_guide_9_0_nu
#define phase mcccurved_guide_9_0_phase
#define reflect mcccurved_guide_9_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33972 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_10_0. */
  SIG_MESSAGE("curved_guide_10_0 (Init)");
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
#define w1 mcccurved_guide_10_0_w1
#define h1 mcccurved_guide_10_0_h1
#define w2 mcccurved_guide_10_0_w2
#define h2 mcccurved_guide_10_0_h2
#define l mcccurved_guide_10_0_l
#define R0 mcccurved_guide_10_0_R0
#define Qc mcccurved_guide_10_0_Qc
#define alpha mcccurved_guide_10_0_alpha
#define m mcccurved_guide_10_0_m
#define W mcccurved_guide_10_0_W
#define nslit mcccurved_guide_10_0_nslit
#define d mcccurved_guide_10_0_d
#define mleft mcccurved_guide_10_0_mleft
#define mright mcccurved_guide_10_0_mright
#define mtop mcccurved_guide_10_0_mtop
#define mbottom mcccurved_guide_10_0_mbottom
#define nhslit mcccurved_guide_10_0_nhslit
#define G mcccurved_guide_10_0_G
#define aleft mcccurved_guide_10_0_aleft
#define aright mcccurved_guide_10_0_aright
#define atop mcccurved_guide_10_0_atop
#define abottom mcccurved_guide_10_0_abottom
#define wavy mcccurved_guide_10_0_wavy
#define wavy_z mcccurved_guide_10_0_wavy_z
#define wavy_tb mcccurved_guide_10_0_wavy_tb
#define wavy_lr mcccurved_guide_10_0_wavy_lr
#define chamfers mcccurved_guide_10_0_chamfers
#define chamfers_z mcccurved_guide_10_0_chamfers_z
#define chamfers_lr mcccurved_guide_10_0_chamfers_lr
#define chamfers_tb mcccurved_guide_10_0_chamfers_tb
#define nelements mcccurved_guide_10_0_nelements
#define nu mcccurved_guide_10_0_nu
#define phase mcccurved_guide_10_0_phase
#define reflect mcccurved_guide_10_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34106 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_11_0. */
  SIG_MESSAGE("curved_guide_11_0 (Init)");
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
#define w1 mcccurved_guide_11_0_w1
#define h1 mcccurved_guide_11_0_h1
#define w2 mcccurved_guide_11_0_w2
#define h2 mcccurved_guide_11_0_h2
#define l mcccurved_guide_11_0_l
#define R0 mcccurved_guide_11_0_R0
#define Qc mcccurved_guide_11_0_Qc
#define alpha mcccurved_guide_11_0_alpha
#define m mcccurved_guide_11_0_m
#define W mcccurved_guide_11_0_W
#define nslit mcccurved_guide_11_0_nslit
#define d mcccurved_guide_11_0_d
#define mleft mcccurved_guide_11_0_mleft
#define mright mcccurved_guide_11_0_mright
#define mtop mcccurved_guide_11_0_mtop
#define mbottom mcccurved_guide_11_0_mbottom
#define nhslit mcccurved_guide_11_0_nhslit
#define G mcccurved_guide_11_0_G
#define aleft mcccurved_guide_11_0_aleft
#define aright mcccurved_guide_11_0_aright
#define atop mcccurved_guide_11_0_atop
#define abottom mcccurved_guide_11_0_abottom
#define wavy mcccurved_guide_11_0_wavy
#define wavy_z mcccurved_guide_11_0_wavy_z
#define wavy_tb mcccurved_guide_11_0_wavy_tb
#define wavy_lr mcccurved_guide_11_0_wavy_lr
#define chamfers mcccurved_guide_11_0_chamfers
#define chamfers_z mcccurved_guide_11_0_chamfers_z
#define chamfers_lr mcccurved_guide_11_0_chamfers_lr
#define chamfers_tb mcccurved_guide_11_0_chamfers_tb
#define nelements mcccurved_guide_11_0_nelements
#define nu mcccurved_guide_11_0_nu
#define phase mcccurved_guide_11_0_phase
#define reflect mcccurved_guide_11_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34240 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_12_0. */
  SIG_MESSAGE("curved_guide_12_0 (Init)");
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
#define w1 mcccurved_guide_12_0_w1
#define h1 mcccurved_guide_12_0_h1
#define w2 mcccurved_guide_12_0_w2
#define h2 mcccurved_guide_12_0_h2
#define l mcccurved_guide_12_0_l
#define R0 mcccurved_guide_12_0_R0
#define Qc mcccurved_guide_12_0_Qc
#define alpha mcccurved_guide_12_0_alpha
#define m mcccurved_guide_12_0_m
#define W mcccurved_guide_12_0_W
#define nslit mcccurved_guide_12_0_nslit
#define d mcccurved_guide_12_0_d
#define mleft mcccurved_guide_12_0_mleft
#define mright mcccurved_guide_12_0_mright
#define mtop mcccurved_guide_12_0_mtop
#define mbottom mcccurved_guide_12_0_mbottom
#define nhslit mcccurved_guide_12_0_nhslit
#define G mcccurved_guide_12_0_G
#define aleft mcccurved_guide_12_0_aleft
#define aright mcccurved_guide_12_0_aright
#define atop mcccurved_guide_12_0_atop
#define abottom mcccurved_guide_12_0_abottom
#define wavy mcccurved_guide_12_0_wavy
#define wavy_z mcccurved_guide_12_0_wavy_z
#define wavy_tb mcccurved_guide_12_0_wavy_tb
#define wavy_lr mcccurved_guide_12_0_wavy_lr
#define chamfers mcccurved_guide_12_0_chamfers
#define chamfers_z mcccurved_guide_12_0_chamfers_z
#define chamfers_lr mcccurved_guide_12_0_chamfers_lr
#define chamfers_tb mcccurved_guide_12_0_chamfers_tb
#define nelements mcccurved_guide_12_0_nelements
#define nu mcccurved_guide_12_0_nu
#define phase mcccurved_guide_12_0_phase
#define reflect mcccurved_guide_12_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34374 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_13_0. */
  SIG_MESSAGE("curved_guide_13_0 (Init)");
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
#define w1 mcccurved_guide_13_0_w1
#define h1 mcccurved_guide_13_0_h1
#define w2 mcccurved_guide_13_0_w2
#define h2 mcccurved_guide_13_0_h2
#define l mcccurved_guide_13_0_l
#define R0 mcccurved_guide_13_0_R0
#define Qc mcccurved_guide_13_0_Qc
#define alpha mcccurved_guide_13_0_alpha
#define m mcccurved_guide_13_0_m
#define W mcccurved_guide_13_0_W
#define nslit mcccurved_guide_13_0_nslit
#define d mcccurved_guide_13_0_d
#define mleft mcccurved_guide_13_0_mleft
#define mright mcccurved_guide_13_0_mright
#define mtop mcccurved_guide_13_0_mtop
#define mbottom mcccurved_guide_13_0_mbottom
#define nhslit mcccurved_guide_13_0_nhslit
#define G mcccurved_guide_13_0_G
#define aleft mcccurved_guide_13_0_aleft
#define aright mcccurved_guide_13_0_aright
#define atop mcccurved_guide_13_0_atop
#define abottom mcccurved_guide_13_0_abottom
#define wavy mcccurved_guide_13_0_wavy
#define wavy_z mcccurved_guide_13_0_wavy_z
#define wavy_tb mcccurved_guide_13_0_wavy_tb
#define wavy_lr mcccurved_guide_13_0_wavy_lr
#define chamfers mcccurved_guide_13_0_chamfers
#define chamfers_z mcccurved_guide_13_0_chamfers_z
#define chamfers_lr mcccurved_guide_13_0_chamfers_lr
#define chamfers_tb mcccurved_guide_13_0_chamfers_tb
#define nelements mcccurved_guide_13_0_nelements
#define nu mcccurved_guide_13_0_nu
#define phase mcccurved_guide_13_0_phase
#define reflect mcccurved_guide_13_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34508 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_14_0. */
  SIG_MESSAGE("curved_guide_14_0 (Init)");
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
#define w1 mcccurved_guide_14_0_w1
#define h1 mcccurved_guide_14_0_h1
#define w2 mcccurved_guide_14_0_w2
#define h2 mcccurved_guide_14_0_h2
#define l mcccurved_guide_14_0_l
#define R0 mcccurved_guide_14_0_R0
#define Qc mcccurved_guide_14_0_Qc
#define alpha mcccurved_guide_14_0_alpha
#define m mcccurved_guide_14_0_m
#define W mcccurved_guide_14_0_W
#define nslit mcccurved_guide_14_0_nslit
#define d mcccurved_guide_14_0_d
#define mleft mcccurved_guide_14_0_mleft
#define mright mcccurved_guide_14_0_mright
#define mtop mcccurved_guide_14_0_mtop
#define mbottom mcccurved_guide_14_0_mbottom
#define nhslit mcccurved_guide_14_0_nhslit
#define G mcccurved_guide_14_0_G
#define aleft mcccurved_guide_14_0_aleft
#define aright mcccurved_guide_14_0_aright
#define atop mcccurved_guide_14_0_atop
#define abottom mcccurved_guide_14_0_abottom
#define wavy mcccurved_guide_14_0_wavy
#define wavy_z mcccurved_guide_14_0_wavy_z
#define wavy_tb mcccurved_guide_14_0_wavy_tb
#define wavy_lr mcccurved_guide_14_0_wavy_lr
#define chamfers mcccurved_guide_14_0_chamfers
#define chamfers_z mcccurved_guide_14_0_chamfers_z
#define chamfers_lr mcccurved_guide_14_0_chamfers_lr
#define chamfers_tb mcccurved_guide_14_0_chamfers_tb
#define nelements mcccurved_guide_14_0_nelements
#define nu mcccurved_guide_14_0_nu
#define phase mcccurved_guide_14_0_phase
#define reflect mcccurved_guide_14_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34642 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_15_0. */
  SIG_MESSAGE("curved_guide_15_0 (Init)");
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
#define w1 mcccurved_guide_15_0_w1
#define h1 mcccurved_guide_15_0_h1
#define w2 mcccurved_guide_15_0_w2
#define h2 mcccurved_guide_15_0_h2
#define l mcccurved_guide_15_0_l
#define R0 mcccurved_guide_15_0_R0
#define Qc mcccurved_guide_15_0_Qc
#define alpha mcccurved_guide_15_0_alpha
#define m mcccurved_guide_15_0_m
#define W mcccurved_guide_15_0_W
#define nslit mcccurved_guide_15_0_nslit
#define d mcccurved_guide_15_0_d
#define mleft mcccurved_guide_15_0_mleft
#define mright mcccurved_guide_15_0_mright
#define mtop mcccurved_guide_15_0_mtop
#define mbottom mcccurved_guide_15_0_mbottom
#define nhslit mcccurved_guide_15_0_nhslit
#define G mcccurved_guide_15_0_G
#define aleft mcccurved_guide_15_0_aleft
#define aright mcccurved_guide_15_0_aright
#define atop mcccurved_guide_15_0_atop
#define abottom mcccurved_guide_15_0_abottom
#define wavy mcccurved_guide_15_0_wavy
#define wavy_z mcccurved_guide_15_0_wavy_z
#define wavy_tb mcccurved_guide_15_0_wavy_tb
#define wavy_lr mcccurved_guide_15_0_wavy_lr
#define chamfers mcccurved_guide_15_0_chamfers
#define chamfers_z mcccurved_guide_15_0_chamfers_z
#define chamfers_lr mcccurved_guide_15_0_chamfers_lr
#define chamfers_tb mcccurved_guide_15_0_chamfers_tb
#define nelements mcccurved_guide_15_0_nelements
#define nu mcccurved_guide_15_0_nu
#define phase mcccurved_guide_15_0_phase
#define reflect mcccurved_guide_15_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34776 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_16_0. */
  SIG_MESSAGE("curved_guide_16_0 (Init)");
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
#define w1 mcccurved_guide_16_0_w1
#define h1 mcccurved_guide_16_0_h1
#define w2 mcccurved_guide_16_0_w2
#define h2 mcccurved_guide_16_0_h2
#define l mcccurved_guide_16_0_l
#define R0 mcccurved_guide_16_0_R0
#define Qc mcccurved_guide_16_0_Qc
#define alpha mcccurved_guide_16_0_alpha
#define m mcccurved_guide_16_0_m
#define W mcccurved_guide_16_0_W
#define nslit mcccurved_guide_16_0_nslit
#define d mcccurved_guide_16_0_d
#define mleft mcccurved_guide_16_0_mleft
#define mright mcccurved_guide_16_0_mright
#define mtop mcccurved_guide_16_0_mtop
#define mbottom mcccurved_guide_16_0_mbottom
#define nhslit mcccurved_guide_16_0_nhslit
#define G mcccurved_guide_16_0_G
#define aleft mcccurved_guide_16_0_aleft
#define aright mcccurved_guide_16_0_aright
#define atop mcccurved_guide_16_0_atop
#define abottom mcccurved_guide_16_0_abottom
#define wavy mcccurved_guide_16_0_wavy
#define wavy_z mcccurved_guide_16_0_wavy_z
#define wavy_tb mcccurved_guide_16_0_wavy_tb
#define wavy_lr mcccurved_guide_16_0_wavy_lr
#define chamfers mcccurved_guide_16_0_chamfers
#define chamfers_z mcccurved_guide_16_0_chamfers_z
#define chamfers_lr mcccurved_guide_16_0_chamfers_lr
#define chamfers_tb mcccurved_guide_16_0_chamfers_tb
#define nelements mcccurved_guide_16_0_nelements
#define nu mcccurved_guide_16_0_nu
#define phase mcccurved_guide_16_0_phase
#define reflect mcccurved_guide_16_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34910 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_17_0. */
  SIG_MESSAGE("curved_guide_17_0 (Init)");
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
#define w1 mcccurved_guide_17_0_w1
#define h1 mcccurved_guide_17_0_h1
#define w2 mcccurved_guide_17_0_w2
#define h2 mcccurved_guide_17_0_h2
#define l mcccurved_guide_17_0_l
#define R0 mcccurved_guide_17_0_R0
#define Qc mcccurved_guide_17_0_Qc
#define alpha mcccurved_guide_17_0_alpha
#define m mcccurved_guide_17_0_m
#define W mcccurved_guide_17_0_W
#define nslit mcccurved_guide_17_0_nslit
#define d mcccurved_guide_17_0_d
#define mleft mcccurved_guide_17_0_mleft
#define mright mcccurved_guide_17_0_mright
#define mtop mcccurved_guide_17_0_mtop
#define mbottom mcccurved_guide_17_0_mbottom
#define nhslit mcccurved_guide_17_0_nhslit
#define G mcccurved_guide_17_0_G
#define aleft mcccurved_guide_17_0_aleft
#define aright mcccurved_guide_17_0_aright
#define atop mcccurved_guide_17_0_atop
#define abottom mcccurved_guide_17_0_abottom
#define wavy mcccurved_guide_17_0_wavy
#define wavy_z mcccurved_guide_17_0_wavy_z
#define wavy_tb mcccurved_guide_17_0_wavy_tb
#define wavy_lr mcccurved_guide_17_0_wavy_lr
#define chamfers mcccurved_guide_17_0_chamfers
#define chamfers_z mcccurved_guide_17_0_chamfers_z
#define chamfers_lr mcccurved_guide_17_0_chamfers_lr
#define chamfers_tb mcccurved_guide_17_0_chamfers_tb
#define nelements mcccurved_guide_17_0_nelements
#define nu mcccurved_guide_17_0_nu
#define phase mcccurved_guide_17_0_phase
#define reflect mcccurved_guide_17_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35044 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_18_beforeChopper. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (Init)");
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
#define w1 mcccurved_guide_18_beforeChopper_w1
#define h1 mcccurved_guide_18_beforeChopper_h1
#define w2 mcccurved_guide_18_beforeChopper_w2
#define h2 mcccurved_guide_18_beforeChopper_h2
#define l mcccurved_guide_18_beforeChopper_l
#define R0 mcccurved_guide_18_beforeChopper_R0
#define Qc mcccurved_guide_18_beforeChopper_Qc
#define alpha mcccurved_guide_18_beforeChopper_alpha
#define m mcccurved_guide_18_beforeChopper_m
#define W mcccurved_guide_18_beforeChopper_W
#define nslit mcccurved_guide_18_beforeChopper_nslit
#define d mcccurved_guide_18_beforeChopper_d
#define mleft mcccurved_guide_18_beforeChopper_mleft
#define mright mcccurved_guide_18_beforeChopper_mright
#define mtop mcccurved_guide_18_beforeChopper_mtop
#define mbottom mcccurved_guide_18_beforeChopper_mbottom
#define nhslit mcccurved_guide_18_beforeChopper_nhslit
#define G mcccurved_guide_18_beforeChopper_G
#define aleft mcccurved_guide_18_beforeChopper_aleft
#define aright mcccurved_guide_18_beforeChopper_aright
#define atop mcccurved_guide_18_beforeChopper_atop
#define abottom mcccurved_guide_18_beforeChopper_abottom
#define wavy mcccurved_guide_18_beforeChopper_wavy
#define wavy_z mcccurved_guide_18_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_18_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_18_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_18_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_18_beforeChopper_nelements
#define nu mcccurved_guide_18_beforeChopper_nu
#define phase mcccurved_guide_18_beforeChopper_phase
#define reflect mcccurved_guide_18_beforeChopper_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35178 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component L_monBeforeFOC2. */
  SIG_MESSAGE("L_monBeforeFOC2 (Init)");
#define mccompcurname  L_monBeforeFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 45
#define nL mccL_monBeforeFOC2_nL
#define L_N mccL_monBeforeFOC2_L_N
#define L_p mccL_monBeforeFOC2_L_p
#define L_p2 mccL_monBeforeFOC2_L_p2
#define filename mccL_monBeforeFOC2_filename
#define xmin mccL_monBeforeFOC2_xmin
#define xmax mccL_monBeforeFOC2_xmax
#define ymin mccL_monBeforeFOC2_ymin
#define ymax mccL_monBeforeFOC2_ymax
#define xwidth mccL_monBeforeFOC2_xwidth
#define yheight mccL_monBeforeFOC2_yheight
#define Lmin mccL_monBeforeFOC2_Lmin
#define Lmax mccL_monBeforeFOC2_Lmax
#define restore_neutron mccL_monBeforeFOC2_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 35259 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFBeforeFOC2. */
  SIG_MESSAGE("ToFBeforeFOC2 (Init)");
#define mccompcurname  ToFBeforeFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccToFBeforeFOC2_nt
#define TOF_N mccToFBeforeFOC2_TOF_N
#define TOF_p mccToFBeforeFOC2_TOF_p
#define TOF_p2 mccToFBeforeFOC2_TOF_p2
#define t_min mccToFBeforeFOC2_t_min
#define t_max mccToFBeforeFOC2_t_max
#define delta_t mccToFBeforeFOC2_delta_t
#define filename mccToFBeforeFOC2_filename
#define xmin mccToFBeforeFOC2_xmin
#define xmax mccToFBeforeFOC2_xmax
#define ymin mccToFBeforeFOC2_ymin
#define ymax mccToFBeforeFOC2_ymax
#define xwidth mccToFBeforeFOC2_xwidth
#define yheight mccToFBeforeFOC2_yheight
#define tmin mccToFBeforeFOC2_tmin
#define tmax mccToFBeforeFOC2_tmax
#define dt mccToFBeforeFOC2_dt
#define restore_neutron mccToFBeforeFOC2_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 35334 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_beforeFOC2. */
  SIG_MESSAGE("PSD_beforeFOC2 (Init)");
#define mccompcurname  PSD_beforeFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 47
#define nx mccPSD_beforeFOC2_nx
#define ny mccPSD_beforeFOC2_ny
#define PSD_N mccPSD_beforeFOC2_PSD_N
#define PSD_p mccPSD_beforeFOC2_PSD_p
#define PSD_p2 mccPSD_beforeFOC2_PSD_p2
#define filename mccPSD_beforeFOC2_filename
#define xmin mccPSD_beforeFOC2_xmin
#define xmax mccPSD_beforeFOC2_xmax
#define ymin mccPSD_beforeFOC2_ymin
#define ymax mccPSD_beforeFOC2_ymax
#define xwidth mccPSD_beforeFOC2_xwidth
#define yheight mccPSD_beforeFOC2_yheight
#define restore_neutron mccPSD_beforeFOC2_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 35397 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component FOC2. */
  SIG_MESSAGE("FOC2 (Init)");
#define mccompcurname  FOC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 48
#define Tg mccFOC2_Tg
#define To mccFOC2_To
#define delta_y mccFOC2_delta_y
#define height mccFOC2_height
#define omega mccFOC2_omega
#define theta_0 mccFOC2_theta_0
#define radius mccFOC2_radius
#define yheight mccFOC2_yheight
#define nu mccFOC2_nu
#define nslit mccFOC2_nslit
#define jitter mccFOC2_jitter
#define delay mccFOC2_delay
#define isfirst mccFOC2_isfirst
#define n_pulse mccFOC2_n_pulse
#define abs_out mccFOC2_abs_out
#define phase mccFOC2_phase
#define xwidth mccFOC2_xwidth
#define verbose mccFOC2_verbose
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 35500 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_afterFOC2. */
  SIG_MESSAGE("PSD_afterFOC2 (Init)");
#define mccompcurname  PSD_afterFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccPSD_afterFOC2_nx
#define ny mccPSD_afterFOC2_ny
#define PSD_N mccPSD_afterFOC2_PSD_N
#define PSD_p mccPSD_afterFOC2_PSD_p
#define PSD_p2 mccPSD_afterFOC2_PSD_p2
#define filename mccPSD_afterFOC2_filename
#define xmin mccPSD_afterFOC2_xmin
#define xmax mccPSD_afterFOC2_xmax
#define ymin mccPSD_afterFOC2_ymin
#define ymax mccPSD_afterFOC2_ymax
#define xwidth mccPSD_afterFOC2_xwidth
#define yheight mccPSD_afterFOC2_yheight
#define restore_neutron mccPSD_afterFOC2_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 35563 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFAfterFOC2. */
  SIG_MESSAGE("ToFAfterFOC2 (Init)");
#define mccompcurname  ToFAfterFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 50
#define nt mccToFAfterFOC2_nt
#define TOF_N mccToFAfterFOC2_TOF_N
#define TOF_p mccToFAfterFOC2_TOF_p
#define TOF_p2 mccToFAfterFOC2_TOF_p2
#define t_min mccToFAfterFOC2_t_min
#define t_max mccToFAfterFOC2_t_max
#define delta_t mccToFAfterFOC2_delta_t
#define filename mccToFAfterFOC2_filename
#define xmin mccToFAfterFOC2_xmin
#define xmax mccToFAfterFOC2_xmax
#define ymin mccToFAfterFOC2_ymin
#define ymax mccToFAfterFOC2_ymax
#define xwidth mccToFAfterFOC2_xwidth
#define yheight mccToFAfterFOC2_yheight
#define tmin mccToFAfterFOC2_tmin
#define tmax mccToFAfterFOC2_tmax
#define dt mccToFAfterFOC2_dt
#define restore_neutron mccToFAfterFOC2_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 35637 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component L_monAfterFOC2. */
  SIG_MESSAGE("L_monAfterFOC2 (Init)");
#define mccompcurname  L_monAfterFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mccL_monAfterFOC2_nL
#define L_N mccL_monAfterFOC2_L_N
#define L_p mccL_monAfterFOC2_L_p
#define L_p2 mccL_monAfterFOC2_L_p2
#define filename mccL_monAfterFOC2_filename
#define xmin mccL_monAfterFOC2_xmin
#define xmax mccL_monAfterFOC2_xmax
#define ymin mccL_monAfterFOC2_ymin
#define ymax mccL_monAfterFOC2_ymax
#define xwidth mccL_monAfterFOC2_xwidth
#define yheight mccL_monAfterFOC2_yheight
#define Lmin mccL_monAfterFOC2_Lmin
#define Lmax mccL_monAfterFOC2_Lmax
#define restore_neutron mccL_monAfterFOC2_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 35700 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_18_afterChopper. */
  SIG_MESSAGE("curved_guide_18_afterChopper (Init)");
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
#define w1 mcccurved_guide_18_afterChopper_w1
#define h1 mcccurved_guide_18_afterChopper_h1
#define w2 mcccurved_guide_18_afterChopper_w2
#define h2 mcccurved_guide_18_afterChopper_h2
#define l mcccurved_guide_18_afterChopper_l
#define R0 mcccurved_guide_18_afterChopper_R0
#define Qc mcccurved_guide_18_afterChopper_Qc
#define alpha mcccurved_guide_18_afterChopper_alpha
#define m mcccurved_guide_18_afterChopper_m
#define W mcccurved_guide_18_afterChopper_W
#define nslit mcccurved_guide_18_afterChopper_nslit
#define d mcccurved_guide_18_afterChopper_d
#define mleft mcccurved_guide_18_afterChopper_mleft
#define mright mcccurved_guide_18_afterChopper_mright
#define mtop mcccurved_guide_18_afterChopper_mtop
#define mbottom mcccurved_guide_18_afterChopper_mbottom
#define nhslit mcccurved_guide_18_afterChopper_nhslit
#define G mcccurved_guide_18_afterChopper_G
#define aleft mcccurved_guide_18_afterChopper_aleft
#define aright mcccurved_guide_18_afterChopper_aright
#define atop mcccurved_guide_18_afterChopper_atop
#define abottom mcccurved_guide_18_afterChopper_abottom
#define wavy mcccurved_guide_18_afterChopper_wavy
#define wavy_z mcccurved_guide_18_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_18_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_afterChopper_wavy_lr
#define chamfers mcccurved_guide_18_afterChopper_chamfers
#define chamfers_z mcccurved_guide_18_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_afterChopper_chamfers_tb
#define nelements mcccurved_guide_18_afterChopper_nelements
#define nu mcccurved_guide_18_afterChopper_nu
#define phase mcccurved_guide_18_afterChopper_phase
#define reflect mcccurved_guide_18_afterChopper_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35812 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_19_0. */
  SIG_MESSAGE("curved_guide_19_0 (Init)");
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
#define w1 mcccurved_guide_19_0_w1
#define h1 mcccurved_guide_19_0_h1
#define w2 mcccurved_guide_19_0_w2
#define h2 mcccurved_guide_19_0_h2
#define l mcccurved_guide_19_0_l
#define R0 mcccurved_guide_19_0_R0
#define Qc mcccurved_guide_19_0_Qc
#define alpha mcccurved_guide_19_0_alpha
#define m mcccurved_guide_19_0_m
#define W mcccurved_guide_19_0_W
#define nslit mcccurved_guide_19_0_nslit
#define d mcccurved_guide_19_0_d
#define mleft mcccurved_guide_19_0_mleft
#define mright mcccurved_guide_19_0_mright
#define mtop mcccurved_guide_19_0_mtop
#define mbottom mcccurved_guide_19_0_mbottom
#define nhslit mcccurved_guide_19_0_nhslit
#define G mcccurved_guide_19_0_G
#define aleft mcccurved_guide_19_0_aleft
#define aright mcccurved_guide_19_0_aright
#define atop mcccurved_guide_19_0_atop
#define abottom mcccurved_guide_19_0_abottom
#define wavy mcccurved_guide_19_0_wavy
#define wavy_z mcccurved_guide_19_0_wavy_z
#define wavy_tb mcccurved_guide_19_0_wavy_tb
#define wavy_lr mcccurved_guide_19_0_wavy_lr
#define chamfers mcccurved_guide_19_0_chamfers
#define chamfers_z mcccurved_guide_19_0_chamfers_z
#define chamfers_lr mcccurved_guide_19_0_chamfers_lr
#define chamfers_tb mcccurved_guide_19_0_chamfers_tb
#define nelements mcccurved_guide_19_0_nelements
#define nu mcccurved_guide_19_0_nu
#define phase mcccurved_guide_19_0_phase
#define reflect mcccurved_guide_19_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35946 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_20_0. */
  SIG_MESSAGE("curved_guide_20_0 (Init)");
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
#define w1 mcccurved_guide_20_0_w1
#define h1 mcccurved_guide_20_0_h1
#define w2 mcccurved_guide_20_0_w2
#define h2 mcccurved_guide_20_0_h2
#define l mcccurved_guide_20_0_l
#define R0 mcccurved_guide_20_0_R0
#define Qc mcccurved_guide_20_0_Qc
#define alpha mcccurved_guide_20_0_alpha
#define m mcccurved_guide_20_0_m
#define W mcccurved_guide_20_0_W
#define nslit mcccurved_guide_20_0_nslit
#define d mcccurved_guide_20_0_d
#define mleft mcccurved_guide_20_0_mleft
#define mright mcccurved_guide_20_0_mright
#define mtop mcccurved_guide_20_0_mtop
#define mbottom mcccurved_guide_20_0_mbottom
#define nhslit mcccurved_guide_20_0_nhslit
#define G mcccurved_guide_20_0_G
#define aleft mcccurved_guide_20_0_aleft
#define aright mcccurved_guide_20_0_aright
#define atop mcccurved_guide_20_0_atop
#define abottom mcccurved_guide_20_0_abottom
#define wavy mcccurved_guide_20_0_wavy
#define wavy_z mcccurved_guide_20_0_wavy_z
#define wavy_tb mcccurved_guide_20_0_wavy_tb
#define wavy_lr mcccurved_guide_20_0_wavy_lr
#define chamfers mcccurved_guide_20_0_chamfers
#define chamfers_z mcccurved_guide_20_0_chamfers_z
#define chamfers_lr mcccurved_guide_20_0_chamfers_lr
#define chamfers_tb mcccurved_guide_20_0_chamfers_tb
#define nelements mcccurved_guide_20_0_nelements
#define nu mcccurved_guide_20_0_nu
#define phase mcccurved_guide_20_0_phase
#define reflect mcccurved_guide_20_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36080 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_21_0. */
  SIG_MESSAGE("curved_guide_21_0 (Init)");
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
#define w1 mcccurved_guide_21_0_w1
#define h1 mcccurved_guide_21_0_h1
#define w2 mcccurved_guide_21_0_w2
#define h2 mcccurved_guide_21_0_h2
#define l mcccurved_guide_21_0_l
#define R0 mcccurved_guide_21_0_R0
#define Qc mcccurved_guide_21_0_Qc
#define alpha mcccurved_guide_21_0_alpha
#define m mcccurved_guide_21_0_m
#define W mcccurved_guide_21_0_W
#define nslit mcccurved_guide_21_0_nslit
#define d mcccurved_guide_21_0_d
#define mleft mcccurved_guide_21_0_mleft
#define mright mcccurved_guide_21_0_mright
#define mtop mcccurved_guide_21_0_mtop
#define mbottom mcccurved_guide_21_0_mbottom
#define nhslit mcccurved_guide_21_0_nhslit
#define G mcccurved_guide_21_0_G
#define aleft mcccurved_guide_21_0_aleft
#define aright mcccurved_guide_21_0_aright
#define atop mcccurved_guide_21_0_atop
#define abottom mcccurved_guide_21_0_abottom
#define wavy mcccurved_guide_21_0_wavy
#define wavy_z mcccurved_guide_21_0_wavy_z
#define wavy_tb mcccurved_guide_21_0_wavy_tb
#define wavy_lr mcccurved_guide_21_0_wavy_lr
#define chamfers mcccurved_guide_21_0_chamfers
#define chamfers_z mcccurved_guide_21_0_chamfers_z
#define chamfers_lr mcccurved_guide_21_0_chamfers_lr
#define chamfers_tb mcccurved_guide_21_0_chamfers_tb
#define nelements mcccurved_guide_21_0_nelements
#define nu mcccurved_guide_21_0_nu
#define phase mcccurved_guide_21_0_phase
#define reflect mcccurved_guide_21_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36214 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_22_0. */
  SIG_MESSAGE("curved_guide_22_0 (Init)");
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
#define w1 mcccurved_guide_22_0_w1
#define h1 mcccurved_guide_22_0_h1
#define w2 mcccurved_guide_22_0_w2
#define h2 mcccurved_guide_22_0_h2
#define l mcccurved_guide_22_0_l
#define R0 mcccurved_guide_22_0_R0
#define Qc mcccurved_guide_22_0_Qc
#define alpha mcccurved_guide_22_0_alpha
#define m mcccurved_guide_22_0_m
#define W mcccurved_guide_22_0_W
#define nslit mcccurved_guide_22_0_nslit
#define d mcccurved_guide_22_0_d
#define mleft mcccurved_guide_22_0_mleft
#define mright mcccurved_guide_22_0_mright
#define mtop mcccurved_guide_22_0_mtop
#define mbottom mcccurved_guide_22_0_mbottom
#define nhslit mcccurved_guide_22_0_nhslit
#define G mcccurved_guide_22_0_G
#define aleft mcccurved_guide_22_0_aleft
#define aright mcccurved_guide_22_0_aright
#define atop mcccurved_guide_22_0_atop
#define abottom mcccurved_guide_22_0_abottom
#define wavy mcccurved_guide_22_0_wavy
#define wavy_z mcccurved_guide_22_0_wavy_z
#define wavy_tb mcccurved_guide_22_0_wavy_tb
#define wavy_lr mcccurved_guide_22_0_wavy_lr
#define chamfers mcccurved_guide_22_0_chamfers
#define chamfers_z mcccurved_guide_22_0_chamfers_z
#define chamfers_lr mcccurved_guide_22_0_chamfers_lr
#define chamfers_tb mcccurved_guide_22_0_chamfers_tb
#define nelements mcccurved_guide_22_0_nelements
#define nu mcccurved_guide_22_0_nu
#define phase mcccurved_guide_22_0_phase
#define reflect mcccurved_guide_22_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36348 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_23_0. */
  SIG_MESSAGE("curved_guide_23_0 (Init)");
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
#define w1 mcccurved_guide_23_0_w1
#define h1 mcccurved_guide_23_0_h1
#define w2 mcccurved_guide_23_0_w2
#define h2 mcccurved_guide_23_0_h2
#define l mcccurved_guide_23_0_l
#define R0 mcccurved_guide_23_0_R0
#define Qc mcccurved_guide_23_0_Qc
#define alpha mcccurved_guide_23_0_alpha
#define m mcccurved_guide_23_0_m
#define W mcccurved_guide_23_0_W
#define nslit mcccurved_guide_23_0_nslit
#define d mcccurved_guide_23_0_d
#define mleft mcccurved_guide_23_0_mleft
#define mright mcccurved_guide_23_0_mright
#define mtop mcccurved_guide_23_0_mtop
#define mbottom mcccurved_guide_23_0_mbottom
#define nhslit mcccurved_guide_23_0_nhslit
#define G mcccurved_guide_23_0_G
#define aleft mcccurved_guide_23_0_aleft
#define aright mcccurved_guide_23_0_aright
#define atop mcccurved_guide_23_0_atop
#define abottom mcccurved_guide_23_0_abottom
#define wavy mcccurved_guide_23_0_wavy
#define wavy_z mcccurved_guide_23_0_wavy_z
#define wavy_tb mcccurved_guide_23_0_wavy_tb
#define wavy_lr mcccurved_guide_23_0_wavy_lr
#define chamfers mcccurved_guide_23_0_chamfers
#define chamfers_z mcccurved_guide_23_0_chamfers_z
#define chamfers_lr mcccurved_guide_23_0_chamfers_lr
#define chamfers_tb mcccurved_guide_23_0_chamfers_tb
#define nelements mcccurved_guide_23_0_nelements
#define nu mcccurved_guide_23_0_nu
#define phase mcccurved_guide_23_0_phase
#define reflect mcccurved_guide_23_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36482 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_24_0. */
  SIG_MESSAGE("curved_guide_24_0 (Init)");
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
#define w1 mcccurved_guide_24_0_w1
#define h1 mcccurved_guide_24_0_h1
#define w2 mcccurved_guide_24_0_w2
#define h2 mcccurved_guide_24_0_h2
#define l mcccurved_guide_24_0_l
#define R0 mcccurved_guide_24_0_R0
#define Qc mcccurved_guide_24_0_Qc
#define alpha mcccurved_guide_24_0_alpha
#define m mcccurved_guide_24_0_m
#define W mcccurved_guide_24_0_W
#define nslit mcccurved_guide_24_0_nslit
#define d mcccurved_guide_24_0_d
#define mleft mcccurved_guide_24_0_mleft
#define mright mcccurved_guide_24_0_mright
#define mtop mcccurved_guide_24_0_mtop
#define mbottom mcccurved_guide_24_0_mbottom
#define nhslit mcccurved_guide_24_0_nhslit
#define G mcccurved_guide_24_0_G
#define aleft mcccurved_guide_24_0_aleft
#define aright mcccurved_guide_24_0_aright
#define atop mcccurved_guide_24_0_atop
#define abottom mcccurved_guide_24_0_abottom
#define wavy mcccurved_guide_24_0_wavy
#define wavy_z mcccurved_guide_24_0_wavy_z
#define wavy_tb mcccurved_guide_24_0_wavy_tb
#define wavy_lr mcccurved_guide_24_0_wavy_lr
#define chamfers mcccurved_guide_24_0_chamfers
#define chamfers_z mcccurved_guide_24_0_chamfers_z
#define chamfers_lr mcccurved_guide_24_0_chamfers_lr
#define chamfers_tb mcccurved_guide_24_0_chamfers_tb
#define nelements mcccurved_guide_24_0_nelements
#define nu mcccurved_guide_24_0_nu
#define phase mcccurved_guide_24_0_phase
#define reflect mcccurved_guide_24_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36616 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_25_0. */
  SIG_MESSAGE("curved_guide_25_0 (Init)");
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
#define w1 mcccurved_guide_25_0_w1
#define h1 mcccurved_guide_25_0_h1
#define w2 mcccurved_guide_25_0_w2
#define h2 mcccurved_guide_25_0_h2
#define l mcccurved_guide_25_0_l
#define R0 mcccurved_guide_25_0_R0
#define Qc mcccurved_guide_25_0_Qc
#define alpha mcccurved_guide_25_0_alpha
#define m mcccurved_guide_25_0_m
#define W mcccurved_guide_25_0_W
#define nslit mcccurved_guide_25_0_nslit
#define d mcccurved_guide_25_0_d
#define mleft mcccurved_guide_25_0_mleft
#define mright mcccurved_guide_25_0_mright
#define mtop mcccurved_guide_25_0_mtop
#define mbottom mcccurved_guide_25_0_mbottom
#define nhslit mcccurved_guide_25_0_nhslit
#define G mcccurved_guide_25_0_G
#define aleft mcccurved_guide_25_0_aleft
#define aright mcccurved_guide_25_0_aright
#define atop mcccurved_guide_25_0_atop
#define abottom mcccurved_guide_25_0_abottom
#define wavy mcccurved_guide_25_0_wavy
#define wavy_z mcccurved_guide_25_0_wavy_z
#define wavy_tb mcccurved_guide_25_0_wavy_tb
#define wavy_lr mcccurved_guide_25_0_wavy_lr
#define chamfers mcccurved_guide_25_0_chamfers
#define chamfers_z mcccurved_guide_25_0_chamfers_z
#define chamfers_lr mcccurved_guide_25_0_chamfers_lr
#define chamfers_tb mcccurved_guide_25_0_chamfers_tb
#define nelements mcccurved_guide_25_0_nelements
#define nu mcccurved_guide_25_0_nu
#define phase mcccurved_guide_25_0_phase
#define reflect mcccurved_guide_25_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36750 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_26_0. */
  SIG_MESSAGE("curved_guide_26_0 (Init)");
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 60
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
#define w1 mcccurved_guide_26_0_w1
#define h1 mcccurved_guide_26_0_h1
#define w2 mcccurved_guide_26_0_w2
#define h2 mcccurved_guide_26_0_h2
#define l mcccurved_guide_26_0_l
#define R0 mcccurved_guide_26_0_R0
#define Qc mcccurved_guide_26_0_Qc
#define alpha mcccurved_guide_26_0_alpha
#define m mcccurved_guide_26_0_m
#define W mcccurved_guide_26_0_W
#define nslit mcccurved_guide_26_0_nslit
#define d mcccurved_guide_26_0_d
#define mleft mcccurved_guide_26_0_mleft
#define mright mcccurved_guide_26_0_mright
#define mtop mcccurved_guide_26_0_mtop
#define mbottom mcccurved_guide_26_0_mbottom
#define nhslit mcccurved_guide_26_0_nhslit
#define G mcccurved_guide_26_0_G
#define aleft mcccurved_guide_26_0_aleft
#define aright mcccurved_guide_26_0_aright
#define atop mcccurved_guide_26_0_atop
#define abottom mcccurved_guide_26_0_abottom
#define wavy mcccurved_guide_26_0_wavy
#define wavy_z mcccurved_guide_26_0_wavy_z
#define wavy_tb mcccurved_guide_26_0_wavy_tb
#define wavy_lr mcccurved_guide_26_0_wavy_lr
#define chamfers mcccurved_guide_26_0_chamfers
#define chamfers_z mcccurved_guide_26_0_chamfers_z
#define chamfers_lr mcccurved_guide_26_0_chamfers_lr
#define chamfers_tb mcccurved_guide_26_0_chamfers_tb
#define nelements mcccurved_guide_26_0_nelements
#define nu mcccurved_guide_26_0_nu
#define phase mcccurved_guide_26_0_phase
#define reflect mcccurved_guide_26_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36884 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_27_0. */
  SIG_MESSAGE("curved_guide_27_0 (Init)");
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 61
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
#define w1 mcccurved_guide_27_0_w1
#define h1 mcccurved_guide_27_0_h1
#define w2 mcccurved_guide_27_0_w2
#define h2 mcccurved_guide_27_0_h2
#define l mcccurved_guide_27_0_l
#define R0 mcccurved_guide_27_0_R0
#define Qc mcccurved_guide_27_0_Qc
#define alpha mcccurved_guide_27_0_alpha
#define m mcccurved_guide_27_0_m
#define W mcccurved_guide_27_0_W
#define nslit mcccurved_guide_27_0_nslit
#define d mcccurved_guide_27_0_d
#define mleft mcccurved_guide_27_0_mleft
#define mright mcccurved_guide_27_0_mright
#define mtop mcccurved_guide_27_0_mtop
#define mbottom mcccurved_guide_27_0_mbottom
#define nhslit mcccurved_guide_27_0_nhslit
#define G mcccurved_guide_27_0_G
#define aleft mcccurved_guide_27_0_aleft
#define aright mcccurved_guide_27_0_aright
#define atop mcccurved_guide_27_0_atop
#define abottom mcccurved_guide_27_0_abottom
#define wavy mcccurved_guide_27_0_wavy
#define wavy_z mcccurved_guide_27_0_wavy_z
#define wavy_tb mcccurved_guide_27_0_wavy_tb
#define wavy_lr mcccurved_guide_27_0_wavy_lr
#define chamfers mcccurved_guide_27_0_chamfers
#define chamfers_z mcccurved_guide_27_0_chamfers_z
#define chamfers_lr mcccurved_guide_27_0_chamfers_lr
#define chamfers_tb mcccurved_guide_27_0_chamfers_tb
#define nelements mcccurved_guide_27_0_nelements
#define nu mcccurved_guide_27_0_nu
#define phase mcccurved_guide_27_0_phase
#define reflect mcccurved_guide_27_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37018 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_28_0. */
  SIG_MESSAGE("curved_guide_28_0 (Init)");
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 62
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
#define w1 mcccurved_guide_28_0_w1
#define h1 mcccurved_guide_28_0_h1
#define w2 mcccurved_guide_28_0_w2
#define h2 mcccurved_guide_28_0_h2
#define l mcccurved_guide_28_0_l
#define R0 mcccurved_guide_28_0_R0
#define Qc mcccurved_guide_28_0_Qc
#define alpha mcccurved_guide_28_0_alpha
#define m mcccurved_guide_28_0_m
#define W mcccurved_guide_28_0_W
#define nslit mcccurved_guide_28_0_nslit
#define d mcccurved_guide_28_0_d
#define mleft mcccurved_guide_28_0_mleft
#define mright mcccurved_guide_28_0_mright
#define mtop mcccurved_guide_28_0_mtop
#define mbottom mcccurved_guide_28_0_mbottom
#define nhslit mcccurved_guide_28_0_nhslit
#define G mcccurved_guide_28_0_G
#define aleft mcccurved_guide_28_0_aleft
#define aright mcccurved_guide_28_0_aright
#define atop mcccurved_guide_28_0_atop
#define abottom mcccurved_guide_28_0_abottom
#define wavy mcccurved_guide_28_0_wavy
#define wavy_z mcccurved_guide_28_0_wavy_z
#define wavy_tb mcccurved_guide_28_0_wavy_tb
#define wavy_lr mcccurved_guide_28_0_wavy_lr
#define chamfers mcccurved_guide_28_0_chamfers
#define chamfers_z mcccurved_guide_28_0_chamfers_z
#define chamfers_lr mcccurved_guide_28_0_chamfers_lr
#define chamfers_tb mcccurved_guide_28_0_chamfers_tb
#define nelements mcccurved_guide_28_0_nelements
#define nu mcccurved_guide_28_0_nu
#define phase mcccurved_guide_28_0_phase
#define reflect mcccurved_guide_28_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37152 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_29_0. */
  SIG_MESSAGE("curved_guide_29_0 (Init)");
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 63
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
#define w1 mcccurved_guide_29_0_w1
#define h1 mcccurved_guide_29_0_h1
#define w2 mcccurved_guide_29_0_w2
#define h2 mcccurved_guide_29_0_h2
#define l mcccurved_guide_29_0_l
#define R0 mcccurved_guide_29_0_R0
#define Qc mcccurved_guide_29_0_Qc
#define alpha mcccurved_guide_29_0_alpha
#define m mcccurved_guide_29_0_m
#define W mcccurved_guide_29_0_W
#define nslit mcccurved_guide_29_0_nslit
#define d mcccurved_guide_29_0_d
#define mleft mcccurved_guide_29_0_mleft
#define mright mcccurved_guide_29_0_mright
#define mtop mcccurved_guide_29_0_mtop
#define mbottom mcccurved_guide_29_0_mbottom
#define nhslit mcccurved_guide_29_0_nhslit
#define G mcccurved_guide_29_0_G
#define aleft mcccurved_guide_29_0_aleft
#define aright mcccurved_guide_29_0_aright
#define atop mcccurved_guide_29_0_atop
#define abottom mcccurved_guide_29_0_abottom
#define wavy mcccurved_guide_29_0_wavy
#define wavy_z mcccurved_guide_29_0_wavy_z
#define wavy_tb mcccurved_guide_29_0_wavy_tb
#define wavy_lr mcccurved_guide_29_0_wavy_lr
#define chamfers mcccurved_guide_29_0_chamfers
#define chamfers_z mcccurved_guide_29_0_chamfers_z
#define chamfers_lr mcccurved_guide_29_0_chamfers_lr
#define chamfers_tb mcccurved_guide_29_0_chamfers_tb
#define nelements mcccurved_guide_29_0_nelements
#define nu mcccurved_guide_29_0_nu
#define phase mcccurved_guide_29_0_phase
#define reflect mcccurved_guide_29_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37286 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_30_0. */
  SIG_MESSAGE("curved_guide_30_0 (Init)");
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
#define w1 mcccurved_guide_30_0_w1
#define h1 mcccurved_guide_30_0_h1
#define w2 mcccurved_guide_30_0_w2
#define h2 mcccurved_guide_30_0_h2
#define l mcccurved_guide_30_0_l
#define R0 mcccurved_guide_30_0_R0
#define Qc mcccurved_guide_30_0_Qc
#define alpha mcccurved_guide_30_0_alpha
#define m mcccurved_guide_30_0_m
#define W mcccurved_guide_30_0_W
#define nslit mcccurved_guide_30_0_nslit
#define d mcccurved_guide_30_0_d
#define mleft mcccurved_guide_30_0_mleft
#define mright mcccurved_guide_30_0_mright
#define mtop mcccurved_guide_30_0_mtop
#define mbottom mcccurved_guide_30_0_mbottom
#define nhslit mcccurved_guide_30_0_nhslit
#define G mcccurved_guide_30_0_G
#define aleft mcccurved_guide_30_0_aleft
#define aright mcccurved_guide_30_0_aright
#define atop mcccurved_guide_30_0_atop
#define abottom mcccurved_guide_30_0_abottom
#define wavy mcccurved_guide_30_0_wavy
#define wavy_z mcccurved_guide_30_0_wavy_z
#define wavy_tb mcccurved_guide_30_0_wavy_tb
#define wavy_lr mcccurved_guide_30_0_wavy_lr
#define chamfers mcccurved_guide_30_0_chamfers
#define chamfers_z mcccurved_guide_30_0_chamfers_z
#define chamfers_lr mcccurved_guide_30_0_chamfers_lr
#define chamfers_tb mcccurved_guide_30_0_chamfers_tb
#define nelements mcccurved_guide_30_0_nelements
#define nu mcccurved_guide_30_0_nu
#define phase mcccurved_guide_30_0_phase
#define reflect mcccurved_guide_30_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37420 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_31_0. */
  SIG_MESSAGE("curved_guide_31_0 (Init)");
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
#define w1 mcccurved_guide_31_0_w1
#define h1 mcccurved_guide_31_0_h1
#define w2 mcccurved_guide_31_0_w2
#define h2 mcccurved_guide_31_0_h2
#define l mcccurved_guide_31_0_l
#define R0 mcccurved_guide_31_0_R0
#define Qc mcccurved_guide_31_0_Qc
#define alpha mcccurved_guide_31_0_alpha
#define m mcccurved_guide_31_0_m
#define W mcccurved_guide_31_0_W
#define nslit mcccurved_guide_31_0_nslit
#define d mcccurved_guide_31_0_d
#define mleft mcccurved_guide_31_0_mleft
#define mright mcccurved_guide_31_0_mright
#define mtop mcccurved_guide_31_0_mtop
#define mbottom mcccurved_guide_31_0_mbottom
#define nhslit mcccurved_guide_31_0_nhslit
#define G mcccurved_guide_31_0_G
#define aleft mcccurved_guide_31_0_aleft
#define aright mcccurved_guide_31_0_aright
#define atop mcccurved_guide_31_0_atop
#define abottom mcccurved_guide_31_0_abottom
#define wavy mcccurved_guide_31_0_wavy
#define wavy_z mcccurved_guide_31_0_wavy_z
#define wavy_tb mcccurved_guide_31_0_wavy_tb
#define wavy_lr mcccurved_guide_31_0_wavy_lr
#define chamfers mcccurved_guide_31_0_chamfers
#define chamfers_z mcccurved_guide_31_0_chamfers_z
#define chamfers_lr mcccurved_guide_31_0_chamfers_lr
#define chamfers_tb mcccurved_guide_31_0_chamfers_tb
#define nelements mcccurved_guide_31_0_nelements
#define nu mcccurved_guide_31_0_nu
#define phase mcccurved_guide_31_0_phase
#define reflect mcccurved_guide_31_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37554 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_32_0. */
  SIG_MESSAGE("curved_guide_32_0 (Init)");
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
#define w1 mcccurved_guide_32_0_w1
#define h1 mcccurved_guide_32_0_h1
#define w2 mcccurved_guide_32_0_w2
#define h2 mcccurved_guide_32_0_h2
#define l mcccurved_guide_32_0_l
#define R0 mcccurved_guide_32_0_R0
#define Qc mcccurved_guide_32_0_Qc
#define alpha mcccurved_guide_32_0_alpha
#define m mcccurved_guide_32_0_m
#define W mcccurved_guide_32_0_W
#define nslit mcccurved_guide_32_0_nslit
#define d mcccurved_guide_32_0_d
#define mleft mcccurved_guide_32_0_mleft
#define mright mcccurved_guide_32_0_mright
#define mtop mcccurved_guide_32_0_mtop
#define mbottom mcccurved_guide_32_0_mbottom
#define nhslit mcccurved_guide_32_0_nhslit
#define G mcccurved_guide_32_0_G
#define aleft mcccurved_guide_32_0_aleft
#define aright mcccurved_guide_32_0_aright
#define atop mcccurved_guide_32_0_atop
#define abottom mcccurved_guide_32_0_abottom
#define wavy mcccurved_guide_32_0_wavy
#define wavy_z mcccurved_guide_32_0_wavy_z
#define wavy_tb mcccurved_guide_32_0_wavy_tb
#define wavy_lr mcccurved_guide_32_0_wavy_lr
#define chamfers mcccurved_guide_32_0_chamfers
#define chamfers_z mcccurved_guide_32_0_chamfers_z
#define chamfers_lr mcccurved_guide_32_0_chamfers_lr
#define chamfers_tb mcccurved_guide_32_0_chamfers_tb
#define nelements mcccurved_guide_32_0_nelements
#define nu mcccurved_guide_32_0_nu
#define phase mcccurved_guide_32_0_phase
#define reflect mcccurved_guide_32_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37688 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_33_0. */
  SIG_MESSAGE("curved_guide_33_0 (Init)");
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
#define w1 mcccurved_guide_33_0_w1
#define h1 mcccurved_guide_33_0_h1
#define w2 mcccurved_guide_33_0_w2
#define h2 mcccurved_guide_33_0_h2
#define l mcccurved_guide_33_0_l
#define R0 mcccurved_guide_33_0_R0
#define Qc mcccurved_guide_33_0_Qc
#define alpha mcccurved_guide_33_0_alpha
#define m mcccurved_guide_33_0_m
#define W mcccurved_guide_33_0_W
#define nslit mcccurved_guide_33_0_nslit
#define d mcccurved_guide_33_0_d
#define mleft mcccurved_guide_33_0_mleft
#define mright mcccurved_guide_33_0_mright
#define mtop mcccurved_guide_33_0_mtop
#define mbottom mcccurved_guide_33_0_mbottom
#define nhslit mcccurved_guide_33_0_nhslit
#define G mcccurved_guide_33_0_G
#define aleft mcccurved_guide_33_0_aleft
#define aright mcccurved_guide_33_0_aright
#define atop mcccurved_guide_33_0_atop
#define abottom mcccurved_guide_33_0_abottom
#define wavy mcccurved_guide_33_0_wavy
#define wavy_z mcccurved_guide_33_0_wavy_z
#define wavy_tb mcccurved_guide_33_0_wavy_tb
#define wavy_lr mcccurved_guide_33_0_wavy_lr
#define chamfers mcccurved_guide_33_0_chamfers
#define chamfers_z mcccurved_guide_33_0_chamfers_z
#define chamfers_lr mcccurved_guide_33_0_chamfers_lr
#define chamfers_tb mcccurved_guide_33_0_chamfers_tb
#define nelements mcccurved_guide_33_0_nelements
#define nu mcccurved_guide_33_0_nu
#define phase mcccurved_guide_33_0_phase
#define reflect mcccurved_guide_33_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37822 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_34_0. */
  SIG_MESSAGE("curved_guide_34_0 (Init)");
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
#define w1 mcccurved_guide_34_0_w1
#define h1 mcccurved_guide_34_0_h1
#define w2 mcccurved_guide_34_0_w2
#define h2 mcccurved_guide_34_0_h2
#define l mcccurved_guide_34_0_l
#define R0 mcccurved_guide_34_0_R0
#define Qc mcccurved_guide_34_0_Qc
#define alpha mcccurved_guide_34_0_alpha
#define m mcccurved_guide_34_0_m
#define W mcccurved_guide_34_0_W
#define nslit mcccurved_guide_34_0_nslit
#define d mcccurved_guide_34_0_d
#define mleft mcccurved_guide_34_0_mleft
#define mright mcccurved_guide_34_0_mright
#define mtop mcccurved_guide_34_0_mtop
#define mbottom mcccurved_guide_34_0_mbottom
#define nhslit mcccurved_guide_34_0_nhslit
#define G mcccurved_guide_34_0_G
#define aleft mcccurved_guide_34_0_aleft
#define aright mcccurved_guide_34_0_aright
#define atop mcccurved_guide_34_0_atop
#define abottom mcccurved_guide_34_0_abottom
#define wavy mcccurved_guide_34_0_wavy
#define wavy_z mcccurved_guide_34_0_wavy_z
#define wavy_tb mcccurved_guide_34_0_wavy_tb
#define wavy_lr mcccurved_guide_34_0_wavy_lr
#define chamfers mcccurved_guide_34_0_chamfers
#define chamfers_z mcccurved_guide_34_0_chamfers_z
#define chamfers_lr mcccurved_guide_34_0_chamfers_lr
#define chamfers_tb mcccurved_guide_34_0_chamfers_tb
#define nelements mcccurved_guide_34_0_nelements
#define nu mcccurved_guide_34_0_nu
#define phase mcccurved_guide_34_0_phase
#define reflect mcccurved_guide_34_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37956 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_35_0. */
  SIG_MESSAGE("curved_guide_35_0 (Init)");
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 69
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
#define w1 mcccurved_guide_35_0_w1
#define h1 mcccurved_guide_35_0_h1
#define w2 mcccurved_guide_35_0_w2
#define h2 mcccurved_guide_35_0_h2
#define l mcccurved_guide_35_0_l
#define R0 mcccurved_guide_35_0_R0
#define Qc mcccurved_guide_35_0_Qc
#define alpha mcccurved_guide_35_0_alpha
#define m mcccurved_guide_35_0_m
#define W mcccurved_guide_35_0_W
#define nslit mcccurved_guide_35_0_nslit
#define d mcccurved_guide_35_0_d
#define mleft mcccurved_guide_35_0_mleft
#define mright mcccurved_guide_35_0_mright
#define mtop mcccurved_guide_35_0_mtop
#define mbottom mcccurved_guide_35_0_mbottom
#define nhslit mcccurved_guide_35_0_nhslit
#define G mcccurved_guide_35_0_G
#define aleft mcccurved_guide_35_0_aleft
#define aright mcccurved_guide_35_0_aright
#define atop mcccurved_guide_35_0_atop
#define abottom mcccurved_guide_35_0_abottom
#define wavy mcccurved_guide_35_0_wavy
#define wavy_z mcccurved_guide_35_0_wavy_z
#define wavy_tb mcccurved_guide_35_0_wavy_tb
#define wavy_lr mcccurved_guide_35_0_wavy_lr
#define chamfers mcccurved_guide_35_0_chamfers
#define chamfers_z mcccurved_guide_35_0_chamfers_z
#define chamfers_lr mcccurved_guide_35_0_chamfers_lr
#define chamfers_tb mcccurved_guide_35_0_chamfers_tb
#define nelements mcccurved_guide_35_0_nelements
#define nu mcccurved_guide_35_0_nu
#define phase mcccurved_guide_35_0_phase
#define reflect mcccurved_guide_35_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38090 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_36_0. */
  SIG_MESSAGE("curved_guide_36_0 (Init)");
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
#define w1 mcccurved_guide_36_0_w1
#define h1 mcccurved_guide_36_0_h1
#define w2 mcccurved_guide_36_0_w2
#define h2 mcccurved_guide_36_0_h2
#define l mcccurved_guide_36_0_l
#define R0 mcccurved_guide_36_0_R0
#define Qc mcccurved_guide_36_0_Qc
#define alpha mcccurved_guide_36_0_alpha
#define m mcccurved_guide_36_0_m
#define W mcccurved_guide_36_0_W
#define nslit mcccurved_guide_36_0_nslit
#define d mcccurved_guide_36_0_d
#define mleft mcccurved_guide_36_0_mleft
#define mright mcccurved_guide_36_0_mright
#define mtop mcccurved_guide_36_0_mtop
#define mbottom mcccurved_guide_36_0_mbottom
#define nhslit mcccurved_guide_36_0_nhslit
#define G mcccurved_guide_36_0_G
#define aleft mcccurved_guide_36_0_aleft
#define aright mcccurved_guide_36_0_aright
#define atop mcccurved_guide_36_0_atop
#define abottom mcccurved_guide_36_0_abottom
#define wavy mcccurved_guide_36_0_wavy
#define wavy_z mcccurved_guide_36_0_wavy_z
#define wavy_tb mcccurved_guide_36_0_wavy_tb
#define wavy_lr mcccurved_guide_36_0_wavy_lr
#define chamfers mcccurved_guide_36_0_chamfers
#define chamfers_z mcccurved_guide_36_0_chamfers_z
#define chamfers_lr mcccurved_guide_36_0_chamfers_lr
#define chamfers_tb mcccurved_guide_36_0_chamfers_tb
#define nelements mcccurved_guide_36_0_nelements
#define nu mcccurved_guide_36_0_nu
#define phase mcccurved_guide_36_0_phase
#define reflect mcccurved_guide_36_0_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38224 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_4. */
  SIG_MESSAGE("EndOfelement_4 (Init)");

  /* Initializations for component elliptical_guide_gravity3. */
  SIG_MESSAGE("elliptical_guide_gravity3 (Init)");
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 72
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
#define l mccelliptical_guide_gravity3_l
#define xwidth mccelliptical_guide_gravity3_xwidth
#define yheight mccelliptical_guide_gravity3_yheight
#define linxw mccelliptical_guide_gravity3_linxw
#define loutxw mccelliptical_guide_gravity3_loutxw
#define linyh mccelliptical_guide_gravity3_linyh
#define loutyh mccelliptical_guide_gravity3_loutyh
#define majorAxisxw mccelliptical_guide_gravity3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity3_dimensionsAt
#define option mccelliptical_guide_gravity3_option
#define R0 mccelliptical_guide_gravity3_R0
#define Qc mccelliptical_guide_gravity3_Qc
#define alpha mccelliptical_guide_gravity3_alpha
#define m mccelliptical_guide_gravity3_m
#define W mccelliptical_guide_gravity3_W
#define alpharight mccelliptical_guide_gravity3_alpharight
#define mright mccelliptical_guide_gravity3_mright
#define alphaleft mccelliptical_guide_gravity3_alphaleft
#define mleft mccelliptical_guide_gravity3_mleft
#define alphatop mccelliptical_guide_gravity3_alphatop
#define mtop mccelliptical_guide_gravity3_mtop
#define alphabottom mccelliptical_guide_gravity3_alphabottom
#define mbottom mccelliptical_guide_gravity3_mbottom
#define verbose mccelliptical_guide_gravity3_verbose
#define enableGravity mccelliptical_guide_gravity3_enableGravity
#define curvature mccelliptical_guide_gravity3_curvature
#line 817 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 38911 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_3. */
  SIG_MESSAGE("EndOfelement_3 (Init)");

  /* Initializations for component straight_guide_2_1. */
  SIG_MESSAGE("straight_guide_2_1 (Init)");
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
#define w1 mccstraight_guide_2_1_w1
#define h1 mccstraight_guide_2_1_h1
#define w2 mccstraight_guide_2_1_w2
#define h2 mccstraight_guide_2_1_h2
#define l mccstraight_guide_2_1_l
#define R0 mccstraight_guide_2_1_R0
#define Qc mccstraight_guide_2_1_Qc
#define alpha mccstraight_guide_2_1_alpha
#define m mccstraight_guide_2_1_m
#define W mccstraight_guide_2_1_W
#define nslit mccstraight_guide_2_1_nslit
#define d mccstraight_guide_2_1_d
#define mleft mccstraight_guide_2_1_mleft
#define mright mccstraight_guide_2_1_mright
#define mtop mccstraight_guide_2_1_mtop
#define mbottom mccstraight_guide_2_1_mbottom
#define nhslit mccstraight_guide_2_1_nhslit
#define G mccstraight_guide_2_1_G
#define aleft mccstraight_guide_2_1_aleft
#define aright mccstraight_guide_2_1_aright
#define atop mccstraight_guide_2_1_atop
#define abottom mccstraight_guide_2_1_abottom
#define wavy mccstraight_guide_2_1_wavy
#define wavy_z mccstraight_guide_2_1_wavy_z
#define wavy_tb mccstraight_guide_2_1_wavy_tb
#define wavy_lr mccstraight_guide_2_1_wavy_lr
#define chamfers mccstraight_guide_2_1_chamfers
#define chamfers_z mccstraight_guide_2_1_chamfers_z
#define chamfers_lr mccstraight_guide_2_1_chamfers_lr
#define chamfers_tb mccstraight_guide_2_1_chamfers_tb
#define nelements mccstraight_guide_2_1_nelements
#define nu mccstraight_guide_2_1_nu
#define phase mccstraight_guide_2_1_phase
#define reflect mccstraight_guide_2_1_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39058 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component L_monBeforeBWC. */
  SIG_MESSAGE("L_monBeforeBWC (Init)");
#define mccompcurname  L_monBeforeBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 75
#define nL mccL_monBeforeBWC_nL
#define L_N mccL_monBeforeBWC_L_N
#define L_p mccL_monBeforeBWC_L_p
#define L_p2 mccL_monBeforeBWC_L_p2
#define filename mccL_monBeforeBWC_filename
#define xmin mccL_monBeforeBWC_xmin
#define xmax mccL_monBeforeBWC_xmax
#define ymin mccL_monBeforeBWC_ymin
#define ymax mccL_monBeforeBWC_ymax
#define xwidth mccL_monBeforeBWC_xwidth
#define yheight mccL_monBeforeBWC_yheight
#define Lmin mccL_monBeforeBWC_Lmin
#define Lmax mccL_monBeforeBWC_Lmax
#define restore_neutron mccL_monBeforeBWC_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 39139 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFBeforeBWC. */
  SIG_MESSAGE("ToFBeforeBWC (Init)");
#define mccompcurname  ToFBeforeBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 76
#define nt mccToFBeforeBWC_nt
#define TOF_N mccToFBeforeBWC_TOF_N
#define TOF_p mccToFBeforeBWC_TOF_p
#define TOF_p2 mccToFBeforeBWC_TOF_p2
#define t_min mccToFBeforeBWC_t_min
#define t_max mccToFBeforeBWC_t_max
#define delta_t mccToFBeforeBWC_delta_t
#define filename mccToFBeforeBWC_filename
#define xmin mccToFBeforeBWC_xmin
#define xmax mccToFBeforeBWC_xmax
#define ymin mccToFBeforeBWC_ymin
#define ymax mccToFBeforeBWC_ymax
#define xwidth mccToFBeforeBWC_xwidth
#define yheight mccToFBeforeBWC_yheight
#define tmin mccToFBeforeBWC_tmin
#define tmax mccToFBeforeBWC_tmax
#define dt mccToFBeforeBWC_dt
#define restore_neutron mccToFBeforeBWC_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 39214 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component BWC1. */
  SIG_MESSAGE("BWC1 (Init)");
#define mccompcurname  BWC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 77
#define Tg mccBWC1_Tg
#define To mccBWC1_To
#define delta_y mccBWC1_delta_y
#define height mccBWC1_height
#define omega mccBWC1_omega
#define theta_0 mccBWC1_theta_0
#define radius mccBWC1_radius
#define yheight mccBWC1_yheight
#define nu mccBWC1_nu
#define nslit mccBWC1_nslit
#define jitter mccBWC1_jitter
#define delay mccBWC1_delay
#define isfirst mccBWC1_isfirst
#define n_pulse mccBWC1_n_pulse
#define abs_out mccBWC1_abs_out
#define phase mccBWC1_phase
#define xwidth mccBWC1_xwidth
#define verbose mccBWC1_verbose
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 39322 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component BWC2. */
  SIG_MESSAGE("BWC2 (Init)");
#define mccompcurname  BWC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 78
#define Tg mccBWC2_Tg
#define To mccBWC2_To
#define delta_y mccBWC2_delta_y
#define height mccBWC2_height
#define omega mccBWC2_omega
#define theta_0 mccBWC2_theta_0
#define radius mccBWC2_radius
#define yheight mccBWC2_yheight
#define nu mccBWC2_nu
#define nslit mccBWC2_nslit
#define jitter mccBWC2_jitter
#define delay mccBWC2_delay
#define isfirst mccBWC2_isfirst
#define n_pulse mccBWC2_n_pulse
#define abs_out mccBWC2_abs_out
#define phase mccBWC2_phase
#define xwidth mccBWC2_xwidth
#define verbose mccBWC2_verbose
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 39430 "BIFROST.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ToFAfterBWC. */
  SIG_MESSAGE("ToFAfterBWC (Init)");
#define mccompcurname  ToFAfterBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 79
#define nt mccToFAfterBWC_nt
#define TOF_N mccToFAfterBWC_TOF_N
#define TOF_p mccToFAfterBWC_TOF_p
#define TOF_p2 mccToFAfterBWC_TOF_p2
#define t_min mccToFAfterBWC_t_min
#define t_max mccToFAfterBWC_t_max
#define delta_t mccToFAfterBWC_delta_t
#define filename mccToFAfterBWC_filename
#define xmin mccToFAfterBWC_xmin
#define xmax mccToFAfterBWC_xmax
#define ymin mccToFAfterBWC_ymin
#define ymax mccToFAfterBWC_ymax
#define xwidth mccToFAfterBWC_xwidth
#define yheight mccToFAfterBWC_yheight
#define tmin mccToFAfterBWC_tmin
#define tmax mccToFAfterBWC_tmax
#define dt mccToFAfterBWC_dt
#define restore_neutron mccToFAfterBWC_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 39509 "BIFROST.c"
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component L_monAfterBWC. */
  SIG_MESSAGE("L_monAfterBWC (Init)");
#define mccompcurname  L_monAfterBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 80
#define nL mccL_monAfterBWC_nL
#define L_N mccL_monAfterBWC_L_N
#define L_p mccL_monAfterBWC_L_p
#define L_p2 mccL_monAfterBWC_L_p2
#define filename mccL_monAfterBWC_filename
#define xmin mccL_monAfterBWC_xmin
#define xmax mccL_monAfterBWC_xmax
#define ymin mccL_monAfterBWC_ymin
#define ymax mccL_monAfterBWC_ymax
#define xwidth mccL_monAfterBWC_xwidth
#define yheight mccL_monAfterBWC_yheight
#define Lmin mccL_monAfterBWC_Lmin
#define Lmax mccL_monAfterBWC_Lmax
#define restore_neutron mccL_monAfterBWC_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 39572 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component straight_guide_2_2. */
  SIG_MESSAGE("straight_guide_2_2 (Init)");
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 81
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
#define w1 mccstraight_guide_2_2_w1
#define h1 mccstraight_guide_2_2_h1
#define w2 mccstraight_guide_2_2_w2
#define h2 mccstraight_guide_2_2_h2
#define l mccstraight_guide_2_2_l
#define R0 mccstraight_guide_2_2_R0
#define Qc mccstraight_guide_2_2_Qc
#define alpha mccstraight_guide_2_2_alpha
#define m mccstraight_guide_2_2_m
#define W mccstraight_guide_2_2_W
#define nslit mccstraight_guide_2_2_nslit
#define d mccstraight_guide_2_2_d
#define mleft mccstraight_guide_2_2_mleft
#define mright mccstraight_guide_2_2_mright
#define mtop mccstraight_guide_2_2_mtop
#define mbottom mccstraight_guide_2_2_mbottom
#define nhslit mccstraight_guide_2_2_nhslit
#define G mccstraight_guide_2_2_G
#define aleft mccstraight_guide_2_2_aleft
#define aright mccstraight_guide_2_2_aright
#define atop mccstraight_guide_2_2_atop
#define abottom mccstraight_guide_2_2_abottom
#define wavy mccstraight_guide_2_2_wavy
#define wavy_z mccstraight_guide_2_2_wavy_z
#define wavy_tb mccstraight_guide_2_2_wavy_tb
#define wavy_lr mccstraight_guide_2_2_wavy_lr
#define chamfers mccstraight_guide_2_2_chamfers
#define chamfers_z mccstraight_guide_2_2_chamfers_z
#define chamfers_lr mccstraight_guide_2_2_chamfers_lr
#define chamfers_tb mccstraight_guide_2_2_chamfers_tb
#define nelements mccstraight_guide_2_2_nelements
#define nu mccstraight_guide_2_2_nu
#define phase mccstraight_guide_2_2_phase
#define reflect mccstraight_guide_2_2_reflect
#line 340 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39684 "BIFROST.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_2. */
  SIG_MESSAGE("EndOfelement_2 (Init)");

  /* Initializations for component elliptical_guide_gravity1_1. */
  SIG_MESSAGE("elliptical_guide_gravity1_1 (Init)");
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 83
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
#define l mccelliptical_guide_gravity1_1_l
#define xwidth mccelliptical_guide_gravity1_1_xwidth
#define yheight mccelliptical_guide_gravity1_1_yheight
#define linxw mccelliptical_guide_gravity1_1_linxw
#define loutxw mccelliptical_guide_gravity1_1_loutxw
#define linyh mccelliptical_guide_gravity1_1_linyh
#define loutyh mccelliptical_guide_gravity1_1_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_1_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_1_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_1_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_1_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_1_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_1_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_1_dimensionsAt
#define option mccelliptical_guide_gravity1_1_option
#define R0 mccelliptical_guide_gravity1_1_R0
#define Qc mccelliptical_guide_gravity1_1_Qc
#define alpha mccelliptical_guide_gravity1_1_alpha
#define m mccelliptical_guide_gravity1_1_m
#define W mccelliptical_guide_gravity1_1_W
#define alpharight mccelliptical_guide_gravity1_1_alpharight
#define mright mccelliptical_guide_gravity1_1_mright
#define alphaleft mccelliptical_guide_gravity1_1_alphaleft
#define mleft mccelliptical_guide_gravity1_1_mleft
#define alphatop mccelliptical_guide_gravity1_1_alphatop
#define mtop mccelliptical_guide_gravity1_1_mtop
#define alphabottom mccelliptical_guide_gravity1_1_alphabottom
#define mbottom mccelliptical_guide_gravity1_1_mbottom
#define verbose mccelliptical_guide_gravity1_1_verbose
#define enableGravity mccelliptical_guide_gravity1_1_enableGravity
#define curvature mccelliptical_guide_gravity1_1_curvature
#line 817 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 40371 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw3. */
  SIG_MESSAGE("DiwJaw3 (Init)");
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 84
#define xmin mccDiwJaw3_xmin
#define xmax mccDiwJaw3_xmax
#define ymin mccDiwJaw3_ymin
#define ymax mccDiwJaw3_ymax
#define radius mccDiwJaw3_radius
#define xwidth mccDiwJaw3_xwidth
#define yheight mccDiwJaw3_yheight
#line 47 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
if (xwidth > 0)  { xmax=xwidth/2;  xmin=-xmax; }
  if (yheight > 0) { ymax=yheight/2; ymin=-ymax; }
  if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Error: give geometry\n", NAME_CURRENT_COMP); exit(-1); }

}
#line 40442 "BIFROST.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component elliptical_guide_gravity1_2. */
  SIG_MESSAGE("elliptical_guide_gravity1_2 (Init)");
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 85
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
#define l mccelliptical_guide_gravity1_2_l
#define xwidth mccelliptical_guide_gravity1_2_xwidth
#define yheight mccelliptical_guide_gravity1_2_yheight
#define linxw mccelliptical_guide_gravity1_2_linxw
#define loutxw mccelliptical_guide_gravity1_2_loutxw
#define linyh mccelliptical_guide_gravity1_2_linyh
#define loutyh mccelliptical_guide_gravity1_2_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_2_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_2_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_2_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_2_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_2_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_2_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_2_dimensionsAt
#define option mccelliptical_guide_gravity1_2_option
#define R0 mccelliptical_guide_gravity1_2_R0
#define Qc mccelliptical_guide_gravity1_2_Qc
#define alpha mccelliptical_guide_gravity1_2_alpha
#define m mccelliptical_guide_gravity1_2_m
#define W mccelliptical_guide_gravity1_2_W
#define alpharight mccelliptical_guide_gravity1_2_alpharight
#define mright mccelliptical_guide_gravity1_2_mright
#define alphaleft mccelliptical_guide_gravity1_2_alphaleft
#define mleft mccelliptical_guide_gravity1_2_mleft
#define alphatop mccelliptical_guide_gravity1_2_alphatop
#define mtop mccelliptical_guide_gravity1_2_mtop
#define alphabottom mccelliptical_guide_gravity1_2_alphabottom
#define mbottom mccelliptical_guide_gravity1_2_mbottom
#define verbose mccelliptical_guide_gravity1_2_verbose
#define enableGravity mccelliptical_guide_gravity1_2_enableGravity
#define curvature mccelliptical_guide_gravity1_2_curvature
#line 817 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 41097 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw2. */
  SIG_MESSAGE("DiwJaw2 (Init)");
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 86
#define xmin mccDiwJaw2_xmin
#define xmax mccDiwJaw2_xmax
#define ymin mccDiwJaw2_ymin
#define ymax mccDiwJaw2_ymax
#define radius mccDiwJaw2_radius
#define xwidth mccDiwJaw2_xwidth
#define yheight mccDiwJaw2_yheight
#line 47 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
if (xwidth > 0)  { xmax=xwidth/2;  xmin=-xmax; }
  if (yheight > 0) { ymax=yheight/2; ymin=-ymax; }
  if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Error: give geometry\n", NAME_CURRENT_COMP); exit(-1); }

}
#line 41168 "BIFROST.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component elliptical_guide_gravity1_3. */
  SIG_MESSAGE("elliptical_guide_gravity1_3 (Init)");
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 87
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
#define l mccelliptical_guide_gravity1_3_l
#define xwidth mccelliptical_guide_gravity1_3_xwidth
#define yheight mccelliptical_guide_gravity1_3_yheight
#define linxw mccelliptical_guide_gravity1_3_linxw
#define loutxw mccelliptical_guide_gravity1_3_loutxw
#define linyh mccelliptical_guide_gravity1_3_linyh
#define loutyh mccelliptical_guide_gravity1_3_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_3_dimensionsAt
#define option mccelliptical_guide_gravity1_3_option
#define R0 mccelliptical_guide_gravity1_3_R0
#define Qc mccelliptical_guide_gravity1_3_Qc
#define alpha mccelliptical_guide_gravity1_3_alpha
#define m mccelliptical_guide_gravity1_3_m
#define W mccelliptical_guide_gravity1_3_W
#define alpharight mccelliptical_guide_gravity1_3_alpharight
#define mright mccelliptical_guide_gravity1_3_mright
#define alphaleft mccelliptical_guide_gravity1_3_alphaleft
#define mleft mccelliptical_guide_gravity1_3_mleft
#define alphatop mccelliptical_guide_gravity1_3_alphatop
#define mtop mccelliptical_guide_gravity1_3_mtop
#define alphabottom mccelliptical_guide_gravity1_3_alphabottom
#define mbottom mccelliptical_guide_gravity1_3_mbottom
#define verbose mccelliptical_guide_gravity1_3_verbose
#define enableGravity mccelliptical_guide_gravity1_3_enableGravity
#define curvature mccelliptical_guide_gravity1_3_curvature
#line 817 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 41823 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw1. */
  SIG_MESSAGE("DiwJaw1 (Init)");
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 88
#define xmin mccDiwJaw1_xmin
#define xmax mccDiwJaw1_xmax
#define ymin mccDiwJaw1_ymin
#define ymax mccDiwJaw1_ymax
#define radius mccDiwJaw1_radius
#define xwidth mccDiwJaw1_xwidth
#define yheight mccDiwJaw1_yheight
#line 47 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
if (xwidth > 0)  { xmax=xwidth/2;  xmin=-xmax; }
  if (yheight > 0) { ymax=yheight/2; ymin=-ymax; }
  if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Error: give geometry\n", NAME_CURRENT_COMP); exit(-1); }

}
#line 41894 "BIFROST.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component elliptical_guide_gravity1_4. */
  SIG_MESSAGE("elliptical_guide_gravity1_4 (Init)");
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 89
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
#define l mccelliptical_guide_gravity1_4_l
#define xwidth mccelliptical_guide_gravity1_4_xwidth
#define yheight mccelliptical_guide_gravity1_4_yheight
#define linxw mccelliptical_guide_gravity1_4_linxw
#define loutxw mccelliptical_guide_gravity1_4_loutxw
#define linyh mccelliptical_guide_gravity1_4_linyh
#define loutyh mccelliptical_guide_gravity1_4_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_4_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_4_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_4_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_4_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_4_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_4_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_4_dimensionsAt
#define option mccelliptical_guide_gravity1_4_option
#define R0 mccelliptical_guide_gravity1_4_R0
#define Qc mccelliptical_guide_gravity1_4_Qc
#define alpha mccelliptical_guide_gravity1_4_alpha
#define m mccelliptical_guide_gravity1_4_m
#define W mccelliptical_guide_gravity1_4_W
#define alpharight mccelliptical_guide_gravity1_4_alpharight
#define mright mccelliptical_guide_gravity1_4_mright
#define alphaleft mccelliptical_guide_gravity1_4_alphaleft
#define mleft mccelliptical_guide_gravity1_4_mleft
#define alphatop mccelliptical_guide_gravity1_4_alphatop
#define mtop mccelliptical_guide_gravity1_4_mtop
#define alphabottom mccelliptical_guide_gravity1_4_alphabottom
#define mbottom mccelliptical_guide_gravity1_4_mbottom
#define verbose mccelliptical_guide_gravity1_4_verbose
#define enableGravity mccelliptical_guide_gravity1_4_enableGravity
#define curvature mccelliptical_guide_gravity1_4_curvature
#line 817 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 42549 "BIFROST.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_1. */
  SIG_MESSAGE("EndOfelement_1 (Init)");

  /* Initializations for component VirtualOutput. */
  SIG_MESSAGE("VirtualOutput (Init)");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 91
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
#define filename mccVirtualOutput_filename
#define bufsize mccVirtualOutput_bufsize
#line 78 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\Virtual_output.comp"
{
sprintf(type,"text");
  long element_size=85; /* mean size per neutron for ascii storing */

  strcpy(Vars.compcurname, NAME_CURRENT_COMP);

  if (bufsize > 0) sprintf(Vars.option, "list=%g borders", bufsize);
  else strcpy(Vars.option, "list all borders");

  if (type && strlen(type) && strcmp(type, "NULL") && strcmp(type,"0"))
  {
    if (strstr(type, "Vitess"))
    { fprintf(stderr, "Virtual_output: %s: Vitess files may be generated using the Vitess_output component\n", NAME_CURRENT_COMP); exit(-1); }
    if (strstr(type, "binary") || strstr(type, "float")) {
      strcat(Vars.option, ", binary float");
      element_size = sizeof(float);
    } else if (strstr(type, "double")) {
      strcat(Vars.option, ", binary double");
      element_size = sizeof(double);
    }
  }

  strcat(Vars.option,", x y z vx vy vz t sx sy sz");
  Monitor_nD_Init(&DEFS, &Vars, 0.1, 0.1, 0, 0,0,0,0,0,0,0); /* dims for mcdisplay */
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  if (bufsize > 0)
    printf("Warning: Virtual_output: %s: buffer size=%g not recommended\n", NAME_CURRENT_COMP, bufsize);
  if (bufsize > 0) printf(
           "Virtual_output: %s: Beware virtual output generated file size (max %g Mo)\n"
           "WARNING         Memory required is %g Mo\n", NAME_CURRENT_COMP,
           bufsize*element_size/1e6, bufsize*sizeof(double)/1e6);
}
#line 42649 "BIFROST.c"
#undef bufsize
#undef filename
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw0. */
  SIG_MESSAGE("DiwJaw0 (Init)");
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 92
#define xmin mccDiwJaw0_xmin
#define xmax mccDiwJaw0_xmax
#define ymin mccDiwJaw0_ymin
#define ymax mccDiwJaw0_ymax
#define radius mccDiwJaw0_radius
#define xwidth mccDiwJaw0_xwidth
#define yheight mccDiwJaw0_yheight
#line 47 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
if (xwidth > 0)  { xmax=xwidth/2;  xmin=-xmax; }
  if (yheight > 0) { ymax=yheight/2; ymin=-ymax; }
  if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Error: give geometry\n", NAME_CURRENT_COMP); exit(-1); }

}
#line 42678 "BIFROST.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Lmon_guide_end. */
  SIG_MESSAGE("Lmon_guide_end (Init)");
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
#define filename mccLmon_guide_end_filename
#define xmin mccLmon_guide_end_xmin
#define xmax mccLmon_guide_end_xmax
#define ymin mccLmon_guide_end_ymin
#define ymax mccLmon_guide_end_ymax
#define xwidth mccLmon_guide_end_xwidth
#define yheight mccLmon_guide_end_yheight
#define Lmin mccLmon_guide_end_Lmin
#define Lmax mccLmon_guide_end_Lmax
#define restore_neutron mccLmon_guide_end_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 42730 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Div2d_sample_B. */
  SIG_MESSAGE("Div2d_sample_B (Init)");
#define mccompcurname  Div2d_sample_B
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 94
#define nh mccDiv2d_sample_B_nh
#define nv mccDiv2d_sample_B_nv
#define Div_N mccDiv2d_sample_B_Div_N
#define Div_p mccDiv2d_sample_B_Div_p
#define Div_p2 mccDiv2d_sample_B_Div_p2
#define filename mccDiv2d_sample_B_filename
#define xmin mccDiv2d_sample_B_xmin
#define xmax mccDiv2d_sample_B_xmax
#define ymin mccDiv2d_sample_B_ymin
#define ymax mccDiv2d_sample_B_ymax
#define xwidth mccDiv2d_sample_B_xwidth
#define yheight mccDiv2d_sample_B_yheight
#define maxdiv_h mccDiv2d_sample_B_maxdiv_h
#define maxdiv_v mccDiv2d_sample_B_maxdiv_v
#define restore_neutron mccDiv2d_sample_B_restore_neutron
#define nx mccDiv2d_sample_B_nx
#define ny mccDiv2d_sample_B_ny
#define nz mccDiv2d_sample_B_nz
#line 65 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Divergence_monitor: %s: Null detection area !\n"
                   "ERROR               (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<nv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 42795 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Div2d_sample. */
  SIG_MESSAGE("Div2d_sample (Init)");
#define mccompcurname  Div2d_sample
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 95
#define nh mccDiv2d_sample_nh
#define nv mccDiv2d_sample_nv
#define Div_N mccDiv2d_sample_Div_N
#define Div_p mccDiv2d_sample_Div_p
#define Div_p2 mccDiv2d_sample_Div_p2
#define filename mccDiv2d_sample_filename
#define xmin mccDiv2d_sample_xmin
#define xmax mccDiv2d_sample_xmax
#define ymin mccDiv2d_sample_ymin
#define ymax mccDiv2d_sample_ymax
#define xwidth mccDiv2d_sample_xwidth
#define yheight mccDiv2d_sample_yheight
#define maxdiv_h mccDiv2d_sample_maxdiv_h
#define maxdiv_v mccDiv2d_sample_maxdiv_v
#define restore_neutron mccDiv2d_sample_restore_neutron
#define nx mccDiv2d_sample_nx
#define ny mccDiv2d_sample_ny
#define nz mccDiv2d_sample_nz
#line 65 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Divergence_monitor: %s: Null detection area !\n"
                   "ERROR               (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<nv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 42864 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_sample. */
  SIG_MESSAGE("PSD_sample (Init)");
#define mccompcurname  PSD_sample
#define mccompcurtype  PSD_monitor
#define mccompcurindex 96
#define nx mccPSD_sample_nx
#define ny mccPSD_sample_ny
#define PSD_N mccPSD_sample_PSD_N
#define PSD_p mccPSD_sample_PSD_p
#define PSD_p2 mccPSD_sample_PSD_p2
#define filename mccPSD_sample_filename
#define xmin mccPSD_sample_xmin
#define xmax mccPSD_sample_xmax
#define ymin mccPSD_sample_ymin
#define ymax mccPSD_sample_ymax
#define xwidth mccPSD_sample_xwidth
#define yheight mccPSD_sample_yheight
#define restore_neutron mccPSD_sample_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 42927 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component HPSD_sample. */
  SIG_MESSAGE("HPSD_sample (Init)");
#define mccompcurname  HPSD_sample
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 97
#define nx mccHPSD_sample_nx
#define PSDlin_N mccHPSD_sample_PSDlin_N
#define PSDlin_p mccHPSD_sample_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_PSDlin_p2
#define filename mccHPSD_sample_filename
#define xmin mccHPSD_sample_xmin
#define xmax mccHPSD_sample_xmax
#define ymin mccHPSD_sample_ymin
#define ymax mccHPSD_sample_ymax
#define xwidth mccHPSD_sample_xwidth
#define yheight mccHPSD_sample_yheight
#define restore_neutron mccHPSD_sample_restore_neutron
#line 58 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
    int i;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSDlin_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
    {
      PSDlin_N[i] = 0;
      PSDlin_p[i] = 0;
      PSDlin_p2[i] = 0;
    }
}
#line 42983 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component VPSD_sample. */
  SIG_MESSAGE("VPSD_sample (Init)");
#define mccompcurname  VPSD_sample
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 98
#define ny mccVPSD_sample_ny
#define filename mccVPSD_sample_filename
#define PSDlin_N mccVPSD_sample_PSDlin_N
#define PSDlin_p mccVPSD_sample_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_PSDlin_p2
#define xmin mccVPSD_sample_xmin
#define xmax mccVPSD_sample_xmax
#define ymin mccVPSD_sample_ymin
#define ymax mccVPSD_sample_ymax
#define xwidth mccVPSD_sample_xwidth
#define yheight mccVPSD_sample_yheight
#define restore_neutron mccVPSD_sample_restore_neutron
#line 56 "PSDlin_y_monitor.comp"
{
    int i;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSDlin_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<ny; i++)
    {
      PSDlin_N[i] = 0;
      PSDlin_p[i] = 0;
      PSDlin_p2[i] = 0;
    }
}
#line 43038 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Hdiv_sample. */
  SIG_MESSAGE("Hdiv_sample (Init)");
#define mccompcurname  Hdiv_sample
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 99
#define nh mccHdiv_sample_nh
#define Div_N mccHdiv_sample_Div_N
#define Div_p mccHdiv_sample_Div_p
#define Div_p2 mccHdiv_sample_Div_p2
#define filename mccHdiv_sample_filename
#define xmin mccHdiv_sample_xmin
#define xmax mccHdiv_sample_xmax
#define ymin mccHdiv_sample_ymin
#define ymax mccHdiv_sample_ymax
#define xwidth mccHdiv_sample_xwidth
#define yheight mccHdiv_sample_yheight
#define h_maxdiv mccHdiv_sample_h_maxdiv
#define restore_neutron mccHdiv_sample_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Hdiv_monitor: %s: Null detection area !\n"
                   "ERROR         (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     {
/*       printf("HDiv_monitor: %d\n",i); */
      Div_N[i] = 0;
      Div_p[i] = 0;
      Div_p2[i] = 0;
     }
/*     printf("%d %d %d\n",i,nh,h_maxdiv); */
}
#line 43096 "BIFROST.c"
#undef restore_neutron
#undef h_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Vdiv_sample. */
  SIG_MESSAGE("Vdiv_sample (Init)");
#define mccompcurname  Vdiv_sample
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 100
#define nv mccVdiv_sample_nv
#define filename mccVdiv_sample_filename
#define restore_neutron mccVdiv_sample_restore_neutron
#define Div_N mccVdiv_sample_Div_N
#define Div_p mccVdiv_sample_Div_p
#define Div_p2 mccVdiv_sample_Div_p2
#define xmin mccVdiv_sample_xmin
#define xmax mccVdiv_sample_xmax
#define ymin mccVdiv_sample_ymin
#define ymax mccVdiv_sample_ymax
#define xwidth mccVdiv_sample_xwidth
#define yheight mccVdiv_sample_yheight
#define v_maxdiv mccVdiv_sample_v_maxdiv
#line 64 "Vdiv_monitor.comp"
{
    int i;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Vdiv_monitor: %s: Null detection area !\n"
                   "ERROR         (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nv; i++)
     {
/*       printf("HDiv_monitor: %d\n",i); */
      Div_N[i] = 0;
      Div_p[i] = 0;
      Div_p2[i] = 0;
     }
/*     printf("%d %d %d\n",i,nv,v_maxdiv); */
}
#line 43155 "BIFROST.c"
#undef v_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component acceptance_x_divx. */
  SIG_MESSAGE("acceptance_x_divx (Init)");
#define mccompcurname  acceptance_x_divx
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 101
#define nh mccacceptance_x_divx_nh
#define ndiv mccacceptance_x_divx_ndiv
#define Div_N mccacceptance_x_divx_Div_N
#define Div_p mccacceptance_x_divx_Div_p
#define Div_p2 mccacceptance_x_divx_Div_p2
#define filename mccacceptance_x_divx_filename
#define xmin mccacceptance_x_divx_xmin
#define xmax mccacceptance_x_divx_xmax
#define ymin mccacceptance_x_divx_ymin
#define ymax mccacceptance_x_divx_ymax
#define xwidth mccacceptance_x_divx_xwidth
#define yheight mccacceptance_x_divx_yheight
#define maxdiv_h mccacceptance_x_divx_maxdiv_h
#define restore_neutron mccacceptance_x_divx_restore_neutron
#define nx mccacceptance_x_divx_nx
#define ny mccacceptance_x_divx_ny
#define nz mccacceptance_x_divx_nz
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("DivPos_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<ndiv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 43218 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component acceptance_y_divy. */
  SIG_MESSAGE("acceptance_y_divy (Init)");
#define mccompcurname  acceptance_y_divy
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 102
#define npos mccacceptance_y_divy_npos
#define ndiv mccacceptance_y_divy_ndiv
#define filename mccacceptance_y_divy_filename
#define restore_neutron mccacceptance_y_divy_restore_neutron
#define Div_N mccacceptance_y_divy_Div_N
#define Div_p mccacceptance_y_divy_Div_p
#define Div_p2 mccacceptance_y_divy_Div_p2
#define xmin mccacceptance_y_divy_xmin
#define xmax mccacceptance_y_divy_xmax
#define ymin mccacceptance_y_divy_ymin
#define ymax mccacceptance_y_divy_ymax
#define xwidth mccacceptance_y_divy_xwidth
#define yheight mccacceptance_y_divy_yheight
#define maxdiv mccacceptance_y_divy_maxdiv
#line 63 "DivPos_y_monitor.comp"
{
    int i,j;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("DivPos_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<npos; i++)
     for (j=0; j<ndiv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
}
#line 43281 "BIFROST.c"
#undef maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Lmon_sample_B. */
  SIG_MESSAGE("Lmon_sample_B (Init)");
#define mccompcurname  Lmon_sample_B
#define mccompcurtype  L_monitor
#define mccompcurindex 103
#define nL mccLmon_sample_B_nL
#define L_N mccLmon_sample_B_L_N
#define L_p mccLmon_sample_B_L_p
#define L_p2 mccLmon_sample_B_L_p2
#define filename mccLmon_sample_B_filename
#define xmin mccLmon_sample_B_xmin
#define xmax mccLmon_sample_B_xmax
#define ymin mccLmon_sample_B_ymin
#define ymax mccLmon_sample_B_ymax
#define xwidth mccLmon_sample_B_xwidth
#define yheight mccLmon_sample_B_yheight
#define Lmin mccLmon_sample_B_Lmin
#define Lmax mccLmon_sample_B_Lmax
#define restore_neutron mccLmon_sample_B_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 43340 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Div2d_sample_maxdiv. */
  SIG_MESSAGE("Div2d_sample_maxdiv (Init)");
#define mccompcurname  Div2d_sample_maxdiv
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 104
#define nh mccDiv2d_sample_maxdiv_nh
#define nv mccDiv2d_sample_maxdiv_nv
#define Div_N mccDiv2d_sample_maxdiv_Div_N
#define Div_p mccDiv2d_sample_maxdiv_Div_p
#define Div_p2 mccDiv2d_sample_maxdiv_Div_p2
#define filename mccDiv2d_sample_maxdiv_filename
#define xmin mccDiv2d_sample_maxdiv_xmin
#define xmax mccDiv2d_sample_maxdiv_xmax
#define ymin mccDiv2d_sample_maxdiv_ymin
#define ymax mccDiv2d_sample_maxdiv_ymax
#define xwidth mccDiv2d_sample_maxdiv_xwidth
#define yheight mccDiv2d_sample_maxdiv_yheight
#define maxdiv_h mccDiv2d_sample_maxdiv_maxdiv_h
#define maxdiv_v mccDiv2d_sample_maxdiv_maxdiv_v
#define restore_neutron mccDiv2d_sample_maxdiv_restore_neutron
#define nx mccDiv2d_sample_maxdiv_nx
#define ny mccDiv2d_sample_maxdiv_ny
#define nz mccDiv2d_sample_maxdiv_nz
#line 65 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Divergence_monitor: %s: Null detection area !\n"
                   "ERROR               (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<nv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 43405 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_v
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_sample_maxdiv. */
  SIG_MESSAGE("PSD_sample_maxdiv (Init)");
#define mccompcurname  PSD_sample_maxdiv
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define nx mccPSD_sample_maxdiv_nx
#define ny mccPSD_sample_maxdiv_ny
#define PSD_N mccPSD_sample_maxdiv_PSD_N
#define PSD_p mccPSD_sample_maxdiv_PSD_p
#define PSD_p2 mccPSD_sample_maxdiv_PSD_p2
#define filename mccPSD_sample_maxdiv_filename
#define xmin mccPSD_sample_maxdiv_xmin
#define xmax mccPSD_sample_maxdiv_xmax
#define ymin mccPSD_sample_maxdiv_ymin
#define ymax mccPSD_sample_maxdiv_ymax
#define xwidth mccPSD_sample_maxdiv_xwidth
#define yheight mccPSD_sample_maxdiv_yheight
#define restore_neutron mccPSD_sample_maxdiv_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 43468 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component HPSD_sample_maxdiv. */
  SIG_MESSAGE("HPSD_sample_maxdiv (Init)");
#define mccompcurname  HPSD_sample_maxdiv
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 106
#define nx mccHPSD_sample_maxdiv_nx
#define PSDlin_N mccHPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccHPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_maxdiv_PSDlin_p2
#define filename mccHPSD_sample_maxdiv_filename
#define xmin mccHPSD_sample_maxdiv_xmin
#define xmax mccHPSD_sample_maxdiv_xmax
#define ymin mccHPSD_sample_maxdiv_ymin
#define ymax mccHPSD_sample_maxdiv_ymax
#define xwidth mccHPSD_sample_maxdiv_xwidth
#define yheight mccHPSD_sample_maxdiv_yheight
#define restore_neutron mccHPSD_sample_maxdiv_restore_neutron
#line 58 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
    int i;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSDlin_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
    {
      PSDlin_N[i] = 0;
      PSDlin_p[i] = 0;
      PSDlin_p2[i] = 0;
    }
}
#line 43524 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component VPSD_sample_maxdiv. */
  SIG_MESSAGE("VPSD_sample_maxdiv (Init)");
#define mccompcurname  VPSD_sample_maxdiv
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 107
#define ny mccVPSD_sample_maxdiv_ny
#define filename mccVPSD_sample_maxdiv_filename
#define PSDlin_N mccVPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccVPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_maxdiv_PSDlin_p2
#define xmin mccVPSD_sample_maxdiv_xmin
#define xmax mccVPSD_sample_maxdiv_xmax
#define ymin mccVPSD_sample_maxdiv_ymin
#define ymax mccVPSD_sample_maxdiv_ymax
#define xwidth mccVPSD_sample_maxdiv_xwidth
#define yheight mccVPSD_sample_maxdiv_yheight
#define restore_neutron mccVPSD_sample_maxdiv_restore_neutron
#line 56 "PSDlin_y_monitor.comp"
{
    int i;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSDlin_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<ny; i++)
    {
      PSDlin_N[i] = 0;
      PSDlin_p[i] = 0;
      PSDlin_p2[i] = 0;
    }
}
#line 43579 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Hdiv_sample_maxdiv. */
  SIG_MESSAGE("Hdiv_sample_maxdiv (Init)");
#define mccompcurname  Hdiv_sample_maxdiv
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 108
#define nh mccHdiv_sample_maxdiv_nh
#define Div_N mccHdiv_sample_maxdiv_Div_N
#define Div_p mccHdiv_sample_maxdiv_Div_p
#define Div_p2 mccHdiv_sample_maxdiv_Div_p2
#define filename mccHdiv_sample_maxdiv_filename
#define xmin mccHdiv_sample_maxdiv_xmin
#define xmax mccHdiv_sample_maxdiv_xmax
#define ymin mccHdiv_sample_maxdiv_ymin
#define ymax mccHdiv_sample_maxdiv_ymax
#define xwidth mccHdiv_sample_maxdiv_xwidth
#define yheight mccHdiv_sample_maxdiv_yheight
#define h_maxdiv mccHdiv_sample_maxdiv_h_maxdiv
#define restore_neutron mccHdiv_sample_maxdiv_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Hdiv_monitor: %s: Null detection area !\n"
                   "ERROR         (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     {
/*       printf("HDiv_monitor: %d\n",i); */
      Div_N[i] = 0;
      Div_p[i] = 0;
      Div_p2[i] = 0;
     }
/*     printf("%d %d %d\n",i,nh,h_maxdiv); */
}
#line 43637 "BIFROST.c"
#undef restore_neutron
#undef h_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Vdiv_sample_maxdiv. */
  SIG_MESSAGE("Vdiv_sample_maxdiv (Init)");
#define mccompcurname  Vdiv_sample_maxdiv
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 109
#define nv mccVdiv_sample_maxdiv_nv
#define filename mccVdiv_sample_maxdiv_filename
#define restore_neutron mccVdiv_sample_maxdiv_restore_neutron
#define Div_N mccVdiv_sample_maxdiv_Div_N
#define Div_p mccVdiv_sample_maxdiv_Div_p
#define Div_p2 mccVdiv_sample_maxdiv_Div_p2
#define xmin mccVdiv_sample_maxdiv_xmin
#define xmax mccVdiv_sample_maxdiv_xmax
#define ymin mccVdiv_sample_maxdiv_ymin
#define ymax mccVdiv_sample_maxdiv_ymax
#define xwidth mccVdiv_sample_maxdiv_xwidth
#define yheight mccVdiv_sample_maxdiv_yheight
#define v_maxdiv mccVdiv_sample_maxdiv_v_maxdiv
#line 64 "Vdiv_monitor.comp"
{
    int i;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("Vdiv_monitor: %s: Null detection area !\n"
                   "ERROR         (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nv; i++)
     {
/*       printf("HDiv_monitor: %d\n",i); */
      Div_N[i] = 0;
      Div_p[i] = 0;
      Div_p2[i] = 0;
     }
/*     printf("%d %d %d\n",i,nv,v_maxdiv); */
}
#line 43696 "BIFROST.c"
#undef v_maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component acceptance_x_divx_maxdiv. */
  SIG_MESSAGE("acceptance_x_divx_maxdiv (Init)");
#define mccompcurname  acceptance_x_divx_maxdiv
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 110
#define nh mccacceptance_x_divx_maxdiv_nh
#define ndiv mccacceptance_x_divx_maxdiv_ndiv
#define Div_N mccacceptance_x_divx_maxdiv_Div_N
#define Div_p mccacceptance_x_divx_maxdiv_Div_p
#define Div_p2 mccacceptance_x_divx_maxdiv_Div_p2
#define filename mccacceptance_x_divx_maxdiv_filename
#define xmin mccacceptance_x_divx_maxdiv_xmin
#define xmax mccacceptance_x_divx_maxdiv_xmax
#define ymin mccacceptance_x_divx_maxdiv_ymin
#define ymax mccacceptance_x_divx_maxdiv_ymax
#define xwidth mccacceptance_x_divx_maxdiv_xwidth
#define yheight mccacceptance_x_divx_maxdiv_yheight
#define maxdiv_h mccacceptance_x_divx_maxdiv_maxdiv_h
#define restore_neutron mccacceptance_x_divx_maxdiv_restore_neutron
#define nx mccacceptance_x_divx_maxdiv_nx
#define ny mccacceptance_x_divx_maxdiv_ny
#define nz mccacceptance_x_divx_maxdiv_nz
#line 67 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("DivPos_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nh; i++)
     for (j=0; j<ndiv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
    NORM(nx,ny,nz);
}
#line 43759 "BIFROST.c"
#undef nz
#undef ny
#undef nx
#undef restore_neutron
#undef maxdiv_h
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component acceptance_y_divy_maxdiv. */
  SIG_MESSAGE("acceptance_y_divy_maxdiv (Init)");
#define mccompcurname  acceptance_y_divy_maxdiv
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 111
#define npos mccacceptance_y_divy_maxdiv_npos
#define ndiv mccacceptance_y_divy_maxdiv_ndiv
#define filename mccacceptance_y_divy_maxdiv_filename
#define restore_neutron mccacceptance_y_divy_maxdiv_restore_neutron
#define Div_N mccacceptance_y_divy_maxdiv_Div_N
#define Div_p mccacceptance_y_divy_maxdiv_Div_p
#define Div_p2 mccacceptance_y_divy_maxdiv_Div_p2
#define xmin mccacceptance_y_divy_maxdiv_xmin
#define xmax mccacceptance_y_divy_maxdiv_xmax
#define ymin mccacceptance_y_divy_maxdiv_ymin
#define ymax mccacceptance_y_divy_maxdiv_ymax
#define xwidth mccacceptance_y_divy_maxdiv_xwidth
#define yheight mccacceptance_y_divy_maxdiv_yheight
#define maxdiv mccacceptance_y_divy_maxdiv_maxdiv
#line 63 "DivPos_y_monitor.comp"
{
    int i,j;

    if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("DivPos_monitor: %s: Null detection area !\n"
                   "ERROR           (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<npos; i++)
     for (j=0; j<ndiv; j++)
     {
      Div_N[i][j] = 0;
      Div_p[i][j] = 0;
      Div_p2[i][j] = 0;
     }
}
#line 43822 "BIFROST.c"
#undef maxdiv
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Lmon_sample. */
  SIG_MESSAGE("Lmon_sample (Init)");
#define mccompcurname  Lmon_sample
#define mccompcurtype  L_monitor
#define mccompcurindex 112
#define nL mccLmon_sample_nL
#define L_N mccLmon_sample_L_N
#define L_p mccLmon_sample_L_p
#define L_p2 mccLmon_sample_L_p2
#define filename mccLmon_sample_filename
#define xmin mccLmon_sample_xmin
#define xmax mccLmon_sample_xmax
#define ymin mccLmon_sample_ymin
#define ymax mccLmon_sample_ymax
#define xwidth mccLmon_sample_xwidth
#define yheight mccLmon_sample_yheight
#define Lmin mccLmon_sample_Lmin
#define Lmax mccLmon_sample_Lmax
#define restore_neutron mccLmon_sample_restore_neutron
#line 61 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 43881 "BIFROST.c"
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component v_sample. */
  SIG_MESSAGE("v_sample (Init)");
#define mccompcurname  v_sample
#define mccompcurtype  V_sample
#define mccompcurindex 113
#define VarsV mccv_sample_VarsV
#define radius mccv_sample_radius
#define thickness mccv_sample_thickness
#define zdepth mccv_sample_zdepth
#define Vc mccv_sample_Vc
#define sigma_abs mccv_sample_sigma_abs
#define sigma_inc mccv_sample_sigma_inc
#define radius_i mccv_sample_radius_i
#define radius_o mccv_sample_radius_o
#define h mccv_sample_h
#define focus_r mccv_sample_focus_r
#define pack mccv_sample_pack
#define frac mccv_sample_frac
#define f_QE mccv_sample_f_QE
#define gamma mccv_sample_gamma
#define target_x mccv_sample_target_x
#define target_y mccv_sample_target_y
#define target_z mccv_sample_target_z
#define focus_xw mccv_sample_focus_xw
#define focus_yh mccv_sample_focus_yh
#define focus_aw mccv_sample_focus_aw
#define focus_ah mccv_sample_focus_ah
#define xwidth mccv_sample_xwidth
#define yheight mccv_sample_yheight
#define zthick mccv_sample_zthick
#define rad_sphere mccv_sample_rad_sphere
#define sig_a mccv_sample_sig_a
#define sig_i mccv_sample_sig_i
#define V0 mccv_sample_V0
#define target_index mccv_sample_target_index
#define multiples mccv_sample_multiples
#line 121 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\obsolete\\V_sample.comp"
{
  /* Backward compatibility */
  if (radius) radius_o = radius;
  if (thickness) radius_i = radius_o - thickness;
  if (zdepth) zthick = zdepth;
  if (yheight) h = yheight;
  if (Vc) V0 = Vc;
  if (sigma_abs) sig_a = sigma_abs;
  if (sigma_inc) sig_i = sigma_inc;

  VarsV.shapetyp = -1;
  if (xwidth && yheight && zdepth)  VarsV.shapetyp=1; /* box */
  else if (radius > 0 && yheight)        VarsV.shapetyp=0; /* cylinder */
  else if (radius && !yheight)           VarsV.shapetyp=2; /* sphere */
  
  if (VarsV.shapetyp < 0)
    exit(fprintf(stderr,"V_sample: %s: sample has invalid dimensions. Please check parameter values.\n", NAME_CURRENT_COMP));

  VarsV.sigma_a=sig_a;
  VarsV.sigma_i=sig_i;
  VarsV.rho = (pack/V0);
  VarsV.my_s=(VarsV.rho * 100 * VarsV.sigma_i);
  VarsV.my_a_v=(VarsV.rho * 100 * VarsV.sigma_a);

  /* now compute target coords if a component index is supplied */
  VarsV.tx= VarsV.ty=VarsV.tz=0;
  if (target_index)
  {
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &VarsV.tx, &VarsV.ty, &VarsV.tz);
  }
  else
  { VarsV.tx = target_x; VarsV.ty = target_y; VarsV.tz = target_z; }

  if (!(VarsV.tx || VarsV.ty || VarsV.tz))
    printf("V_sample: %s: The target is not defined. Using direct beam (Z-axis).\n",
      NAME_CURRENT_COMP);

  VarsV.distance=sqrt(VarsV.tx*VarsV.tx+VarsV.ty*VarsV.ty+VarsV.tz*VarsV.tz);

  /* different ways of setting rectangular area */
  VarsV.aw  = VarsV.ah = 0;
  if (focus_xw) {
  VarsV.xw = focus_xw;
  }
  if (focus_yh) {
    VarsV.yh = focus_yh;
  }
  if (focus_aw) {
    VarsV.aw = DEG2RAD*focus_aw;
  }
  if (focus_ah) {
    VarsV.ah = DEG2RAD*focus_ah;
  }
}
#line 43994 "BIFROST.c"
#undef multiples
#undef target_index
#undef V0
#undef sig_i
#undef sig_a
#undef rad_sphere
#undef zthick
#undef yheight
#undef xwidth
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef target_z
#undef target_y
#undef target_x
#undef gamma
#undef f_QE
#undef frac
#undef pack
#undef focus_r
#undef h
#undef radius_o
#undef radius_i
#undef sigma_inc
#undef sigma_abs
#undef Vc
#undef zdepth
#undef thickness
#undef radius
#undef VarsV
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Mono_Cradle. */
  SIG_MESSAGE("Mono_Cradle (Init)");

  /* Initializations for component XY_ARM. */
  SIG_MESSAGE("XY_ARM (Init)");

  /* Initializations for component monochromator_flat. */
  SIG_MESSAGE("monochromator_flat (Init)");
#define mccompcurname  monochromator_flat
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 116
#define mos_rms_y mccmonochromator_flat_mos_rms_y
#define mos_rms_z mccmonochromator_flat_mos_rms_z
#define mos_rms_max mccmonochromator_flat_mos_rms_max
#define mono_Q mccmonochromator_flat_mono_Q
#define SlabWidth mccmonochromator_flat_SlabWidth
#define SlabHeight mccmonochromator_flat_SlabHeight
#define rTable mccmonochromator_flat_rTable
#define tTable mccmonochromator_flat_tTable
#define row mccmonochromator_flat_row
#define col mccmonochromator_flat_col
#define tiltH mccmonochromator_flat_tiltH
#define tiltV mccmonochromator_flat_tiltV
#define reflect mccmonochromator_flat_reflect
#define transmit mccmonochromator_flat_transmit
#define zwidth mccmonochromator_flat_zwidth
#define yheight mccmonochromator_flat_yheight
#define gap mccmonochromator_flat_gap
#define NH mccmonochromator_flat_NH
#define NV mccmonochromator_flat_NV
#define mosaich mccmonochromator_flat_mosaich
#define mosaicv mccmonochromator_flat_mosaicv
#define r0 mccmonochromator_flat_r0
#define t0 mccmonochromator_flat_t0
#define Q mccmonochromator_flat_Q
#define RV mccmonochromator_flat_RV
#define RH mccmonochromator_flat_RH
#define DM mccmonochromator_flat_DM
#define mosaic mccmonochromator_flat_mosaic
#define width mccmonochromator_flat_width
#define height mccmonochromator_flat_height
#define verbose mccmonochromator_flat_verbose
#define order mccmonochromator_flat_order
#line 148 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 44154 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component monochromator2. */
  SIG_MESSAGE("monochromator2 (Init)");
#define mccompcurname  monochromator2
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 117
#define mos_rms_y mccmonochromator2_mos_rms_y
#define mos_rms_z mccmonochromator2_mos_rms_z
#define mos_rms_max mccmonochromator2_mos_rms_max
#define mono_Q mccmonochromator2_mono_Q
#define SlabWidth mccmonochromator2_SlabWidth
#define SlabHeight mccmonochromator2_SlabHeight
#define rTable mccmonochromator2_rTable
#define tTable mccmonochromator2_tTable
#define row mccmonochromator2_row
#define col mccmonochromator2_col
#define tiltH mccmonochromator2_tiltH
#define tiltV mccmonochromator2_tiltV
#define reflect mccmonochromator2_reflect
#define transmit mccmonochromator2_transmit
#define zwidth mccmonochromator2_zwidth
#define yheight mccmonochromator2_yheight
#define gap mccmonochromator2_gap
#define NH mccmonochromator2_NH
#define NV mccmonochromator2_NV
#define mosaich mccmonochromator2_mosaich
#define mosaicv mccmonochromator2_mosaicv
#define r0 mccmonochromator2_r0
#define t0 mccmonochromator2_t0
#define Q mccmonochromator2_Q
#define RV mccmonochromator2_RV
#define RH mccmonochromator2_RH
#define DM mccmonochromator2_DM
#define mosaic mccmonochromator2_mosaic
#define width mccmonochromator2_width
#define height mccmonochromator2_height
#define verbose mccmonochromator2_verbose
#define order mccmonochromator2_order
#line 148 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 44309 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component monochromator3. */
  SIG_MESSAGE("monochromator3 (Init)");
#define mccompcurname  monochromator3
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 118
#define mos_rms_y mccmonochromator3_mos_rms_y
#define mos_rms_z mccmonochromator3_mos_rms_z
#define mos_rms_max mccmonochromator3_mos_rms_max
#define mono_Q mccmonochromator3_mono_Q
#define SlabWidth mccmonochromator3_SlabWidth
#define SlabHeight mccmonochromator3_SlabHeight
#define rTable mccmonochromator3_rTable
#define tTable mccmonochromator3_tTable
#define row mccmonochromator3_row
#define col mccmonochromator3_col
#define tiltH mccmonochromator3_tiltH
#define tiltV mccmonochromator3_tiltV
#define reflect mccmonochromator3_reflect
#define transmit mccmonochromator3_transmit
#define zwidth mccmonochromator3_zwidth
#define yheight mccmonochromator3_yheight
#define gap mccmonochromator3_gap
#define NH mccmonochromator3_NH
#define NV mccmonochromator3_NV
#define mosaich mccmonochromator3_mosaich
#define mosaicv mccmonochromator3_mosaicv
#define r0 mccmonochromator3_r0
#define t0 mccmonochromator3_t0
#define Q mccmonochromator3_Q
#define RV mccmonochromator3_RV
#define RH mccmonochromator3_RH
#define DM mccmonochromator3_DM
#define mosaic mccmonochromator3_mosaic
#define width mccmonochromator3_width
#define height mccmonochromator3_height
#define verbose mccmonochromator3_verbose
#define order mccmonochromator3_order
#line 148 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 44464 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component monochromator4. */
  SIG_MESSAGE("monochromator4 (Init)");
#define mccompcurname  monochromator4
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 119
#define mos_rms_y mccmonochromator4_mos_rms_y
#define mos_rms_z mccmonochromator4_mos_rms_z
#define mos_rms_max mccmonochromator4_mos_rms_max
#define mono_Q mccmonochromator4_mono_Q
#define SlabWidth mccmonochromator4_SlabWidth
#define SlabHeight mccmonochromator4_SlabHeight
#define rTable mccmonochromator4_rTable
#define tTable mccmonochromator4_tTable
#define row mccmonochromator4_row
#define col mccmonochromator4_col
#define tiltH mccmonochromator4_tiltH
#define tiltV mccmonochromator4_tiltV
#define reflect mccmonochromator4_reflect
#define transmit mccmonochromator4_transmit
#define zwidth mccmonochromator4_zwidth
#define yheight mccmonochromator4_yheight
#define gap mccmonochromator4_gap
#define NH mccmonochromator4_NH
#define NV mccmonochromator4_NV
#define mosaich mccmonochromator4_mosaich
#define mosaicv mccmonochromator4_mosaicv
#define r0 mccmonochromator4_r0
#define t0 mccmonochromator4_t0
#define Q mccmonochromator4_Q
#define RV mccmonochromator4_RV
#define RH mccmonochromator4_RH
#define DM mccmonochromator4_DM
#define mosaic mccmonochromator4_mosaic
#define width mccmonochromator4_width
#define height mccmonochromator4_height
#define verbose mccmonochromator4_verbose
#define order mccmonochromator4_order
#line 148 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 44619 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component monochromator5. */
  SIG_MESSAGE("monochromator5 (Init)");
#define mccompcurname  monochromator5
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 120
#define mos_rms_y mccmonochromator5_mos_rms_y
#define mos_rms_z mccmonochromator5_mos_rms_z
#define mos_rms_max mccmonochromator5_mos_rms_max
#define mono_Q mccmonochromator5_mono_Q
#define SlabWidth mccmonochromator5_SlabWidth
#define SlabHeight mccmonochromator5_SlabHeight
#define rTable mccmonochromator5_rTable
#define tTable mccmonochromator5_tTable
#define row mccmonochromator5_row
#define col mccmonochromator5_col
#define tiltH mccmonochromator5_tiltH
#define tiltV mccmonochromator5_tiltV
#define reflect mccmonochromator5_reflect
#define transmit mccmonochromator5_transmit
#define zwidth mccmonochromator5_zwidth
#define yheight mccmonochromator5_yheight
#define gap mccmonochromator5_gap
#define NH mccmonochromator5_NH
#define NV mccmonochromator5_NV
#define mosaich mccmonochromator5_mosaich
#define mosaicv mccmonochromator5_mosaicv
#define r0 mccmonochromator5_r0
#define t0 mccmonochromator5_t0
#define Q mccmonochromator5_Q
#define RV mccmonochromator5_RV
#define RH mccmonochromator5_RH
#define DM mccmonochromator5_DM
#define mosaic mccmonochromator5_mosaic
#define width mccmonochromator5_width
#define height mccmonochromator5_height
#define verbose mccmonochromator5_verbose
#define order mccmonochromator5_order
#line 148 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 44774 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component monochromator6. */
  SIG_MESSAGE("monochromator6 (Init)");
#define mccompcurname  monochromator6
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 121
#define mos_rms_y mccmonochromator6_mos_rms_y
#define mos_rms_z mccmonochromator6_mos_rms_z
#define mos_rms_max mccmonochromator6_mos_rms_max
#define mono_Q mccmonochromator6_mono_Q
#define SlabWidth mccmonochromator6_SlabWidth
#define SlabHeight mccmonochromator6_SlabHeight
#define rTable mccmonochromator6_rTable
#define tTable mccmonochromator6_tTable
#define row mccmonochromator6_row
#define col mccmonochromator6_col
#define tiltH mccmonochromator6_tiltH
#define tiltV mccmonochromator6_tiltV
#define reflect mccmonochromator6_reflect
#define transmit mccmonochromator6_transmit
#define zwidth mccmonochromator6_zwidth
#define yheight mccmonochromator6_yheight
#define gap mccmonochromator6_gap
#define NH mccmonochromator6_NH
#define NV mccmonochromator6_NV
#define mosaich mccmonochromator6_mosaich
#define mosaicv mccmonochromator6_mosaicv
#define r0 mccmonochromator6_r0
#define t0 mccmonochromator6_t0
#define Q mccmonochromator6_Q
#define RV mccmonochromator6_RV
#define RH mccmonochromator6_RH
#define DM mccmonochromator6_DM
#define mosaic mccmonochromator6_mosaic
#define width mccmonochromator6_width
#define height mccmonochromator6_height
#define verbose mccmonochromator6_verbose
#define order mccmonochromator6_order
#line 148 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 44929 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component monochromator7. */
  SIG_MESSAGE("monochromator7 (Init)");
#define mccompcurname  monochromator7
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 122
#define mos_rms_y mccmonochromator7_mos_rms_y
#define mos_rms_z mccmonochromator7_mos_rms_z
#define mos_rms_max mccmonochromator7_mos_rms_max
#define mono_Q mccmonochromator7_mono_Q
#define SlabWidth mccmonochromator7_SlabWidth
#define SlabHeight mccmonochromator7_SlabHeight
#define rTable mccmonochromator7_rTable
#define tTable mccmonochromator7_tTable
#define row mccmonochromator7_row
#define col mccmonochromator7_col
#define tiltH mccmonochromator7_tiltH
#define tiltV mccmonochromator7_tiltV
#define reflect mccmonochromator7_reflect
#define transmit mccmonochromator7_transmit
#define zwidth mccmonochromator7_zwidth
#define yheight mccmonochromator7_yheight
#define gap mccmonochromator7_gap
#define NH mccmonochromator7_NH
#define NV mccmonochromator7_NV
#define mosaich mccmonochromator7_mosaich
#define mosaicv mccmonochromator7_mosaicv
#define r0 mccmonochromator7_r0
#define t0 mccmonochromator7_t0
#define Q mccmonochromator7_Q
#define RV mccmonochromator7_RV
#define RH mccmonochromator7_RH
#define DM mccmonochromator7_DM
#define mosaic mccmonochromator7_mosaic
#define width mccmonochromator7_width
#define height mccmonochromator7_height
#define verbose mccmonochromator7_verbose
#define order mccmonochromator7_order
#line 148 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int i;

  if (mosaic != 0) {
    mos_rms_y = MIN2RAD*mosaic/sqrt(8*log(2));
    mos_rms_z = mos_rms_y; }
  else {
    mos_rms_y = MIN2RAD*mosaich/sqrt(8*log(2));
    mos_rms_z = MIN2RAD*mosaicv/sqrt(8*log(2)); }
  mos_rms_max = mos_rms_y > mos_rms_z ? mos_rms_y : mos_rms_z;

  mono_Q = Q;
  if (DM != 0) mono_Q = 2*PI/DM;

  if (mono_Q <= 0) { fprintf(stderr,"Monochromator_curved: %s: Error scattering vector Q = 0\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 <  0) { fprintf(stderr,"Monochromator_curved: %s: Error reflectivity r0 is negative\n", NAME_CURRENT_COMP); exit(-1); }
  if (r0 == 0) { fprintf(stderr,"Monochromator_curved: %s: Reflectivity r0 is null. Ignoring component.\n", NAME_CURRENT_COMP); }
  if (NH*NV == 0) { fprintf(stderr,"Monochromator_curved: %s: no slabs ??? (NH or NV=0)\n", NAME_CURRENT_COMP); exit(-1); }


  if (verbose && r0)
  {
    printf("Monochromator_curved: component %s Q=%.3g Angs-1 (DM=%.4g Angs)\n", NAME_CURRENT_COMP, mono_Q, 2*PI/mono_Q);
    if (NH*NV == 1) printf("            flat.\n");
    else
    { if (NH > 1)
      { printf("            horizontal: %i blades", (int)NH);
        if (RH != 0) printf(" focusing with RH=%.3g [m]", RH);
        printf("\n");
      }
      if (NV > 1)
      { printf("            vertical:   %i blades", (int)NV);
        if (RV != 0) printf(" focusing with RV=%.3g [m]", RV);
        printf("\n");
      }
    }
  }

  if (reflect != NULL && r0 && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Reflectivity data (k, R) from %s\n", NAME_CURRENT_COMP, reflect);
    Table_Read(&rTable, reflect, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&rTable);         /* rebin as evenly, increasing array */
    if (rTable.rows < 2) Table_Free(&rTable);
    if (verbose) Table_Info(rTable);
  } else rTable.data = NULL;

  if (transmit != NULL && strlen(transmit) && strcmp(transmit,"NULL") && strcmp(transmit,"0"))
  {
    if (verbose) fprintf(stdout, "Monochromator_curved: %s: Transmission data (k, T) from %s\n", NAME_CURRENT_COMP, transmit);
    Table_Read(&tTable, transmit, 1); /* read 1st block data from file into rTable */
    Table_Rebin(&tTable);         /* rebin as evenly, increasing array */
    if (tTable.rows < 2) Table_Free(&tTable);
    if (verbose) Table_Info(tTable);
  } else tTable.data = NULL;

  if (width == 0) SlabWidth = zwidth;
  else SlabWidth = (width+gap)/NH - gap;
  if (height == 0) SlabHeight = yheight;
  else SlabHeight = (height+gap)/NV - gap;

  tiltH=malloc((int)(NH+1)*sizeof(double));
  tiltV=malloc((int)(NV+1)*sizeof(double));

  if (!tiltH) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NH=%g).\n", NAME_CURRENT_COMP, NH);
  else if (RH) { /* pre-compute tilts */
    for (i=0;i<=NH;i++)
    {
      tiltH[i]=asin((i-(NH+1)/2)*(SlabWidth+gap)/RH);
    }
  }
  if (!tiltV) printf("Monochromator_curved: %s: Warning: not enough memory to allocate tilts (NV=%g).\n", NAME_CURRENT_COMP, NV);
  else if (RV) {
    for (i=0;i<=NV;i++)
    {
      tiltV[i]=-asin((i-(NV+1)/2)*(SlabHeight+gap)/RV);
    }
  }

}
#line 45084 "BIFROST.c"
#undef order
#undef verbose
#undef height
#undef width
#undef mosaic
#undef DM
#undef RH
#undef RV
#undef Q
#undef t0
#undef r0
#undef mosaicv
#undef mosaich
#undef NV
#undef NH
#undef gap
#undef yheight
#undef zwidth
#undef transmit
#undef reflect
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Mono_Out. */
  SIG_MESSAGE("Mono_Out (Init)");

  /* Initializations for component psd_monitor. */
  SIG_MESSAGE("psd_monitor (Init)");
#define mccompcurname  psd_monitor
#define mccompcurtype  PSD_monitor
#define mccompcurindex 124
#define nx mccpsd_monitor_nx
#define ny mccpsd_monitor_ny
#define PSD_N mccpsd_monitor_PSD_N
#define PSD_p mccpsd_monitor_PSD_p
#define PSD_p2 mccpsd_monitor_PSD_p2
#define filename mccpsd_monitor_filename
#define xmin mccpsd_monitor_xmin
#define xmax mccpsd_monitor_xmax
#define ymin mccpsd_monitor_ymin
#define ymax mccpsd_monitor_ymax
#define xwidth mccpsd_monitor_xwidth
#define yheight mccpsd_monitor_yheight
#define restore_neutron mccpsd_monitor_restore_neutron
#line 60 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
int i,j;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("PSD_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nx; i++)
     for (j=0; j<ny; j++)
     {
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
     }
}
#line 45164 "BIFROST.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component e_monitor. */
  SIG_MESSAGE("e_monitor (Init)");
#define mccompcurname  e_monitor
#define mccompcurtype  E_monitor
#define mccompcurindex 125
#define nE mcce_monitor_nE
#define E_N mcce_monitor_E_N
#define E_p mcce_monitor_E_p
#define E_p2 mcce_monitor_E_p2
#define S_p mcce_monitor_S_p
#define S_pE mcce_monitor_S_pE
#define S_pE2 mcce_monitor_S_pE2
#define filename mcce_monitor_filename
#define xmin mcce_monitor_xmin
#define xmax mcce_monitor_xmax
#define ymin mcce_monitor_ymin
#define ymax mcce_monitor_ymax
#define xwidth mcce_monitor_xwidth
#define yheight mcce_monitor_yheight
#define Emin mcce_monitor_Emin
#define Emax mcce_monitor_Emax
#define restore_neutron mcce_monitor_restore_neutron
#line 65 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 45226 "BIFROST.c"
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if(mcdotrace) mcdisplay();
    mcDEBUG_INSTR_END()
  }

} /* end init */

void mcraytrace(void) {
  /* Neutronics-specific defines */
#ifdef NEUTRONICS
extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;
#endif
  /* End of Neutronics-specific defines */
  /* Copy neutron state to local variables. */
  MCNUM mcnlx = mcnx;
  MCNUM mcnly = mcny;
  MCNUM mcnlz = mcnz;
  MCNUM mcnlvx = mcnvx;
  MCNUM mcnlvy = mcnvy;
  MCNUM mcnlvz = mcnvz;
  MCNUM mcnlt = mcnt;
  MCNUM mcnlsx = mcnsx;
  MCNUM mcnlsy = mcnsy;
  MCNUM mcnlsz = mcnsz;
  MCNUM mcnlp = mcnp;

  mcDEBUG_ENTER()
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define mcabsorb mcabsorbAll
  /* TRACE Component Origin [1] */
  mccoordschange(mcposrOrigin, mcrotrOrigin,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Origin (without coords transformations) */
  mcJumpTrace_Origin:
  SIG_MESSAGE("Origin (Trace)");
  mcDEBUG_COMP("Origin")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompOrigin
  STORE_NEUTRON(1,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[1]++;
  mcPCounter[1] += p;
  mcP2Counter[1] += p*p;
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 70 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\misc\\Progress_bar.comp"
{
  double ncount;
  ncount = mcget_run_num();
  if (!StartTime) {
    time(&StartTime); /* compute starting time */
    IntermediateCnts = 1e3;
  }
  time_t NowTime;
  time(&NowTime);
  /* compute initial estimate of computation duration */
  if (!EndTime && ncount >= IntermediateCnts) {
    CurrentTime = NowTime;
    if (difftime(NowTime,StartTime) > 10 && ncount) { /* wait 10 sec before writing ETA */
      EndTime = StartTime + (time_t)(difftime(NowTime,StartTime)
				     *(double)mcget_ncount()/ncount);
      IntermediateCnts = 0;
      fprintf(stdout, "\nTrace ETA ");
      if (difftime(EndTime,StartTime) < 60.0)
        fprintf(stdout, "%g [s] %% ", difftime(EndTime,StartTime));
      else if (difftime(EndTime,StartTime) > 3600.0)
        fprintf(stdout, "%g [h] %% ", difftime(EndTime,StartTime)/3600.0);
      else
        fprintf(stdout, "%g [min] %% ", difftime(EndTime,StartTime)/60.0);
    } else IntermediateCnts += 1e3;
    fflush(stdout);
  }

  /* display percentage when percent or minutes have reached step */
  if (EndTime && mcget_ncount() &&
    (    (minutes && difftime(NowTime,CurrentTime) > minutes*60)
      || (percent && !minutes && ncount >= IntermediateCnts))   )
  {
    fprintf(stdout, "%d ", (int)(ncount*100.0/mcget_ncount())); fflush(stdout);
    CurrentTime = NowTime;

    IntermediateCnts = ncount + percent*mcget_ncount()/100;
    /* check that next intermediate ncount check is a multiple of the desired percentage */
    IntermediateCnts = floor(IntermediateCnts*100/percent/mcget_ncount())*percent*mcget_ncount()/100;
    /* raise flag to indicate that we did something */
    SCATTER;
    if (flag_save) mcsave(NULL);
  }
}
#line 45401 "BIFROST.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompOrigin:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(1,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ESS_source [2] */
  mccoordschange(mcposrESS_source, mcrotrESS_source,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ESS_source (without coords transformations) */
  mcJumpTrace_ESS_source:
  SIG_MESSAGE("ESS_source (Trace)");
  mcDEBUG_COMP("ESS_source")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompESS_source
  STORE_NEUTRON(2,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[2]++;
  mcPCounter[2] += p;
  mcP2Counter[2] += p*p;
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
{   /* Declarations of ESS_source=ESS_butterfly() SETTING parameters. */
char* sector = mccESS_source_sector;
int beamline = mccESS_source_beamline;
MCNUM yheight = mccESS_source_yheight;
MCNUM cold_frac = mccESS_source_cold_frac;
int target_index = mccESS_source_target_index;
MCNUM dist = mccESS_source_dist;
MCNUM focus_xw = mccESS_source_focus_xw;
MCNUM focus_yh = mccESS_source_focus_yh;
MCNUM c_performance = mccESS_source_c_performance;
MCNUM t_performance = mccESS_source_t_performance;
MCNUM Lmin = mccESS_source_Lmin;
MCNUM Lmax = mccESS_source_Lmax;
MCNUM tmax_multiplier = mccESS_source_tmax_multiplier;
int n_pulses = mccESS_source_n_pulses;
MCNUM acc_power = mccESS_source_acc_power;
MCNUM tfocus_dist = mccESS_source_tfocus_dist;
MCNUM tfocus_time = mccESS_source_tfocus_time;
MCNUM tfocus_width = mccESS_source_tfocus_width;
#line 434 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\ESS_butterfly.comp"
{
  
  /* Cold or thermal event? */
  p=1;
  xtmp = rand01();
  y = randpm1()*delta_y;
  modextras.Y=y;
  if (rand01() < cold_frac) {
    iscold=1;
    if (rand01() < wfrac_cold) { // "Broad face" 
      x = rC1_x + (rC2_x - rC1_x)*xtmp;
      z = rC1_z + (rC2_z - rC1_z)*xtmp;
      x0 = C1_x + (C2_x - C1_x)*xtmp;
      z0 = C1_z + (C2_z - C1_z)*xtmp;
      surf_sign=-1;
      cos_factor=cos_cold;
    } else {
      x = rC1_x + (rC3_x - rC1_x)*xtmp;
      z = rC1_z + (rC3_z - rC1_z)*xtmp;
      x0 = C1_x + (C3_x - C1_x)*xtmp;
      z0 = C1_z + (C3_z - C1_z)*xtmp;    
      surf_sign=1;
      cos_factor=cos_thermal;
    }
    modextras.X=((-1.0*isleft*x0)-dxCold[beamline-1]);
    w_geom=w_geom_c;
  } else {
    iscold=0;
    if (rand01() < wfrac_thermal) { // "Broad face" 
      x = rT1_x + (rT2_x - rT1_x)*xtmp;
      z = rT1_z + (rT2_z - rT1_z)*xtmp;
      x0 = T1_x + (T2_x - T1_x)*xtmp;
      z0 = T1_z + (T2_z - T1_z)*xtmp;
      surf_sign=1;
      cos_factor=cos_thermal;
    } else {
      x = rT1_x + (rT3_x - rT1_x)*xtmp;
      z = rT1_z + (rT3_z - rT1_z)*xtmp;
      x0 = T1_x + (T3_x - T1_x)*xtmp;
      z0 = T1_z + (T3_z - T1_z)*xtmp;
      surf_sign=-1;
      cos_factor=cos_thermal;
    }
    modextras.X=((-1.0*isleft*x0)+dxThermal[beamline-1]);
    w_geom=w_geom_t;
  }

  SCATTER;
  /* Where are we going? */
  randvec_target_rect_real(&xf, &yf, &zf, NULL,
			   tx, ty, tz, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 0);
  w_focus=focus_xw*focus_yh/(tx*tx+ty*ty+tz*tz);
  
  dx = xf-x;
  dy = yf-y;
  dz = zf-z;
  r = sqrt(dx*dx+dy*dy+dz*dz);
  
  lambda = Lmin+l_range*rand01();    /* Choose from uniform distribution */

  k = 2*PI/lambda;
  v = K2V*k;

  vz = v*dz/r;
  vy = v*dy/r;
  vx = v*dx/r;

  /* Are we using time focusing? */
  if (tfocus_width>0) {
    double dt = tfocus_dist/vz;
    t = tfocus_time-dt; /* Set time to hit time window center */
    t += randpm1()*tfocus_width/2.0; 
    if (t<0) ABSORB;                       /* Kill neutron if outside pulse duration */
    if (t>modextras.tmultiplier*ESS_SOURCE_DURATION) ABSORB;
    w_tfocus=tfocus_width/(modextras.tmultiplier*ESS_SOURCE_DURATION);
  } else {
    /* Simple, random wavelength @ random time */
    t = rand01()*modextras.tmultiplier*ESS_SOURCE_DURATION;
    w_tfocus=1;
  }
  
  if (iscold) {          //case: cold moderator
    /* Apply simple engineering reality correction */
    cold_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
    p *= c_performance;
    p *= ColdScalars[beamline-1];
  }  else  {                      //case: thermal moderator
    thermal_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
    p *= t_performance;
    p *= ThermalScalars[beamline-1];
  }
  
  p*=w_stat*w_focus*w_geom*w_mult*w_tfocus;
  t+=(double)floor((n_pulses)*rand01())/ESS_SOURCE_FREQUENCY;   /* Select a random pulse */
  p*=cos_factor;

  /* Correct weight for sampling of cold vs. thermal events. */
  if (iscold) {
    p /= cold_frac;
  } else {
    p /= (1-cold_frac);
  }
  SCATTER;
}
#line 45701 "BIFROST.c"
}   /* End of ESS_source=ESS_butterfly() SETTING parameter declarations. */
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompESS_source:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(2,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component StartOfGuide [3] */
  mccoordschange(mcposrStartOfGuide, mcrotrStartOfGuide,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component StartOfGuide (without coords transformations) */
  mcJumpTrace_StartOfGuide:
  SIG_MESSAGE("StartOfGuide (Trace)");
  mcDEBUG_COMP("StartOfGuide")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompStartOfGuide
  STORE_NEUTRON(3,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[3]++;
  mcPCounter[3] += p;
  mcP2Counter[3] += p*p;
#define mccompcurname  StartOfGuide
#define mccompcurtype  Arm
#define mccompcurindex 3
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompStartOfGuide:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(3,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component NBOA [4] */
  mccoordschange(mcposrNBOA, mcrotrNBOA,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component NBOA (without coords transformations) */
  mcJumpTrace_NBOA:
  SIG_MESSAGE("NBOA (Trace)");
  mcDEBUG_COMP("NBOA")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompNBOA
  STORE_NEUTRON(4,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[4]++;
  mcPCounter[4] += p;
  mcP2Counter[4] += p*p;
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
{   /* Declarations of NBOA=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccNBOA_l;
MCNUM xwidth = mccNBOA_xwidth;
MCNUM yheight = mccNBOA_yheight;
MCNUM linxw = mccNBOA_linxw;
MCNUM loutxw = mccNBOA_loutxw;
MCNUM linyh = mccNBOA_linyh;
MCNUM loutyh = mccNBOA_loutyh;
MCNUM majorAxisxw = mccNBOA_majorAxisxw;
MCNUM minorAxisxw = mccNBOA_minorAxisxw;
MCNUM majorAxisyh = mccNBOA_majorAxisyh;
MCNUM minorAxisyh = mccNBOA_minorAxisyh;
MCNUM majorAxisoffsetxw = mccNBOA_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccNBOA_majorAxisoffsetyh;
char* dimensionsAt = mccNBOA_dimensionsAt;
char* option = mccNBOA_option;
MCNUM R0 = mccNBOA_R0;
MCNUM Qc = mccNBOA_Qc;
MCNUM alpha = mccNBOA_alpha;
MCNUM m = mccNBOA_m;
MCNUM W = mccNBOA_W;
MCNUM alpharight = mccNBOA_alpharight;
MCNUM mright = mccNBOA_mright;
MCNUM alphaleft = mccNBOA_alphaleft;
MCNUM mleft = mccNBOA_mleft;
MCNUM alphatop = mccNBOA_alphatop;
MCNUM mtop = mccNBOA_mtop;
MCNUM alphabottom = mccNBOA_alphabottom;
MCNUM mbottom = mccNBOA_mbottom;
char* verbose = mccNBOA_verbose;
MCNUM enableGravity = mccNBOA_enableGravity;
MCNUM curvature = mccNBOA_curvature;
#line 1420 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
  PROP_Z0;
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 )
		  ABSORB;


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		if(boolean == 0) ABSORB;
		if(timeToCollision < 1e-15) ABSORB;

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 46093 "BIFROST.c"
}   /* End of NBOA=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompNBOA:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(4,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_6 [5] */
  mccoordschange(mcposrEndOfelement_6, mcrotrEndOfelement_6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_6 (without coords transformations) */
  mcJumpTrace_EndOfelement_6:
  SIG_MESSAGE("EndOfelement_6 (Trace)");
  mcDEBUG_COMP("EndOfelement_6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_6
  STORE_NEUTRON(5,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[5]++;
  mcPCounter[5] += p;
  mcP2Counter[5] += p*p;
#define mccompcurname  EndOfelement_6
#define mccompcurtype  Arm
#define mccompcurindex 5
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(5,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monBeforePSC1 [6] */
  mccoordschange(mcposrL_monBeforePSC1, mcrotrL_monBeforePSC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monBeforePSC1 (without coords transformations) */
  mcJumpTrace_L_monBeforePSC1:
  SIG_MESSAGE("L_monBeforePSC1 (Trace)");
  mcDEBUG_COMP("L_monBeforePSC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monBeforePSC1
  STORE_NEUTRON(6,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[6]++;
  mcPCounter[6] += p;
  mcP2Counter[6] += p*p;
#define mccompcurname  L_monBeforePSC1
#define mccompcurtype  L_monitor
#define mccompcurindex 6
#define nL mccL_monBeforePSC1_nL
#define L_N mccL_monBeforePSC1_L_N
#define L_p mccL_monBeforePSC1_L_p
#define L_p2 mccL_monBeforePSC1_L_p2
{   /* Declarations of L_monBeforePSC1=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforePSC1_filename;
MCNUM xmin = mccL_monBeforePSC1_xmin;
MCNUM xmax = mccL_monBeforePSC1_xmax;
MCNUM ymin = mccL_monBeforePSC1_ymin;
MCNUM ymax = mccL_monBeforePSC1_ymax;
MCNUM xwidth = mccL_monBeforePSC1_xwidth;
MCNUM yheight = mccL_monBeforePSC1_yheight;
MCNUM Lmin = mccL_monBeforePSC1_Lmin;
MCNUM Lmax = mccL_monBeforePSC1_Lmax;
MCNUM restore_neutron = mccL_monBeforePSC1_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 46353 "BIFROST.c"
}   /* End of L_monBeforePSC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monBeforePSC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(6,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFBeforerPSC1 [7] */
  mccoordschange(mcposrToFBeforerPSC1, mcrotrToFBeforerPSC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFBeforerPSC1 (without coords transformations) */
  mcJumpTrace_ToFBeforerPSC1:
  SIG_MESSAGE("ToFBeforerPSC1 (Trace)");
  mcDEBUG_COMP("ToFBeforerPSC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFBeforerPSC1
  STORE_NEUTRON(7,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[7]++;
  mcPCounter[7] += p;
  mcP2Counter[7] += p*p;
#define mccompcurname  ToFBeforerPSC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 7
#define nt mccToFBeforerPSC1_nt
#define TOF_N mccToFBeforerPSC1_TOF_N
#define TOF_p mccToFBeforerPSC1_TOF_p
#define TOF_p2 mccToFBeforerPSC1_TOF_p2
#define t_min mccToFBeforerPSC1_t_min
#define t_max mccToFBeforerPSC1_t_max
#define delta_t mccToFBeforerPSC1_delta_t
{   /* Declarations of ToFBeforerPSC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforerPSC1_filename;
MCNUM xmin = mccToFBeforerPSC1_xmin;
MCNUM xmax = mccToFBeforerPSC1_xmax;
MCNUM ymin = mccToFBeforerPSC1_ymin;
MCNUM ymax = mccToFBeforerPSC1_ymax;
MCNUM xwidth = mccToFBeforerPSC1_xwidth;
MCNUM yheight = mccToFBeforerPSC1_yheight;
MCNUM tmin = mccToFBeforerPSC1_tmin;
MCNUM tmax = mccToFBeforerPSC1_tmax;
MCNUM dt = mccToFBeforerPSC1_dt;
MCNUM restore_neutron = mccToFBeforerPSC1_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 46500 "BIFROST.c"
}   /* End of ToFBeforerPSC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFBeforerPSC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(7,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_beforePulseShapping1 [8] */
  mccoordschange(mcposrPSD_beforePulseShapping1, mcrotrPSD_beforePulseShapping1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_beforePulseShapping1 (without coords transformations) */
  mcJumpTrace_PSD_beforePulseShapping1:
  SIG_MESSAGE("PSD_beforePulseShapping1 (Trace)");
  mcDEBUG_COMP("PSD_beforePulseShapping1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_beforePulseShapping1
  STORE_NEUTRON(8,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[8]++;
  mcPCounter[8] += p;
  mcP2Counter[8] += p*p;
#define mccompcurname  PSD_beforePulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 8
#define nx mccPSD_beforePulseShapping1_nx
#define ny mccPSD_beforePulseShapping1_ny
#define PSD_N mccPSD_beforePulseShapping1_PSD_N
#define PSD_p mccPSD_beforePulseShapping1_PSD_p
#define PSD_p2 mccPSD_beforePulseShapping1_PSD_p2
{   /* Declarations of PSD_beforePulseShapping1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforePulseShapping1_filename;
MCNUM xmin = mccPSD_beforePulseShapping1_xmin;
MCNUM xmax = mccPSD_beforePulseShapping1_xmax;
MCNUM ymin = mccPSD_beforePulseShapping1_ymin;
MCNUM ymax = mccPSD_beforePulseShapping1_ymax;
MCNUM xwidth = mccPSD_beforePulseShapping1_xwidth;
MCNUM yheight = mccPSD_beforePulseShapping1_yheight;
MCNUM restore_neutron = mccPSD_beforePulseShapping1_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 46644 "BIFROST.c"
}   /* End of PSD_beforePulseShapping1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_beforePulseShapping1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(8,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component TofLambdaBeforePSC [9] */
  mccoordschange(mcposrTofLambdaBeforePSC, mcrotrTofLambdaBeforePSC,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component TofLambdaBeforePSC (without coords transformations) */
  mcJumpTrace_TofLambdaBeforePSC:
  SIG_MESSAGE("TofLambdaBeforePSC (Trace)");
  mcDEBUG_COMP("TofLambdaBeforePSC")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompTofLambdaBeforePSC
  STORE_NEUTRON(9,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[9]++;
  mcPCounter[9] += p;
  mcP2Counter[9] += p*p;
#define mccompcurname  TofLambdaBeforePSC
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 9
#define nL mccTofLambdaBeforePSC_nL
#define nt mccTofLambdaBeforePSC_nt
#define tmin mccTofLambdaBeforePSC_tmin
#define tmax mccTofLambdaBeforePSC_tmax
#define tt_0 mccTofLambdaBeforePSC_tt_0
#define tt_1 mccTofLambdaBeforePSC_tt_1
#define TOFL_N mccTofLambdaBeforePSC_TOFL_N
#define TOFL_p mccTofLambdaBeforePSC_TOFL_p
#define TOFL_p2 mccTofLambdaBeforePSC_TOFL_p2
{   /* Declarations of TofLambdaBeforePSC=TOFLambda_monitor() SETTING parameters. */
char* filename = mccTofLambdaBeforePSC_filename;
MCNUM xmin = mccTofLambdaBeforePSC_xmin;
MCNUM xmax = mccTofLambdaBeforePSC_xmax;
MCNUM ymin = mccTofLambdaBeforePSC_ymin;
MCNUM ymax = mccTofLambdaBeforePSC_ymax;
MCNUM xwidth = mccTofLambdaBeforePSC_xwidth;
MCNUM yheight = mccTofLambdaBeforePSC_yheight;
MCNUM Lmin = mccTofLambdaBeforePSC_Lmin;
MCNUM Lmax = mccTofLambdaBeforePSC_Lmax;
MCNUM restore_neutron = mccTofLambdaBeforePSC_restore_neutron;
#line 84 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
    int i,j;
    double div;
    double lambda;

    PROP_Z0;
    lambda = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
    if (x>xmin && x<xmax && y>ymin && y<ymax &&
        lambda > Lmin && lambda < Lmax)
    {
      if (t < tt_1 && t > tt_0)
      {
        i = floor((lambda - Lmin)*nL/(Lmax - Lmin));
        j = floor((t-tt_0)*nt/(tt_1-tt_0));
/*  printf("tt_0, tt_1, nt %g %g %i t j %g %i \n",tt_0,tt_1,nt,t,j);
*/        TOFL_N[j][i]++;
        TOFL_p[j][i] += p;
        TOFL_p2[j][i] += p*p;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 46799 "BIFROST.c"
}   /* End of TofLambdaBeforePSC=TOFLambda_monitor() SETTING parameter declarations. */
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompTofLambdaBeforePSC:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(9,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PulseShapingChopper [10] */
  mccoordschange(mcposrPulseShapingChopper, mcrotrPulseShapingChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PulseShapingChopper (without coords transformations) */
  mcJumpTrace_PulseShapingChopper:
  SIG_MESSAGE("PulseShapingChopper (Trace)");
  mcDEBUG_COMP("PulseShapingChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPulseShapingChopper
  STORE_NEUTRON(10,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[10]++;
  mcPCounter[10] += p;
  mcP2Counter[10] += p*p;
#define mccompcurname  PulseShapingChopper
#define mccompcurtype  DiskChopper
#define mccompcurindex 10
#define Tg mccPulseShapingChopper_Tg
#define To mccPulseShapingChopper_To
#define delta_y mccPulseShapingChopper_delta_y
#define height mccPulseShapingChopper_height
#define omega mccPulseShapingChopper_omega
{   /* Declarations of PulseShapingChopper=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccPulseShapingChopper_theta_0;
MCNUM radius = mccPulseShapingChopper_radius;
MCNUM yheight = mccPulseShapingChopper_yheight;
MCNUM nu = mccPulseShapingChopper_nu;
MCNUM nslit = mccPulseShapingChopper_nslit;
MCNUM jitter = mccPulseShapingChopper_jitter;
MCNUM delay = mccPulseShapingChopper_delay;
MCNUM isfirst = mccPulseShapingChopper_isfirst;
MCNUM n_pulse = mccPulseShapingChopper_n_pulse;
MCNUM abs_out = mccPulseShapingChopper_abs_out;
MCNUM phase = mccPulseShapingChopper_phase;
MCNUM xwidth = mccPulseShapingChopper_xwidth;
MCNUM verbose = mccPulseShapingChopper_verbose;
#line 130 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 46966 "BIFROST.c"
}   /* End of PulseShapingChopper=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPulseShapingChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(10,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_AfterPulseShapping1 [11] */
  mccoordschange(mcposrPSD_AfterPulseShapping1, mcrotrPSD_AfterPulseShapping1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_AfterPulseShapping1 (without coords transformations) */
  mcJumpTrace_PSD_AfterPulseShapping1:
  SIG_MESSAGE("PSD_AfterPulseShapping1 (Trace)");
  mcDEBUG_COMP("PSD_AfterPulseShapping1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_AfterPulseShapping1
  STORE_NEUTRON(11,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[11]++;
  mcPCounter[11] += p;
  mcP2Counter[11] += p*p;
#define mccompcurname  PSD_AfterPulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 11
#define nx mccPSD_AfterPulseShapping1_nx
#define ny mccPSD_AfterPulseShapping1_ny
#define PSD_N mccPSD_AfterPulseShapping1_PSD_N
#define PSD_p mccPSD_AfterPulseShapping1_PSD_p
#define PSD_p2 mccPSD_AfterPulseShapping1_PSD_p2
{   /* Declarations of PSD_AfterPulseShapping1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_AfterPulseShapping1_filename;
MCNUM xmin = mccPSD_AfterPulseShapping1_xmin;
MCNUM xmax = mccPSD_AfterPulseShapping1_xmax;
MCNUM ymin = mccPSD_AfterPulseShapping1_ymin;
MCNUM ymax = mccPSD_AfterPulseShapping1_ymax;
MCNUM xwidth = mccPSD_AfterPulseShapping1_xwidth;
MCNUM yheight = mccPSD_AfterPulseShapping1_yheight;
MCNUM restore_neutron = mccPSD_AfterPulseShapping1_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 47108 "BIFROST.c"
}   /* End of PSD_AfterPulseShapping1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_AfterPulseShapping1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(11,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFInsidePSC [12] */
  mccoordschange(mcposrToFInsidePSC, mcrotrToFInsidePSC,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFInsidePSC (without coords transformations) */
  mcJumpTrace_ToFInsidePSC:
  SIG_MESSAGE("ToFInsidePSC (Trace)");
  mcDEBUG_COMP("ToFInsidePSC")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFInsidePSC
  STORE_NEUTRON(12,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[12]++;
  mcPCounter[12] += p;
  mcP2Counter[12] += p*p;
#define mccompcurname  ToFInsidePSC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 12
#define nt mccToFInsidePSC_nt
#define TOF_N mccToFInsidePSC_TOF_N
#define TOF_p mccToFInsidePSC_TOF_p
#define TOF_p2 mccToFInsidePSC_TOF_p2
#define t_min mccToFInsidePSC_t_min
#define t_max mccToFInsidePSC_t_max
#define delta_t mccToFInsidePSC_delta_t
{   /* Declarations of ToFInsidePSC=TOF_monitor() SETTING parameters. */
char* filename = mccToFInsidePSC_filename;
MCNUM xmin = mccToFInsidePSC_xmin;
MCNUM xmax = mccToFInsidePSC_xmax;
MCNUM ymin = mccToFInsidePSC_ymin;
MCNUM ymax = mccToFInsidePSC_ymax;
MCNUM xwidth = mccToFInsidePSC_xwidth;
MCNUM yheight = mccToFInsidePSC_yheight;
MCNUM tmin = mccToFInsidePSC_tmin;
MCNUM tmax = mccToFInsidePSC_tmax;
MCNUM dt = mccToFInsidePSC_dt;
MCNUM restore_neutron = mccToFInsidePSC_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 47256 "BIFROST.c"
}   /* End of ToFInsidePSC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFInsidePSC:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(12,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PulseShapingChopper2 [13] */
  mccoordschange(mcposrPulseShapingChopper2, mcrotrPulseShapingChopper2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PulseShapingChopper2 (without coords transformations) */
  mcJumpTrace_PulseShapingChopper2:
  SIG_MESSAGE("PulseShapingChopper2 (Trace)");
  mcDEBUG_COMP("PulseShapingChopper2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPulseShapingChopper2
  STORE_NEUTRON(13,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[13]++;
  mcPCounter[13] += p;
  mcP2Counter[13] += p*p;
#define mccompcurname  PulseShapingChopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 13
#define Tg mccPulseShapingChopper2_Tg
#define To mccPulseShapingChopper2_To
#define delta_y mccPulseShapingChopper2_delta_y
#define height mccPulseShapingChopper2_height
#define omega mccPulseShapingChopper2_omega
{   /* Declarations of PulseShapingChopper2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccPulseShapingChopper2_theta_0;
MCNUM radius = mccPulseShapingChopper2_radius;
MCNUM yheight = mccPulseShapingChopper2_yheight;
MCNUM nu = mccPulseShapingChopper2_nu;
MCNUM nslit = mccPulseShapingChopper2_nslit;
MCNUM jitter = mccPulseShapingChopper2_jitter;
MCNUM delay = mccPulseShapingChopper2_delay;
MCNUM isfirst = mccPulseShapingChopper2_isfirst;
MCNUM n_pulse = mccPulseShapingChopper2_n_pulse;
MCNUM abs_out = mccPulseShapingChopper2_abs_out;
MCNUM phase = mccPulseShapingChopper2_phase;
MCNUM xwidth = mccPulseShapingChopper2_xwidth;
MCNUM verbose = mccPulseShapingChopper2_verbose;
#line 130 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 47421 "BIFROST.c"
}   /* End of PulseShapingChopper2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPulseShapingChopper2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(13,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component TofLambdaAfterPSC2 [14] */
  mccoordschange(mcposrTofLambdaAfterPSC2, mcrotrTofLambdaAfterPSC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component TofLambdaAfterPSC2 (without coords transformations) */
  mcJumpTrace_TofLambdaAfterPSC2:
  SIG_MESSAGE("TofLambdaAfterPSC2 (Trace)");
  mcDEBUG_COMP("TofLambdaAfterPSC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompTofLambdaAfterPSC2
  STORE_NEUTRON(14,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[14]++;
  mcPCounter[14] += p;
  mcP2Counter[14] += p*p;
#define mccompcurname  TofLambdaAfterPSC2
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 14
#define nL mccTofLambdaAfterPSC2_nL
#define nt mccTofLambdaAfterPSC2_nt
#define tmin mccTofLambdaAfterPSC2_tmin
#define tmax mccTofLambdaAfterPSC2_tmax
#define tt_0 mccTofLambdaAfterPSC2_tt_0
#define tt_1 mccTofLambdaAfterPSC2_tt_1
#define TOFL_N mccTofLambdaAfterPSC2_TOFL_N
#define TOFL_p mccTofLambdaAfterPSC2_TOFL_p
#define TOFL_p2 mccTofLambdaAfterPSC2_TOFL_p2
{   /* Declarations of TofLambdaAfterPSC2=TOFLambda_monitor() SETTING parameters. */
char* filename = mccTofLambdaAfterPSC2_filename;
MCNUM xmin = mccTofLambdaAfterPSC2_xmin;
MCNUM xmax = mccTofLambdaAfterPSC2_xmax;
MCNUM ymin = mccTofLambdaAfterPSC2_ymin;
MCNUM ymax = mccTofLambdaAfterPSC2_ymax;
MCNUM xwidth = mccTofLambdaAfterPSC2_xwidth;
MCNUM yheight = mccTofLambdaAfterPSC2_yheight;
MCNUM Lmin = mccTofLambdaAfterPSC2_Lmin;
MCNUM Lmax = mccTofLambdaAfterPSC2_Lmax;
MCNUM restore_neutron = mccTofLambdaAfterPSC2_restore_neutron;
#line 84 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
    int i,j;
    double div;
    double lambda;

    PROP_Z0;
    lambda = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
    if (x>xmin && x<xmax && y>ymin && y<ymax &&
        lambda > Lmin && lambda < Lmax)
    {
      if (t < tt_1 && t > tt_0)
      {
        i = floor((lambda - Lmin)*nL/(Lmax - Lmin));
        j = floor((t-tt_0)*nt/(tt_1-tt_0));
/*  printf("tt_0, tt_1, nt %g %g %i t j %g %i \n",tt_0,tt_1,nt,t,j);
*/        TOFL_N[j][i]++;
        TOFL_p[j][i] += p;
        TOFL_p2[j][i] += p*p;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 47576 "BIFROST.c"
}   /* End of TofLambdaAfterPSC2=TOFLambda_monitor() SETTING parameter declarations. */
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompTofLambdaAfterPSC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(14,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_AfterPSC2 [15] */
  mccoordschange(mcposrPSD_AfterPSC2, mcrotrPSD_AfterPSC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_AfterPSC2 (without coords transformations) */
  mcJumpTrace_PSD_AfterPSC2:
  SIG_MESSAGE("PSD_AfterPSC2 (Trace)");
  mcDEBUG_COMP("PSD_AfterPSC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_AfterPSC2
  STORE_NEUTRON(15,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[15]++;
  mcPCounter[15] += p;
  mcP2Counter[15] += p*p;
#define mccompcurname  PSD_AfterPSC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 15
#define nx mccPSD_AfterPSC2_nx
#define ny mccPSD_AfterPSC2_ny
#define PSD_N mccPSD_AfterPSC2_PSD_N
#define PSD_p mccPSD_AfterPSC2_PSD_p
#define PSD_p2 mccPSD_AfterPSC2_PSD_p2
{   /* Declarations of PSD_AfterPSC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_AfterPSC2_filename;
MCNUM xmin = mccPSD_AfterPSC2_xmin;
MCNUM xmax = mccPSD_AfterPSC2_xmax;
MCNUM ymin = mccPSD_AfterPSC2_ymin;
MCNUM ymax = mccPSD_AfterPSC2_ymax;
MCNUM xwidth = mccPSD_AfterPSC2_xwidth;
MCNUM yheight = mccPSD_AfterPSC2_yheight;
MCNUM restore_neutron = mccPSD_AfterPSC2_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 47722 "BIFROST.c"
}   /* End of PSD_AfterPSC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_AfterPSC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(15,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFAfterPSC2 [16] */
  mccoordschange(mcposrToFAfterPSC2, mcrotrToFAfterPSC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFAfterPSC2 (without coords transformations) */
  mcJumpTrace_ToFAfterPSC2:
  SIG_MESSAGE("ToFAfterPSC2 (Trace)");
  mcDEBUG_COMP("ToFAfterPSC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFAfterPSC2
  STORE_NEUTRON(16,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[16]++;
  mcPCounter[16] += p;
  mcP2Counter[16] += p*p;
#define mccompcurname  ToFAfterPSC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 16
#define nt mccToFAfterPSC2_nt
#define TOF_N mccToFAfterPSC2_TOF_N
#define TOF_p mccToFAfterPSC2_TOF_p
#define TOF_p2 mccToFAfterPSC2_TOF_p2
#define t_min mccToFAfterPSC2_t_min
#define t_max mccToFAfterPSC2_t_max
#define delta_t mccToFAfterPSC2_delta_t
{   /* Declarations of ToFAfterPSC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterPSC2_filename;
MCNUM xmin = mccToFAfterPSC2_xmin;
MCNUM xmax = mccToFAfterPSC2_xmax;
MCNUM ymin = mccToFAfterPSC2_ymin;
MCNUM ymax = mccToFAfterPSC2_ymax;
MCNUM xwidth = mccToFAfterPSC2_xwidth;
MCNUM yheight = mccToFAfterPSC2_yheight;
MCNUM tmin = mccToFAfterPSC2_tmin;
MCNUM tmax = mccToFAfterPSC2_tmax;
MCNUM dt = mccToFAfterPSC2_dt;
MCNUM restore_neutron = mccToFAfterPSC2_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 47870 "BIFROST.c"
}   /* End of ToFAfterPSC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFAfterPSC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(16,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monAfterPSC2 [17] */
  mccoordschange(mcposrL_monAfterPSC2, mcrotrL_monAfterPSC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monAfterPSC2 (without coords transformations) */
  mcJumpTrace_L_monAfterPSC2:
  SIG_MESSAGE("L_monAfterPSC2 (Trace)");
  mcDEBUG_COMP("L_monAfterPSC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monAfterPSC2
  STORE_NEUTRON(17,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[17]++;
  mcPCounter[17] += p;
  mcP2Counter[17] += p*p;
#define mccompcurname  L_monAfterPSC2
#define mccompcurtype  L_monitor
#define mccompcurindex 17
#define nL mccL_monAfterPSC2_nL
#define L_N mccL_monAfterPSC2_L_N
#define L_p mccL_monAfterPSC2_L_p
#define L_p2 mccL_monAfterPSC2_L_p2
{   /* Declarations of L_monAfterPSC2=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterPSC2_filename;
MCNUM xmin = mccL_monAfterPSC2_xmin;
MCNUM xmax = mccL_monAfterPSC2_xmax;
MCNUM ymin = mccL_monAfterPSC2_ymin;
MCNUM ymax = mccL_monAfterPSC2_ymax;
MCNUM xwidth = mccL_monAfterPSC2_xwidth;
MCNUM yheight = mccL_monAfterPSC2_yheight;
MCNUM Lmin = mccL_monAfterPSC2_Lmin;
MCNUM Lmax = mccL_monAfterPSC2_Lmax;
MCNUM restore_neutron = mccL_monAfterPSC2_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 48019 "BIFROST.c"
}   /* End of L_monAfterPSC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monAfterPSC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(17,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_5 [18] */
  mccoordschange(mcposrEndOfelement_5, mcrotrEndOfelement_5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_5 (without coords transformations) */
  mcJumpTrace_EndOfelement_5:
  SIG_MESSAGE("EndOfelement_5 (Trace)");
  mcDEBUG_COMP("EndOfelement_5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_5
  STORE_NEUTRON(18,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[18]++;
  mcPCounter[18] += p;
  mcP2Counter[18] += p*p;
#define mccompcurname  EndOfelement_5
#define mccompcurtype  Arm
#define mccompcurindex 18
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(18,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_1_0 [19] */
  mccoordschange(mcposrcurved_guide_1_0, mcrotrcurved_guide_1_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_1_0 (without coords transformations) */
  mcJumpTrace_curved_guide_1_0:
  SIG_MESSAGE("curved_guide_1_0 (Trace)");
  mcDEBUG_COMP("curved_guide_1_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_1_0
  STORE_NEUTRON(19,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[19]++;
  mcPCounter[19] += p;
  mcP2Counter[19] += p*p;
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
{   /* Declarations of curved_guide_1_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_1_0_w1;
MCNUM h1 = mcccurved_guide_1_0_h1;
MCNUM w2 = mcccurved_guide_1_0_w2;
MCNUM h2 = mcccurved_guide_1_0_h2;
MCNUM l = mcccurved_guide_1_0_l;
MCNUM R0 = mcccurved_guide_1_0_R0;
MCNUM Qc = mcccurved_guide_1_0_Qc;
MCNUM alpha = mcccurved_guide_1_0_alpha;
MCNUM m = mcccurved_guide_1_0_m;
MCNUM W = mcccurved_guide_1_0_W;
MCNUM nslit = mcccurved_guide_1_0_nslit;
MCNUM d = mcccurved_guide_1_0_d;
MCNUM mleft = mcccurved_guide_1_0_mleft;
MCNUM mright = mcccurved_guide_1_0_mright;
MCNUM mtop = mcccurved_guide_1_0_mtop;
MCNUM mbottom = mcccurved_guide_1_0_mbottom;
MCNUM nhslit = mcccurved_guide_1_0_nhslit;
MCNUM G = mcccurved_guide_1_0_G;
MCNUM aleft = mcccurved_guide_1_0_aleft;
MCNUM aright = mcccurved_guide_1_0_aright;
MCNUM atop = mcccurved_guide_1_0_atop;
MCNUM abottom = mcccurved_guide_1_0_abottom;
MCNUM wavy = mcccurved_guide_1_0_wavy;
MCNUM wavy_z = mcccurved_guide_1_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_1_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_1_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_1_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_1_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_1_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_1_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_1_0_nelements;
MCNUM nu = mcccurved_guide_1_0_nu;
MCNUM phase = mcccurved_guide_1_0_phase;
char* reflect = mcccurved_guide_1_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48437 "BIFROST.c"
}   /* End of curved_guide_1_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_1_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(19,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_2_0 [20] */
  mccoordschange(mcposrcurved_guide_2_0, mcrotrcurved_guide_2_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_2_0 (without coords transformations) */
  mcJumpTrace_curved_guide_2_0:
  SIG_MESSAGE("curved_guide_2_0 (Trace)");
  mcDEBUG_COMP("curved_guide_2_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_2_0
  STORE_NEUTRON(20,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[20]++;
  mcPCounter[20] += p;
  mcP2Counter[20] += p*p;
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
{   /* Declarations of curved_guide_2_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_2_0_w1;
MCNUM h1 = mcccurved_guide_2_0_h1;
MCNUM w2 = mcccurved_guide_2_0_w2;
MCNUM h2 = mcccurved_guide_2_0_h2;
MCNUM l = mcccurved_guide_2_0_l;
MCNUM R0 = mcccurved_guide_2_0_R0;
MCNUM Qc = mcccurved_guide_2_0_Qc;
MCNUM alpha = mcccurved_guide_2_0_alpha;
MCNUM m = mcccurved_guide_2_0_m;
MCNUM W = mcccurved_guide_2_0_W;
MCNUM nslit = mcccurved_guide_2_0_nslit;
MCNUM d = mcccurved_guide_2_0_d;
MCNUM mleft = mcccurved_guide_2_0_mleft;
MCNUM mright = mcccurved_guide_2_0_mright;
MCNUM mtop = mcccurved_guide_2_0_mtop;
MCNUM mbottom = mcccurved_guide_2_0_mbottom;
MCNUM nhslit = mcccurved_guide_2_0_nhslit;
MCNUM G = mcccurved_guide_2_0_G;
MCNUM aleft = mcccurved_guide_2_0_aleft;
MCNUM aright = mcccurved_guide_2_0_aright;
MCNUM atop = mcccurved_guide_2_0_atop;
MCNUM abottom = mcccurved_guide_2_0_abottom;
MCNUM wavy = mcccurved_guide_2_0_wavy;
MCNUM wavy_z = mcccurved_guide_2_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_2_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_2_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_2_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_2_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_2_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_2_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_2_0_nelements;
MCNUM nu = mcccurved_guide_2_0_nu;
MCNUM phase = mcccurved_guide_2_0_phase;
char* reflect = mcccurved_guide_2_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48750 "BIFROST.c"
}   /* End of curved_guide_2_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_2_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(20,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_3_0 [21] */
  mccoordschange(mcposrcurved_guide_3_0, mcrotrcurved_guide_3_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_3_0 (without coords transformations) */
  mcJumpTrace_curved_guide_3_0:
  SIG_MESSAGE("curved_guide_3_0 (Trace)");
  mcDEBUG_COMP("curved_guide_3_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_3_0
  STORE_NEUTRON(21,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[21]++;
  mcPCounter[21] += p;
  mcP2Counter[21] += p*p;
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
{   /* Declarations of curved_guide_3_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_3_0_w1;
MCNUM h1 = mcccurved_guide_3_0_h1;
MCNUM w2 = mcccurved_guide_3_0_w2;
MCNUM h2 = mcccurved_guide_3_0_h2;
MCNUM l = mcccurved_guide_3_0_l;
MCNUM R0 = mcccurved_guide_3_0_R0;
MCNUM Qc = mcccurved_guide_3_0_Qc;
MCNUM alpha = mcccurved_guide_3_0_alpha;
MCNUM m = mcccurved_guide_3_0_m;
MCNUM W = mcccurved_guide_3_0_W;
MCNUM nslit = mcccurved_guide_3_0_nslit;
MCNUM d = mcccurved_guide_3_0_d;
MCNUM mleft = mcccurved_guide_3_0_mleft;
MCNUM mright = mcccurved_guide_3_0_mright;
MCNUM mtop = mcccurved_guide_3_0_mtop;
MCNUM mbottom = mcccurved_guide_3_0_mbottom;
MCNUM nhslit = mcccurved_guide_3_0_nhslit;
MCNUM G = mcccurved_guide_3_0_G;
MCNUM aleft = mcccurved_guide_3_0_aleft;
MCNUM aright = mcccurved_guide_3_0_aright;
MCNUM atop = mcccurved_guide_3_0_atop;
MCNUM abottom = mcccurved_guide_3_0_abottom;
MCNUM wavy = mcccurved_guide_3_0_wavy;
MCNUM wavy_z = mcccurved_guide_3_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_3_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_3_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_3_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_3_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_3_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_3_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_3_0_nelements;
MCNUM nu = mcccurved_guide_3_0_nu;
MCNUM phase = mcccurved_guide_3_0_phase;
char* reflect = mcccurved_guide_3_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49063 "BIFROST.c"
}   /* End of curved_guide_3_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_3_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(21,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_4_0 [22] */
  mccoordschange(mcposrcurved_guide_4_0, mcrotrcurved_guide_4_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_4_0 (without coords transformations) */
  mcJumpTrace_curved_guide_4_0:
  SIG_MESSAGE("curved_guide_4_0 (Trace)");
  mcDEBUG_COMP("curved_guide_4_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_4_0
  STORE_NEUTRON(22,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[22]++;
  mcPCounter[22] += p;
  mcP2Counter[22] += p*p;
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
{   /* Declarations of curved_guide_4_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_4_0_w1;
MCNUM h1 = mcccurved_guide_4_0_h1;
MCNUM w2 = mcccurved_guide_4_0_w2;
MCNUM h2 = mcccurved_guide_4_0_h2;
MCNUM l = mcccurved_guide_4_0_l;
MCNUM R0 = mcccurved_guide_4_0_R0;
MCNUM Qc = mcccurved_guide_4_0_Qc;
MCNUM alpha = mcccurved_guide_4_0_alpha;
MCNUM m = mcccurved_guide_4_0_m;
MCNUM W = mcccurved_guide_4_0_W;
MCNUM nslit = mcccurved_guide_4_0_nslit;
MCNUM d = mcccurved_guide_4_0_d;
MCNUM mleft = mcccurved_guide_4_0_mleft;
MCNUM mright = mcccurved_guide_4_0_mright;
MCNUM mtop = mcccurved_guide_4_0_mtop;
MCNUM mbottom = mcccurved_guide_4_0_mbottom;
MCNUM nhslit = mcccurved_guide_4_0_nhslit;
MCNUM G = mcccurved_guide_4_0_G;
MCNUM aleft = mcccurved_guide_4_0_aleft;
MCNUM aright = mcccurved_guide_4_0_aright;
MCNUM atop = mcccurved_guide_4_0_atop;
MCNUM abottom = mcccurved_guide_4_0_abottom;
MCNUM wavy = mcccurved_guide_4_0_wavy;
MCNUM wavy_z = mcccurved_guide_4_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_4_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_4_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_4_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_4_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_4_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_4_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_4_0_nelements;
MCNUM nu = mcccurved_guide_4_0_nu;
MCNUM phase = mcccurved_guide_4_0_phase;
char* reflect = mcccurved_guide_4_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49376 "BIFROST.c"
}   /* End of curved_guide_4_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_4_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(22,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_5_beforeChopper [23] */
  mccoordschange(mcposrcurved_guide_5_beforeChopper, mcrotrcurved_guide_5_beforeChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_5_beforeChopper (without coords transformations) */
  mcJumpTrace_curved_guide_5_beforeChopper:
  SIG_MESSAGE("curved_guide_5_beforeChopper (Trace)");
  mcDEBUG_COMP("curved_guide_5_beforeChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_5_beforeChopper
  STORE_NEUTRON(23,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[23]++;
  mcPCounter[23] += p;
  mcP2Counter[23] += p*p;
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
{   /* Declarations of curved_guide_5_beforeChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_5_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_5_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_5_beforeChopper_h2;
MCNUM l = mcccurved_guide_5_beforeChopper_l;
MCNUM R0 = mcccurved_guide_5_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_5_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_5_beforeChopper_alpha;
MCNUM m = mcccurved_guide_5_beforeChopper_m;
MCNUM W = mcccurved_guide_5_beforeChopper_W;
MCNUM nslit = mcccurved_guide_5_beforeChopper_nslit;
MCNUM d = mcccurved_guide_5_beforeChopper_d;
MCNUM mleft = mcccurved_guide_5_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_5_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_5_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_5_beforeChopper_G;
MCNUM aleft = mcccurved_guide_5_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_5_beforeChopper_aright;
MCNUM atop = mcccurved_guide_5_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_5_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_5_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_5_beforeChopper_nu;
MCNUM phase = mcccurved_guide_5_beforeChopper_phase;
char* reflect = mcccurved_guide_5_beforeChopper_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49689 "BIFROST.c"
}   /* End of curved_guide_5_beforeChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_5_beforeChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(23,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monBeforeFOC1 [24] */
  mccoordschange(mcposrL_monBeforeFOC1, mcrotrL_monBeforeFOC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monBeforeFOC1 (without coords transformations) */
  mcJumpTrace_L_monBeforeFOC1:
  SIG_MESSAGE("L_monBeforeFOC1 (Trace)");
  mcDEBUG_COMP("L_monBeforeFOC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monBeforeFOC1
  STORE_NEUTRON(24,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[24]++;
  mcPCounter[24] += p;
  mcP2Counter[24] += p*p;
#define mccompcurname  L_monBeforeFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccL_monBeforeFOC1_nL
#define L_N mccL_monBeforeFOC1_L_N
#define L_p mccL_monBeforeFOC1_L_p
#define L_p2 mccL_monBeforeFOC1_L_p2
{   /* Declarations of L_monBeforeFOC1=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeFOC1_filename;
MCNUM xmin = mccL_monBeforeFOC1_xmin;
MCNUM xmax = mccL_monBeforeFOC1_xmax;
MCNUM ymin = mccL_monBeforeFOC1_ymin;
MCNUM ymax = mccL_monBeforeFOC1_ymax;
MCNUM xwidth = mccL_monBeforeFOC1_xwidth;
MCNUM yheight = mccL_monBeforeFOC1_yheight;
MCNUM Lmin = mccL_monBeforeFOC1_Lmin;
MCNUM Lmax = mccL_monBeforeFOC1_Lmax;
MCNUM restore_neutron = mccL_monBeforeFOC1_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 49833 "BIFROST.c"
}   /* End of L_monBeforeFOC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monBeforeFOC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(24,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFBeforeFOC1 [25] */
  mccoordschange(mcposrToFBeforeFOC1, mcrotrToFBeforeFOC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFBeforeFOC1 (without coords transformations) */
  mcJumpTrace_ToFBeforeFOC1:
  SIG_MESSAGE("ToFBeforeFOC1 (Trace)");
  mcDEBUG_COMP("ToFBeforeFOC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFBeforeFOC1
  STORE_NEUTRON(25,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[25]++;
  mcPCounter[25] += p;
  mcP2Counter[25] += p*p;
#define mccompcurname  ToFBeforeFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 25
#define nt mccToFBeforeFOC1_nt
#define TOF_N mccToFBeforeFOC1_TOF_N
#define TOF_p mccToFBeforeFOC1_TOF_p
#define TOF_p2 mccToFBeforeFOC1_TOF_p2
#define t_min mccToFBeforeFOC1_t_min
#define t_max mccToFBeforeFOC1_t_max
#define delta_t mccToFBeforeFOC1_delta_t
{   /* Declarations of ToFBeforeFOC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeFOC1_filename;
MCNUM xmin = mccToFBeforeFOC1_xmin;
MCNUM xmax = mccToFBeforeFOC1_xmax;
MCNUM ymin = mccToFBeforeFOC1_ymin;
MCNUM ymax = mccToFBeforeFOC1_ymax;
MCNUM xwidth = mccToFBeforeFOC1_xwidth;
MCNUM yheight = mccToFBeforeFOC1_yheight;
MCNUM tmin = mccToFBeforeFOC1_tmin;
MCNUM tmax = mccToFBeforeFOC1_tmax;
MCNUM dt = mccToFBeforeFOC1_dt;
MCNUM restore_neutron = mccToFBeforeFOC1_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 49980 "BIFROST.c"
}   /* End of ToFBeforeFOC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFBeforeFOC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(25,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_beforeFOC1 [26] */
  mccoordschange(mcposrPSD_beforeFOC1, mcrotrPSD_beforeFOC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_beforeFOC1 (without coords transformations) */
  mcJumpTrace_PSD_beforeFOC1:
  SIG_MESSAGE("PSD_beforeFOC1 (Trace)");
  mcDEBUG_COMP("PSD_beforeFOC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_beforeFOC1
  STORE_NEUTRON(26,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[26]++;
  mcPCounter[26] += p;
  mcP2Counter[26] += p*p;
#define mccompcurname  PSD_beforeFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 26
#define nx mccPSD_beforeFOC1_nx
#define ny mccPSD_beforeFOC1_ny
#define PSD_N mccPSD_beforeFOC1_PSD_N
#define PSD_p mccPSD_beforeFOC1_PSD_p
#define PSD_p2 mccPSD_beforeFOC1_PSD_p2
{   /* Declarations of PSD_beforeFOC1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforeFOC1_filename;
MCNUM xmin = mccPSD_beforeFOC1_xmin;
MCNUM xmax = mccPSD_beforeFOC1_xmax;
MCNUM ymin = mccPSD_beforeFOC1_ymin;
MCNUM ymax = mccPSD_beforeFOC1_ymax;
MCNUM xwidth = mccPSD_beforeFOC1_xwidth;
MCNUM yheight = mccPSD_beforeFOC1_yheight;
MCNUM restore_neutron = mccPSD_beforeFOC1_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 50124 "BIFROST.c"
}   /* End of PSD_beforeFOC1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_beforeFOC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(26,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component FOC1 [27] */
  mccoordschange(mcposrFOC1, mcrotrFOC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component FOC1 (without coords transformations) */
  mcJumpTrace_FOC1:
  SIG_MESSAGE("FOC1 (Trace)");
  mcDEBUG_COMP("FOC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompFOC1
  STORE_NEUTRON(27,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[27]++;
  mcPCounter[27] += p;
  mcP2Counter[27] += p*p;
#define mccompcurname  FOC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 27
#define Tg mccFOC1_Tg
#define To mccFOC1_To
#define delta_y mccFOC1_delta_y
#define height mccFOC1_height
#define omega mccFOC1_omega
{   /* Declarations of FOC1=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccFOC1_theta_0;
MCNUM radius = mccFOC1_radius;
MCNUM yheight = mccFOC1_yheight;
MCNUM nu = mccFOC1_nu;
MCNUM nslit = mccFOC1_nslit;
MCNUM jitter = mccFOC1_jitter;
MCNUM delay = mccFOC1_delay;
MCNUM isfirst = mccFOC1_isfirst;
MCNUM n_pulse = mccFOC1_n_pulse;
MCNUM abs_out = mccFOC1_abs_out;
MCNUM phase = mccFOC1_phase;
MCNUM xwidth = mccFOC1_xwidth;
MCNUM verbose = mccFOC1_verbose;
#line 130 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 50287 "BIFROST.c"
}   /* End of FOC1=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompFOC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(27,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_afterFOC1 [28] */
  mccoordschange(mcposrPSD_afterFOC1, mcrotrPSD_afterFOC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_afterFOC1 (without coords transformations) */
  mcJumpTrace_PSD_afterFOC1:
  SIG_MESSAGE("PSD_afterFOC1 (Trace)");
  mcDEBUG_COMP("PSD_afterFOC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_afterFOC1
  STORE_NEUTRON(28,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[28]++;
  mcPCounter[28] += p;
  mcP2Counter[28] += p*p;
#define mccompcurname  PSD_afterFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 28
#define nx mccPSD_afterFOC1_nx
#define ny mccPSD_afterFOC1_ny
#define PSD_N mccPSD_afterFOC1_PSD_N
#define PSD_p mccPSD_afterFOC1_PSD_p
#define PSD_p2 mccPSD_afterFOC1_PSD_p2
{   /* Declarations of PSD_afterFOC1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_afterFOC1_filename;
MCNUM xmin = mccPSD_afterFOC1_xmin;
MCNUM xmax = mccPSD_afterFOC1_xmax;
MCNUM ymin = mccPSD_afterFOC1_ymin;
MCNUM ymax = mccPSD_afterFOC1_ymax;
MCNUM xwidth = mccPSD_afterFOC1_xwidth;
MCNUM yheight = mccPSD_afterFOC1_yheight;
MCNUM restore_neutron = mccPSD_afterFOC1_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 50429 "BIFROST.c"
}   /* End of PSD_afterFOC1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_afterFOC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(28,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFAfterFOC1 [29] */
  mccoordschange(mcposrToFAfterFOC1, mcrotrToFAfterFOC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFAfterFOC1 (without coords transformations) */
  mcJumpTrace_ToFAfterFOC1:
  SIG_MESSAGE("ToFAfterFOC1 (Trace)");
  mcDEBUG_COMP("ToFAfterFOC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFAfterFOC1
  STORE_NEUTRON(29,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[29]++;
  mcPCounter[29] += p;
  mcP2Counter[29] += p*p;
#define mccompcurname  ToFAfterFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 29
#define nt mccToFAfterFOC1_nt
#define TOF_N mccToFAfterFOC1_TOF_N
#define TOF_p mccToFAfterFOC1_TOF_p
#define TOF_p2 mccToFAfterFOC1_TOF_p2
#define t_min mccToFAfterFOC1_t_min
#define t_max mccToFAfterFOC1_t_max
#define delta_t mccToFAfterFOC1_delta_t
{   /* Declarations of ToFAfterFOC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterFOC1_filename;
MCNUM xmin = mccToFAfterFOC1_xmin;
MCNUM xmax = mccToFAfterFOC1_xmax;
MCNUM ymin = mccToFAfterFOC1_ymin;
MCNUM ymax = mccToFAfterFOC1_ymax;
MCNUM xwidth = mccToFAfterFOC1_xwidth;
MCNUM yheight = mccToFAfterFOC1_yheight;
MCNUM tmin = mccToFAfterFOC1_tmin;
MCNUM tmax = mccToFAfterFOC1_tmax;
MCNUM dt = mccToFAfterFOC1_dt;
MCNUM restore_neutron = mccToFAfterFOC1_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 50577 "BIFROST.c"
}   /* End of ToFAfterFOC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFAfterFOC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(29,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monAfterFOC1 [30] */
  mccoordschange(mcposrL_monAfterFOC1, mcrotrL_monAfterFOC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monAfterFOC1 (without coords transformations) */
  mcJumpTrace_L_monAfterFOC1:
  SIG_MESSAGE("L_monAfterFOC1 (Trace)");
  mcDEBUG_COMP("L_monAfterFOC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monAfterFOC1
  STORE_NEUTRON(30,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[30]++;
  mcPCounter[30] += p;
  mcP2Counter[30] += p*p;
#define mccompcurname  L_monAfterFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 30
#define nL mccL_monAfterFOC1_nL
#define L_N mccL_monAfterFOC1_L_N
#define L_p mccL_monAfterFOC1_L_p
#define L_p2 mccL_monAfterFOC1_L_p2
{   /* Declarations of L_monAfterFOC1=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterFOC1_filename;
MCNUM xmin = mccL_monAfterFOC1_xmin;
MCNUM xmax = mccL_monAfterFOC1_xmax;
MCNUM ymin = mccL_monAfterFOC1_ymin;
MCNUM ymax = mccL_monAfterFOC1_ymax;
MCNUM xwidth = mccL_monAfterFOC1_xwidth;
MCNUM yheight = mccL_monAfterFOC1_yheight;
MCNUM Lmin = mccL_monAfterFOC1_Lmin;
MCNUM Lmax = mccL_monAfterFOC1_Lmax;
MCNUM restore_neutron = mccL_monAfterFOC1_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 50726 "BIFROST.c"
}   /* End of L_monAfterFOC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monAfterFOC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(30,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_5_afterChopper [31] */
  mccoordschange(mcposrcurved_guide_5_afterChopper, mcrotrcurved_guide_5_afterChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_5_afterChopper (without coords transformations) */
  mcJumpTrace_curved_guide_5_afterChopper:
  SIG_MESSAGE("curved_guide_5_afterChopper (Trace)");
  mcDEBUG_COMP("curved_guide_5_afterChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_5_afterChopper
  STORE_NEUTRON(31,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[31]++;
  mcPCounter[31] += p;
  mcP2Counter[31] += p*p;
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
{   /* Declarations of curved_guide_5_afterChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_afterChopper_w1;
MCNUM h1 = mcccurved_guide_5_afterChopper_h1;
MCNUM w2 = mcccurved_guide_5_afterChopper_w2;
MCNUM h2 = mcccurved_guide_5_afterChopper_h2;
MCNUM l = mcccurved_guide_5_afterChopper_l;
MCNUM R0 = mcccurved_guide_5_afterChopper_R0;
MCNUM Qc = mcccurved_guide_5_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_5_afterChopper_alpha;
MCNUM m = mcccurved_guide_5_afterChopper_m;
MCNUM W = mcccurved_guide_5_afterChopper_W;
MCNUM nslit = mcccurved_guide_5_afterChopper_nslit;
MCNUM d = mcccurved_guide_5_afterChopper_d;
MCNUM mleft = mcccurved_guide_5_afterChopper_mleft;
MCNUM mright = mcccurved_guide_5_afterChopper_mright;
MCNUM mtop = mcccurved_guide_5_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_afterChopper_nhslit;
MCNUM G = mcccurved_guide_5_afterChopper_G;
MCNUM aleft = mcccurved_guide_5_afterChopper_aleft;
MCNUM aright = mcccurved_guide_5_afterChopper_aright;
MCNUM atop = mcccurved_guide_5_afterChopper_atop;
MCNUM abottom = mcccurved_guide_5_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_5_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_afterChopper_nelements;
MCNUM nu = mcccurved_guide_5_afterChopper_nu;
MCNUM phase = mcccurved_guide_5_afterChopper_phase;
char* reflect = mcccurved_guide_5_afterChopper_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51041 "BIFROST.c"
}   /* End of curved_guide_5_afterChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_5_afterChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(31,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_6_0 [32] */
  mccoordschange(mcposrcurved_guide_6_0, mcrotrcurved_guide_6_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_6_0 (without coords transformations) */
  mcJumpTrace_curved_guide_6_0:
  SIG_MESSAGE("curved_guide_6_0 (Trace)");
  mcDEBUG_COMP("curved_guide_6_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_6_0
  STORE_NEUTRON(32,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[32]++;
  mcPCounter[32] += p;
  mcP2Counter[32] += p*p;
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
{   /* Declarations of curved_guide_6_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_6_0_w1;
MCNUM h1 = mcccurved_guide_6_0_h1;
MCNUM w2 = mcccurved_guide_6_0_w2;
MCNUM h2 = mcccurved_guide_6_0_h2;
MCNUM l = mcccurved_guide_6_0_l;
MCNUM R0 = mcccurved_guide_6_0_R0;
MCNUM Qc = mcccurved_guide_6_0_Qc;
MCNUM alpha = mcccurved_guide_6_0_alpha;
MCNUM m = mcccurved_guide_6_0_m;
MCNUM W = mcccurved_guide_6_0_W;
MCNUM nslit = mcccurved_guide_6_0_nslit;
MCNUM d = mcccurved_guide_6_0_d;
MCNUM mleft = mcccurved_guide_6_0_mleft;
MCNUM mright = mcccurved_guide_6_0_mright;
MCNUM mtop = mcccurved_guide_6_0_mtop;
MCNUM mbottom = mcccurved_guide_6_0_mbottom;
MCNUM nhslit = mcccurved_guide_6_0_nhslit;
MCNUM G = mcccurved_guide_6_0_G;
MCNUM aleft = mcccurved_guide_6_0_aleft;
MCNUM aright = mcccurved_guide_6_0_aright;
MCNUM atop = mcccurved_guide_6_0_atop;
MCNUM abottom = mcccurved_guide_6_0_abottom;
MCNUM wavy = mcccurved_guide_6_0_wavy;
MCNUM wavy_z = mcccurved_guide_6_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_6_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_6_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_6_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_6_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_6_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_6_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_6_0_nelements;
MCNUM nu = mcccurved_guide_6_0_nu;
MCNUM phase = mcccurved_guide_6_0_phase;
char* reflect = mcccurved_guide_6_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51354 "BIFROST.c"
}   /* End of curved_guide_6_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_6_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(32,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_7_0 [33] */
  mccoordschange(mcposrcurved_guide_7_0, mcrotrcurved_guide_7_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_7_0 (without coords transformations) */
  mcJumpTrace_curved_guide_7_0:
  SIG_MESSAGE("curved_guide_7_0 (Trace)");
  mcDEBUG_COMP("curved_guide_7_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_7_0
  STORE_NEUTRON(33,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[33]++;
  mcPCounter[33] += p;
  mcP2Counter[33] += p*p;
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
{   /* Declarations of curved_guide_7_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_7_0_w1;
MCNUM h1 = mcccurved_guide_7_0_h1;
MCNUM w2 = mcccurved_guide_7_0_w2;
MCNUM h2 = mcccurved_guide_7_0_h2;
MCNUM l = mcccurved_guide_7_0_l;
MCNUM R0 = mcccurved_guide_7_0_R0;
MCNUM Qc = mcccurved_guide_7_0_Qc;
MCNUM alpha = mcccurved_guide_7_0_alpha;
MCNUM m = mcccurved_guide_7_0_m;
MCNUM W = mcccurved_guide_7_0_W;
MCNUM nslit = mcccurved_guide_7_0_nslit;
MCNUM d = mcccurved_guide_7_0_d;
MCNUM mleft = mcccurved_guide_7_0_mleft;
MCNUM mright = mcccurved_guide_7_0_mright;
MCNUM mtop = mcccurved_guide_7_0_mtop;
MCNUM mbottom = mcccurved_guide_7_0_mbottom;
MCNUM nhslit = mcccurved_guide_7_0_nhslit;
MCNUM G = mcccurved_guide_7_0_G;
MCNUM aleft = mcccurved_guide_7_0_aleft;
MCNUM aright = mcccurved_guide_7_0_aright;
MCNUM atop = mcccurved_guide_7_0_atop;
MCNUM abottom = mcccurved_guide_7_0_abottom;
MCNUM wavy = mcccurved_guide_7_0_wavy;
MCNUM wavy_z = mcccurved_guide_7_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_7_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_7_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_7_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_7_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_7_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_7_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_7_0_nelements;
MCNUM nu = mcccurved_guide_7_0_nu;
MCNUM phase = mcccurved_guide_7_0_phase;
char* reflect = mcccurved_guide_7_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51667 "BIFROST.c"
}   /* End of curved_guide_7_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_7_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(33,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_8_0 [34] */
  mccoordschange(mcposrcurved_guide_8_0, mcrotrcurved_guide_8_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_8_0 (without coords transformations) */
  mcJumpTrace_curved_guide_8_0:
  SIG_MESSAGE("curved_guide_8_0 (Trace)");
  mcDEBUG_COMP("curved_guide_8_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_8_0
  STORE_NEUTRON(34,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[34]++;
  mcPCounter[34] += p;
  mcP2Counter[34] += p*p;
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
{   /* Declarations of curved_guide_8_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_8_0_w1;
MCNUM h1 = mcccurved_guide_8_0_h1;
MCNUM w2 = mcccurved_guide_8_0_w2;
MCNUM h2 = mcccurved_guide_8_0_h2;
MCNUM l = mcccurved_guide_8_0_l;
MCNUM R0 = mcccurved_guide_8_0_R0;
MCNUM Qc = mcccurved_guide_8_0_Qc;
MCNUM alpha = mcccurved_guide_8_0_alpha;
MCNUM m = mcccurved_guide_8_0_m;
MCNUM W = mcccurved_guide_8_0_W;
MCNUM nslit = mcccurved_guide_8_0_nslit;
MCNUM d = mcccurved_guide_8_0_d;
MCNUM mleft = mcccurved_guide_8_0_mleft;
MCNUM mright = mcccurved_guide_8_0_mright;
MCNUM mtop = mcccurved_guide_8_0_mtop;
MCNUM mbottom = mcccurved_guide_8_0_mbottom;
MCNUM nhslit = mcccurved_guide_8_0_nhslit;
MCNUM G = mcccurved_guide_8_0_G;
MCNUM aleft = mcccurved_guide_8_0_aleft;
MCNUM aright = mcccurved_guide_8_0_aright;
MCNUM atop = mcccurved_guide_8_0_atop;
MCNUM abottom = mcccurved_guide_8_0_abottom;
MCNUM wavy = mcccurved_guide_8_0_wavy;
MCNUM wavy_z = mcccurved_guide_8_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_8_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_8_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_8_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_8_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_8_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_8_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_8_0_nelements;
MCNUM nu = mcccurved_guide_8_0_nu;
MCNUM phase = mcccurved_guide_8_0_phase;
char* reflect = mcccurved_guide_8_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51980 "BIFROST.c"
}   /* End of curved_guide_8_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_8_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(34,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_9_0 [35] */
  mccoordschange(mcposrcurved_guide_9_0, mcrotrcurved_guide_9_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_9_0 (without coords transformations) */
  mcJumpTrace_curved_guide_9_0:
  SIG_MESSAGE("curved_guide_9_0 (Trace)");
  mcDEBUG_COMP("curved_guide_9_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_9_0
  STORE_NEUTRON(35,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[35]++;
  mcPCounter[35] += p;
  mcP2Counter[35] += p*p;
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
{   /* Declarations of curved_guide_9_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_9_0_w1;
MCNUM h1 = mcccurved_guide_9_0_h1;
MCNUM w2 = mcccurved_guide_9_0_w2;
MCNUM h2 = mcccurved_guide_9_0_h2;
MCNUM l = mcccurved_guide_9_0_l;
MCNUM R0 = mcccurved_guide_9_0_R0;
MCNUM Qc = mcccurved_guide_9_0_Qc;
MCNUM alpha = mcccurved_guide_9_0_alpha;
MCNUM m = mcccurved_guide_9_0_m;
MCNUM W = mcccurved_guide_9_0_W;
MCNUM nslit = mcccurved_guide_9_0_nslit;
MCNUM d = mcccurved_guide_9_0_d;
MCNUM mleft = mcccurved_guide_9_0_mleft;
MCNUM mright = mcccurved_guide_9_0_mright;
MCNUM mtop = mcccurved_guide_9_0_mtop;
MCNUM mbottom = mcccurved_guide_9_0_mbottom;
MCNUM nhslit = mcccurved_guide_9_0_nhslit;
MCNUM G = mcccurved_guide_9_0_G;
MCNUM aleft = mcccurved_guide_9_0_aleft;
MCNUM aright = mcccurved_guide_9_0_aright;
MCNUM atop = mcccurved_guide_9_0_atop;
MCNUM abottom = mcccurved_guide_9_0_abottom;
MCNUM wavy = mcccurved_guide_9_0_wavy;
MCNUM wavy_z = mcccurved_guide_9_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_9_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_9_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_9_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_9_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_9_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_9_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_9_0_nelements;
MCNUM nu = mcccurved_guide_9_0_nu;
MCNUM phase = mcccurved_guide_9_0_phase;
char* reflect = mcccurved_guide_9_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52293 "BIFROST.c"
}   /* End of curved_guide_9_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_9_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(35,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_10_0 [36] */
  mccoordschange(mcposrcurved_guide_10_0, mcrotrcurved_guide_10_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_10_0 (without coords transformations) */
  mcJumpTrace_curved_guide_10_0:
  SIG_MESSAGE("curved_guide_10_0 (Trace)");
  mcDEBUG_COMP("curved_guide_10_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_10_0
  STORE_NEUTRON(36,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[36]++;
  mcPCounter[36] += p;
  mcP2Counter[36] += p*p;
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
{   /* Declarations of curved_guide_10_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_10_0_w1;
MCNUM h1 = mcccurved_guide_10_0_h1;
MCNUM w2 = mcccurved_guide_10_0_w2;
MCNUM h2 = mcccurved_guide_10_0_h2;
MCNUM l = mcccurved_guide_10_0_l;
MCNUM R0 = mcccurved_guide_10_0_R0;
MCNUM Qc = mcccurved_guide_10_0_Qc;
MCNUM alpha = mcccurved_guide_10_0_alpha;
MCNUM m = mcccurved_guide_10_0_m;
MCNUM W = mcccurved_guide_10_0_W;
MCNUM nslit = mcccurved_guide_10_0_nslit;
MCNUM d = mcccurved_guide_10_0_d;
MCNUM mleft = mcccurved_guide_10_0_mleft;
MCNUM mright = mcccurved_guide_10_0_mright;
MCNUM mtop = mcccurved_guide_10_0_mtop;
MCNUM mbottom = mcccurved_guide_10_0_mbottom;
MCNUM nhslit = mcccurved_guide_10_0_nhslit;
MCNUM G = mcccurved_guide_10_0_G;
MCNUM aleft = mcccurved_guide_10_0_aleft;
MCNUM aright = mcccurved_guide_10_0_aright;
MCNUM atop = mcccurved_guide_10_0_atop;
MCNUM abottom = mcccurved_guide_10_0_abottom;
MCNUM wavy = mcccurved_guide_10_0_wavy;
MCNUM wavy_z = mcccurved_guide_10_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_10_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_10_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_10_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_10_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_10_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_10_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_10_0_nelements;
MCNUM nu = mcccurved_guide_10_0_nu;
MCNUM phase = mcccurved_guide_10_0_phase;
char* reflect = mcccurved_guide_10_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52606 "BIFROST.c"
}   /* End of curved_guide_10_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_10_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(36,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_11_0 [37] */
  mccoordschange(mcposrcurved_guide_11_0, mcrotrcurved_guide_11_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_11_0 (without coords transformations) */
  mcJumpTrace_curved_guide_11_0:
  SIG_MESSAGE("curved_guide_11_0 (Trace)");
  mcDEBUG_COMP("curved_guide_11_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_11_0
  STORE_NEUTRON(37,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[37]++;
  mcPCounter[37] += p;
  mcP2Counter[37] += p*p;
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
{   /* Declarations of curved_guide_11_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_11_0_w1;
MCNUM h1 = mcccurved_guide_11_0_h1;
MCNUM w2 = mcccurved_guide_11_0_w2;
MCNUM h2 = mcccurved_guide_11_0_h2;
MCNUM l = mcccurved_guide_11_0_l;
MCNUM R0 = mcccurved_guide_11_0_R0;
MCNUM Qc = mcccurved_guide_11_0_Qc;
MCNUM alpha = mcccurved_guide_11_0_alpha;
MCNUM m = mcccurved_guide_11_0_m;
MCNUM W = mcccurved_guide_11_0_W;
MCNUM nslit = mcccurved_guide_11_0_nslit;
MCNUM d = mcccurved_guide_11_0_d;
MCNUM mleft = mcccurved_guide_11_0_mleft;
MCNUM mright = mcccurved_guide_11_0_mright;
MCNUM mtop = mcccurved_guide_11_0_mtop;
MCNUM mbottom = mcccurved_guide_11_0_mbottom;
MCNUM nhslit = mcccurved_guide_11_0_nhslit;
MCNUM G = mcccurved_guide_11_0_G;
MCNUM aleft = mcccurved_guide_11_0_aleft;
MCNUM aright = mcccurved_guide_11_0_aright;
MCNUM atop = mcccurved_guide_11_0_atop;
MCNUM abottom = mcccurved_guide_11_0_abottom;
MCNUM wavy = mcccurved_guide_11_0_wavy;
MCNUM wavy_z = mcccurved_guide_11_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_11_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_11_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_11_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_11_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_11_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_11_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_11_0_nelements;
MCNUM nu = mcccurved_guide_11_0_nu;
MCNUM phase = mcccurved_guide_11_0_phase;
char* reflect = mcccurved_guide_11_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52919 "BIFROST.c"
}   /* End of curved_guide_11_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_11_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(37,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_12_0 [38] */
  mccoordschange(mcposrcurved_guide_12_0, mcrotrcurved_guide_12_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_12_0 (without coords transformations) */
  mcJumpTrace_curved_guide_12_0:
  SIG_MESSAGE("curved_guide_12_0 (Trace)");
  mcDEBUG_COMP("curved_guide_12_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_12_0
  STORE_NEUTRON(38,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[38]++;
  mcPCounter[38] += p;
  mcP2Counter[38] += p*p;
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
{   /* Declarations of curved_guide_12_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_12_0_w1;
MCNUM h1 = mcccurved_guide_12_0_h1;
MCNUM w2 = mcccurved_guide_12_0_w2;
MCNUM h2 = mcccurved_guide_12_0_h2;
MCNUM l = mcccurved_guide_12_0_l;
MCNUM R0 = mcccurved_guide_12_0_R0;
MCNUM Qc = mcccurved_guide_12_0_Qc;
MCNUM alpha = mcccurved_guide_12_0_alpha;
MCNUM m = mcccurved_guide_12_0_m;
MCNUM W = mcccurved_guide_12_0_W;
MCNUM nslit = mcccurved_guide_12_0_nslit;
MCNUM d = mcccurved_guide_12_0_d;
MCNUM mleft = mcccurved_guide_12_0_mleft;
MCNUM mright = mcccurved_guide_12_0_mright;
MCNUM mtop = mcccurved_guide_12_0_mtop;
MCNUM mbottom = mcccurved_guide_12_0_mbottom;
MCNUM nhslit = mcccurved_guide_12_0_nhslit;
MCNUM G = mcccurved_guide_12_0_G;
MCNUM aleft = mcccurved_guide_12_0_aleft;
MCNUM aright = mcccurved_guide_12_0_aright;
MCNUM atop = mcccurved_guide_12_0_atop;
MCNUM abottom = mcccurved_guide_12_0_abottom;
MCNUM wavy = mcccurved_guide_12_0_wavy;
MCNUM wavy_z = mcccurved_guide_12_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_12_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_12_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_12_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_12_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_12_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_12_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_12_0_nelements;
MCNUM nu = mcccurved_guide_12_0_nu;
MCNUM phase = mcccurved_guide_12_0_phase;
char* reflect = mcccurved_guide_12_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53232 "BIFROST.c"
}   /* End of curved_guide_12_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_12_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(38,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_13_0 [39] */
  mccoordschange(mcposrcurved_guide_13_0, mcrotrcurved_guide_13_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_13_0 (without coords transformations) */
  mcJumpTrace_curved_guide_13_0:
  SIG_MESSAGE("curved_guide_13_0 (Trace)");
  mcDEBUG_COMP("curved_guide_13_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_13_0
  STORE_NEUTRON(39,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[39]++;
  mcPCounter[39] += p;
  mcP2Counter[39] += p*p;
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
{   /* Declarations of curved_guide_13_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_13_0_w1;
MCNUM h1 = mcccurved_guide_13_0_h1;
MCNUM w2 = mcccurved_guide_13_0_w2;
MCNUM h2 = mcccurved_guide_13_0_h2;
MCNUM l = mcccurved_guide_13_0_l;
MCNUM R0 = mcccurved_guide_13_0_R0;
MCNUM Qc = mcccurved_guide_13_0_Qc;
MCNUM alpha = mcccurved_guide_13_0_alpha;
MCNUM m = mcccurved_guide_13_0_m;
MCNUM W = mcccurved_guide_13_0_W;
MCNUM nslit = mcccurved_guide_13_0_nslit;
MCNUM d = mcccurved_guide_13_0_d;
MCNUM mleft = mcccurved_guide_13_0_mleft;
MCNUM mright = mcccurved_guide_13_0_mright;
MCNUM mtop = mcccurved_guide_13_0_mtop;
MCNUM mbottom = mcccurved_guide_13_0_mbottom;
MCNUM nhslit = mcccurved_guide_13_0_nhslit;
MCNUM G = mcccurved_guide_13_0_G;
MCNUM aleft = mcccurved_guide_13_0_aleft;
MCNUM aright = mcccurved_guide_13_0_aright;
MCNUM atop = mcccurved_guide_13_0_atop;
MCNUM abottom = mcccurved_guide_13_0_abottom;
MCNUM wavy = mcccurved_guide_13_0_wavy;
MCNUM wavy_z = mcccurved_guide_13_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_13_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_13_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_13_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_13_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_13_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_13_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_13_0_nelements;
MCNUM nu = mcccurved_guide_13_0_nu;
MCNUM phase = mcccurved_guide_13_0_phase;
char* reflect = mcccurved_guide_13_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53545 "BIFROST.c"
}   /* End of curved_guide_13_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_13_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(39,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_14_0 [40] */
  mccoordschange(mcposrcurved_guide_14_0, mcrotrcurved_guide_14_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_14_0 (without coords transformations) */
  mcJumpTrace_curved_guide_14_0:
  SIG_MESSAGE("curved_guide_14_0 (Trace)");
  mcDEBUG_COMP("curved_guide_14_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_14_0
  STORE_NEUTRON(40,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[40]++;
  mcPCounter[40] += p;
  mcP2Counter[40] += p*p;
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
{   /* Declarations of curved_guide_14_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_14_0_w1;
MCNUM h1 = mcccurved_guide_14_0_h1;
MCNUM w2 = mcccurved_guide_14_0_w2;
MCNUM h2 = mcccurved_guide_14_0_h2;
MCNUM l = mcccurved_guide_14_0_l;
MCNUM R0 = mcccurved_guide_14_0_R0;
MCNUM Qc = mcccurved_guide_14_0_Qc;
MCNUM alpha = mcccurved_guide_14_0_alpha;
MCNUM m = mcccurved_guide_14_0_m;
MCNUM W = mcccurved_guide_14_0_W;
MCNUM nslit = mcccurved_guide_14_0_nslit;
MCNUM d = mcccurved_guide_14_0_d;
MCNUM mleft = mcccurved_guide_14_0_mleft;
MCNUM mright = mcccurved_guide_14_0_mright;
MCNUM mtop = mcccurved_guide_14_0_mtop;
MCNUM mbottom = mcccurved_guide_14_0_mbottom;
MCNUM nhslit = mcccurved_guide_14_0_nhslit;
MCNUM G = mcccurved_guide_14_0_G;
MCNUM aleft = mcccurved_guide_14_0_aleft;
MCNUM aright = mcccurved_guide_14_0_aright;
MCNUM atop = mcccurved_guide_14_0_atop;
MCNUM abottom = mcccurved_guide_14_0_abottom;
MCNUM wavy = mcccurved_guide_14_0_wavy;
MCNUM wavy_z = mcccurved_guide_14_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_14_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_14_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_14_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_14_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_14_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_14_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_14_0_nelements;
MCNUM nu = mcccurved_guide_14_0_nu;
MCNUM phase = mcccurved_guide_14_0_phase;
char* reflect = mcccurved_guide_14_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53858 "BIFROST.c"
}   /* End of curved_guide_14_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_14_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(40,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_15_0 [41] */
  mccoordschange(mcposrcurved_guide_15_0, mcrotrcurved_guide_15_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_15_0 (without coords transformations) */
  mcJumpTrace_curved_guide_15_0:
  SIG_MESSAGE("curved_guide_15_0 (Trace)");
  mcDEBUG_COMP("curved_guide_15_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_15_0
  STORE_NEUTRON(41,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[41]++;
  mcPCounter[41] += p;
  mcP2Counter[41] += p*p;
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
{   /* Declarations of curved_guide_15_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_15_0_w1;
MCNUM h1 = mcccurved_guide_15_0_h1;
MCNUM w2 = mcccurved_guide_15_0_w2;
MCNUM h2 = mcccurved_guide_15_0_h2;
MCNUM l = mcccurved_guide_15_0_l;
MCNUM R0 = mcccurved_guide_15_0_R0;
MCNUM Qc = mcccurved_guide_15_0_Qc;
MCNUM alpha = mcccurved_guide_15_0_alpha;
MCNUM m = mcccurved_guide_15_0_m;
MCNUM W = mcccurved_guide_15_0_W;
MCNUM nslit = mcccurved_guide_15_0_nslit;
MCNUM d = mcccurved_guide_15_0_d;
MCNUM mleft = mcccurved_guide_15_0_mleft;
MCNUM mright = mcccurved_guide_15_0_mright;
MCNUM mtop = mcccurved_guide_15_0_mtop;
MCNUM mbottom = mcccurved_guide_15_0_mbottom;
MCNUM nhslit = mcccurved_guide_15_0_nhslit;
MCNUM G = mcccurved_guide_15_0_G;
MCNUM aleft = mcccurved_guide_15_0_aleft;
MCNUM aright = mcccurved_guide_15_0_aright;
MCNUM atop = mcccurved_guide_15_0_atop;
MCNUM abottom = mcccurved_guide_15_0_abottom;
MCNUM wavy = mcccurved_guide_15_0_wavy;
MCNUM wavy_z = mcccurved_guide_15_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_15_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_15_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_15_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_15_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_15_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_15_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_15_0_nelements;
MCNUM nu = mcccurved_guide_15_0_nu;
MCNUM phase = mcccurved_guide_15_0_phase;
char* reflect = mcccurved_guide_15_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 54171 "BIFROST.c"
}   /* End of curved_guide_15_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_15_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(41,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_16_0 [42] */
  mccoordschange(mcposrcurved_guide_16_0, mcrotrcurved_guide_16_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_16_0 (without coords transformations) */
  mcJumpTrace_curved_guide_16_0:
  SIG_MESSAGE("curved_guide_16_0 (Trace)");
  mcDEBUG_COMP("curved_guide_16_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_16_0
  STORE_NEUTRON(42,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[42]++;
  mcPCounter[42] += p;
  mcP2Counter[42] += p*p;
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
{   /* Declarations of curved_guide_16_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_16_0_w1;
MCNUM h1 = mcccurved_guide_16_0_h1;
MCNUM w2 = mcccurved_guide_16_0_w2;
MCNUM h2 = mcccurved_guide_16_0_h2;
MCNUM l = mcccurved_guide_16_0_l;
MCNUM R0 = mcccurved_guide_16_0_R0;
MCNUM Qc = mcccurved_guide_16_0_Qc;
MCNUM alpha = mcccurved_guide_16_0_alpha;
MCNUM m = mcccurved_guide_16_0_m;
MCNUM W = mcccurved_guide_16_0_W;
MCNUM nslit = mcccurved_guide_16_0_nslit;
MCNUM d = mcccurved_guide_16_0_d;
MCNUM mleft = mcccurved_guide_16_0_mleft;
MCNUM mright = mcccurved_guide_16_0_mright;
MCNUM mtop = mcccurved_guide_16_0_mtop;
MCNUM mbottom = mcccurved_guide_16_0_mbottom;
MCNUM nhslit = mcccurved_guide_16_0_nhslit;
MCNUM G = mcccurved_guide_16_0_G;
MCNUM aleft = mcccurved_guide_16_0_aleft;
MCNUM aright = mcccurved_guide_16_0_aright;
MCNUM atop = mcccurved_guide_16_0_atop;
MCNUM abottom = mcccurved_guide_16_0_abottom;
MCNUM wavy = mcccurved_guide_16_0_wavy;
MCNUM wavy_z = mcccurved_guide_16_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_16_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_16_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_16_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_16_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_16_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_16_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_16_0_nelements;
MCNUM nu = mcccurved_guide_16_0_nu;
MCNUM phase = mcccurved_guide_16_0_phase;
char* reflect = mcccurved_guide_16_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 54484 "BIFROST.c"
}   /* End of curved_guide_16_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_16_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(42,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_17_0 [43] */
  mccoordschange(mcposrcurved_guide_17_0, mcrotrcurved_guide_17_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_17_0 (without coords transformations) */
  mcJumpTrace_curved_guide_17_0:
  SIG_MESSAGE("curved_guide_17_0 (Trace)");
  mcDEBUG_COMP("curved_guide_17_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_17_0
  STORE_NEUTRON(43,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[43]++;
  mcPCounter[43] += p;
  mcP2Counter[43] += p*p;
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
{   /* Declarations of curved_guide_17_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_17_0_w1;
MCNUM h1 = mcccurved_guide_17_0_h1;
MCNUM w2 = mcccurved_guide_17_0_w2;
MCNUM h2 = mcccurved_guide_17_0_h2;
MCNUM l = mcccurved_guide_17_0_l;
MCNUM R0 = mcccurved_guide_17_0_R0;
MCNUM Qc = mcccurved_guide_17_0_Qc;
MCNUM alpha = mcccurved_guide_17_0_alpha;
MCNUM m = mcccurved_guide_17_0_m;
MCNUM W = mcccurved_guide_17_0_W;
MCNUM nslit = mcccurved_guide_17_0_nslit;
MCNUM d = mcccurved_guide_17_0_d;
MCNUM mleft = mcccurved_guide_17_0_mleft;
MCNUM mright = mcccurved_guide_17_0_mright;
MCNUM mtop = mcccurved_guide_17_0_mtop;
MCNUM mbottom = mcccurved_guide_17_0_mbottom;
MCNUM nhslit = mcccurved_guide_17_0_nhslit;
MCNUM G = mcccurved_guide_17_0_G;
MCNUM aleft = mcccurved_guide_17_0_aleft;
MCNUM aright = mcccurved_guide_17_0_aright;
MCNUM atop = mcccurved_guide_17_0_atop;
MCNUM abottom = mcccurved_guide_17_0_abottom;
MCNUM wavy = mcccurved_guide_17_0_wavy;
MCNUM wavy_z = mcccurved_guide_17_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_17_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_17_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_17_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_17_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_17_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_17_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_17_0_nelements;
MCNUM nu = mcccurved_guide_17_0_nu;
MCNUM phase = mcccurved_guide_17_0_phase;
char* reflect = mcccurved_guide_17_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 54797 "BIFROST.c"
}   /* End of curved_guide_17_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_17_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(43,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_18_beforeChopper [44] */
  mccoordschange(mcposrcurved_guide_18_beforeChopper, mcrotrcurved_guide_18_beforeChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_18_beforeChopper (without coords transformations) */
  mcJumpTrace_curved_guide_18_beforeChopper:
  SIG_MESSAGE("curved_guide_18_beforeChopper (Trace)");
  mcDEBUG_COMP("curved_guide_18_beforeChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_18_beforeChopper
  STORE_NEUTRON(44,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[44]++;
  mcPCounter[44] += p;
  mcP2Counter[44] += p*p;
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
{   /* Declarations of curved_guide_18_beforeChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_18_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_18_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_18_beforeChopper_h2;
MCNUM l = mcccurved_guide_18_beforeChopper_l;
MCNUM R0 = mcccurved_guide_18_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_18_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_18_beforeChopper_alpha;
MCNUM m = mcccurved_guide_18_beforeChopper_m;
MCNUM W = mcccurved_guide_18_beforeChopper_W;
MCNUM nslit = mcccurved_guide_18_beforeChopper_nslit;
MCNUM d = mcccurved_guide_18_beforeChopper_d;
MCNUM mleft = mcccurved_guide_18_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_18_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_18_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_18_beforeChopper_G;
MCNUM aleft = mcccurved_guide_18_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_18_beforeChopper_aright;
MCNUM atop = mcccurved_guide_18_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_18_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_18_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_18_beforeChopper_nu;
MCNUM phase = mcccurved_guide_18_beforeChopper_phase;
char* reflect = mcccurved_guide_18_beforeChopper_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 55110 "BIFROST.c"
}   /* End of curved_guide_18_beforeChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_18_beforeChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(44,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monBeforeFOC2 [45] */
  mccoordschange(mcposrL_monBeforeFOC2, mcrotrL_monBeforeFOC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monBeforeFOC2 (without coords transformations) */
  mcJumpTrace_L_monBeforeFOC2:
  SIG_MESSAGE("L_monBeforeFOC2 (Trace)");
  mcDEBUG_COMP("L_monBeforeFOC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monBeforeFOC2
  STORE_NEUTRON(45,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[45]++;
  mcPCounter[45] += p;
  mcP2Counter[45] += p*p;
#define mccompcurname  L_monBeforeFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 45
#define nL mccL_monBeforeFOC2_nL
#define L_N mccL_monBeforeFOC2_L_N
#define L_p mccL_monBeforeFOC2_L_p
#define L_p2 mccL_monBeforeFOC2_L_p2
{   /* Declarations of L_monBeforeFOC2=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeFOC2_filename;
MCNUM xmin = mccL_monBeforeFOC2_xmin;
MCNUM xmax = mccL_monBeforeFOC2_xmax;
MCNUM ymin = mccL_monBeforeFOC2_ymin;
MCNUM ymax = mccL_monBeforeFOC2_ymax;
MCNUM xwidth = mccL_monBeforeFOC2_xwidth;
MCNUM yheight = mccL_monBeforeFOC2_yheight;
MCNUM Lmin = mccL_monBeforeFOC2_Lmin;
MCNUM Lmax = mccL_monBeforeFOC2_Lmax;
MCNUM restore_neutron = mccL_monBeforeFOC2_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55254 "BIFROST.c"
}   /* End of L_monBeforeFOC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monBeforeFOC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(45,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFBeforeFOC2 [46] */
  mccoordschange(mcposrToFBeforeFOC2, mcrotrToFBeforeFOC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFBeforeFOC2 (without coords transformations) */
  mcJumpTrace_ToFBeforeFOC2:
  SIG_MESSAGE("ToFBeforeFOC2 (Trace)");
  mcDEBUG_COMP("ToFBeforeFOC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFBeforeFOC2
  STORE_NEUTRON(46,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[46]++;
  mcPCounter[46] += p;
  mcP2Counter[46] += p*p;
#define mccompcurname  ToFBeforeFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccToFBeforeFOC2_nt
#define TOF_N mccToFBeforeFOC2_TOF_N
#define TOF_p mccToFBeforeFOC2_TOF_p
#define TOF_p2 mccToFBeforeFOC2_TOF_p2
#define t_min mccToFBeforeFOC2_t_min
#define t_max mccToFBeforeFOC2_t_max
#define delta_t mccToFBeforeFOC2_delta_t
{   /* Declarations of ToFBeforeFOC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeFOC2_filename;
MCNUM xmin = mccToFBeforeFOC2_xmin;
MCNUM xmax = mccToFBeforeFOC2_xmax;
MCNUM ymin = mccToFBeforeFOC2_ymin;
MCNUM ymax = mccToFBeforeFOC2_ymax;
MCNUM xwidth = mccToFBeforeFOC2_xwidth;
MCNUM yheight = mccToFBeforeFOC2_yheight;
MCNUM tmin = mccToFBeforeFOC2_tmin;
MCNUM tmax = mccToFBeforeFOC2_tmax;
MCNUM dt = mccToFBeforeFOC2_dt;
MCNUM restore_neutron = mccToFBeforeFOC2_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55401 "BIFROST.c"
}   /* End of ToFBeforeFOC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFBeforeFOC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(46,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_beforeFOC2 [47] */
  mccoordschange(mcposrPSD_beforeFOC2, mcrotrPSD_beforeFOC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_beforeFOC2 (without coords transformations) */
  mcJumpTrace_PSD_beforeFOC2:
  SIG_MESSAGE("PSD_beforeFOC2 (Trace)");
  mcDEBUG_COMP("PSD_beforeFOC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_beforeFOC2
  STORE_NEUTRON(47,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[47]++;
  mcPCounter[47] += p;
  mcP2Counter[47] += p*p;
#define mccompcurname  PSD_beforeFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 47
#define nx mccPSD_beforeFOC2_nx
#define ny mccPSD_beforeFOC2_ny
#define PSD_N mccPSD_beforeFOC2_PSD_N
#define PSD_p mccPSD_beforeFOC2_PSD_p
#define PSD_p2 mccPSD_beforeFOC2_PSD_p2
{   /* Declarations of PSD_beforeFOC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforeFOC2_filename;
MCNUM xmin = mccPSD_beforeFOC2_xmin;
MCNUM xmax = mccPSD_beforeFOC2_xmax;
MCNUM ymin = mccPSD_beforeFOC2_ymin;
MCNUM ymax = mccPSD_beforeFOC2_ymax;
MCNUM xwidth = mccPSD_beforeFOC2_xwidth;
MCNUM yheight = mccPSD_beforeFOC2_yheight;
MCNUM restore_neutron = mccPSD_beforeFOC2_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55545 "BIFROST.c"
}   /* End of PSD_beforeFOC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_beforeFOC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(47,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component FOC2 [48] */
  mccoordschange(mcposrFOC2, mcrotrFOC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component FOC2 (without coords transformations) */
  mcJumpTrace_FOC2:
  SIG_MESSAGE("FOC2 (Trace)");
  mcDEBUG_COMP("FOC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompFOC2
  STORE_NEUTRON(48,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[48]++;
  mcPCounter[48] += p;
  mcP2Counter[48] += p*p;
#define mccompcurname  FOC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 48
#define Tg mccFOC2_Tg
#define To mccFOC2_To
#define delta_y mccFOC2_delta_y
#define height mccFOC2_height
#define omega mccFOC2_omega
{   /* Declarations of FOC2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccFOC2_theta_0;
MCNUM radius = mccFOC2_radius;
MCNUM yheight = mccFOC2_yheight;
MCNUM nu = mccFOC2_nu;
MCNUM nslit = mccFOC2_nslit;
MCNUM jitter = mccFOC2_jitter;
MCNUM delay = mccFOC2_delay;
MCNUM isfirst = mccFOC2_isfirst;
MCNUM n_pulse = mccFOC2_n_pulse;
MCNUM abs_out = mccFOC2_abs_out;
MCNUM phase = mccFOC2_phase;
MCNUM xwidth = mccFOC2_xwidth;
MCNUM verbose = mccFOC2_verbose;
#line 130 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 55708 "BIFROST.c"
}   /* End of FOC2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompFOC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(48,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_afterFOC2 [49] */
  mccoordschange(mcposrPSD_afterFOC2, mcrotrPSD_afterFOC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_afterFOC2 (without coords transformations) */
  mcJumpTrace_PSD_afterFOC2:
  SIG_MESSAGE("PSD_afterFOC2 (Trace)");
  mcDEBUG_COMP("PSD_afterFOC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_afterFOC2
  STORE_NEUTRON(49,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[49]++;
  mcPCounter[49] += p;
  mcP2Counter[49] += p*p;
#define mccompcurname  PSD_afterFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccPSD_afterFOC2_nx
#define ny mccPSD_afterFOC2_ny
#define PSD_N mccPSD_afterFOC2_PSD_N
#define PSD_p mccPSD_afterFOC2_PSD_p
#define PSD_p2 mccPSD_afterFOC2_PSD_p2
{   /* Declarations of PSD_afterFOC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_afterFOC2_filename;
MCNUM xmin = mccPSD_afterFOC2_xmin;
MCNUM xmax = mccPSD_afterFOC2_xmax;
MCNUM ymin = mccPSD_afterFOC2_ymin;
MCNUM ymax = mccPSD_afterFOC2_ymax;
MCNUM xwidth = mccPSD_afterFOC2_xwidth;
MCNUM yheight = mccPSD_afterFOC2_yheight;
MCNUM restore_neutron = mccPSD_afterFOC2_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55850 "BIFROST.c"
}   /* End of PSD_afterFOC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_afterFOC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(49,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFAfterFOC2 [50] */
  mccoordschange(mcposrToFAfterFOC2, mcrotrToFAfterFOC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFAfterFOC2 (without coords transformations) */
  mcJumpTrace_ToFAfterFOC2:
  SIG_MESSAGE("ToFAfterFOC2 (Trace)");
  mcDEBUG_COMP("ToFAfterFOC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFAfterFOC2
  STORE_NEUTRON(50,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[50]++;
  mcPCounter[50] += p;
  mcP2Counter[50] += p*p;
#define mccompcurname  ToFAfterFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 50
#define nt mccToFAfterFOC2_nt
#define TOF_N mccToFAfterFOC2_TOF_N
#define TOF_p mccToFAfterFOC2_TOF_p
#define TOF_p2 mccToFAfterFOC2_TOF_p2
#define t_min mccToFAfterFOC2_t_min
#define t_max mccToFAfterFOC2_t_max
#define delta_t mccToFAfterFOC2_delta_t
{   /* Declarations of ToFAfterFOC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterFOC2_filename;
MCNUM xmin = mccToFAfterFOC2_xmin;
MCNUM xmax = mccToFAfterFOC2_xmax;
MCNUM ymin = mccToFAfterFOC2_ymin;
MCNUM ymax = mccToFAfterFOC2_ymax;
MCNUM xwidth = mccToFAfterFOC2_xwidth;
MCNUM yheight = mccToFAfterFOC2_yheight;
MCNUM tmin = mccToFAfterFOC2_tmin;
MCNUM tmax = mccToFAfterFOC2_tmax;
MCNUM dt = mccToFAfterFOC2_dt;
MCNUM restore_neutron = mccToFAfterFOC2_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55998 "BIFROST.c"
}   /* End of ToFAfterFOC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFAfterFOC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(50,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monAfterFOC2 [51] */
  mccoordschange(mcposrL_monAfterFOC2, mcrotrL_monAfterFOC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monAfterFOC2 (without coords transformations) */
  mcJumpTrace_L_monAfterFOC2:
  SIG_MESSAGE("L_monAfterFOC2 (Trace)");
  mcDEBUG_COMP("L_monAfterFOC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monAfterFOC2
  STORE_NEUTRON(51,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[51]++;
  mcPCounter[51] += p;
  mcP2Counter[51] += p*p;
#define mccompcurname  L_monAfterFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mccL_monAfterFOC2_nL
#define L_N mccL_monAfterFOC2_L_N
#define L_p mccL_monAfterFOC2_L_p
#define L_p2 mccL_monAfterFOC2_L_p2
{   /* Declarations of L_monAfterFOC2=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterFOC2_filename;
MCNUM xmin = mccL_monAfterFOC2_xmin;
MCNUM xmax = mccL_monAfterFOC2_xmax;
MCNUM ymin = mccL_monAfterFOC2_ymin;
MCNUM ymax = mccL_monAfterFOC2_ymax;
MCNUM xwidth = mccL_monAfterFOC2_xwidth;
MCNUM yheight = mccL_monAfterFOC2_yheight;
MCNUM Lmin = mccL_monAfterFOC2_Lmin;
MCNUM Lmax = mccL_monAfterFOC2_Lmax;
MCNUM restore_neutron = mccL_monAfterFOC2_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 56147 "BIFROST.c"
}   /* End of L_monAfterFOC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monAfterFOC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(51,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_18_afterChopper [52] */
  mccoordschange(mcposrcurved_guide_18_afterChopper, mcrotrcurved_guide_18_afterChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_18_afterChopper (without coords transformations) */
  mcJumpTrace_curved_guide_18_afterChopper:
  SIG_MESSAGE("curved_guide_18_afterChopper (Trace)");
  mcDEBUG_COMP("curved_guide_18_afterChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_18_afterChopper
  STORE_NEUTRON(52,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[52]++;
  mcPCounter[52] += p;
  mcP2Counter[52] += p*p;
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
{   /* Declarations of curved_guide_18_afterChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_afterChopper_w1;
MCNUM h1 = mcccurved_guide_18_afterChopper_h1;
MCNUM w2 = mcccurved_guide_18_afterChopper_w2;
MCNUM h2 = mcccurved_guide_18_afterChopper_h2;
MCNUM l = mcccurved_guide_18_afterChopper_l;
MCNUM R0 = mcccurved_guide_18_afterChopper_R0;
MCNUM Qc = mcccurved_guide_18_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_18_afterChopper_alpha;
MCNUM m = mcccurved_guide_18_afterChopper_m;
MCNUM W = mcccurved_guide_18_afterChopper_W;
MCNUM nslit = mcccurved_guide_18_afterChopper_nslit;
MCNUM d = mcccurved_guide_18_afterChopper_d;
MCNUM mleft = mcccurved_guide_18_afterChopper_mleft;
MCNUM mright = mcccurved_guide_18_afterChopper_mright;
MCNUM mtop = mcccurved_guide_18_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_afterChopper_nhslit;
MCNUM G = mcccurved_guide_18_afterChopper_G;
MCNUM aleft = mcccurved_guide_18_afterChopper_aleft;
MCNUM aright = mcccurved_guide_18_afterChopper_aright;
MCNUM atop = mcccurved_guide_18_afterChopper_atop;
MCNUM abottom = mcccurved_guide_18_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_18_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_afterChopper_nelements;
MCNUM nu = mcccurved_guide_18_afterChopper_nu;
MCNUM phase = mcccurved_guide_18_afterChopper_phase;
char* reflect = mcccurved_guide_18_afterChopper_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56462 "BIFROST.c"
}   /* End of curved_guide_18_afterChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_18_afterChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(52,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_19_0 [53] */
  mccoordschange(mcposrcurved_guide_19_0, mcrotrcurved_guide_19_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_19_0 (without coords transformations) */
  mcJumpTrace_curved_guide_19_0:
  SIG_MESSAGE("curved_guide_19_0 (Trace)");
  mcDEBUG_COMP("curved_guide_19_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_19_0
  STORE_NEUTRON(53,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[53]++;
  mcPCounter[53] += p;
  mcP2Counter[53] += p*p;
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
{   /* Declarations of curved_guide_19_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_19_0_w1;
MCNUM h1 = mcccurved_guide_19_0_h1;
MCNUM w2 = mcccurved_guide_19_0_w2;
MCNUM h2 = mcccurved_guide_19_0_h2;
MCNUM l = mcccurved_guide_19_0_l;
MCNUM R0 = mcccurved_guide_19_0_R0;
MCNUM Qc = mcccurved_guide_19_0_Qc;
MCNUM alpha = mcccurved_guide_19_0_alpha;
MCNUM m = mcccurved_guide_19_0_m;
MCNUM W = mcccurved_guide_19_0_W;
MCNUM nslit = mcccurved_guide_19_0_nslit;
MCNUM d = mcccurved_guide_19_0_d;
MCNUM mleft = mcccurved_guide_19_0_mleft;
MCNUM mright = mcccurved_guide_19_0_mright;
MCNUM mtop = mcccurved_guide_19_0_mtop;
MCNUM mbottom = mcccurved_guide_19_0_mbottom;
MCNUM nhslit = mcccurved_guide_19_0_nhslit;
MCNUM G = mcccurved_guide_19_0_G;
MCNUM aleft = mcccurved_guide_19_0_aleft;
MCNUM aright = mcccurved_guide_19_0_aright;
MCNUM atop = mcccurved_guide_19_0_atop;
MCNUM abottom = mcccurved_guide_19_0_abottom;
MCNUM wavy = mcccurved_guide_19_0_wavy;
MCNUM wavy_z = mcccurved_guide_19_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_19_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_19_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_19_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_19_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_19_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_19_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_19_0_nelements;
MCNUM nu = mcccurved_guide_19_0_nu;
MCNUM phase = mcccurved_guide_19_0_phase;
char* reflect = mcccurved_guide_19_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56775 "BIFROST.c"
}   /* End of curved_guide_19_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_19_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(53,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_20_0 [54] */
  mccoordschange(mcposrcurved_guide_20_0, mcrotrcurved_guide_20_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_20_0 (without coords transformations) */
  mcJumpTrace_curved_guide_20_0:
  SIG_MESSAGE("curved_guide_20_0 (Trace)");
  mcDEBUG_COMP("curved_guide_20_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_20_0
  STORE_NEUTRON(54,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[54]++;
  mcPCounter[54] += p;
  mcP2Counter[54] += p*p;
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
{   /* Declarations of curved_guide_20_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_20_0_w1;
MCNUM h1 = mcccurved_guide_20_0_h1;
MCNUM w2 = mcccurved_guide_20_0_w2;
MCNUM h2 = mcccurved_guide_20_0_h2;
MCNUM l = mcccurved_guide_20_0_l;
MCNUM R0 = mcccurved_guide_20_0_R0;
MCNUM Qc = mcccurved_guide_20_0_Qc;
MCNUM alpha = mcccurved_guide_20_0_alpha;
MCNUM m = mcccurved_guide_20_0_m;
MCNUM W = mcccurved_guide_20_0_W;
MCNUM nslit = mcccurved_guide_20_0_nslit;
MCNUM d = mcccurved_guide_20_0_d;
MCNUM mleft = mcccurved_guide_20_0_mleft;
MCNUM mright = mcccurved_guide_20_0_mright;
MCNUM mtop = mcccurved_guide_20_0_mtop;
MCNUM mbottom = mcccurved_guide_20_0_mbottom;
MCNUM nhslit = mcccurved_guide_20_0_nhslit;
MCNUM G = mcccurved_guide_20_0_G;
MCNUM aleft = mcccurved_guide_20_0_aleft;
MCNUM aright = mcccurved_guide_20_0_aright;
MCNUM atop = mcccurved_guide_20_0_atop;
MCNUM abottom = mcccurved_guide_20_0_abottom;
MCNUM wavy = mcccurved_guide_20_0_wavy;
MCNUM wavy_z = mcccurved_guide_20_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_20_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_20_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_20_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_20_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_20_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_20_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_20_0_nelements;
MCNUM nu = mcccurved_guide_20_0_nu;
MCNUM phase = mcccurved_guide_20_0_phase;
char* reflect = mcccurved_guide_20_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57088 "BIFROST.c"
}   /* End of curved_guide_20_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_20_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_21_0 [55] */
  mccoordschange(mcposrcurved_guide_21_0, mcrotrcurved_guide_21_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_21_0 (without coords transformations) */
  mcJumpTrace_curved_guide_21_0:
  SIG_MESSAGE("curved_guide_21_0 (Trace)");
  mcDEBUG_COMP("curved_guide_21_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_21_0
  STORE_NEUTRON(55,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[55]++;
  mcPCounter[55] += p;
  mcP2Counter[55] += p*p;
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
{   /* Declarations of curved_guide_21_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_21_0_w1;
MCNUM h1 = mcccurved_guide_21_0_h1;
MCNUM w2 = mcccurved_guide_21_0_w2;
MCNUM h2 = mcccurved_guide_21_0_h2;
MCNUM l = mcccurved_guide_21_0_l;
MCNUM R0 = mcccurved_guide_21_0_R0;
MCNUM Qc = mcccurved_guide_21_0_Qc;
MCNUM alpha = mcccurved_guide_21_0_alpha;
MCNUM m = mcccurved_guide_21_0_m;
MCNUM W = mcccurved_guide_21_0_W;
MCNUM nslit = mcccurved_guide_21_0_nslit;
MCNUM d = mcccurved_guide_21_0_d;
MCNUM mleft = mcccurved_guide_21_0_mleft;
MCNUM mright = mcccurved_guide_21_0_mright;
MCNUM mtop = mcccurved_guide_21_0_mtop;
MCNUM mbottom = mcccurved_guide_21_0_mbottom;
MCNUM nhslit = mcccurved_guide_21_0_nhslit;
MCNUM G = mcccurved_guide_21_0_G;
MCNUM aleft = mcccurved_guide_21_0_aleft;
MCNUM aright = mcccurved_guide_21_0_aright;
MCNUM atop = mcccurved_guide_21_0_atop;
MCNUM abottom = mcccurved_guide_21_0_abottom;
MCNUM wavy = mcccurved_guide_21_0_wavy;
MCNUM wavy_z = mcccurved_guide_21_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_21_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_21_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_21_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_21_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_21_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_21_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_21_0_nelements;
MCNUM nu = mcccurved_guide_21_0_nu;
MCNUM phase = mcccurved_guide_21_0_phase;
char* reflect = mcccurved_guide_21_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57401 "BIFROST.c"
}   /* End of curved_guide_21_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_21_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(55,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_22_0 [56] */
  mccoordschange(mcposrcurved_guide_22_0, mcrotrcurved_guide_22_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_22_0 (without coords transformations) */
  mcJumpTrace_curved_guide_22_0:
  SIG_MESSAGE("curved_guide_22_0 (Trace)");
  mcDEBUG_COMP("curved_guide_22_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_22_0
  STORE_NEUTRON(56,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[56]++;
  mcPCounter[56] += p;
  mcP2Counter[56] += p*p;
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
{   /* Declarations of curved_guide_22_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_22_0_w1;
MCNUM h1 = mcccurved_guide_22_0_h1;
MCNUM w2 = mcccurved_guide_22_0_w2;
MCNUM h2 = mcccurved_guide_22_0_h2;
MCNUM l = mcccurved_guide_22_0_l;
MCNUM R0 = mcccurved_guide_22_0_R0;
MCNUM Qc = mcccurved_guide_22_0_Qc;
MCNUM alpha = mcccurved_guide_22_0_alpha;
MCNUM m = mcccurved_guide_22_0_m;
MCNUM W = mcccurved_guide_22_0_W;
MCNUM nslit = mcccurved_guide_22_0_nslit;
MCNUM d = mcccurved_guide_22_0_d;
MCNUM mleft = mcccurved_guide_22_0_mleft;
MCNUM mright = mcccurved_guide_22_0_mright;
MCNUM mtop = mcccurved_guide_22_0_mtop;
MCNUM mbottom = mcccurved_guide_22_0_mbottom;
MCNUM nhslit = mcccurved_guide_22_0_nhslit;
MCNUM G = mcccurved_guide_22_0_G;
MCNUM aleft = mcccurved_guide_22_0_aleft;
MCNUM aright = mcccurved_guide_22_0_aright;
MCNUM atop = mcccurved_guide_22_0_atop;
MCNUM abottom = mcccurved_guide_22_0_abottom;
MCNUM wavy = mcccurved_guide_22_0_wavy;
MCNUM wavy_z = mcccurved_guide_22_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_22_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_22_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_22_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_22_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_22_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_22_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_22_0_nelements;
MCNUM nu = mcccurved_guide_22_0_nu;
MCNUM phase = mcccurved_guide_22_0_phase;
char* reflect = mcccurved_guide_22_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57714 "BIFROST.c"
}   /* End of curved_guide_22_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_22_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(56,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_23_0 [57] */
  mccoordschange(mcposrcurved_guide_23_0, mcrotrcurved_guide_23_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_23_0 (without coords transformations) */
  mcJumpTrace_curved_guide_23_0:
  SIG_MESSAGE("curved_guide_23_0 (Trace)");
  mcDEBUG_COMP("curved_guide_23_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_23_0
  STORE_NEUTRON(57,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[57]++;
  mcPCounter[57] += p;
  mcP2Counter[57] += p*p;
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
{   /* Declarations of curved_guide_23_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_23_0_w1;
MCNUM h1 = mcccurved_guide_23_0_h1;
MCNUM w2 = mcccurved_guide_23_0_w2;
MCNUM h2 = mcccurved_guide_23_0_h2;
MCNUM l = mcccurved_guide_23_0_l;
MCNUM R0 = mcccurved_guide_23_0_R0;
MCNUM Qc = mcccurved_guide_23_0_Qc;
MCNUM alpha = mcccurved_guide_23_0_alpha;
MCNUM m = mcccurved_guide_23_0_m;
MCNUM W = mcccurved_guide_23_0_W;
MCNUM nslit = mcccurved_guide_23_0_nslit;
MCNUM d = mcccurved_guide_23_0_d;
MCNUM mleft = mcccurved_guide_23_0_mleft;
MCNUM mright = mcccurved_guide_23_0_mright;
MCNUM mtop = mcccurved_guide_23_0_mtop;
MCNUM mbottom = mcccurved_guide_23_0_mbottom;
MCNUM nhslit = mcccurved_guide_23_0_nhslit;
MCNUM G = mcccurved_guide_23_0_G;
MCNUM aleft = mcccurved_guide_23_0_aleft;
MCNUM aright = mcccurved_guide_23_0_aright;
MCNUM atop = mcccurved_guide_23_0_atop;
MCNUM abottom = mcccurved_guide_23_0_abottom;
MCNUM wavy = mcccurved_guide_23_0_wavy;
MCNUM wavy_z = mcccurved_guide_23_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_23_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_23_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_23_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_23_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_23_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_23_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_23_0_nelements;
MCNUM nu = mcccurved_guide_23_0_nu;
MCNUM phase = mcccurved_guide_23_0_phase;
char* reflect = mcccurved_guide_23_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 58027 "BIFROST.c"
}   /* End of curved_guide_23_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_23_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(57,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_24_0 [58] */
  mccoordschange(mcposrcurved_guide_24_0, mcrotrcurved_guide_24_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_24_0 (without coords transformations) */
  mcJumpTrace_curved_guide_24_0:
  SIG_MESSAGE("curved_guide_24_0 (Trace)");
  mcDEBUG_COMP("curved_guide_24_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_24_0
  STORE_NEUTRON(58,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[58]++;
  mcPCounter[58] += p;
  mcP2Counter[58] += p*p;
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
{   /* Declarations of curved_guide_24_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_24_0_w1;
MCNUM h1 = mcccurved_guide_24_0_h1;
MCNUM w2 = mcccurved_guide_24_0_w2;
MCNUM h2 = mcccurved_guide_24_0_h2;
MCNUM l = mcccurved_guide_24_0_l;
MCNUM R0 = mcccurved_guide_24_0_R0;
MCNUM Qc = mcccurved_guide_24_0_Qc;
MCNUM alpha = mcccurved_guide_24_0_alpha;
MCNUM m = mcccurved_guide_24_0_m;
MCNUM W = mcccurved_guide_24_0_W;
MCNUM nslit = mcccurved_guide_24_0_nslit;
MCNUM d = mcccurved_guide_24_0_d;
MCNUM mleft = mcccurved_guide_24_0_mleft;
MCNUM mright = mcccurved_guide_24_0_mright;
MCNUM mtop = mcccurved_guide_24_0_mtop;
MCNUM mbottom = mcccurved_guide_24_0_mbottom;
MCNUM nhslit = mcccurved_guide_24_0_nhslit;
MCNUM G = mcccurved_guide_24_0_G;
MCNUM aleft = mcccurved_guide_24_0_aleft;
MCNUM aright = mcccurved_guide_24_0_aright;
MCNUM atop = mcccurved_guide_24_0_atop;
MCNUM abottom = mcccurved_guide_24_0_abottom;
MCNUM wavy = mcccurved_guide_24_0_wavy;
MCNUM wavy_z = mcccurved_guide_24_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_24_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_24_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_24_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_24_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_24_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_24_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_24_0_nelements;
MCNUM nu = mcccurved_guide_24_0_nu;
MCNUM phase = mcccurved_guide_24_0_phase;
char* reflect = mcccurved_guide_24_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 58340 "BIFROST.c"
}   /* End of curved_guide_24_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_24_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(58,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_25_0 [59] */
  mccoordschange(mcposrcurved_guide_25_0, mcrotrcurved_guide_25_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_25_0 (without coords transformations) */
  mcJumpTrace_curved_guide_25_0:
  SIG_MESSAGE("curved_guide_25_0 (Trace)");
  mcDEBUG_COMP("curved_guide_25_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_25_0
  STORE_NEUTRON(59,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[59]++;
  mcPCounter[59] += p;
  mcP2Counter[59] += p*p;
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
{   /* Declarations of curved_guide_25_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_25_0_w1;
MCNUM h1 = mcccurved_guide_25_0_h1;
MCNUM w2 = mcccurved_guide_25_0_w2;
MCNUM h2 = mcccurved_guide_25_0_h2;
MCNUM l = mcccurved_guide_25_0_l;
MCNUM R0 = mcccurved_guide_25_0_R0;
MCNUM Qc = mcccurved_guide_25_0_Qc;
MCNUM alpha = mcccurved_guide_25_0_alpha;
MCNUM m = mcccurved_guide_25_0_m;
MCNUM W = mcccurved_guide_25_0_W;
MCNUM nslit = mcccurved_guide_25_0_nslit;
MCNUM d = mcccurved_guide_25_0_d;
MCNUM mleft = mcccurved_guide_25_0_mleft;
MCNUM mright = mcccurved_guide_25_0_mright;
MCNUM mtop = mcccurved_guide_25_0_mtop;
MCNUM mbottom = mcccurved_guide_25_0_mbottom;
MCNUM nhslit = mcccurved_guide_25_0_nhslit;
MCNUM G = mcccurved_guide_25_0_G;
MCNUM aleft = mcccurved_guide_25_0_aleft;
MCNUM aright = mcccurved_guide_25_0_aright;
MCNUM atop = mcccurved_guide_25_0_atop;
MCNUM abottom = mcccurved_guide_25_0_abottom;
MCNUM wavy = mcccurved_guide_25_0_wavy;
MCNUM wavy_z = mcccurved_guide_25_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_25_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_25_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_25_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_25_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_25_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_25_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_25_0_nelements;
MCNUM nu = mcccurved_guide_25_0_nu;
MCNUM phase = mcccurved_guide_25_0_phase;
char* reflect = mcccurved_guide_25_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 58653 "BIFROST.c"
}   /* End of curved_guide_25_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_25_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(59,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_26_0 [60] */
  mccoordschange(mcposrcurved_guide_26_0, mcrotrcurved_guide_26_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_26_0 (without coords transformations) */
  mcJumpTrace_curved_guide_26_0:
  SIG_MESSAGE("curved_guide_26_0 (Trace)");
  mcDEBUG_COMP("curved_guide_26_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_26_0
  STORE_NEUTRON(60,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[60]++;
  mcPCounter[60] += p;
  mcP2Counter[60] += p*p;
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 60
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
{   /* Declarations of curved_guide_26_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_26_0_w1;
MCNUM h1 = mcccurved_guide_26_0_h1;
MCNUM w2 = mcccurved_guide_26_0_w2;
MCNUM h2 = mcccurved_guide_26_0_h2;
MCNUM l = mcccurved_guide_26_0_l;
MCNUM R0 = mcccurved_guide_26_0_R0;
MCNUM Qc = mcccurved_guide_26_0_Qc;
MCNUM alpha = mcccurved_guide_26_0_alpha;
MCNUM m = mcccurved_guide_26_0_m;
MCNUM W = mcccurved_guide_26_0_W;
MCNUM nslit = mcccurved_guide_26_0_nslit;
MCNUM d = mcccurved_guide_26_0_d;
MCNUM mleft = mcccurved_guide_26_0_mleft;
MCNUM mright = mcccurved_guide_26_0_mright;
MCNUM mtop = mcccurved_guide_26_0_mtop;
MCNUM mbottom = mcccurved_guide_26_0_mbottom;
MCNUM nhslit = mcccurved_guide_26_0_nhslit;
MCNUM G = mcccurved_guide_26_0_G;
MCNUM aleft = mcccurved_guide_26_0_aleft;
MCNUM aright = mcccurved_guide_26_0_aright;
MCNUM atop = mcccurved_guide_26_0_atop;
MCNUM abottom = mcccurved_guide_26_0_abottom;
MCNUM wavy = mcccurved_guide_26_0_wavy;
MCNUM wavy_z = mcccurved_guide_26_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_26_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_26_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_26_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_26_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_26_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_26_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_26_0_nelements;
MCNUM nu = mcccurved_guide_26_0_nu;
MCNUM phase = mcccurved_guide_26_0_phase;
char* reflect = mcccurved_guide_26_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 58966 "BIFROST.c"
}   /* End of curved_guide_26_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_26_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(60,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_27_0 [61] */
  mccoordschange(mcposrcurved_guide_27_0, mcrotrcurved_guide_27_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_27_0 (without coords transformations) */
  mcJumpTrace_curved_guide_27_0:
  SIG_MESSAGE("curved_guide_27_0 (Trace)");
  mcDEBUG_COMP("curved_guide_27_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_27_0
  STORE_NEUTRON(61,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[61]++;
  mcPCounter[61] += p;
  mcP2Counter[61] += p*p;
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 61
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
{   /* Declarations of curved_guide_27_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_27_0_w1;
MCNUM h1 = mcccurved_guide_27_0_h1;
MCNUM w2 = mcccurved_guide_27_0_w2;
MCNUM h2 = mcccurved_guide_27_0_h2;
MCNUM l = mcccurved_guide_27_0_l;
MCNUM R0 = mcccurved_guide_27_0_R0;
MCNUM Qc = mcccurved_guide_27_0_Qc;
MCNUM alpha = mcccurved_guide_27_0_alpha;
MCNUM m = mcccurved_guide_27_0_m;
MCNUM W = mcccurved_guide_27_0_W;
MCNUM nslit = mcccurved_guide_27_0_nslit;
MCNUM d = mcccurved_guide_27_0_d;
MCNUM mleft = mcccurved_guide_27_0_mleft;
MCNUM mright = mcccurved_guide_27_0_mright;
MCNUM mtop = mcccurved_guide_27_0_mtop;
MCNUM mbottom = mcccurved_guide_27_0_mbottom;
MCNUM nhslit = mcccurved_guide_27_0_nhslit;
MCNUM G = mcccurved_guide_27_0_G;
MCNUM aleft = mcccurved_guide_27_0_aleft;
MCNUM aright = mcccurved_guide_27_0_aright;
MCNUM atop = mcccurved_guide_27_0_atop;
MCNUM abottom = mcccurved_guide_27_0_abottom;
MCNUM wavy = mcccurved_guide_27_0_wavy;
MCNUM wavy_z = mcccurved_guide_27_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_27_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_27_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_27_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_27_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_27_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_27_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_27_0_nelements;
MCNUM nu = mcccurved_guide_27_0_nu;
MCNUM phase = mcccurved_guide_27_0_phase;
char* reflect = mcccurved_guide_27_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59279 "BIFROST.c"
}   /* End of curved_guide_27_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_27_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(61,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_28_0 [62] */
  mccoordschange(mcposrcurved_guide_28_0, mcrotrcurved_guide_28_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_28_0 (without coords transformations) */
  mcJumpTrace_curved_guide_28_0:
  SIG_MESSAGE("curved_guide_28_0 (Trace)");
  mcDEBUG_COMP("curved_guide_28_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_28_0
  STORE_NEUTRON(62,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[62]++;
  mcPCounter[62] += p;
  mcP2Counter[62] += p*p;
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 62
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
{   /* Declarations of curved_guide_28_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_28_0_w1;
MCNUM h1 = mcccurved_guide_28_0_h1;
MCNUM w2 = mcccurved_guide_28_0_w2;
MCNUM h2 = mcccurved_guide_28_0_h2;
MCNUM l = mcccurved_guide_28_0_l;
MCNUM R0 = mcccurved_guide_28_0_R0;
MCNUM Qc = mcccurved_guide_28_0_Qc;
MCNUM alpha = mcccurved_guide_28_0_alpha;
MCNUM m = mcccurved_guide_28_0_m;
MCNUM W = mcccurved_guide_28_0_W;
MCNUM nslit = mcccurved_guide_28_0_nslit;
MCNUM d = mcccurved_guide_28_0_d;
MCNUM mleft = mcccurved_guide_28_0_mleft;
MCNUM mright = mcccurved_guide_28_0_mright;
MCNUM mtop = mcccurved_guide_28_0_mtop;
MCNUM mbottom = mcccurved_guide_28_0_mbottom;
MCNUM nhslit = mcccurved_guide_28_0_nhslit;
MCNUM G = mcccurved_guide_28_0_G;
MCNUM aleft = mcccurved_guide_28_0_aleft;
MCNUM aright = mcccurved_guide_28_0_aright;
MCNUM atop = mcccurved_guide_28_0_atop;
MCNUM abottom = mcccurved_guide_28_0_abottom;
MCNUM wavy = mcccurved_guide_28_0_wavy;
MCNUM wavy_z = mcccurved_guide_28_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_28_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_28_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_28_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_28_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_28_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_28_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_28_0_nelements;
MCNUM nu = mcccurved_guide_28_0_nu;
MCNUM phase = mcccurved_guide_28_0_phase;
char* reflect = mcccurved_guide_28_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59592 "BIFROST.c"
}   /* End of curved_guide_28_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_28_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(62,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_29_0 [63] */
  mccoordschange(mcposrcurved_guide_29_0, mcrotrcurved_guide_29_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_29_0 (without coords transformations) */
  mcJumpTrace_curved_guide_29_0:
  SIG_MESSAGE("curved_guide_29_0 (Trace)");
  mcDEBUG_COMP("curved_guide_29_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_29_0
  STORE_NEUTRON(63,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[63]++;
  mcPCounter[63] += p;
  mcP2Counter[63] += p*p;
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 63
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
{   /* Declarations of curved_guide_29_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_29_0_w1;
MCNUM h1 = mcccurved_guide_29_0_h1;
MCNUM w2 = mcccurved_guide_29_0_w2;
MCNUM h2 = mcccurved_guide_29_0_h2;
MCNUM l = mcccurved_guide_29_0_l;
MCNUM R0 = mcccurved_guide_29_0_R0;
MCNUM Qc = mcccurved_guide_29_0_Qc;
MCNUM alpha = mcccurved_guide_29_0_alpha;
MCNUM m = mcccurved_guide_29_0_m;
MCNUM W = mcccurved_guide_29_0_W;
MCNUM nslit = mcccurved_guide_29_0_nslit;
MCNUM d = mcccurved_guide_29_0_d;
MCNUM mleft = mcccurved_guide_29_0_mleft;
MCNUM mright = mcccurved_guide_29_0_mright;
MCNUM mtop = mcccurved_guide_29_0_mtop;
MCNUM mbottom = mcccurved_guide_29_0_mbottom;
MCNUM nhslit = mcccurved_guide_29_0_nhslit;
MCNUM G = mcccurved_guide_29_0_G;
MCNUM aleft = mcccurved_guide_29_0_aleft;
MCNUM aright = mcccurved_guide_29_0_aright;
MCNUM atop = mcccurved_guide_29_0_atop;
MCNUM abottom = mcccurved_guide_29_0_abottom;
MCNUM wavy = mcccurved_guide_29_0_wavy;
MCNUM wavy_z = mcccurved_guide_29_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_29_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_29_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_29_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_29_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_29_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_29_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_29_0_nelements;
MCNUM nu = mcccurved_guide_29_0_nu;
MCNUM phase = mcccurved_guide_29_0_phase;
char* reflect = mcccurved_guide_29_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59905 "BIFROST.c"
}   /* End of curved_guide_29_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_29_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(63,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_30_0 [64] */
  mccoordschange(mcposrcurved_guide_30_0, mcrotrcurved_guide_30_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_30_0 (without coords transformations) */
  mcJumpTrace_curved_guide_30_0:
  SIG_MESSAGE("curved_guide_30_0 (Trace)");
  mcDEBUG_COMP("curved_guide_30_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_30_0
  STORE_NEUTRON(64,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[64]++;
  mcPCounter[64] += p;
  mcP2Counter[64] += p*p;
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
{   /* Declarations of curved_guide_30_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_30_0_w1;
MCNUM h1 = mcccurved_guide_30_0_h1;
MCNUM w2 = mcccurved_guide_30_0_w2;
MCNUM h2 = mcccurved_guide_30_0_h2;
MCNUM l = mcccurved_guide_30_0_l;
MCNUM R0 = mcccurved_guide_30_0_R0;
MCNUM Qc = mcccurved_guide_30_0_Qc;
MCNUM alpha = mcccurved_guide_30_0_alpha;
MCNUM m = mcccurved_guide_30_0_m;
MCNUM W = mcccurved_guide_30_0_W;
MCNUM nslit = mcccurved_guide_30_0_nslit;
MCNUM d = mcccurved_guide_30_0_d;
MCNUM mleft = mcccurved_guide_30_0_mleft;
MCNUM mright = mcccurved_guide_30_0_mright;
MCNUM mtop = mcccurved_guide_30_0_mtop;
MCNUM mbottom = mcccurved_guide_30_0_mbottom;
MCNUM nhslit = mcccurved_guide_30_0_nhslit;
MCNUM G = mcccurved_guide_30_0_G;
MCNUM aleft = mcccurved_guide_30_0_aleft;
MCNUM aright = mcccurved_guide_30_0_aright;
MCNUM atop = mcccurved_guide_30_0_atop;
MCNUM abottom = mcccurved_guide_30_0_abottom;
MCNUM wavy = mcccurved_guide_30_0_wavy;
MCNUM wavy_z = mcccurved_guide_30_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_30_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_30_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_30_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_30_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_30_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_30_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_30_0_nelements;
MCNUM nu = mcccurved_guide_30_0_nu;
MCNUM phase = mcccurved_guide_30_0_phase;
char* reflect = mcccurved_guide_30_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 60218 "BIFROST.c"
}   /* End of curved_guide_30_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_30_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(64,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_31_0 [65] */
  mccoordschange(mcposrcurved_guide_31_0, mcrotrcurved_guide_31_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_31_0 (without coords transformations) */
  mcJumpTrace_curved_guide_31_0:
  SIG_MESSAGE("curved_guide_31_0 (Trace)");
  mcDEBUG_COMP("curved_guide_31_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_31_0
  STORE_NEUTRON(65,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[65]++;
  mcPCounter[65] += p;
  mcP2Counter[65] += p*p;
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
{   /* Declarations of curved_guide_31_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_31_0_w1;
MCNUM h1 = mcccurved_guide_31_0_h1;
MCNUM w2 = mcccurved_guide_31_0_w2;
MCNUM h2 = mcccurved_guide_31_0_h2;
MCNUM l = mcccurved_guide_31_0_l;
MCNUM R0 = mcccurved_guide_31_0_R0;
MCNUM Qc = mcccurved_guide_31_0_Qc;
MCNUM alpha = mcccurved_guide_31_0_alpha;
MCNUM m = mcccurved_guide_31_0_m;
MCNUM W = mcccurved_guide_31_0_W;
MCNUM nslit = mcccurved_guide_31_0_nslit;
MCNUM d = mcccurved_guide_31_0_d;
MCNUM mleft = mcccurved_guide_31_0_mleft;
MCNUM mright = mcccurved_guide_31_0_mright;
MCNUM mtop = mcccurved_guide_31_0_mtop;
MCNUM mbottom = mcccurved_guide_31_0_mbottom;
MCNUM nhslit = mcccurved_guide_31_0_nhslit;
MCNUM G = mcccurved_guide_31_0_G;
MCNUM aleft = mcccurved_guide_31_0_aleft;
MCNUM aright = mcccurved_guide_31_0_aright;
MCNUM atop = mcccurved_guide_31_0_atop;
MCNUM abottom = mcccurved_guide_31_0_abottom;
MCNUM wavy = mcccurved_guide_31_0_wavy;
MCNUM wavy_z = mcccurved_guide_31_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_31_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_31_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_31_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_31_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_31_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_31_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_31_0_nelements;
MCNUM nu = mcccurved_guide_31_0_nu;
MCNUM phase = mcccurved_guide_31_0_phase;
char* reflect = mcccurved_guide_31_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 60531 "BIFROST.c"
}   /* End of curved_guide_31_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_31_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(65,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_32_0 [66] */
  mccoordschange(mcposrcurved_guide_32_0, mcrotrcurved_guide_32_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_32_0 (without coords transformations) */
  mcJumpTrace_curved_guide_32_0:
  SIG_MESSAGE("curved_guide_32_0 (Trace)");
  mcDEBUG_COMP("curved_guide_32_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_32_0
  STORE_NEUTRON(66,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[66]++;
  mcPCounter[66] += p;
  mcP2Counter[66] += p*p;
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
{   /* Declarations of curved_guide_32_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_32_0_w1;
MCNUM h1 = mcccurved_guide_32_0_h1;
MCNUM w2 = mcccurved_guide_32_0_w2;
MCNUM h2 = mcccurved_guide_32_0_h2;
MCNUM l = mcccurved_guide_32_0_l;
MCNUM R0 = mcccurved_guide_32_0_R0;
MCNUM Qc = mcccurved_guide_32_0_Qc;
MCNUM alpha = mcccurved_guide_32_0_alpha;
MCNUM m = mcccurved_guide_32_0_m;
MCNUM W = mcccurved_guide_32_0_W;
MCNUM nslit = mcccurved_guide_32_0_nslit;
MCNUM d = mcccurved_guide_32_0_d;
MCNUM mleft = mcccurved_guide_32_0_mleft;
MCNUM mright = mcccurved_guide_32_0_mright;
MCNUM mtop = mcccurved_guide_32_0_mtop;
MCNUM mbottom = mcccurved_guide_32_0_mbottom;
MCNUM nhslit = mcccurved_guide_32_0_nhslit;
MCNUM G = mcccurved_guide_32_0_G;
MCNUM aleft = mcccurved_guide_32_0_aleft;
MCNUM aright = mcccurved_guide_32_0_aright;
MCNUM atop = mcccurved_guide_32_0_atop;
MCNUM abottom = mcccurved_guide_32_0_abottom;
MCNUM wavy = mcccurved_guide_32_0_wavy;
MCNUM wavy_z = mcccurved_guide_32_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_32_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_32_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_32_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_32_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_32_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_32_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_32_0_nelements;
MCNUM nu = mcccurved_guide_32_0_nu;
MCNUM phase = mcccurved_guide_32_0_phase;
char* reflect = mcccurved_guide_32_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 60844 "BIFROST.c"
}   /* End of curved_guide_32_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_32_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(66,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_33_0 [67] */
  mccoordschange(mcposrcurved_guide_33_0, mcrotrcurved_guide_33_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_33_0 (without coords transformations) */
  mcJumpTrace_curved_guide_33_0:
  SIG_MESSAGE("curved_guide_33_0 (Trace)");
  mcDEBUG_COMP("curved_guide_33_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_33_0
  STORE_NEUTRON(67,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[67]++;
  mcPCounter[67] += p;
  mcP2Counter[67] += p*p;
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
{   /* Declarations of curved_guide_33_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_33_0_w1;
MCNUM h1 = mcccurved_guide_33_0_h1;
MCNUM w2 = mcccurved_guide_33_0_w2;
MCNUM h2 = mcccurved_guide_33_0_h2;
MCNUM l = mcccurved_guide_33_0_l;
MCNUM R0 = mcccurved_guide_33_0_R0;
MCNUM Qc = mcccurved_guide_33_0_Qc;
MCNUM alpha = mcccurved_guide_33_0_alpha;
MCNUM m = mcccurved_guide_33_0_m;
MCNUM W = mcccurved_guide_33_0_W;
MCNUM nslit = mcccurved_guide_33_0_nslit;
MCNUM d = mcccurved_guide_33_0_d;
MCNUM mleft = mcccurved_guide_33_0_mleft;
MCNUM mright = mcccurved_guide_33_0_mright;
MCNUM mtop = mcccurved_guide_33_0_mtop;
MCNUM mbottom = mcccurved_guide_33_0_mbottom;
MCNUM nhslit = mcccurved_guide_33_0_nhslit;
MCNUM G = mcccurved_guide_33_0_G;
MCNUM aleft = mcccurved_guide_33_0_aleft;
MCNUM aright = mcccurved_guide_33_0_aright;
MCNUM atop = mcccurved_guide_33_0_atop;
MCNUM abottom = mcccurved_guide_33_0_abottom;
MCNUM wavy = mcccurved_guide_33_0_wavy;
MCNUM wavy_z = mcccurved_guide_33_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_33_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_33_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_33_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_33_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_33_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_33_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_33_0_nelements;
MCNUM nu = mcccurved_guide_33_0_nu;
MCNUM phase = mcccurved_guide_33_0_phase;
char* reflect = mcccurved_guide_33_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 61157 "BIFROST.c"
}   /* End of curved_guide_33_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_33_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(67,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_34_0 [68] */
  mccoordschange(mcposrcurved_guide_34_0, mcrotrcurved_guide_34_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_34_0 (without coords transformations) */
  mcJumpTrace_curved_guide_34_0:
  SIG_MESSAGE("curved_guide_34_0 (Trace)");
  mcDEBUG_COMP("curved_guide_34_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_34_0
  STORE_NEUTRON(68,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[68]++;
  mcPCounter[68] += p;
  mcP2Counter[68] += p*p;
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
{   /* Declarations of curved_guide_34_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_34_0_w1;
MCNUM h1 = mcccurved_guide_34_0_h1;
MCNUM w2 = mcccurved_guide_34_0_w2;
MCNUM h2 = mcccurved_guide_34_0_h2;
MCNUM l = mcccurved_guide_34_0_l;
MCNUM R0 = mcccurved_guide_34_0_R0;
MCNUM Qc = mcccurved_guide_34_0_Qc;
MCNUM alpha = mcccurved_guide_34_0_alpha;
MCNUM m = mcccurved_guide_34_0_m;
MCNUM W = mcccurved_guide_34_0_W;
MCNUM nslit = mcccurved_guide_34_0_nslit;
MCNUM d = mcccurved_guide_34_0_d;
MCNUM mleft = mcccurved_guide_34_0_mleft;
MCNUM mright = mcccurved_guide_34_0_mright;
MCNUM mtop = mcccurved_guide_34_0_mtop;
MCNUM mbottom = mcccurved_guide_34_0_mbottom;
MCNUM nhslit = mcccurved_guide_34_0_nhslit;
MCNUM G = mcccurved_guide_34_0_G;
MCNUM aleft = mcccurved_guide_34_0_aleft;
MCNUM aright = mcccurved_guide_34_0_aright;
MCNUM atop = mcccurved_guide_34_0_atop;
MCNUM abottom = mcccurved_guide_34_0_abottom;
MCNUM wavy = mcccurved_guide_34_0_wavy;
MCNUM wavy_z = mcccurved_guide_34_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_34_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_34_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_34_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_34_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_34_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_34_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_34_0_nelements;
MCNUM nu = mcccurved_guide_34_0_nu;
MCNUM phase = mcccurved_guide_34_0_phase;
char* reflect = mcccurved_guide_34_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 61470 "BIFROST.c"
}   /* End of curved_guide_34_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_34_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(68,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_35_0 [69] */
  mccoordschange(mcposrcurved_guide_35_0, mcrotrcurved_guide_35_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_35_0 (without coords transformations) */
  mcJumpTrace_curved_guide_35_0:
  SIG_MESSAGE("curved_guide_35_0 (Trace)");
  mcDEBUG_COMP("curved_guide_35_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_35_0
  STORE_NEUTRON(69,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[69]++;
  mcPCounter[69] += p;
  mcP2Counter[69] += p*p;
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 69
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
{   /* Declarations of curved_guide_35_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_35_0_w1;
MCNUM h1 = mcccurved_guide_35_0_h1;
MCNUM w2 = mcccurved_guide_35_0_w2;
MCNUM h2 = mcccurved_guide_35_0_h2;
MCNUM l = mcccurved_guide_35_0_l;
MCNUM R0 = mcccurved_guide_35_0_R0;
MCNUM Qc = mcccurved_guide_35_0_Qc;
MCNUM alpha = mcccurved_guide_35_0_alpha;
MCNUM m = mcccurved_guide_35_0_m;
MCNUM W = mcccurved_guide_35_0_W;
MCNUM nslit = mcccurved_guide_35_0_nslit;
MCNUM d = mcccurved_guide_35_0_d;
MCNUM mleft = mcccurved_guide_35_0_mleft;
MCNUM mright = mcccurved_guide_35_0_mright;
MCNUM mtop = mcccurved_guide_35_0_mtop;
MCNUM mbottom = mcccurved_guide_35_0_mbottom;
MCNUM nhslit = mcccurved_guide_35_0_nhslit;
MCNUM G = mcccurved_guide_35_0_G;
MCNUM aleft = mcccurved_guide_35_0_aleft;
MCNUM aright = mcccurved_guide_35_0_aright;
MCNUM atop = mcccurved_guide_35_0_atop;
MCNUM abottom = mcccurved_guide_35_0_abottom;
MCNUM wavy = mcccurved_guide_35_0_wavy;
MCNUM wavy_z = mcccurved_guide_35_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_35_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_35_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_35_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_35_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_35_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_35_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_35_0_nelements;
MCNUM nu = mcccurved_guide_35_0_nu;
MCNUM phase = mcccurved_guide_35_0_phase;
char* reflect = mcccurved_guide_35_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 61783 "BIFROST.c"
}   /* End of curved_guide_35_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_35_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(69,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_36_0 [70] */
  mccoordschange(mcposrcurved_guide_36_0, mcrotrcurved_guide_36_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_36_0 (without coords transformations) */
  mcJumpTrace_curved_guide_36_0:
  SIG_MESSAGE("curved_guide_36_0 (Trace)");
  mcDEBUG_COMP("curved_guide_36_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_36_0
  STORE_NEUTRON(70,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[70]++;
  mcPCounter[70] += p;
  mcP2Counter[70] += p*p;
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
{   /* Declarations of curved_guide_36_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_36_0_w1;
MCNUM h1 = mcccurved_guide_36_0_h1;
MCNUM w2 = mcccurved_guide_36_0_w2;
MCNUM h2 = mcccurved_guide_36_0_h2;
MCNUM l = mcccurved_guide_36_0_l;
MCNUM R0 = mcccurved_guide_36_0_R0;
MCNUM Qc = mcccurved_guide_36_0_Qc;
MCNUM alpha = mcccurved_guide_36_0_alpha;
MCNUM m = mcccurved_guide_36_0_m;
MCNUM W = mcccurved_guide_36_0_W;
MCNUM nslit = mcccurved_guide_36_0_nslit;
MCNUM d = mcccurved_guide_36_0_d;
MCNUM mleft = mcccurved_guide_36_0_mleft;
MCNUM mright = mcccurved_guide_36_0_mright;
MCNUM mtop = mcccurved_guide_36_0_mtop;
MCNUM mbottom = mcccurved_guide_36_0_mbottom;
MCNUM nhslit = mcccurved_guide_36_0_nhslit;
MCNUM G = mcccurved_guide_36_0_G;
MCNUM aleft = mcccurved_guide_36_0_aleft;
MCNUM aright = mcccurved_guide_36_0_aright;
MCNUM atop = mcccurved_guide_36_0_atop;
MCNUM abottom = mcccurved_guide_36_0_abottom;
MCNUM wavy = mcccurved_guide_36_0_wavy;
MCNUM wavy_z = mcccurved_guide_36_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_36_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_36_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_36_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_36_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_36_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_36_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_36_0_nelements;
MCNUM nu = mcccurved_guide_36_0_nu;
MCNUM phase = mcccurved_guide_36_0_phase;
char* reflect = mcccurved_guide_36_0_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 62096 "BIFROST.c"
}   /* End of curved_guide_36_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_36_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(70,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_4 [71] */
  mccoordschange(mcposrEndOfelement_4, mcrotrEndOfelement_4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_4 (without coords transformations) */
  mcJumpTrace_EndOfelement_4:
  SIG_MESSAGE("EndOfelement_4 (Trace)");
  mcDEBUG_COMP("EndOfelement_4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_4
  STORE_NEUTRON(71,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[71]++;
  mcPCounter[71] += p;
  mcP2Counter[71] += p*p;
#define mccompcurname  EndOfelement_4
#define mccompcurtype  Arm
#define mccompcurindex 71
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(71,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity3 [72] */
  mccoordschange(mcposrelliptical_guide_gravity3, mcrotrelliptical_guide_gravity3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity3 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity3:
  SIG_MESSAGE("elliptical_guide_gravity3 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity3
  STORE_NEUTRON(72,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[72]++;
  mcPCounter[72] += p;
  mcP2Counter[72] += p*p;
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 72
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity3=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity3_l;
MCNUM xwidth = mccelliptical_guide_gravity3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity3_yheight;
MCNUM linxw = mccelliptical_guide_gravity3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity3_dimensionsAt;
char* option = mccelliptical_guide_gravity3_option;
MCNUM R0 = mccelliptical_guide_gravity3_R0;
MCNUM Qc = mccelliptical_guide_gravity3_Qc;
MCNUM alpha = mccelliptical_guide_gravity3_alpha;
MCNUM m = mccelliptical_guide_gravity3_m;
MCNUM W = mccelliptical_guide_gravity3_W;
MCNUM alpharight = mccelliptical_guide_gravity3_alpharight;
MCNUM mright = mccelliptical_guide_gravity3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity3_mbottom;
char* verbose = mccelliptical_guide_gravity3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity3_curvature;
#line 1420 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
  PROP_Z0;
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 )
		  ABSORB;


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		if(boolean == 0) ABSORB;
		if(timeToCollision < 1e-15) ABSORB;

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 62423 "BIFROST.c"
}   /* End of elliptical_guide_gravity3=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(72,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_3 [73] */
  mccoordschange(mcposrEndOfelement_3, mcrotrEndOfelement_3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_3 (without coords transformations) */
  mcJumpTrace_EndOfelement_3:
  SIG_MESSAGE("EndOfelement_3 (Trace)");
  mcDEBUG_COMP("EndOfelement_3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_3
  STORE_NEUTRON(73,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[73]++;
  mcPCounter[73] += p;
  mcP2Counter[73] += p*p;
#define mccompcurname  EndOfelement_3
#define mccompcurtype  Arm
#define mccompcurindex 73
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(73,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component straight_guide_2_1 [74] */
  mccoordschange(mcposrstraight_guide_2_1, mcrotrstraight_guide_2_1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component straight_guide_2_1 (without coords transformations) */
  mcJumpTrace_straight_guide_2_1:
  SIG_MESSAGE("straight_guide_2_1 (Trace)");
  mcDEBUG_COMP("straight_guide_2_1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompstraight_guide_2_1
  STORE_NEUTRON(74,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[74]++;
  mcPCounter[74] += p;
  mcP2Counter[74] += p*p;
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
{   /* Declarations of straight_guide_2_1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_1_w1;
MCNUM h1 = mccstraight_guide_2_1_h1;
MCNUM w2 = mccstraight_guide_2_1_w2;
MCNUM h2 = mccstraight_guide_2_1_h2;
MCNUM l = mccstraight_guide_2_1_l;
MCNUM R0 = mccstraight_guide_2_1_R0;
MCNUM Qc = mccstraight_guide_2_1_Qc;
MCNUM alpha = mccstraight_guide_2_1_alpha;
MCNUM m = mccstraight_guide_2_1_m;
MCNUM W = mccstraight_guide_2_1_W;
MCNUM nslit = mccstraight_guide_2_1_nslit;
MCNUM d = mccstraight_guide_2_1_d;
MCNUM mleft = mccstraight_guide_2_1_mleft;
MCNUM mright = mccstraight_guide_2_1_mright;
MCNUM mtop = mccstraight_guide_2_1_mtop;
MCNUM mbottom = mccstraight_guide_2_1_mbottom;
MCNUM nhslit = mccstraight_guide_2_1_nhslit;
MCNUM G = mccstraight_guide_2_1_G;
MCNUM aleft = mccstraight_guide_2_1_aleft;
MCNUM aright = mccstraight_guide_2_1_aright;
MCNUM atop = mccstraight_guide_2_1_atop;
MCNUM abottom = mccstraight_guide_2_1_abottom;
MCNUM wavy = mccstraight_guide_2_1_wavy;
MCNUM wavy_z = mccstraight_guide_2_1_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_1_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_1_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_1_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_1_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_1_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_1_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_1_nelements;
MCNUM nu = mccstraight_guide_2_1_nu;
MCNUM phase = mccstraight_guide_2_1_phase;
char* reflect = mccstraight_guide_2_1_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 62852 "BIFROST.c"
}   /* End of straight_guide_2_1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompstraight_guide_2_1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(74,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monBeforeBWC [75] */
  mccoordschange(mcposrL_monBeforeBWC, mcrotrL_monBeforeBWC,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monBeforeBWC (without coords transformations) */
  mcJumpTrace_L_monBeforeBWC:
  SIG_MESSAGE("L_monBeforeBWC (Trace)");
  mcDEBUG_COMP("L_monBeforeBWC")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monBeforeBWC
  STORE_NEUTRON(75,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[75]++;
  mcPCounter[75] += p;
  mcP2Counter[75] += p*p;
#define mccompcurname  L_monBeforeBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 75
#define nL mccL_monBeforeBWC_nL
#define L_N mccL_monBeforeBWC_L_N
#define L_p mccL_monBeforeBWC_L_p
#define L_p2 mccL_monBeforeBWC_L_p2
{   /* Declarations of L_monBeforeBWC=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeBWC_filename;
MCNUM xmin = mccL_monBeforeBWC_xmin;
MCNUM xmax = mccL_monBeforeBWC_xmax;
MCNUM ymin = mccL_monBeforeBWC_ymin;
MCNUM ymax = mccL_monBeforeBWC_ymax;
MCNUM xwidth = mccL_monBeforeBWC_xwidth;
MCNUM yheight = mccL_monBeforeBWC_yheight;
MCNUM Lmin = mccL_monBeforeBWC_Lmin;
MCNUM Lmax = mccL_monBeforeBWC_Lmax;
MCNUM restore_neutron = mccL_monBeforeBWC_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 62996 "BIFROST.c"
}   /* End of L_monBeforeBWC=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monBeforeBWC:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFBeforeBWC [76] */
  mccoordschange(mcposrToFBeforeBWC, mcrotrToFBeforeBWC,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFBeforeBWC (without coords transformations) */
  mcJumpTrace_ToFBeforeBWC:
  SIG_MESSAGE("ToFBeforeBWC (Trace)");
  mcDEBUG_COMP("ToFBeforeBWC")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFBeforeBWC
  STORE_NEUTRON(76,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[76]++;
  mcPCounter[76] += p;
  mcP2Counter[76] += p*p;
#define mccompcurname  ToFBeforeBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 76
#define nt mccToFBeforeBWC_nt
#define TOF_N mccToFBeforeBWC_TOF_N
#define TOF_p mccToFBeforeBWC_TOF_p
#define TOF_p2 mccToFBeforeBWC_TOF_p2
#define t_min mccToFBeforeBWC_t_min
#define t_max mccToFBeforeBWC_t_max
#define delta_t mccToFBeforeBWC_delta_t
{   /* Declarations of ToFBeforeBWC=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeBWC_filename;
MCNUM xmin = mccToFBeforeBWC_xmin;
MCNUM xmax = mccToFBeforeBWC_xmax;
MCNUM ymin = mccToFBeforeBWC_ymin;
MCNUM ymax = mccToFBeforeBWC_ymax;
MCNUM xwidth = mccToFBeforeBWC_xwidth;
MCNUM yheight = mccToFBeforeBWC_yheight;
MCNUM tmin = mccToFBeforeBWC_tmin;
MCNUM tmax = mccToFBeforeBWC_tmax;
MCNUM dt = mccToFBeforeBWC_dt;
MCNUM restore_neutron = mccToFBeforeBWC_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63143 "BIFROST.c"
}   /* End of ToFBeforeBWC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFBeforeBWC:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(76,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BWC1 [77] */
  mccoordschange(mcposrBWC1, mcrotrBWC1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BWC1 (without coords transformations) */
  mcJumpTrace_BWC1:
  SIG_MESSAGE("BWC1 (Trace)");
  mcDEBUG_COMP("BWC1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBWC1
  STORE_NEUTRON(77,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[77]++;
  mcPCounter[77] += p;
  mcP2Counter[77] += p*p;
#define mccompcurname  BWC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 77
#define Tg mccBWC1_Tg
#define To mccBWC1_To
#define delta_y mccBWC1_delta_y
#define height mccBWC1_height
#define omega mccBWC1_omega
{   /* Declarations of BWC1=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccBWC1_theta_0;
MCNUM radius = mccBWC1_radius;
MCNUM yheight = mccBWC1_yheight;
MCNUM nu = mccBWC1_nu;
MCNUM nslit = mccBWC1_nslit;
MCNUM jitter = mccBWC1_jitter;
MCNUM delay = mccBWC1_delay;
MCNUM isfirst = mccBWC1_isfirst;
MCNUM n_pulse = mccBWC1_n_pulse;
MCNUM abs_out = mccBWC1_abs_out;
MCNUM phase = mccBWC1_phase;
MCNUM xwidth = mccBWC1_xwidth;
MCNUM verbose = mccBWC1_verbose;
#line 130 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 63308 "BIFROST.c"
}   /* End of BWC1=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBWC1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(77,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component BWC2 [78] */
  mccoordschange(mcposrBWC2, mcrotrBWC2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component BWC2 (without coords transformations) */
  mcJumpTrace_BWC2:
  SIG_MESSAGE("BWC2 (Trace)");
  mcDEBUG_COMP("BWC2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBWC2
  STORE_NEUTRON(78,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[78]++;
  mcPCounter[78] += p;
  mcP2Counter[78] += p*p;
#define mccompcurname  BWC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 78
#define Tg mccBWC2_Tg
#define To mccBWC2_To
#define delta_y mccBWC2_delta_y
#define height mccBWC2_height
#define omega mccBWC2_omega
{   /* Declarations of BWC2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccBWC2_theta_0;
MCNUM radius = mccBWC2_radius;
MCNUM yheight = mccBWC2_yheight;
MCNUM nu = mccBWC2_nu;
MCNUM nslit = mccBWC2_nslit;
MCNUM jitter = mccBWC2_jitter;
MCNUM delay = mccBWC2_delay;
MCNUM isfirst = mccBWC2_isfirst;
MCNUM n_pulse = mccBWC2_n_pulse;
MCNUM abs_out = mccBWC2_abs_out;
MCNUM phase = mccBWC2_phase;
MCNUM xwidth = mccBWC2_xwidth;
MCNUM verbose = mccBWC2_verbose;
#line 130 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 63471 "BIFROST.c"
}   /* End of BWC2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBWC2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(78,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ToFAfterBWC [79] */
  mccoordschange(mcposrToFAfterBWC, mcrotrToFAfterBWC,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ToFAfterBWC (without coords transformations) */
  mcJumpTrace_ToFAfterBWC:
  SIG_MESSAGE("ToFAfterBWC (Trace)");
  mcDEBUG_COMP("ToFAfterBWC")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompToFAfterBWC
  STORE_NEUTRON(79,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[79]++;
  mcPCounter[79] += p;
  mcP2Counter[79] += p*p;
#define mccompcurname  ToFAfterBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 79
#define nt mccToFAfterBWC_nt
#define TOF_N mccToFAfterBWC_TOF_N
#define TOF_p mccToFAfterBWC_TOF_p
#define TOF_p2 mccToFAfterBWC_TOF_p2
#define t_min mccToFAfterBWC_t_min
#define t_max mccToFAfterBWC_t_max
#define delta_t mccToFAfterBWC_delta_t
{   /* Declarations of ToFAfterBWC=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterBWC_filename;
MCNUM xmin = mccToFAfterBWC_xmin;
MCNUM xmax = mccToFAfterBWC_xmax;
MCNUM ymin = mccToFAfterBWC_ymin;
MCNUM ymax = mccToFAfterBWC_ymax;
MCNUM xwidth = mccToFAfterBWC_xwidth;
MCNUM yheight = mccToFAfterBWC_yheight;
MCNUM tmin = mccToFAfterBWC_tmin;
MCNUM tmax = mccToFAfterBWC_tmax;
MCNUM dt = mccToFAfterBWC_dt;
MCNUM restore_neutron = mccToFAfterBWC_restore_neutron;
#line 94 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63619 "BIFROST.c"
}   /* End of ToFAfterBWC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompToFAfterBWC:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(79,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component L_monAfterBWC [80] */
  mccoordschange(mcposrL_monAfterBWC, mcrotrL_monAfterBWC,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component L_monAfterBWC (without coords transformations) */
  mcJumpTrace_L_monAfterBWC:
  SIG_MESSAGE("L_monAfterBWC (Trace)");
  mcDEBUG_COMP("L_monAfterBWC")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompL_monAfterBWC
  STORE_NEUTRON(80,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[80]++;
  mcPCounter[80] += p;
  mcP2Counter[80] += p*p;
#define mccompcurname  L_monAfterBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 80
#define nL mccL_monAfterBWC_nL
#define L_N mccL_monAfterBWC_L_N
#define L_p mccL_monAfterBWC_L_p
#define L_p2 mccL_monAfterBWC_L_p2
{   /* Declarations of L_monAfterBWC=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterBWC_filename;
MCNUM xmin = mccL_monAfterBWC_xmin;
MCNUM xmax = mccL_monAfterBWC_xmax;
MCNUM ymin = mccL_monAfterBWC_ymin;
MCNUM ymax = mccL_monAfterBWC_ymax;
MCNUM xwidth = mccL_monAfterBWC_xwidth;
MCNUM yheight = mccL_monAfterBWC_yheight;
MCNUM Lmin = mccL_monAfterBWC_Lmin;
MCNUM Lmax = mccL_monAfterBWC_Lmax;
MCNUM restore_neutron = mccL_monAfterBWC_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63768 "BIFROST.c"
}   /* End of L_monAfterBWC=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompL_monAfterBWC:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(80,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component straight_guide_2_2 [81] */
  mccoordschange(mcposrstraight_guide_2_2, mcrotrstraight_guide_2_2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component straight_guide_2_2 (without coords transformations) */
  mcJumpTrace_straight_guide_2_2:
  SIG_MESSAGE("straight_guide_2_2 (Trace)");
  mcDEBUG_COMP("straight_guide_2_2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompstraight_guide_2_2
  STORE_NEUTRON(81,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[81]++;
  mcPCounter[81] += p;
  mcP2Counter[81] += p*p;
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 81
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
{   /* Declarations of straight_guide_2_2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_2_w1;
MCNUM h1 = mccstraight_guide_2_2_h1;
MCNUM w2 = mccstraight_guide_2_2_w2;
MCNUM h2 = mccstraight_guide_2_2_h2;
MCNUM l = mccstraight_guide_2_2_l;
MCNUM R0 = mccstraight_guide_2_2_R0;
MCNUM Qc = mccstraight_guide_2_2_Qc;
MCNUM alpha = mccstraight_guide_2_2_alpha;
MCNUM m = mccstraight_guide_2_2_m;
MCNUM W = mccstraight_guide_2_2_W;
MCNUM nslit = mccstraight_guide_2_2_nslit;
MCNUM d = mccstraight_guide_2_2_d;
MCNUM mleft = mccstraight_guide_2_2_mleft;
MCNUM mright = mccstraight_guide_2_2_mright;
MCNUM mtop = mccstraight_guide_2_2_mtop;
MCNUM mbottom = mccstraight_guide_2_2_mbottom;
MCNUM nhslit = mccstraight_guide_2_2_nhslit;
MCNUM G = mccstraight_guide_2_2_G;
MCNUM aleft = mccstraight_guide_2_2_aleft;
MCNUM aright = mccstraight_guide_2_2_aright;
MCNUM atop = mccstraight_guide_2_2_atop;
MCNUM abottom = mccstraight_guide_2_2_abottom;
MCNUM wavy = mccstraight_guide_2_2_wavy;
MCNUM wavy_z = mccstraight_guide_2_2_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_2_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_2_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_2_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_2_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_2_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_2_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_2_nelements;
MCNUM nu = mccstraight_guide_2_2_nu;
MCNUM phase = mccstraight_guide_2_2_phase;
char* reflect = mccstraight_guide_2_2_reflect;
#line 393 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 64083 "BIFROST.c"
}   /* End of straight_guide_2_2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompstraight_guide_2_2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(81,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_2 [82] */
  mccoordschange(mcposrEndOfelement_2, mcrotrEndOfelement_2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_2 (without coords transformations) */
  mcJumpTrace_EndOfelement_2:
  SIG_MESSAGE("EndOfelement_2 (Trace)");
  mcDEBUG_COMP("EndOfelement_2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_2
  STORE_NEUTRON(82,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[82]++;
  mcPCounter[82] += p;
  mcP2Counter[82] += p*p;
#define mccompcurname  EndOfelement_2
#define mccompcurtype  Arm
#define mccompcurindex 82
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(82,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_1 [83] */
  mccoordschange(mcposrelliptical_guide_gravity1_1, mcrotrelliptical_guide_gravity1_1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_1 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_1:
  SIG_MESSAGE("elliptical_guide_gravity1_1 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_1
  STORE_NEUTRON(83,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[83]++;
  mcPCounter[83] += p;
  mcP2Counter[83] += p*p;
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 83
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_1=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_1_l;
MCNUM xwidth = mccelliptical_guide_gravity1_1_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_1_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_1_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_1_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_1_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_1_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_1_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_1_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_1_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_1_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_1_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_1_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_1_dimensionsAt;
char* option = mccelliptical_guide_gravity1_1_option;
MCNUM R0 = mccelliptical_guide_gravity1_1_R0;
MCNUM Qc = mccelliptical_guide_gravity1_1_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_1_alpha;
MCNUM m = mccelliptical_guide_gravity1_1_m;
MCNUM W = mccelliptical_guide_gravity1_1_W;
MCNUM alpharight = mccelliptical_guide_gravity1_1_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_1_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_1_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_1_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_1_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_1_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_1_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_1_mbottom;
char* verbose = mccelliptical_guide_gravity1_1_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_1_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_1_curvature;
#line 1420 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
  PROP_Z0;
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 )
		  ABSORB;


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		if(boolean == 0) ABSORB;
		if(timeToCollision < 1e-15) ABSORB;

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 64410 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_1=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(83,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw3 [84] */
  mccoordschange(mcposrDiwJaw3, mcrotrDiwJaw3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw3 (without coords transformations) */
  mcJumpTrace_DiwJaw3:
  SIG_MESSAGE("DiwJaw3 (Trace)");
  mcDEBUG_COMP("DiwJaw3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw3
  STORE_NEUTRON(84,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[84]++;
  mcPCounter[84] += p;
  mcP2Counter[84] += p*p;
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 84
{   /* Declarations of DiwJaw3=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw3_xmin;
MCNUM xmax = mccDiwJaw3_xmax;
MCNUM ymin = mccDiwJaw3_ymin;
MCNUM ymax = mccDiwJaw3_ymax;
MCNUM radius = mccDiwJaw3_radius;
MCNUM xwidth = mccDiwJaw3_xwidth;
MCNUM yheight = mccDiwJaw3_yheight;
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 64547 "BIFROST.c"
}   /* End of DiwJaw3=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(84,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_2 [85] */
  mccoordschange(mcposrelliptical_guide_gravity1_2, mcrotrelliptical_guide_gravity1_2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_2 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_2:
  SIG_MESSAGE("elliptical_guide_gravity1_2 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_2
  STORE_NEUTRON(85,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[85]++;
  mcPCounter[85] += p;
  mcP2Counter[85] += p*p;
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 85
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_2=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_2_l;
MCNUM xwidth = mccelliptical_guide_gravity1_2_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_2_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_2_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_2_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_2_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_2_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_2_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_2_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_2_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_2_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_2_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_2_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_2_dimensionsAt;
char* option = mccelliptical_guide_gravity1_2_option;
MCNUM R0 = mccelliptical_guide_gravity1_2_R0;
MCNUM Qc = mccelliptical_guide_gravity1_2_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_2_alpha;
MCNUM m = mccelliptical_guide_gravity1_2_m;
MCNUM W = mccelliptical_guide_gravity1_2_W;
MCNUM alpharight = mccelliptical_guide_gravity1_2_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_2_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_2_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_2_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_2_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_2_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_2_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_2_mbottom;
char* verbose = mccelliptical_guide_gravity1_2_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_2_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_2_curvature;
#line 1420 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
  PROP_Z0;
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 )
		  ABSORB;


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		if(boolean == 0) ABSORB;
		if(timeToCollision < 1e-15) ABSORB;

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 64769 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_2=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(85,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw2 [86] */
  mccoordschange(mcposrDiwJaw2, mcrotrDiwJaw2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw2 (without coords transformations) */
  mcJumpTrace_DiwJaw2:
  SIG_MESSAGE("DiwJaw2 (Trace)");
  mcDEBUG_COMP("DiwJaw2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw2
  STORE_NEUTRON(86,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[86]++;
  mcPCounter[86] += p;
  mcP2Counter[86] += p*p;
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 86
{   /* Declarations of DiwJaw2=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw2_xmin;
MCNUM xmax = mccDiwJaw2_xmax;
MCNUM ymin = mccDiwJaw2_ymin;
MCNUM ymax = mccDiwJaw2_ymax;
MCNUM radius = mccDiwJaw2_radius;
MCNUM xwidth = mccDiwJaw2_xwidth;
MCNUM yheight = mccDiwJaw2_yheight;
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 64906 "BIFROST.c"
}   /* End of DiwJaw2=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(86,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_3 [87] */
  mccoordschange(mcposrelliptical_guide_gravity1_3, mcrotrelliptical_guide_gravity1_3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_3 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_3:
  SIG_MESSAGE("elliptical_guide_gravity1_3 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_3
  STORE_NEUTRON(87,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[87]++;
  mcPCounter[87] += p;
  mcP2Counter[87] += p*p;
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 87
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_3=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_3_l;
MCNUM xwidth = mccelliptical_guide_gravity1_3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_3_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_3_dimensionsAt;
char* option = mccelliptical_guide_gravity1_3_option;
MCNUM R0 = mccelliptical_guide_gravity1_3_R0;
MCNUM Qc = mccelliptical_guide_gravity1_3_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_3_alpha;
MCNUM m = mccelliptical_guide_gravity1_3_m;
MCNUM W = mccelliptical_guide_gravity1_3_W;
MCNUM alpharight = mccelliptical_guide_gravity1_3_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_3_mbottom;
char* verbose = mccelliptical_guide_gravity1_3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_3_curvature;
#line 1420 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
  PROP_Z0;
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 )
		  ABSORB;


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		if(boolean == 0) ABSORB;
		if(timeToCollision < 1e-15) ABSORB;

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 65128 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_3=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(87,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw1 [88] */
  mccoordschange(mcposrDiwJaw1, mcrotrDiwJaw1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw1 (without coords transformations) */
  mcJumpTrace_DiwJaw1:
  SIG_MESSAGE("DiwJaw1 (Trace)");
  mcDEBUG_COMP("DiwJaw1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw1
  STORE_NEUTRON(88,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[88]++;
  mcPCounter[88] += p;
  mcP2Counter[88] += p*p;
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 88
{   /* Declarations of DiwJaw1=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw1_xmin;
MCNUM xmax = mccDiwJaw1_xmax;
MCNUM ymin = mccDiwJaw1_ymin;
MCNUM ymax = mccDiwJaw1_ymax;
MCNUM radius = mccDiwJaw1_radius;
MCNUM xwidth = mccDiwJaw1_xwidth;
MCNUM yheight = mccDiwJaw1_yheight;
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 65265 "BIFROST.c"
}   /* End of DiwJaw1=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(88,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_4 [89] */
  mccoordschange(mcposrelliptical_guide_gravity1_4, mcrotrelliptical_guide_gravity1_4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_4 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_4:
  SIG_MESSAGE("elliptical_guide_gravity1_4 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_4
  STORE_NEUTRON(89,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[89]++;
  mcPCounter[89] += p;
  mcP2Counter[89] += p*p;
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 89
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_4=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_4_l;
MCNUM xwidth = mccelliptical_guide_gravity1_4_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_4_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_4_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_4_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_4_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_4_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_4_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_4_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_4_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_4_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_4_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_4_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_4_dimensionsAt;
char* option = mccelliptical_guide_gravity1_4_option;
MCNUM R0 = mccelliptical_guide_gravity1_4_R0;
MCNUM Qc = mccelliptical_guide_gravity1_4_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_4_alpha;
MCNUM m = mccelliptical_guide_gravity1_4_m;
MCNUM W = mccelliptical_guide_gravity1_4_W;
MCNUM alpharight = mccelliptical_guide_gravity1_4_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_4_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_4_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_4_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_4_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_4_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_4_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_4_mbottom;
char* verbose = mccelliptical_guide_gravity1_4_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_4_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_4_curvature;
#line 1420 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{
  PROP_Z0;
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 )
		  ABSORB;


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		if(boolean == 0) ABSORB;
		if(timeToCollision < 1e-15) ABSORB;

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 65487 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_4=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(89,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_1 [90] */
  mccoordschange(mcposrEndOfelement_1, mcrotrEndOfelement_1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_1 (without coords transformations) */
  mcJumpTrace_EndOfelement_1:
  SIG_MESSAGE("EndOfelement_1 (Trace)");
  mcDEBUG_COMP("EndOfelement_1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_1
  STORE_NEUTRON(90,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[90]++;
  mcPCounter[90] += p;
  mcP2Counter[90] += p*p;
#define mccompcurname  EndOfelement_1
#define mccompcurtype  Arm
#define mccompcurindex 90
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(90,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component VirtualOutput [91] */
  mccoordschange(mcposrVirtualOutput, mcrotrVirtualOutput,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component VirtualOutput (without coords transformations) */
  mcJumpTrace_VirtualOutput:
  SIG_MESSAGE("VirtualOutput (Trace)");
  mcDEBUG_COMP("VirtualOutput")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompVirtualOutput
  STORE_NEUTRON(91,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[91]++;
  mcPCounter[91] += p;
  mcP2Counter[91] += p*p;
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 91
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
/* 'VirtualOutput=Virtual_output()' component instance has conditional execution */
if (( mcipmakeVirtualSource == 1 ))

#line 116 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\Virtual_output.comp"
{
  double pp=0;

  /* PROP_Z0; */
  /* transfer current neutron to Monitor_nD vars */
  Vars.cp  = p;
  Vars.cx  = x;
  Vars.cvx = vx;
  Vars.csx = sx;
  Vars.cy  = y;
  Vars.cvy = vy;
  Vars.csy = sy;
  Vars.cz  = z;
  Vars.cvz = vz;
  Vars.csz = sz;
  Vars.ct  = t;

  pp = Monitor_nD_Trace(&DEFS, &Vars);

  SCATTER;
}
#line 65739 "BIFROST.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompVirtualOutput:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(91,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw0 [92] */
  mccoordschange(mcposrDiwJaw0, mcrotrDiwJaw0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw0 (without coords transformations) */
  mcJumpTrace_DiwJaw0:
  SIG_MESSAGE("DiwJaw0 (Trace)");
  mcDEBUG_COMP("DiwJaw0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw0
  STORE_NEUTRON(92,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[92]++;
  mcPCounter[92] += p;
  mcP2Counter[92] += p*p;
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 92
{   /* Declarations of DiwJaw0=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw0_xmin;
MCNUM xmax = mccDiwJaw0_xmax;
MCNUM ymin = mccDiwJaw0_ymin;
MCNUM ymax = mccDiwJaw0_ymax;
MCNUM radius = mccDiwJaw0_radius;
MCNUM xwidth = mccDiwJaw0_xwidth;
MCNUM yheight = mccDiwJaw0_yheight;
#line 56 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
    || ((radius != 0) && (x*x + y*y > radius*radius)))
      ABSORB;
    else
        SCATTER;
}
#line 65863 "BIFROST.c"
}   /* End of DiwJaw0=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(92,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Lmon_guide_end [93] */
  mccoordschange(mcposrLmon_guide_end, mcrotrLmon_guide_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Lmon_guide_end (without coords transformations) */
  mcJumpTrace_Lmon_guide_end:
  SIG_MESSAGE("Lmon_guide_end (Trace)");
  mcDEBUG_COMP("Lmon_guide_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompLmon_guide_end
  STORE_NEUTRON(93,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[93]++;
  mcPCounter[93] += p;
  mcP2Counter[93] += p*p;
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
{   /* Declarations of Lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mccLmon_guide_end_filename;
MCNUM xmin = mccLmon_guide_end_xmin;
MCNUM xmax = mccLmon_guide_end_xmax;
MCNUM ymin = mccLmon_guide_end_ymin;
MCNUM ymax = mccLmon_guide_end_ymax;
MCNUM xwidth = mccLmon_guide_end_xwidth;
MCNUM yheight = mccLmon_guide_end_yheight;
MCNUM Lmin = mccLmon_guide_end_Lmin;
MCNUM Lmax = mccLmon_guide_end_Lmax;
MCNUM restore_neutron = mccLmon_guide_end_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66005 "BIFROST.c"
}   /* End of Lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompLmon_guide_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(93,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Div2d_sample_B [94] */
  mccoordschange(mcposrDiv2d_sample_B, mcrotrDiv2d_sample_B,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Div2d_sample_B (without coords transformations) */
  mcJumpTrace_Div2d_sample_B:
  SIG_MESSAGE("Div2d_sample_B (Trace)");
  mcDEBUG_COMP("Div2d_sample_B")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiv2d_sample_B
  STORE_NEUTRON(94,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[94]++;
  mcPCounter[94] += p;
  mcP2Counter[94] += p*p;
#define mccompcurname  Div2d_sample_B
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 94
#define nh mccDiv2d_sample_B_nh
#define nv mccDiv2d_sample_B_nv
#define Div_N mccDiv2d_sample_B_Div_N
#define Div_p mccDiv2d_sample_B_Div_p
#define Div_p2 mccDiv2d_sample_B_Div_p2
{   /* Declarations of Div2d_sample_B=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_B_filename;
MCNUM xmin = mccDiv2d_sample_B_xmin;
MCNUM xmax = mccDiv2d_sample_B_xmax;
MCNUM ymin = mccDiv2d_sample_B_ymin;
MCNUM ymax = mccDiv2d_sample_B_ymax;
MCNUM xwidth = mccDiv2d_sample_B_xwidth;
MCNUM yheight = mccDiv2d_sample_B_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_B_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_B_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_B_restore_neutron;
MCNUM nx = mccDiv2d_sample_B_nx;
MCNUM ny = mccDiv2d_sample_B_ny;
MCNUM nz = mccDiv2d_sample_B_nz;
#line 88 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    int i,j;
    double h_div, v_div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      h_div = RAD2DEG*atan2(vx,vn);
      v_div = RAD2DEG*atan2(vy,vn);
      if (h_div < maxdiv_h && h_div > -maxdiv_h &&
          v_div < maxdiv_v && v_div > -maxdiv_v)
      {
        i = floor((h_div + maxdiv_h)*nh/(2.0*maxdiv_h));
        j = floor((v_div + maxdiv_v)*nv/(2.0*maxdiv_v));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66161 "BIFROST.c"
/* 'Div2d_sample_B=Divergence_monitor()' component instance extend code */
    SIG_MESSAGE("Div2d_sample_B (Trace:Extend)");
#line 1490 "BIFROST.instr"
    x_div = RAD2DEG*atan2(vx,vz);
    y_div = RAD2DEG*atan2(vy,vz);
    if (SCATTERED) flag=1; else flag=0;
#line 66168 "BIFROST.c"
}   /* End of Div2d_sample_B=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiv2d_sample_B:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(94,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Div2d_sample [95] */
  mccoordschange(mcposrDiv2d_sample, mcrotrDiv2d_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Div2d_sample (without coords transformations) */
  mcJumpTrace_Div2d_sample:
  SIG_MESSAGE("Div2d_sample (Trace)");
  mcDEBUG_COMP("Div2d_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiv2d_sample
  STORE_NEUTRON(95,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[95]++;
  mcPCounter[95] += p;
  mcP2Counter[95] += p*p;
#define mccompcurname  Div2d_sample
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 95
#define nh mccDiv2d_sample_nh
#define nv mccDiv2d_sample_nv
#define Div_N mccDiv2d_sample_Div_N
#define Div_p mccDiv2d_sample_Div_p
#define Div_p2 mccDiv2d_sample_Div_p2
{   /* Declarations of Div2d_sample=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_filename;
MCNUM xmin = mccDiv2d_sample_xmin;
MCNUM xmax = mccDiv2d_sample_xmax;
MCNUM ymin = mccDiv2d_sample_ymin;
MCNUM ymax = mccDiv2d_sample_ymax;
MCNUM xwidth = mccDiv2d_sample_xwidth;
MCNUM yheight = mccDiv2d_sample_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_restore_neutron;
MCNUM nx = mccDiv2d_sample_nx;
MCNUM ny = mccDiv2d_sample_ny;
MCNUM nz = mccDiv2d_sample_nz;
#line 88 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    int i,j;
    double h_div, v_div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      h_div = RAD2DEG*atan2(vx,vn);
      v_div = RAD2DEG*atan2(vy,vn);
      if (h_div < maxdiv_h && h_div > -maxdiv_h &&
          v_div < maxdiv_v && v_div > -maxdiv_v)
      {
        i = floor((h_div + maxdiv_h)*nh/(2.0*maxdiv_h));
        j = floor((v_div + maxdiv_v)*nv/(2.0*maxdiv_v));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66325 "BIFROST.c"
}   /* End of Div2d_sample=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiv2d_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(95,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_sample [96] */
  mccoordschange(mcposrPSD_sample, mcrotrPSD_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_sample (without coords transformations) */
  mcJumpTrace_PSD_sample:
  SIG_MESSAGE("PSD_sample (Trace)");
  mcDEBUG_COMP("PSD_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_sample
  STORE_NEUTRON(96,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[96]++;
  mcPCounter[96] += p;
  mcP2Counter[96] += p*p;
#define mccompcurname  PSD_sample
#define mccompcurtype  PSD_monitor
#define mccompcurindex 96
#define nx mccPSD_sample_nx
#define ny mccPSD_sample_ny
#define PSD_N mccPSD_sample_PSD_N
#define PSD_p mccPSD_sample_PSD_p
#define PSD_p2 mccPSD_sample_PSD_p2
{   /* Declarations of PSD_sample=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_sample_filename;
MCNUM xmin = mccPSD_sample_xmin;
MCNUM xmax = mccPSD_sample_xmax;
MCNUM ymin = mccPSD_sample_ymin;
MCNUM ymax = mccPSD_sample_ymax;
MCNUM xwidth = mccPSD_sample_xwidth;
MCNUM yheight = mccPSD_sample_yheight;
MCNUM restore_neutron = mccPSD_sample_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66467 "BIFROST.c"
}   /* End of PSD_sample=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(96,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component HPSD_sample [97] */
  mccoordschange(mcposrHPSD_sample, mcrotrHPSD_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component HPSD_sample (without coords transformations) */
  mcJumpTrace_HPSD_sample:
  SIG_MESSAGE("HPSD_sample (Trace)");
  mcDEBUG_COMP("HPSD_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompHPSD_sample
  STORE_NEUTRON(97,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[97]++;
  mcPCounter[97] += p;
  mcP2Counter[97] += p*p;
#define mccompcurname  HPSD_sample
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 97
#define nx mccHPSD_sample_nx
#define PSDlin_N mccHPSD_sample_PSDlin_N
#define PSDlin_p mccHPSD_sample_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_PSDlin_p2
{   /* Declarations of HPSD_sample=PSDlin_monitor() SETTING parameters. */
char* filename = mccHPSD_sample_filename;
MCNUM xmin = mccHPSD_sample_xmin;
MCNUM xmax = mccHPSD_sample_xmax;
MCNUM ymin = mccHPSD_sample_ymin;
MCNUM ymax = mccHPSD_sample_ymax;
MCNUM xwidth = mccHPSD_sample_xwidth;
MCNUM yheight = mccHPSD_sample_yheight;
MCNUM restore_neutron = mccHPSD_sample_restore_neutron;
#line 80 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor(nx*(x-xmin)/(xmax-xmin));              /* Bin number */
      if((i >= nx) || (i<0))
      {
        printf("FATAL ERROR: wrong positioning in linear PSD. i= %i \n",i);
        exit(1);
      }
      PSDlin_N[i]++;
      PSDlin_p[i] += p;
      PSDlin_p2[i] += p*p;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66611 "BIFROST.c"
}   /* End of HPSD_sample=PSDlin_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompHPSD_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(97,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component VPSD_sample [98] */
  mccoordschange(mcposrVPSD_sample, mcrotrVPSD_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component VPSD_sample (without coords transformations) */
  mcJumpTrace_VPSD_sample:
  SIG_MESSAGE("VPSD_sample (Trace)");
  mcDEBUG_COMP("VPSD_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompVPSD_sample
  STORE_NEUTRON(98,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[98]++;
  mcPCounter[98] += p;
  mcP2Counter[98] += p*p;
#define mccompcurname  VPSD_sample
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 98
#define ny mccVPSD_sample_ny
#define filename mccVPSD_sample_filename
#define PSDlin_N mccVPSD_sample_PSDlin_N
#define PSDlin_p mccVPSD_sample_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_PSDlin_p2
{   /* Declarations of VPSD_sample=PSDlin_y_monitor() SETTING parameters. */
MCNUM xmin = mccVPSD_sample_xmin;
MCNUM xmax = mccVPSD_sample_xmax;
MCNUM ymin = mccVPSD_sample_ymin;
MCNUM ymax = mccVPSD_sample_ymax;
MCNUM xwidth = mccVPSD_sample_xwidth;
MCNUM yheight = mccVPSD_sample_yheight;
MCNUM restore_neutron = mccVPSD_sample_restore_neutron;
#line 77 "PSDlin_y_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor(ny*(y-ymin)/(ymax-ymin));              /* Bin number */
      if((i >= ny) || (i<0))
      {
        printf("FATAL ERROR: wrong positioning in linear PSD. i= %i \n",i);
        exit(1);
      }
      PSDlin_N[i]++;
      PSDlin_p[i] += p;
      PSDlin_p2[i] += p*p;
    } 
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66754 "BIFROST.c"
}   /* End of VPSD_sample=PSDlin_y_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompVPSD_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(98,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Hdiv_sample [99] */
  mccoordschange(mcposrHdiv_sample, mcrotrHdiv_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Hdiv_sample (without coords transformations) */
  mcJumpTrace_Hdiv_sample:
  SIG_MESSAGE("Hdiv_sample (Trace)");
  mcDEBUG_COMP("Hdiv_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompHdiv_sample
  STORE_NEUTRON(99,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[99]++;
  mcPCounter[99] += p;
  mcP2Counter[99] += p*p;
#define mccompcurname  Hdiv_sample
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 99
#define nh mccHdiv_sample_nh
#define Div_N mccHdiv_sample_Div_N
#define Div_p mccHdiv_sample_Div_p
#define Div_p2 mccHdiv_sample_Div_p2
{   /* Declarations of Hdiv_sample=Hdiv_monitor() SETTING parameters. */
char* filename = mccHdiv_sample_filename;
MCNUM xmin = mccHdiv_sample_xmin;
MCNUM xmax = mccHdiv_sample_xmax;
MCNUM ymin = mccHdiv_sample_ymin;
MCNUM ymax = mccHdiv_sample_ymax;
MCNUM xwidth = mccHdiv_sample_xwidth;
MCNUM yheight = mccHdiv_sample_yheight;
MCNUM h_maxdiv = mccHdiv_sample_h_maxdiv;
MCNUM restore_neutron = mccHdiv_sample_restore_neutron;
#line 84 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
    int i;
    double h_div;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      h_div = RAD2DEG*atan2(vx,vz);
      if (h_div < (double)h_maxdiv && h_div > -(double)h_maxdiv)
      {
        i = floor((h_div + (double)h_maxdiv)*nh/(2.0*(double)h_maxdiv));
        Div_N[i]++;
        Div_p[i] += p;
        Div_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66900 "BIFROST.c"
}   /* End of Hdiv_sample=Hdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompHdiv_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(99,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Vdiv_sample [100] */
  mccoordschange(mcposrVdiv_sample, mcrotrVdiv_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Vdiv_sample (without coords transformations) */
  mcJumpTrace_Vdiv_sample:
  SIG_MESSAGE("Vdiv_sample (Trace)");
  mcDEBUG_COMP("Vdiv_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompVdiv_sample
  STORE_NEUTRON(100,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[100]++;
  mcPCounter[100] += p;
  mcP2Counter[100] += p*p;
#define mccompcurname  Vdiv_sample
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 100
#define nv mccVdiv_sample_nv
#define filename mccVdiv_sample_filename
#define restore_neutron mccVdiv_sample_restore_neutron
#define Div_N mccVdiv_sample_Div_N
#define Div_p mccVdiv_sample_Div_p
#define Div_p2 mccVdiv_sample_Div_p2
{   /* Declarations of Vdiv_sample=Vdiv_monitor() SETTING parameters. */
MCNUM xmin = mccVdiv_sample_xmin;
MCNUM xmax = mccVdiv_sample_xmax;
MCNUM ymin = mccVdiv_sample_ymin;
MCNUM ymax = mccVdiv_sample_ymax;
MCNUM xwidth = mccVdiv_sample_xwidth;
MCNUM yheight = mccVdiv_sample_yheight;
MCNUM v_maxdiv = mccVdiv_sample_v_maxdiv;
#line 87 "Vdiv_monitor.comp"
{
    int i;
    double v_div;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      v_div = RAD2DEG*atan2(vy,vz);
      if (v_div < (double)v_maxdiv && v_div > -(double)v_maxdiv)
      {
        i = floor((v_div + (double)v_maxdiv)*nv/(2.0*(double)v_maxdiv));
        Div_N[i]++;
        Div_p[i] += p;
        Div_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 67045 "BIFROST.c"
}   /* End of Vdiv_sample=Vdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompVdiv_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(100,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component acceptance_x_divx [101] */
  mccoordschange(mcposracceptance_x_divx, mcrotracceptance_x_divx,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component acceptance_x_divx (without coords transformations) */
  mcJumpTrace_acceptance_x_divx:
  SIG_MESSAGE("acceptance_x_divx (Trace)");
  mcDEBUG_COMP("acceptance_x_divx")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompacceptance_x_divx
  STORE_NEUTRON(101,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[101]++;
  mcPCounter[101] += p;
  mcP2Counter[101] += p*p;
#define mccompcurname  acceptance_x_divx
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 101
#define nh mccacceptance_x_divx_nh
#define ndiv mccacceptance_x_divx_ndiv
#define Div_N mccacceptance_x_divx_Div_N
#define Div_p mccacceptance_x_divx_Div_p
#define Div_p2 mccacceptance_x_divx_Div_p2
{   /* Declarations of acceptance_x_divx=DivPos_monitor() SETTING parameters. */
char* filename = mccacceptance_x_divx_filename;
MCNUM xmin = mccacceptance_x_divx_xmin;
MCNUM xmax = mccacceptance_x_divx_xmax;
MCNUM ymin = mccacceptance_x_divx_ymin;
MCNUM ymax = mccacceptance_x_divx_ymax;
MCNUM xwidth = mccacceptance_x_divx_xwidth;
MCNUM yheight = mccacceptance_x_divx_yheight;
MCNUM maxdiv_h = mccacceptance_x_divx_maxdiv_h;
MCNUM restore_neutron = mccacceptance_x_divx_restore_neutron;
MCNUM nx = mccacceptance_x_divx_nx;
MCNUM ny = mccacceptance_x_divx_ny;
MCNUM nz = mccacceptance_x_divx_nz;
#line 91 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
    int i,j;
    double div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      div = RAD2DEG*atan2(vx,vn);

      if (div < maxdiv_h && div > -maxdiv_h)
      {
        i = floor((x - xmin)*nh/(xmax - xmin));
        j = floor((div + maxdiv_h)*ndiv/(2.0*maxdiv_h));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 67201 "BIFROST.c"
}   /* End of acceptance_x_divx=DivPos_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompacceptance_x_divx:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(101,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component acceptance_y_divy [102] */
  mccoordschange(mcposracceptance_y_divy, mcrotracceptance_y_divy,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component acceptance_y_divy (without coords transformations) */
  mcJumpTrace_acceptance_y_divy:
  SIG_MESSAGE("acceptance_y_divy (Trace)");
  mcDEBUG_COMP("acceptance_y_divy")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompacceptance_y_divy
  STORE_NEUTRON(102,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[102]++;
  mcPCounter[102] += p;
  mcP2Counter[102] += p*p;
#define mccompcurname  acceptance_y_divy
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 102
#define npos mccacceptance_y_divy_npos
#define ndiv mccacceptance_y_divy_ndiv
#define filename mccacceptance_y_divy_filename
#define restore_neutron mccacceptance_y_divy_restore_neutron
#define Div_N mccacceptance_y_divy_Div_N
#define Div_p mccacceptance_y_divy_Div_p
#define Div_p2 mccacceptance_y_divy_Div_p2
{   /* Declarations of acceptance_y_divy=DivPos_y_monitor() SETTING parameters. */
MCNUM xmin = mccacceptance_y_divy_xmin;
MCNUM xmax = mccacceptance_y_divy_xmax;
MCNUM ymin = mccacceptance_y_divy_ymin;
MCNUM ymax = mccacceptance_y_divy_ymax;
MCNUM xwidth = mccacceptance_y_divy_xwidth;
MCNUM yheight = mccacceptance_y_divy_yheight;
MCNUM maxdiv = mccacceptance_y_divy_maxdiv;
#line 85 "DivPos_y_monitor.comp"
{
    int i,j;
    double div;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      div = RAD2DEG*atan2(vy,vz);
      if (div < maxdiv && div > -maxdiv)
      {
        i = floor((y - ymin)*npos/(ymax - ymin));
        j = floor((div + maxdiv)*ndiv/(2.0*maxdiv));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 67349 "BIFROST.c"
}   /* End of acceptance_y_divy=DivPos_y_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompacceptance_y_divy:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(102,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Lmon_sample_B [103] */
  mccoordschange(mcposrLmon_sample_B, mcrotrLmon_sample_B,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Lmon_sample_B (without coords transformations) */
  mcJumpTrace_Lmon_sample_B:
  SIG_MESSAGE("Lmon_sample_B (Trace)");
  mcDEBUG_COMP("Lmon_sample_B")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompLmon_sample_B
  STORE_NEUTRON(103,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[103]++;
  mcPCounter[103] += p;
  mcP2Counter[103] += p*p;
#define mccompcurname  Lmon_sample_B
#define mccompcurtype  L_monitor
#define mccompcurindex 103
#define nL mccLmon_sample_B_nL
#define L_N mccLmon_sample_B_L_N
#define L_p mccLmon_sample_B_L_p
#define L_p2 mccLmon_sample_B_L_p2
{   /* Declarations of Lmon_sample_B=L_monitor() SETTING parameters. */
char* filename = mccLmon_sample_B_filename;
MCNUM xmin = mccLmon_sample_B_xmin;
MCNUM xmax = mccLmon_sample_B_xmax;
MCNUM ymin = mccLmon_sample_B_ymin;
MCNUM ymax = mccLmon_sample_B_ymax;
MCNUM xwidth = mccLmon_sample_B_xwidth;
MCNUM yheight = mccLmon_sample_B_yheight;
MCNUM Lmin = mccLmon_sample_B_Lmin;
MCNUM Lmax = mccLmon_sample_B_Lmax;
MCNUM restore_neutron = mccLmon_sample_B_restore_neutron;
/* 'Lmon_sample_B=L_monitor()' component instance has conditional execution */
if (flag)

#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 67500 "BIFROST.c"
}   /* End of Lmon_sample_B=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompLmon_sample_B:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(103,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Div2d_sample_maxdiv [104] */
  mccoordschange(mcposrDiv2d_sample_maxdiv, mcrotrDiv2d_sample_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Div2d_sample_maxdiv (without coords transformations) */
  mcJumpTrace_Div2d_sample_maxdiv:
  SIG_MESSAGE("Div2d_sample_maxdiv (Trace)");
  mcDEBUG_COMP("Div2d_sample_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiv2d_sample_maxdiv
  STORE_NEUTRON(104,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[104]++;
  mcPCounter[104] += p;
  mcP2Counter[104] += p*p;
#define mccompcurname  Div2d_sample_maxdiv
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 104
#define nh mccDiv2d_sample_maxdiv_nh
#define nv mccDiv2d_sample_maxdiv_nv
#define Div_N mccDiv2d_sample_maxdiv_Div_N
#define Div_p mccDiv2d_sample_maxdiv_Div_p
#define Div_p2 mccDiv2d_sample_maxdiv_Div_p2
{   /* Declarations of Div2d_sample_maxdiv=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_maxdiv_filename;
MCNUM xmin = mccDiv2d_sample_maxdiv_xmin;
MCNUM xmax = mccDiv2d_sample_maxdiv_xmax;
MCNUM ymin = mccDiv2d_sample_maxdiv_ymin;
MCNUM ymax = mccDiv2d_sample_maxdiv_ymax;
MCNUM xwidth = mccDiv2d_sample_maxdiv_xwidth;
MCNUM yheight = mccDiv2d_sample_maxdiv_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_maxdiv_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_maxdiv_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_maxdiv_restore_neutron;
MCNUM nx = mccDiv2d_sample_maxdiv_nx;
MCNUM ny = mccDiv2d_sample_maxdiv_ny;
MCNUM nz = mccDiv2d_sample_maxdiv_nz;
#line 88 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    int i,j;
    double h_div, v_div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      h_div = RAD2DEG*atan2(vx,vn);
      v_div = RAD2DEG*atan2(vy,vn);
      if (h_div < maxdiv_h && h_div > -maxdiv_h &&
          v_div < maxdiv_v && v_div > -maxdiv_v)
      {
        i = floor((h_div + maxdiv_h)*nh/(2.0*maxdiv_h));
        j = floor((v_div + maxdiv_v)*nv/(2.0*maxdiv_v));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 67656 "BIFROST.c"
}   /* End of Div2d_sample_maxdiv=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiv2d_sample_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(104,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_sample_maxdiv [105] */
  mccoordschange(mcposrPSD_sample_maxdiv, mcrotrPSD_sample_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_sample_maxdiv (without coords transformations) */
  mcJumpTrace_PSD_sample_maxdiv:
  SIG_MESSAGE("PSD_sample_maxdiv (Trace)");
  mcDEBUG_COMP("PSD_sample_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_sample_maxdiv
  STORE_NEUTRON(105,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[105]++;
  mcPCounter[105] += p;
  mcP2Counter[105] += p*p;
#define mccompcurname  PSD_sample_maxdiv
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define nx mccPSD_sample_maxdiv_nx
#define ny mccPSD_sample_maxdiv_ny
#define PSD_N mccPSD_sample_maxdiv_PSD_N
#define PSD_p mccPSD_sample_maxdiv_PSD_p
#define PSD_p2 mccPSD_sample_maxdiv_PSD_p2
{   /* Declarations of PSD_sample_maxdiv=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_sample_maxdiv_filename;
MCNUM xmin = mccPSD_sample_maxdiv_xmin;
MCNUM xmax = mccPSD_sample_maxdiv_xmax;
MCNUM ymin = mccPSD_sample_maxdiv_ymin;
MCNUM ymax = mccPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccPSD_sample_maxdiv_restore_neutron;
/* 'PSD_sample_maxdiv=PSD_monitor()' component instance has conditional execution */
if (( x_div < 0.750000 && x_div > -0.750000 && y_div < 0.750000 && y_div > -0.750000 ))

#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 67800 "BIFROST.c"
}   /* End of PSD_sample_maxdiv=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_sample_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(105,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component HPSD_sample_maxdiv [106] */
  mccoordschange(mcposrHPSD_sample_maxdiv, mcrotrHPSD_sample_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component HPSD_sample_maxdiv (without coords transformations) */
  mcJumpTrace_HPSD_sample_maxdiv:
  SIG_MESSAGE("HPSD_sample_maxdiv (Trace)");
  mcDEBUG_COMP("HPSD_sample_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompHPSD_sample_maxdiv
  STORE_NEUTRON(106,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[106]++;
  mcPCounter[106] += p;
  mcP2Counter[106] += p*p;
#define mccompcurname  HPSD_sample_maxdiv
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 106
#define nx mccHPSD_sample_maxdiv_nx
#define PSDlin_N mccHPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccHPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_maxdiv_PSDlin_p2
{   /* Declarations of HPSD_sample_maxdiv=PSDlin_monitor() SETTING parameters. */
char* filename = mccHPSD_sample_maxdiv_filename;
MCNUM xmin = mccHPSD_sample_maxdiv_xmin;
MCNUM xmax = mccHPSD_sample_maxdiv_xmax;
MCNUM ymin = mccHPSD_sample_maxdiv_ymin;
MCNUM ymax = mccHPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccHPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccHPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccHPSD_sample_maxdiv_restore_neutron;
/* 'HPSD_sample_maxdiv=PSDlin_monitor()' component instance has conditional execution */
if (( x_div < 0.750000 && x_div > -0.750000 && y_div < 0.750000 && y_div > -0.750000 ))

#line 80 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor(nx*(x-xmin)/(xmax-xmin));              /* Bin number */
      if((i >= nx) || (i<0))
      {
        printf("FATAL ERROR: wrong positioning in linear PSD. i= %i \n",i);
        exit(1);
      }
      PSDlin_N[i]++;
      PSDlin_p[i] += p;
      PSDlin_p2[i] += p*p;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 67946 "BIFROST.c"
}   /* End of HPSD_sample_maxdiv=PSDlin_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompHPSD_sample_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(106,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component VPSD_sample_maxdiv [107] */
  mccoordschange(mcposrVPSD_sample_maxdiv, mcrotrVPSD_sample_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component VPSD_sample_maxdiv (without coords transformations) */
  mcJumpTrace_VPSD_sample_maxdiv:
  SIG_MESSAGE("VPSD_sample_maxdiv (Trace)");
  mcDEBUG_COMP("VPSD_sample_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompVPSD_sample_maxdiv
  STORE_NEUTRON(107,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[107]++;
  mcPCounter[107] += p;
  mcP2Counter[107] += p*p;
#define mccompcurname  VPSD_sample_maxdiv
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 107
#define ny mccVPSD_sample_maxdiv_ny
#define filename mccVPSD_sample_maxdiv_filename
#define PSDlin_N mccVPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccVPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_maxdiv_PSDlin_p2
{   /* Declarations of VPSD_sample_maxdiv=PSDlin_y_monitor() SETTING parameters. */
MCNUM xmin = mccVPSD_sample_maxdiv_xmin;
MCNUM xmax = mccVPSD_sample_maxdiv_xmax;
MCNUM ymin = mccVPSD_sample_maxdiv_ymin;
MCNUM ymax = mccVPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccVPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccVPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccVPSD_sample_maxdiv_restore_neutron;
/* 'VPSD_sample_maxdiv=PSDlin_y_monitor()' component instance has conditional execution */
if (( x_div < 0.750000 && x_div > -0.750000 && y_div < 0.750000 && y_div > -0.750000 ))

#line 77 "PSDlin_y_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor(ny*(y-ymin)/(ymax-ymin));              /* Bin number */
      if((i >= ny) || (i<0))
      {
        printf("FATAL ERROR: wrong positioning in linear PSD. i= %i \n",i);
        exit(1);
      }
      PSDlin_N[i]++;
      PSDlin_p[i] += p;
      PSDlin_p2[i] += p*p;
    } 
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68091 "BIFROST.c"
}   /* End of VPSD_sample_maxdiv=PSDlin_y_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompVPSD_sample_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(107,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Hdiv_sample_maxdiv [108] */
  mccoordschange(mcposrHdiv_sample_maxdiv, mcrotrHdiv_sample_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Hdiv_sample_maxdiv (without coords transformations) */
  mcJumpTrace_Hdiv_sample_maxdiv:
  SIG_MESSAGE("Hdiv_sample_maxdiv (Trace)");
  mcDEBUG_COMP("Hdiv_sample_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompHdiv_sample_maxdiv
  STORE_NEUTRON(108,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[108]++;
  mcPCounter[108] += p;
  mcP2Counter[108] += p*p;
#define mccompcurname  Hdiv_sample_maxdiv
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 108
#define nh mccHdiv_sample_maxdiv_nh
#define Div_N mccHdiv_sample_maxdiv_Div_N
#define Div_p mccHdiv_sample_maxdiv_Div_p
#define Div_p2 mccHdiv_sample_maxdiv_Div_p2
{   /* Declarations of Hdiv_sample_maxdiv=Hdiv_monitor() SETTING parameters. */
char* filename = mccHdiv_sample_maxdiv_filename;
MCNUM xmin = mccHdiv_sample_maxdiv_xmin;
MCNUM xmax = mccHdiv_sample_maxdiv_xmax;
MCNUM ymin = mccHdiv_sample_maxdiv_ymin;
MCNUM ymax = mccHdiv_sample_maxdiv_ymax;
MCNUM xwidth = mccHdiv_sample_maxdiv_xwidth;
MCNUM yheight = mccHdiv_sample_maxdiv_yheight;
MCNUM h_maxdiv = mccHdiv_sample_maxdiv_h_maxdiv;
MCNUM restore_neutron = mccHdiv_sample_maxdiv_restore_neutron;
/* 'Hdiv_sample_maxdiv=Hdiv_monitor()' component instance has conditional execution */
if (( y_div < 0.750000 && y_div > -0.750000 ))

#line 84 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
    int i;
    double h_div;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      h_div = RAD2DEG*atan2(vx,vz);
      if (h_div < (double)h_maxdiv && h_div > -(double)h_maxdiv)
      {
        i = floor((h_div + (double)h_maxdiv)*nh/(2.0*(double)h_maxdiv));
        Div_N[i]++;
        Div_p[i] += p;
        Div_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68239 "BIFROST.c"
}   /* End of Hdiv_sample_maxdiv=Hdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompHdiv_sample_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(108,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Vdiv_sample_maxdiv [109] */
  mccoordschange(mcposrVdiv_sample_maxdiv, mcrotrVdiv_sample_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Vdiv_sample_maxdiv (without coords transformations) */
  mcJumpTrace_Vdiv_sample_maxdiv:
  SIG_MESSAGE("Vdiv_sample_maxdiv (Trace)");
  mcDEBUG_COMP("Vdiv_sample_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompVdiv_sample_maxdiv
  STORE_NEUTRON(109,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[109]++;
  mcPCounter[109] += p;
  mcP2Counter[109] += p*p;
#define mccompcurname  Vdiv_sample_maxdiv
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 109
#define nv mccVdiv_sample_maxdiv_nv
#define filename mccVdiv_sample_maxdiv_filename
#define restore_neutron mccVdiv_sample_maxdiv_restore_neutron
#define Div_N mccVdiv_sample_maxdiv_Div_N
#define Div_p mccVdiv_sample_maxdiv_Div_p
#define Div_p2 mccVdiv_sample_maxdiv_Div_p2
{   /* Declarations of Vdiv_sample_maxdiv=Vdiv_monitor() SETTING parameters. */
MCNUM xmin = mccVdiv_sample_maxdiv_xmin;
MCNUM xmax = mccVdiv_sample_maxdiv_xmax;
MCNUM ymin = mccVdiv_sample_maxdiv_ymin;
MCNUM ymax = mccVdiv_sample_maxdiv_ymax;
MCNUM xwidth = mccVdiv_sample_maxdiv_xwidth;
MCNUM yheight = mccVdiv_sample_maxdiv_yheight;
MCNUM v_maxdiv = mccVdiv_sample_maxdiv_v_maxdiv;
/* 'Vdiv_sample_maxdiv=Vdiv_monitor()' component instance has conditional execution */
if (( x_div < 0.750000 && x_div > -0.750000 ))

#line 87 "Vdiv_monitor.comp"
{
    int i;
    double v_div;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      v_div = RAD2DEG*atan2(vy,vz);
      if (v_div < (double)v_maxdiv && v_div > -(double)v_maxdiv)
      {
        i = floor((v_div + (double)v_maxdiv)*nv/(2.0*(double)v_maxdiv));
        Div_N[i]++;
        Div_p[i] += p;
        Div_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68386 "BIFROST.c"
}   /* End of Vdiv_sample_maxdiv=Vdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompVdiv_sample_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(109,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component acceptance_x_divx_maxdiv [110] */
  mccoordschange(mcposracceptance_x_divx_maxdiv, mcrotracceptance_x_divx_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component acceptance_x_divx_maxdiv (without coords transformations) */
  mcJumpTrace_acceptance_x_divx_maxdiv:
  SIG_MESSAGE("acceptance_x_divx_maxdiv (Trace)");
  mcDEBUG_COMP("acceptance_x_divx_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompacceptance_x_divx_maxdiv
  STORE_NEUTRON(110,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[110]++;
  mcPCounter[110] += p;
  mcP2Counter[110] += p*p;
#define mccompcurname  acceptance_x_divx_maxdiv
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 110
#define nh mccacceptance_x_divx_maxdiv_nh
#define ndiv mccacceptance_x_divx_maxdiv_ndiv
#define Div_N mccacceptance_x_divx_maxdiv_Div_N
#define Div_p mccacceptance_x_divx_maxdiv_Div_p
#define Div_p2 mccacceptance_x_divx_maxdiv_Div_p2
{   /* Declarations of acceptance_x_divx_maxdiv=DivPos_monitor() SETTING parameters. */
char* filename = mccacceptance_x_divx_maxdiv_filename;
MCNUM xmin = mccacceptance_x_divx_maxdiv_xmin;
MCNUM xmax = mccacceptance_x_divx_maxdiv_xmax;
MCNUM ymin = mccacceptance_x_divx_maxdiv_ymin;
MCNUM ymax = mccacceptance_x_divx_maxdiv_ymax;
MCNUM xwidth = mccacceptance_x_divx_maxdiv_xwidth;
MCNUM yheight = mccacceptance_x_divx_maxdiv_yheight;
MCNUM maxdiv_h = mccacceptance_x_divx_maxdiv_maxdiv_h;
MCNUM restore_neutron = mccacceptance_x_divx_maxdiv_restore_neutron;
MCNUM nx = mccacceptance_x_divx_maxdiv_nx;
MCNUM ny = mccacceptance_x_divx_maxdiv_ny;
MCNUM nz = mccacceptance_x_divx_maxdiv_nz;
/* 'acceptance_x_divx_maxdiv=DivPos_monitor()' component instance has conditional execution */
if (( y_div < 0.750000 && y_div > -0.750000 ))

#line 91 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
    int i,j;
    double div;
    double v, vn;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      /* Find length of projection onto the [nx ny nz] axis */
      vn = scalar_prod(vx, vy, vz, nx, ny, nz);
      div = RAD2DEG*atan2(vx,vn);

      if (div < maxdiv_h && div > -maxdiv_h)
      {
        i = floor((x - xmin)*nh/(xmax - xmin));
        j = floor((div + maxdiv_h)*ndiv/(2.0*maxdiv_h));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68544 "BIFROST.c"
}   /* End of acceptance_x_divx_maxdiv=DivPos_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompacceptance_x_divx_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(110,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component acceptance_y_divy_maxdiv [111] */
  mccoordschange(mcposracceptance_y_divy_maxdiv, mcrotracceptance_y_divy_maxdiv,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component acceptance_y_divy_maxdiv (without coords transformations) */
  mcJumpTrace_acceptance_y_divy_maxdiv:
  SIG_MESSAGE("acceptance_y_divy_maxdiv (Trace)");
  mcDEBUG_COMP("acceptance_y_divy_maxdiv")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompacceptance_y_divy_maxdiv
  STORE_NEUTRON(111,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[111]++;
  mcPCounter[111] += p;
  mcP2Counter[111] += p*p;
#define mccompcurname  acceptance_y_divy_maxdiv
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 111
#define npos mccacceptance_y_divy_maxdiv_npos
#define ndiv mccacceptance_y_divy_maxdiv_ndiv
#define filename mccacceptance_y_divy_maxdiv_filename
#define restore_neutron mccacceptance_y_divy_maxdiv_restore_neutron
#define Div_N mccacceptance_y_divy_maxdiv_Div_N
#define Div_p mccacceptance_y_divy_maxdiv_Div_p
#define Div_p2 mccacceptance_y_divy_maxdiv_Div_p2
{   /* Declarations of acceptance_y_divy_maxdiv=DivPos_y_monitor() SETTING parameters. */
MCNUM xmin = mccacceptance_y_divy_maxdiv_xmin;
MCNUM xmax = mccacceptance_y_divy_maxdiv_xmax;
MCNUM ymin = mccacceptance_y_divy_maxdiv_ymin;
MCNUM ymax = mccacceptance_y_divy_maxdiv_ymax;
MCNUM xwidth = mccacceptance_y_divy_maxdiv_xwidth;
MCNUM yheight = mccacceptance_y_divy_maxdiv_yheight;
MCNUM maxdiv = mccacceptance_y_divy_maxdiv_maxdiv;
/* 'acceptance_y_divy_maxdiv=DivPos_y_monitor()' component instance has conditional execution */
if (( x_div < 0.750000 && x_div > -0.750000 ))

#line 85 "DivPos_y_monitor.comp"
{
    int i,j;
    double div;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      div = RAD2DEG*atan2(vy,vz);
      if (div < maxdiv && div > -maxdiv)
      {
        i = floor((y - ymin)*npos/(ymax - ymin));
        j = floor((div + maxdiv)*ndiv/(2.0*maxdiv));
        Div_N[i][j]++;
        Div_p[i][j] += p;
        Div_p2[i][j] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68694 "BIFROST.c"
}   /* End of acceptance_y_divy_maxdiv=DivPos_y_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompacceptance_y_divy_maxdiv:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(111,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Lmon_sample [112] */
  mccoordschange(mcposrLmon_sample, mcrotrLmon_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Lmon_sample (without coords transformations) */
  mcJumpTrace_Lmon_sample:
  SIG_MESSAGE("Lmon_sample (Trace)");
  mcDEBUG_COMP("Lmon_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompLmon_sample
  STORE_NEUTRON(112,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[112]++;
  mcPCounter[112] += p;
  mcP2Counter[112] += p*p;
#define mccompcurname  Lmon_sample
#define mccompcurtype  L_monitor
#define mccompcurindex 112
#define nL mccLmon_sample_nL
#define L_N mccLmon_sample_L_N
#define L_p mccLmon_sample_L_p
#define L_p2 mccLmon_sample_L_p2
{   /* Declarations of Lmon_sample=L_monitor() SETTING parameters. */
char* filename = mccLmon_sample_filename;
MCNUM xmin = mccLmon_sample_xmin;
MCNUM xmax = mccLmon_sample_xmax;
MCNUM ymin = mccLmon_sample_ymin;
MCNUM ymax = mccLmon_sample_ymax;
MCNUM xwidth = mccLmon_sample_xwidth;
MCNUM yheight = mccLmon_sample_yheight;
MCNUM Lmin = mccLmon_sample_Lmin;
MCNUM Lmax = mccLmon_sample_Lmax;
MCNUM restore_neutron = mccLmon_sample_restore_neutron;
#line 83 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68843 "BIFROST.c"
}   /* End of Lmon_sample=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompLmon_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(112,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component v_sample [113] */
  mccoordschange(mcposrv_sample, mcrotrv_sample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component v_sample (without coords transformations) */
  mcJumpTrace_v_sample:
  SIG_MESSAGE("v_sample (Trace)");
  mcDEBUG_COMP("v_sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompv_sample
  STORE_NEUTRON(113,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[113]++;
  mcPCounter[113] += p;
  mcP2Counter[113] += p*p;
#define mccompcurname  v_sample
#define mccompcurtype  V_sample
#define mccompcurindex 113
#define VarsV mccv_sample_VarsV
{   /* Declarations of v_sample=V_sample() SETTING parameters. */
MCNUM radius = mccv_sample_radius;
MCNUM thickness = mccv_sample_thickness;
MCNUM zdepth = mccv_sample_zdepth;
MCNUM Vc = mccv_sample_Vc;
MCNUM sigma_abs = mccv_sample_sigma_abs;
MCNUM sigma_inc = mccv_sample_sigma_inc;
MCNUM radius_i = mccv_sample_radius_i;
MCNUM radius_o = mccv_sample_radius_o;
MCNUM h = mccv_sample_h;
MCNUM focus_r = mccv_sample_focus_r;
MCNUM pack = mccv_sample_pack;
MCNUM frac = mccv_sample_frac;
MCNUM f_QE = mccv_sample_f_QE;
MCNUM gamma = mccv_sample_gamma;
MCNUM target_x = mccv_sample_target_x;
MCNUM target_y = mccv_sample_target_y;
MCNUM target_z = mccv_sample_target_z;
MCNUM focus_xw = mccv_sample_focus_xw;
MCNUM focus_yh = mccv_sample_focus_yh;
MCNUM focus_aw = mccv_sample_focus_aw;
MCNUM focus_ah = mccv_sample_focus_ah;
MCNUM xwidth = mccv_sample_xwidth;
MCNUM yheight = mccv_sample_yheight;
MCNUM zthick = mccv_sample_zthick;
MCNUM rad_sphere = mccv_sample_rad_sphere;
MCNUM sig_a = mccv_sample_sig_a;
MCNUM sig_i = mccv_sample_sig_i;
MCNUM V0 = mccv_sample_V0;
int target_index = mccv_sample_target_index;
MCNUM multiples = mccv_sample_multiples;
#line 180 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\obsolete\\V_sample.comp"
{
  double t0, t3;                /* Entry/exit time for outer cylinder */
  double t1, t2;                /* Entry/exit time for inner cylinder */
  double v;                     /* Neutron velocity */
  double dt0, dt1, dt2, dt;     /* Flight times through sample */
  double l_full;                /* Flight path length for non-scattered neutron */
  double l_i, l_o=0;            /* Flight path lenght in/out for scattered neutron */
  double my_a=0;                  /* Velocity-dependent attenuation factor */
  double solid_angle=0;         /* Solid angle of target as seen from scattering point */
  double aim_x=0, aim_y=0, aim_z=1;   /* Position of target relative to scattering point */
  double v_i, v_f, E_i, E_f; /* initial and final energies and velocities */
  double dE;                 /* Energy transfer */
  int    intersect=0;

  if (VarsV.shapetyp == 2)
    intersect = sphere_intersect(&t0, &t3, x, y, z, vx, vy, vz, rad_sphere);
  else
    if (VarsV.shapetyp == 1)
      intersect = box_intersect(&t0, &t3, x, y, z, vx, vy, vz, xwidth, yheight, zthick);
  else
    intersect = cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius_o, h);
  if(intersect)
  {
    if(t0 < 0) ABSORB; /* we already passed the sample; this is illegal */
    /* Neutron enters at t=t0. */
    if(VarsV.shapetyp == 1 || VarsV.shapetyp == 2)
      t1 = t2 = t3;
    else
      if(!radius_i || !cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius_i, h))
        t1 = t2 = t3;

    dt0 = t1-t0;                /* Time in sample, ingoing */
    dt1 = t2-t1;                /* Time in hole */
    dt2 = t3-t2;                /* Time in sample, outgoing */
    v = sqrt(vx*vx + vy*vy + vz*vz);
    l_full = v * (dt0 + dt2);   /* Length of full path through sample */
    if (v) my_a = VarsV.my_a_v*(2200/v);

    if (frac >= 1 || rand01()<frac)          /* Scattering */
    {
      dt = rand01()*(dt0+dt2);    /* Time of scattering (relative to t0) */
      l_i = v*dt;                 /* Penetration in sample: scattering+abs */
      if (dt > dt0)
        dt += dt1;                /* jump to 2nd side of cylinder */

      PROP_DT(dt+t0);             /* Point of scattering */

      if ((VarsV.tx || VarsV.ty || VarsV.tz)) {
        aim_x = VarsV.tx-x;       /* Vector pointing at target (anal./det.) */
        aim_y = VarsV.ty-y;
        aim_z = VarsV.tz-z;
      }
      if(VarsV.aw && VarsV.ah) {
        randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
          aim_x, aim_y, aim_z, VarsV.aw, VarsV.ah, ROT_A_CURRENT_COMP);
      } else if(VarsV.xw && VarsV.yh) {
        randvec_target_rect(&vx, &vy, &vz, &solid_angle,
          aim_x, aim_y, aim_z, VarsV.xw, VarsV.yh, ROT_A_CURRENT_COMP);
      } else {
        randvec_target_circle(&vx, &vy, &vz, &solid_angle, aim_x, aim_y, aim_z, focus_r);
      }
      NORM(vx, vy, vz);

      v_i = v;          /* Store initial velocity in case of quasielastic */
      if (rand01()<f_QE)	/* Quasielastic contribution */
	{
          E_i = VS2E*v_i*v_i;
          dE = gamma*tan(PI/2*randpm1());
          E_f = E_i + dE;
          if (E_f <= 0)
            ABSORB;
	  v_f = SE2V*sqrt(E_f);
          v = v_f;
	  /*          printf("vi: %g Ei: %g dE: %g Ef %g vf: %g v: %g \n",
		      v_i,E_i,dE,E_f,v_f,v); */
	}

      vx *= v;
      vy *= v;
      vz *= v;

      if(VarsV.shapetyp == 0) {
        if(!cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius_o, h)) {
          /* ??? did not hit cylinder */
          printf("FATAL ERROR: Did not hit cylinder from inside.\n");
          exit(1);
        }
        dt = t3; /* outgoing point */
        if(cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius_i, h) &&
           t2 > 0)
          dt -= (t2-t1);            /* Subtract hollow part */
      }
      else {
        if(VarsV.shapetyp == 1) {
	      if(!box_intersect(&t0, &t3, x, y, z, vx, vy, vz, xwidth, yheight, zthick)) {
            /* ??? did not hit box */
            printf("FATAL ERROR: Did not hit box from inside.\n");
            exit(1);
          }
          dt = t3;
        }
        else {
	      if(!sphere_intersect(&t0, &t3, x, y, z, vx, vy, vz, rad_sphere)) {
            /* ??? did not hit sphere */
            printf("FATAL ERROR: Did not hit sphere from inside.\n");
            exit(1);
          }
          dt = t3;  
        }
      }
      l_o = v*dt; /* trajectory after scattering point: absorption only */

      p *= v/v_i*l_full*VarsV.my_s*exp(-my_a*(l_i+v_i/v*l_o)-VarsV.my_s*l_i);
      if (!multiples) {
	/* If no "multiples", correct by applying scattering cross-sec and
	   implicitly "absorb" further scattering (as in PowderN) 
	   We are currently (august 2007) having a debate on which solution 
	   is the most reasonable */
	p *= exp(-VarsV.my_s*l_o);
      }
      /* We do not consider scattering from 2nd part (outgoing) */
      p /= 4*PI/solid_angle;
      p /= frac;

      /* Polarisation part (1/3 NSF, 2/3 SF) */
      sx *= -1.0/3.0;
      sy *= -1.0/3.0;
      sz *= -1.0/3.0;

      SCATTER;
    }
    else /* Transmitting; always elastic */
    {
      p *= exp(-(my_a+VarsV.my_s)*l_full);
      p /= (1-frac);
    }
  }
}
#line 69123 "BIFROST.c"
}   /* End of v_sample=V_sample() SETTING parameter declarations. */
#undef VarsV
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompv_sample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(113,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Mono_Cradle [114] */
  mccoordschange(mcposrMono_Cradle, mcrotrMono_Cradle,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Mono_Cradle (without coords transformations) */
  mcJumpTrace_Mono_Cradle:
  SIG_MESSAGE("Mono_Cradle (Trace)");
  mcDEBUG_COMP("Mono_Cradle")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompMono_Cradle
  STORE_NEUTRON(114,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[114]++;
  mcPCounter[114] += p;
  mcP2Counter[114] += p*p;
#define mccompcurname  Mono_Cradle
#define mccompcurtype  Arm
#define mccompcurindex 114
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompMono_Cradle:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(114,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component XY_ARM [115] */
  mccoordschange(mcposrXY_ARM, mcrotrXY_ARM,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component XY_ARM (without coords transformations) */
  mcJumpTrace_XY_ARM:
  SIG_MESSAGE("XY_ARM (Trace)");
  mcDEBUG_COMP("XY_ARM")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompXY_ARM
  STORE_NEUTRON(115,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[115]++;
  mcPCounter[115] += p;
  mcP2Counter[115] += p*p;
#define mccompcurname  XY_ARM
#define mccompcurtype  Arm
#define mccompcurindex 115
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompXY_ARM:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(115,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator_flat [116] */
  mccoordschange(mcposrmonochromator_flat, mcrotrmonochromator_flat,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator_flat (without coords transformations) */
  mcJumpTrace_monochromator_flat:
  SIG_MESSAGE("monochromator_flat (Trace)");
  mcDEBUG_COMP("monochromator_flat")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator_flat
  STORE_NEUTRON(116,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[116]++;
  mcPCounter[116] += p;
  mcP2Counter[116] += p*p;
#define mccompcurname  monochromator_flat
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 116
#define mos_rms_y mccmonochromator_flat_mos_rms_y
#define mos_rms_z mccmonochromator_flat_mos_rms_z
#define mos_rms_max mccmonochromator_flat_mos_rms_max
#define mono_Q mccmonochromator_flat_mono_Q
#define SlabWidth mccmonochromator_flat_SlabWidth
#define SlabHeight mccmonochromator_flat_SlabHeight
#define rTable mccmonochromator_flat_rTable
#define tTable mccmonochromator_flat_tTable
#define row mccmonochromator_flat_row
#define col mccmonochromator_flat_col
#define tiltH mccmonochromator_flat_tiltH
#define tiltV mccmonochromator_flat_tiltV
{   /* Declarations of monochromator_flat=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator_flat_reflect;
char* transmit = mccmonochromator_flat_transmit;
MCNUM zwidth = mccmonochromator_flat_zwidth;
MCNUM yheight = mccmonochromator_flat_yheight;
MCNUM gap = mccmonochromator_flat_gap;
MCNUM NH = mccmonochromator_flat_NH;
MCNUM NV = mccmonochromator_flat_NV;
MCNUM mosaich = mccmonochromator_flat_mosaich;
MCNUM mosaicv = mccmonochromator_flat_mosaicv;
MCNUM r0 = mccmonochromator_flat_r0;
MCNUM t0 = mccmonochromator_flat_t0;
MCNUM Q = mccmonochromator_flat_Q;
MCNUM RV = mccmonochromator_flat_RV;
MCNUM RH = mccmonochromator_flat_RH;
MCNUM DM = mccmonochromator_flat_DM;
MCNUM mosaic = mccmonochromator_flat_mosaic;
MCNUM width = mccmonochromator_flat_width;
MCNUM height = mccmonochromator_flat_height;
MCNUM verbose = mccmonochromator_flat_verbose;
MCNUM order = mccmonochromator_flat_order;
#line 230 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

            SCATTER;
          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 69693 "BIFROST.c"
}   /* End of monochromator_flat=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator_flat:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(116,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator2 [117] */
  mccoordschange(mcposrmonochromator2, mcrotrmonochromator2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator2 (without coords transformations) */
  mcJumpTrace_monochromator2:
  SIG_MESSAGE("monochromator2 (Trace)");
  mcDEBUG_COMP("monochromator2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator2
  STORE_NEUTRON(117,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[117]++;
  mcPCounter[117] += p;
  mcP2Counter[117] += p*p;
#define mccompcurname  monochromator2
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 117
#define mos_rms_y mccmonochromator2_mos_rms_y
#define mos_rms_z mccmonochromator2_mos_rms_z
#define mos_rms_max mccmonochromator2_mos_rms_max
#define mono_Q mccmonochromator2_mono_Q
#define SlabWidth mccmonochromator2_SlabWidth
#define SlabHeight mccmonochromator2_SlabHeight
#define rTable mccmonochromator2_rTable
#define tTable mccmonochromator2_tTable
#define row mccmonochromator2_row
#define col mccmonochromator2_col
#define tiltH mccmonochromator2_tiltH
#define tiltV mccmonochromator2_tiltV
{   /* Declarations of monochromator2=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator2_reflect;
char* transmit = mccmonochromator2_transmit;
MCNUM zwidth = mccmonochromator2_zwidth;
MCNUM yheight = mccmonochromator2_yheight;
MCNUM gap = mccmonochromator2_gap;
MCNUM NH = mccmonochromator2_NH;
MCNUM NV = mccmonochromator2_NV;
MCNUM mosaich = mccmonochromator2_mosaich;
MCNUM mosaicv = mccmonochromator2_mosaicv;
MCNUM r0 = mccmonochromator2_r0;
MCNUM t0 = mccmonochromator2_t0;
MCNUM Q = mccmonochromator2_Q;
MCNUM RV = mccmonochromator2_RV;
MCNUM RH = mccmonochromator2_RH;
MCNUM DM = mccmonochromator2_DM;
MCNUM mosaic = mccmonochromator2_mosaic;
MCNUM width = mccmonochromator2_width;
MCNUM height = mccmonochromator2_height;
MCNUM verbose = mccmonochromator2_verbose;
MCNUM order = mccmonochromator2_order;
#line 230 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

            SCATTER;
          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 70068 "BIFROST.c"
}   /* End of monochromator2=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(117,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator3 [118] */
  mccoordschange(mcposrmonochromator3, mcrotrmonochromator3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator3 (without coords transformations) */
  mcJumpTrace_monochromator3:
  SIG_MESSAGE("monochromator3 (Trace)");
  mcDEBUG_COMP("monochromator3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator3
  STORE_NEUTRON(118,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[118]++;
  mcPCounter[118] += p;
  mcP2Counter[118] += p*p;
#define mccompcurname  monochromator3
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 118
#define mos_rms_y mccmonochromator3_mos_rms_y
#define mos_rms_z mccmonochromator3_mos_rms_z
#define mos_rms_max mccmonochromator3_mos_rms_max
#define mono_Q mccmonochromator3_mono_Q
#define SlabWidth mccmonochromator3_SlabWidth
#define SlabHeight mccmonochromator3_SlabHeight
#define rTable mccmonochromator3_rTable
#define tTable mccmonochromator3_tTable
#define row mccmonochromator3_row
#define col mccmonochromator3_col
#define tiltH mccmonochromator3_tiltH
#define tiltV mccmonochromator3_tiltV
{   /* Declarations of monochromator3=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator3_reflect;
char* transmit = mccmonochromator3_transmit;
MCNUM zwidth = mccmonochromator3_zwidth;
MCNUM yheight = mccmonochromator3_yheight;
MCNUM gap = mccmonochromator3_gap;
MCNUM NH = mccmonochromator3_NH;
MCNUM NV = mccmonochromator3_NV;
MCNUM mosaich = mccmonochromator3_mosaich;
MCNUM mosaicv = mccmonochromator3_mosaicv;
MCNUM r0 = mccmonochromator3_r0;
MCNUM t0 = mccmonochromator3_t0;
MCNUM Q = mccmonochromator3_Q;
MCNUM RV = mccmonochromator3_RV;
MCNUM RH = mccmonochromator3_RH;
MCNUM DM = mccmonochromator3_DM;
MCNUM mosaic = mccmonochromator3_mosaic;
MCNUM width = mccmonochromator3_width;
MCNUM height = mccmonochromator3_height;
MCNUM verbose = mccmonochromator3_verbose;
MCNUM order = mccmonochromator3_order;
#line 230 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

            SCATTER;
          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 70443 "BIFROST.c"
}   /* End of monochromator3=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(118,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator4 [119] */
  mccoordschange(mcposrmonochromator4, mcrotrmonochromator4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator4 (without coords transformations) */
  mcJumpTrace_monochromator4:
  SIG_MESSAGE("monochromator4 (Trace)");
  mcDEBUG_COMP("monochromator4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator4
  STORE_NEUTRON(119,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[119]++;
  mcPCounter[119] += p;
  mcP2Counter[119] += p*p;
#define mccompcurname  monochromator4
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 119
#define mos_rms_y mccmonochromator4_mos_rms_y
#define mos_rms_z mccmonochromator4_mos_rms_z
#define mos_rms_max mccmonochromator4_mos_rms_max
#define mono_Q mccmonochromator4_mono_Q
#define SlabWidth mccmonochromator4_SlabWidth
#define SlabHeight mccmonochromator4_SlabHeight
#define rTable mccmonochromator4_rTable
#define tTable mccmonochromator4_tTable
#define row mccmonochromator4_row
#define col mccmonochromator4_col
#define tiltH mccmonochromator4_tiltH
#define tiltV mccmonochromator4_tiltV
{   /* Declarations of monochromator4=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator4_reflect;
char* transmit = mccmonochromator4_transmit;
MCNUM zwidth = mccmonochromator4_zwidth;
MCNUM yheight = mccmonochromator4_yheight;
MCNUM gap = mccmonochromator4_gap;
MCNUM NH = mccmonochromator4_NH;
MCNUM NV = mccmonochromator4_NV;
MCNUM mosaich = mccmonochromator4_mosaich;
MCNUM mosaicv = mccmonochromator4_mosaicv;
MCNUM r0 = mccmonochromator4_r0;
MCNUM t0 = mccmonochromator4_t0;
MCNUM Q = mccmonochromator4_Q;
MCNUM RV = mccmonochromator4_RV;
MCNUM RH = mccmonochromator4_RH;
MCNUM DM = mccmonochromator4_DM;
MCNUM mosaic = mccmonochromator4_mosaic;
MCNUM width = mccmonochromator4_width;
MCNUM height = mccmonochromator4_height;
MCNUM verbose = mccmonochromator4_verbose;
MCNUM order = mccmonochromator4_order;
#line 230 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

            SCATTER;
          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 70818 "BIFROST.c"
}   /* End of monochromator4=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(119,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator5 [120] */
  mccoordschange(mcposrmonochromator5, mcrotrmonochromator5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator5 (without coords transformations) */
  mcJumpTrace_monochromator5:
  SIG_MESSAGE("monochromator5 (Trace)");
  mcDEBUG_COMP("monochromator5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator5
  STORE_NEUTRON(120,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[120]++;
  mcPCounter[120] += p;
  mcP2Counter[120] += p*p;
#define mccompcurname  monochromator5
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 120
#define mos_rms_y mccmonochromator5_mos_rms_y
#define mos_rms_z mccmonochromator5_mos_rms_z
#define mos_rms_max mccmonochromator5_mos_rms_max
#define mono_Q mccmonochromator5_mono_Q
#define SlabWidth mccmonochromator5_SlabWidth
#define SlabHeight mccmonochromator5_SlabHeight
#define rTable mccmonochromator5_rTable
#define tTable mccmonochromator5_tTable
#define row mccmonochromator5_row
#define col mccmonochromator5_col
#define tiltH mccmonochromator5_tiltH
#define tiltV mccmonochromator5_tiltV
{   /* Declarations of monochromator5=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator5_reflect;
char* transmit = mccmonochromator5_transmit;
MCNUM zwidth = mccmonochromator5_zwidth;
MCNUM yheight = mccmonochromator5_yheight;
MCNUM gap = mccmonochromator5_gap;
MCNUM NH = mccmonochromator5_NH;
MCNUM NV = mccmonochromator5_NV;
MCNUM mosaich = mccmonochromator5_mosaich;
MCNUM mosaicv = mccmonochromator5_mosaicv;
MCNUM r0 = mccmonochromator5_r0;
MCNUM t0 = mccmonochromator5_t0;
MCNUM Q = mccmonochromator5_Q;
MCNUM RV = mccmonochromator5_RV;
MCNUM RH = mccmonochromator5_RH;
MCNUM DM = mccmonochromator5_DM;
MCNUM mosaic = mccmonochromator5_mosaic;
MCNUM width = mccmonochromator5_width;
MCNUM height = mccmonochromator5_height;
MCNUM verbose = mccmonochromator5_verbose;
MCNUM order = mccmonochromator5_order;
#line 230 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

            SCATTER;
          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 71193 "BIFROST.c"
}   /* End of monochromator5=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(120,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator6 [121] */
  mccoordschange(mcposrmonochromator6, mcrotrmonochromator6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator6 (without coords transformations) */
  mcJumpTrace_monochromator6:
  SIG_MESSAGE("monochromator6 (Trace)");
  mcDEBUG_COMP("monochromator6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator6
  STORE_NEUTRON(121,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[121]++;
  mcPCounter[121] += p;
  mcP2Counter[121] += p*p;
#define mccompcurname  monochromator6
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 121
#define mos_rms_y mccmonochromator6_mos_rms_y
#define mos_rms_z mccmonochromator6_mos_rms_z
#define mos_rms_max mccmonochromator6_mos_rms_max
#define mono_Q mccmonochromator6_mono_Q
#define SlabWidth mccmonochromator6_SlabWidth
#define SlabHeight mccmonochromator6_SlabHeight
#define rTable mccmonochromator6_rTable
#define tTable mccmonochromator6_tTable
#define row mccmonochromator6_row
#define col mccmonochromator6_col
#define tiltH mccmonochromator6_tiltH
#define tiltV mccmonochromator6_tiltV
{   /* Declarations of monochromator6=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator6_reflect;
char* transmit = mccmonochromator6_transmit;
MCNUM zwidth = mccmonochromator6_zwidth;
MCNUM yheight = mccmonochromator6_yheight;
MCNUM gap = mccmonochromator6_gap;
MCNUM NH = mccmonochromator6_NH;
MCNUM NV = mccmonochromator6_NV;
MCNUM mosaich = mccmonochromator6_mosaich;
MCNUM mosaicv = mccmonochromator6_mosaicv;
MCNUM r0 = mccmonochromator6_r0;
MCNUM t0 = mccmonochromator6_t0;
MCNUM Q = mccmonochromator6_Q;
MCNUM RV = mccmonochromator6_RV;
MCNUM RH = mccmonochromator6_RH;
MCNUM DM = mccmonochromator6_DM;
MCNUM mosaic = mccmonochromator6_mosaic;
MCNUM width = mccmonochromator6_width;
MCNUM height = mccmonochromator6_height;
MCNUM verbose = mccmonochromator6_verbose;
MCNUM order = mccmonochromator6_order;
#line 230 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

            SCATTER;
          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 71568 "BIFROST.c"
}   /* End of monochromator6=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(121,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component monochromator7 [122] */
  mccoordschange(mcposrmonochromator7, mcrotrmonochromator7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component monochromator7 (without coords transformations) */
  mcJumpTrace_monochromator7:
  SIG_MESSAGE("monochromator7 (Trace)");
  mcDEBUG_COMP("monochromator7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmonochromator7
  STORE_NEUTRON(122,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[122]++;
  mcPCounter[122] += p;
  mcP2Counter[122] += p*p;
#define mccompcurname  monochromator7
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 122
#define mos_rms_y mccmonochromator7_mos_rms_y
#define mos_rms_z mccmonochromator7_mos_rms_z
#define mos_rms_max mccmonochromator7_mos_rms_max
#define mono_Q mccmonochromator7_mono_Q
#define SlabWidth mccmonochromator7_SlabWidth
#define SlabHeight mccmonochromator7_SlabHeight
#define rTable mccmonochromator7_rTable
#define tTable mccmonochromator7_tTable
#define row mccmonochromator7_row
#define col mccmonochromator7_col
#define tiltH mccmonochromator7_tiltH
#define tiltV mccmonochromator7_tiltV
{   /* Declarations of monochromator7=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator7_reflect;
char* transmit = mccmonochromator7_transmit;
MCNUM zwidth = mccmonochromator7_zwidth;
MCNUM yheight = mccmonochromator7_yheight;
MCNUM gap = mccmonochromator7_gap;
MCNUM NH = mccmonochromator7_NH;
MCNUM NV = mccmonochromator7_NV;
MCNUM mosaich = mccmonochromator7_mosaich;
MCNUM mosaicv = mccmonochromator7_mosaicv;
MCNUM r0 = mccmonochromator7_r0;
MCNUM t0 = mccmonochromator7_t0;
MCNUM Q = mccmonochromator7_Q;
MCNUM RV = mccmonochromator7_RV;
MCNUM RH = mccmonochromator7_RH;
MCNUM DM = mccmonochromator7_DM;
MCNUM mosaic = mccmonochromator7_mosaic;
MCNUM width = mccmonochromator7_width;
MCNUM height = mccmonochromator7_height;
MCNUM verbose = mccmonochromator7_verbose;
MCNUM order = mccmonochromator7_order;
#line 230 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  double dt;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0 && r0)
  {                             /* Moving towards crystal? */
    double zmin,zmax, ymin,ymax;

    /* Propagate to crystal plane */
    PROP_DT(dt);    /* now in the vertical plane of monochromator */

    zmax = ((NH*(SlabWidth+gap))-gap)/2;
    zmin = -zmax;
    ymax = ((NV*(SlabHeight+gap))-gap)/2;
    ymin = -ymax;

    /* hit a slab or a gap ? */

    if (z>zmin && z<zmax && y>ymin && y<ymax) { /* Intersect the crystal? */
      double tilth,tiltv;         /* used to calculate tilt angle of slab */
      double ratio, Q_order, k, kux,kuy,kuz;
      double kix,kiy,kiz;
      int    do_transmit = 0;

      col = ceil ( (z-zmin)/(SlabWidth +gap));  /* which slab hit ? */
      row = ceil ( (y-ymin)/(SlabHeight+gap));
      if (RH != 0) tilth = tiltH ? tiltH[(int)col] :  asin((col-(NH+1)/2)*(SlabWidth+gap)/RH);
      else tilth=0;
      if (RV != 0) tiltv = tiltV ? tiltV[(int)row] : -asin((row-(NV+1)/2)*(SlabHeight+gap)/RV);
      else tiltv=0;

      /* restore neutron in order to transform to slab coordinates */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);

      /* rotate with tilth (around Y) and tiltv (around Z), center on plate */
      double center_z=zmin+(col-0.5)*(SlabWidth+gap) -gap/2;
      double center_y=ymin+(row-0.5)*(SlabHeight+gap)-gap/2;
      Rotation T;
      rot_set_rotation(T, 0, tilth,    tiltv);
      /* now make the coordinate system change */
      mccoordschange_polarisation(T, &vx, &vy, &vz);
      y-=center_y;
      z-=center_z;
      coords_get(rot_apply(T,coords_set(x,y,z)),&x,&y,&z);

      /* this is where polaisation should be handled, plus further down */
      /* mccoordschange_polarisation(t, &sx, &sy, &sz); */

      /* now propagate to slab plane */
      PROP_X0;

      if (fabs(z) <= SlabWidth/2 && fabs(y) <= SlabHeight/2) { /* not in gap ? */
        kix = V2K*vx;             /* Initial wave vector */
        kiy = V2K*vy;
        kiz = V2K*vz;
        /* Get reflection order and corresponding nominal scattering vector q0
          of correct length and direction. Only the order with the closest
          scattering vector is considered */
        ratio = -2*kix/mono_Q;
        Q_order = floor(ratio + .5);
        if(Q_order == 0.0) Q_order = ratio < 0 ? -1 : 1;
        /* Order will be negative when the neutron enters from the back, in
          which case the direction of Q0 is flipped. */
        if(Q_order < 0) Q_order = -Q_order;
        /* Make sure the order is small enough to allow Bragg scattering at the
          given neutron wavelength */
        k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
        kux = kix/k;              /* Unit vector along ki */
        kuy = kiy/k;
        kuz = kiz/k;
        if(Q_order > 2*k/mono_Q) Q_order--;
        if((!order && Q_order > 0) || (Q_order == fabs(order) && order)) {           /* Bragg scattering possible? */
          double q0, q0x, theta, delta, p_reflect, my_r0;

          q0 = Q_order*mono_Q;
          q0x = ratio < 0 ? -q0 : q0;
          theta = asin(q0/(2*k)); /* Actual bragg angle */
          /* Make MC choice: reflect or transmit? */
          delta = asin(fabs(kux)) - theta;

          if (rTable.data != NULL)
          {
            my_r0 = r0*Table_Value(rTable, k, 1); /* 2nd column */
          }
          else my_r0 = r0;
          if (my_r0 > 1)
          {
            if (my_r0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered reflectivity from %f to 1 (k=%f)\n", my_r0, k);
            my_r0=0.999;
          }
          if (my_r0 < 0)
          {
            if (verbose) fprintf(stdout, "Warning: Monochromator_curved : raised reflectivity from %f to 0 (k=%f)\n", my_r0, k);
            my_r0=0;
          }

          p_reflect = fabs(my_r0)*exp(-kiz*kiz/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_y*mos_rms_y))*
                        exp(-kiy*kiy/(kiy*kiy + kiz*kiz)*(delta*delta)/
                            (2*mos_rms_z*mos_rms_z));

          if(rand01() <= p_reflect) { /* Reflect */
            double bx,by,bz,ax,ay,az,phi;
            double cos_2theta,k_sin_2theta,cos_phi,sin_phi,q_x,q_y,q_z;
            double total,c1x,c1y,c1z,w,mos_sample;
            int i=0;

            cos_2theta   = cos(2*theta);
            k_sin_2theta = k*sin(2*theta);
            /* Get unit normal to plane containing ki and most probable kf */
            vec_prod(bx, by, bz, kix, kiy, kiz, q0x, 0, 0);
            NORM(bx,by,bz);
            bx *= k_sin_2theta;
            by *= k_sin_2theta;
            bz *= k_sin_2theta;
            /* Get unit vector normal to ki and b */
            vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
            /* Compute the total scattering probability at this ki */
            total = 0;
            /* Choose width of Gaussian distribution to sample the angle
            * phi on the Debye-Scherrer cone for the scattered neutron.
            * The radius of the Debye-Scherrer cone is smaller by a
            * factor 1/cos(theta) than the radius of the (partial) sphere
            * describing the possible orientations of Q due to mosaicity, so we
            * start with a width 1/cos(theta) greater than the largest of
            * the two mosaics. */
            mos_sample = mos_rms_max/cos(theta);
            c1x = kix*(cos_2theta-1);
            c1y = kiy*(cos_2theta-1);
            c1z = kiz*(cos_2theta-1);
            /* Loop, repeatedly reducing the sample width until it is small
            * enough to avoid sampling scattering directions with
            * ridiculously low scattering probability.
            * Use a cut-off at 5 times the gauss width for considering
            * scattering probability as well as for integration limits
            * when integrating the sampled distribution below. */
            for(i=0; i<100; i++) {
              w = 5*mos_sample;
              cos_phi = cos(w);
              sin_phi = sin(w);
              q_x =  c1x + cos_phi*ax + sin_phi*bx;
              q_y = (c1y + cos_phi*ay + sin_phi*by)/mos_rms_z;
              q_z = (c1z + cos_phi*az + sin_phi*bz)/mos_rms_y;
              /* Stop when we get near a factor of 25=5^2. */
              if(q_z*q_z + q_y*q_y < (25/(2.0/3.0))*(q_x*q_x))
                break;
              mos_sample *= (2.0/3.0);
            }
            /* Now integrate the chosen sampling distribution, using a
            * cut-off at five times sigma. */
            for(i = 0; i < (sizeof(Gauss_X)/sizeof(double)); i++)
            {
              phi = w*Gauss_X[i];
              cos_phi = cos(phi);
              sin_phi = sin(phi);
              q_x = c1x + cos_phi*ax + sin_phi*bx;
              q_y = c1y + cos_phi*ay + sin_phi*by;
              q_z = c1z + cos_phi*az + sin_phi*bz;
              p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                          GAUSS((q_y/q_x),0,mos_rms_z);
              total += Gauss_W[i]*p_reflect;
            }
            total *= w;
            /* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
             * width 1/cos(theta) greater than the mosaic and correct for any
             * error by adjusting the neutron weight later. */
            phi = mos_sample*randnorm();
            /* Compute final wave vector kf and scattering vector q = ki - kf */
            cos_phi = cos(phi);
            sin_phi = sin(phi);
            q_x = c1x + cos_phi*ax + sin_phi*bx;
            q_y = c1y + cos_phi*ay + sin_phi*by;
            q_z = c1z + cos_phi*az + sin_phi*bz;
            p_reflect = GAUSS((q_z/q_x),0,mos_rms_y)*
                        GAUSS((q_y/q_x),0,mos_rms_z);

            vx = K2V*(kix+q_x);
            vy = K2V*(kiy+q_y);
            vz = K2V*(kiz+q_z);
            p_reflect /= total*GAUSS(phi,0,mos_sample);
            if (p_reflect <= 0) ABSORB;
            if (p_reflect > 1)  p_reflect = 1;
            p *= p_reflect;

            SCATTER;
          } /* End MC choice to reflect or transmit neutron (if tmp<p_reflect) */
          else do_transmit = 1;
            /* else transmit neutron */
        } /* End bragg scattering possible (if order) */
        else do_transmit=1;
        if (do_transmit)
        {
          double my_t0;
          if (tTable.data != NULL)
          {
            my_t0 = t0*Table_Value(tTable, k, 1); /* 2nd column */
          }
          else my_t0 = t0;
          /* do not SCATTER, else GROUP does not work */
          if (my_t0 > 1)
          {
            if (my_t0 > 1.01 && verbose) fprintf(stdout, "Warning: Monochromator_curved : lowered transmission from %f to 1 (k=%f)\n", my_t0, k);
            my_t0=0.999;
          }
          if (my_t0 > 0) p*= my_t0;
          else ABSORB;
        }
      } /* end if not in gap */
      /* rotate back in component frame */
      Rotation TT;
      rot_transpose(T, TT);
      /* now make the coordinate system change */
      mccoordschange_polarisation(TT, &vx, &vy, &vz);
      coords_get(rot_apply(TT,coords_set(x,y,z)),&x,&y,&z);
      y+=center_y;
      z+=center_z;

      /* mccoordschange_polarisation(tt, &sx, &sy, &sz); */
    } /* End intersect the crystal (if z) */
    else {
      /* restore neutron state when no interaction */
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
  } /* End neutron moving towards crystal (if vx)*/
}
#line 71943 "BIFROST.c"
}   /* End of monochromator7=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmonochromator7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(122,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Mono_Out [123] */
  mccoordschange(mcposrMono_Out, mcrotrMono_Out,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Mono_Out (without coords transformations) */
  mcJumpTrace_Mono_Out:
  SIG_MESSAGE("Mono_Out (Trace)");
  mcDEBUG_COMP("Mono_Out")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompMono_Out
  STORE_NEUTRON(123,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[123]++;
  mcPCounter[123] += p;
  mcP2Counter[123] += p*p;
#define mccompcurname  Mono_Out
#define mccompcurtype  Arm
#define mccompcurindex 123
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompMono_Out:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(123,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component psd_monitor [124] */
  mccoordschange(mcposrpsd_monitor, mcrotrpsd_monitor,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component psd_monitor (without coords transformations) */
  mcJumpTrace_psd_monitor:
  SIG_MESSAGE("psd_monitor (Trace)");
  mcDEBUG_COMP("psd_monitor")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComppsd_monitor
  STORE_NEUTRON(124,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[124]++;
  mcPCounter[124] += p;
  mcP2Counter[124] += p*p;
#define mccompcurname  psd_monitor
#define mccompcurtype  PSD_monitor
#define mccompcurindex 124
#define nx mccpsd_monitor_nx
#define ny mccpsd_monitor_ny
#define PSD_N mccpsd_monitor_PSD_N
#define PSD_p mccpsd_monitor_PSD_p
#define PSD_p2 mccpsd_monitor_PSD_p2
{   /* Declarations of psd_monitor=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_monitor_filename;
MCNUM xmin = mccpsd_monitor_xmin;
MCNUM xmax = mccpsd_monitor_xmax;
MCNUM ymin = mccpsd_monitor_ymin;
MCNUM ymax = mccpsd_monitor_ymax;
MCNUM xwidth = mccpsd_monitor_xwidth;
MCNUM yheight = mccpsd_monitor_yheight;
MCNUM restore_neutron = mccpsd_monitor_restore_neutron;
#line 82 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    int i,j;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((x - xmin)*nx/(xmax - xmin));
      j = floor((y - ymin)*ny/(ymax - ymin));
      PSD_N[i][j]++;
      PSD_p[i][j] += p;
      PSD_p2[i][j] += p*p;
      SCATTER;
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 72195 "BIFROST.c"
}   /* End of psd_monitor=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComppsd_monitor:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(124,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component e_monitor [125] */
  mccoordschange(mcposre_monitor, mcrotre_monitor,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component e_monitor (without coords transformations) */
  mcJumpTrace_e_monitor:
  SIG_MESSAGE("e_monitor (Trace)");
  mcDEBUG_COMP("e_monitor")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompe_monitor
  STORE_NEUTRON(125,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[125]++;
  mcPCounter[125] += p;
  mcP2Counter[125] += p*p;
#define mccompcurname  e_monitor
#define mccompcurtype  E_monitor
#define mccompcurindex 125
#define nE mcce_monitor_nE
#define E_N mcce_monitor_E_N
#define E_p mcce_monitor_E_p
#define E_p2 mcce_monitor_E_p2
#define S_p mcce_monitor_S_p
#define S_pE mcce_monitor_S_pE
#define S_pE2 mcce_monitor_S_pE2
{   /* Declarations of e_monitor=E_monitor() SETTING parameters. */
char* filename = mcce_monitor_filename;
MCNUM xmin = mcce_monitor_xmin;
MCNUM xmax = mcce_monitor_xmax;
MCNUM ymin = mcce_monitor_ymin;
MCNUM ymax = mcce_monitor_ymax;
MCNUM xwidth = mcce_monitor_xwidth;
MCNUM yheight = mcce_monitor_yheight;
MCNUM Emin = mcce_monitor_Emin;
MCNUM Emax = mcce_monitor_Emax;
MCNUM restore_neutron = mcce_monitor_restore_neutron;
#line 88 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 72350 "BIFROST.c"
}   /* End of e_monitor=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompe_monitor:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(125,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  mcabsorbAll:
  mcDEBUG_LEAVE()
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)
  /* Copy neutron state to global variables. */
  mcnx = mcnlx;
  mcny = mcnly;
  mcnz = mcnlz;
  mcnvx = mcnlvx;
  mcnvy = mcnlvy;
  mcnvz = mcnlvz;
  mcnt = mcnlt;
  mcnsx = mcnlsx;
  mcnsy = mcnlsy;
  mcnsz = mcnlsz;
  mcnp = mcnlp;

} /* end trace */

void mcsave(FILE *handle) {
  if (!handle) mcsiminfo_init(NULL);
  /* User component SAVE code. */

  /* User SAVE code for component 'Origin'. */
  SIG_MESSAGE("Origin (Save)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 115 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\misc\\Progress_bar.comp"
{
  MPI_MASTER(fprintf(stdout, "\nSave [%s]\n", mcinstrument_name););
  if (profile && strlen(profile) && strcmp(profile,"NULL") && strcmp(profile,"0")) {
    char filename[256];
    if (!strlen(profile) || !strcmp(profile,"NULL") || !strcmp(profile,"0")) strcpy(filename, mcinstrument_name);
    else strcpy(filename, profile);
    DETECTOR_OUT_1D(
        "Intensity profiler",
        "Component index [1]",
        "Intensity",
        "prof", 1, mcNUMCOMP, mcNUMCOMP-1,
        &mcNCounter[1],&mcPCounter[1],&mcP2Counter[1],
        filename);

  }
}
#line 72466 "BIFROST.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monBeforePSC1'. */
  SIG_MESSAGE("L_monBeforePSC1 (Save)");
#define mccompcurname  L_monBeforePSC1
#define mccompcurtype  L_monitor
#define mccompcurindex 6
#define nL mccL_monBeforePSC1_nL
#define L_N mccL_monBeforePSC1_L_N
#define L_p mccL_monBeforePSC1_L_p
#define L_p2 mccL_monBeforePSC1_L_p2
{   /* Declarations of L_monBeforePSC1=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforePSC1_filename;
MCNUM xmin = mccL_monBeforePSC1_xmin;
MCNUM xmax = mccL_monBeforePSC1_xmax;
MCNUM ymin = mccL_monBeforePSC1_ymin;
MCNUM ymax = mccL_monBeforePSC1_ymax;
MCNUM xwidth = mccL_monBeforePSC1_xwidth;
MCNUM yheight = mccL_monBeforePSC1_yheight;
MCNUM Lmin = mccL_monBeforePSC1_Lmin;
MCNUM Lmax = mccL_monBeforePSC1_Lmax;
MCNUM restore_neutron = mccL_monBeforePSC1_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 72506 "BIFROST.c"
}   /* End of L_monBeforePSC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFBeforerPSC1'. */
  SIG_MESSAGE("ToFBeforerPSC1 (Save)");
#define mccompcurname  ToFBeforerPSC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 7
#define nt mccToFBeforerPSC1_nt
#define TOF_N mccToFBeforerPSC1_TOF_N
#define TOF_p mccToFBeforerPSC1_TOF_p
#define TOF_p2 mccToFBeforerPSC1_TOF_p2
#define t_min mccToFBeforerPSC1_t_min
#define t_max mccToFBeforerPSC1_t_max
#define delta_t mccToFBeforerPSC1_delta_t
{   /* Declarations of ToFBeforerPSC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforerPSC1_filename;
MCNUM xmin = mccToFBeforerPSC1_xmin;
MCNUM xmax = mccToFBeforerPSC1_xmax;
MCNUM ymin = mccToFBeforerPSC1_ymin;
MCNUM ymax = mccToFBeforerPSC1_ymax;
MCNUM xwidth = mccToFBeforerPSC1_xwidth;
MCNUM yheight = mccToFBeforerPSC1_yheight;
MCNUM tmin = mccToFBeforerPSC1_tmin;
MCNUM tmax = mccToFBeforerPSC1_tmax;
MCNUM dt = mccToFBeforerPSC1_dt;
MCNUM restore_neutron = mccToFBeforerPSC1_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 72550 "BIFROST.c"
}   /* End of ToFBeforerPSC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_beforePulseShapping1'. */
  SIG_MESSAGE("PSD_beforePulseShapping1 (Save)");
#define mccompcurname  PSD_beforePulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 8
#define nx mccPSD_beforePulseShapping1_nx
#define ny mccPSD_beforePulseShapping1_ny
#define PSD_N mccPSD_beforePulseShapping1_PSD_N
#define PSD_p mccPSD_beforePulseShapping1_PSD_p
#define PSD_p2 mccPSD_beforePulseShapping1_PSD_p2
{   /* Declarations of PSD_beforePulseShapping1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforePulseShapping1_filename;
MCNUM xmin = mccPSD_beforePulseShapping1_xmin;
MCNUM xmax = mccPSD_beforePulseShapping1_xmax;
MCNUM ymin = mccPSD_beforePulseShapping1_ymin;
MCNUM ymax = mccPSD_beforePulseShapping1_ymax;
MCNUM xwidth = mccPSD_beforePulseShapping1_xwidth;
MCNUM yheight = mccPSD_beforePulseShapping1_yheight;
MCNUM restore_neutron = mccPSD_beforePulseShapping1_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 72593 "BIFROST.c"
}   /* End of PSD_beforePulseShapping1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'TofLambdaBeforePSC'. */
  SIG_MESSAGE("TofLambdaBeforePSC (Save)");
#define mccompcurname  TofLambdaBeforePSC
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 9
#define nL mccTofLambdaBeforePSC_nL
#define nt mccTofLambdaBeforePSC_nt
#define tmin mccTofLambdaBeforePSC_tmin
#define tmax mccTofLambdaBeforePSC_tmax
#define tt_0 mccTofLambdaBeforePSC_tt_0
#define tt_1 mccTofLambdaBeforePSC_tt_1
#define TOFL_N mccTofLambdaBeforePSC_TOFL_N
#define TOFL_p mccTofLambdaBeforePSC_TOFL_p
#define TOFL_p2 mccTofLambdaBeforePSC_TOFL_p2
{   /* Declarations of TofLambdaBeforePSC=TOFLambda_monitor() SETTING parameters. */
char* filename = mccTofLambdaBeforePSC_filename;
MCNUM xmin = mccTofLambdaBeforePSC_xmin;
MCNUM xmax = mccTofLambdaBeforePSC_xmax;
MCNUM ymin = mccTofLambdaBeforePSC_ymin;
MCNUM ymax = mccTofLambdaBeforePSC_ymax;
MCNUM xwidth = mccTofLambdaBeforePSC_xwidth;
MCNUM yheight = mccTofLambdaBeforePSC_yheight;
MCNUM Lmin = mccTofLambdaBeforePSC_Lmin;
MCNUM Lmax = mccTofLambdaBeforePSC_Lmax;
MCNUM restore_neutron = mccTofLambdaBeforePSC_restore_neutron;
#line 109 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
    DETECTOR_OUT_2D(
        "TOF-wavelength monitor",
        "Time-of-flight [\\gms]", "Wavelength [AA]",
        tmin, tmax, Lmin, Lmax,
        nt, nL,
        &TOFL_N[0][0],&TOFL_p[0][0],&TOFL_p2[0][0],
        filename);
}
#line 72639 "BIFROST.c"
}   /* End of TofLambdaBeforePSC=TOFLambda_monitor() SETTING parameter declarations. */
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_AfterPulseShapping1'. */
  SIG_MESSAGE("PSD_AfterPulseShapping1 (Save)");
#define mccompcurname  PSD_AfterPulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 11
#define nx mccPSD_AfterPulseShapping1_nx
#define ny mccPSD_AfterPulseShapping1_ny
#define PSD_N mccPSD_AfterPulseShapping1_PSD_N
#define PSD_p mccPSD_AfterPulseShapping1_PSD_p
#define PSD_p2 mccPSD_AfterPulseShapping1_PSD_p2
{   /* Declarations of PSD_AfterPulseShapping1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_AfterPulseShapping1_filename;
MCNUM xmin = mccPSD_AfterPulseShapping1_xmin;
MCNUM xmax = mccPSD_AfterPulseShapping1_xmax;
MCNUM ymin = mccPSD_AfterPulseShapping1_ymin;
MCNUM ymax = mccPSD_AfterPulseShapping1_ymax;
MCNUM xwidth = mccPSD_AfterPulseShapping1_xwidth;
MCNUM yheight = mccPSD_AfterPulseShapping1_yheight;
MCNUM restore_neutron = mccPSD_AfterPulseShapping1_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 72684 "BIFROST.c"
}   /* End of PSD_AfterPulseShapping1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFInsidePSC'. */
  SIG_MESSAGE("ToFInsidePSC (Save)");
#define mccompcurname  ToFInsidePSC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 12
#define nt mccToFInsidePSC_nt
#define TOF_N mccToFInsidePSC_TOF_N
#define TOF_p mccToFInsidePSC_TOF_p
#define TOF_p2 mccToFInsidePSC_TOF_p2
#define t_min mccToFInsidePSC_t_min
#define t_max mccToFInsidePSC_t_max
#define delta_t mccToFInsidePSC_delta_t
{   /* Declarations of ToFInsidePSC=TOF_monitor() SETTING parameters. */
char* filename = mccToFInsidePSC_filename;
MCNUM xmin = mccToFInsidePSC_xmin;
MCNUM xmax = mccToFInsidePSC_xmax;
MCNUM ymin = mccToFInsidePSC_ymin;
MCNUM ymax = mccToFInsidePSC_ymax;
MCNUM xwidth = mccToFInsidePSC_xwidth;
MCNUM yheight = mccToFInsidePSC_yheight;
MCNUM tmin = mccToFInsidePSC_tmin;
MCNUM tmax = mccToFInsidePSC_tmax;
MCNUM dt = mccToFInsidePSC_dt;
MCNUM restore_neutron = mccToFInsidePSC_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 72729 "BIFROST.c"
}   /* End of ToFInsidePSC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'TofLambdaAfterPSC2'. */
  SIG_MESSAGE("TofLambdaAfterPSC2 (Save)");
#define mccompcurname  TofLambdaAfterPSC2
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 14
#define nL mccTofLambdaAfterPSC2_nL
#define nt mccTofLambdaAfterPSC2_nt
#define tmin mccTofLambdaAfterPSC2_tmin
#define tmax mccTofLambdaAfterPSC2_tmax
#define tt_0 mccTofLambdaAfterPSC2_tt_0
#define tt_1 mccTofLambdaAfterPSC2_tt_1
#define TOFL_N mccTofLambdaAfterPSC2_TOFL_N
#define TOFL_p mccTofLambdaAfterPSC2_TOFL_p
#define TOFL_p2 mccTofLambdaAfterPSC2_TOFL_p2
{   /* Declarations of TofLambdaAfterPSC2=TOFLambda_monitor() SETTING parameters. */
char* filename = mccTofLambdaAfterPSC2_filename;
MCNUM xmin = mccTofLambdaAfterPSC2_xmin;
MCNUM xmax = mccTofLambdaAfterPSC2_xmax;
MCNUM ymin = mccTofLambdaAfterPSC2_ymin;
MCNUM ymax = mccTofLambdaAfterPSC2_ymax;
MCNUM xwidth = mccTofLambdaAfterPSC2_xwidth;
MCNUM yheight = mccTofLambdaAfterPSC2_yheight;
MCNUM Lmin = mccTofLambdaAfterPSC2_Lmin;
MCNUM Lmax = mccTofLambdaAfterPSC2_Lmax;
MCNUM restore_neutron = mccTofLambdaAfterPSC2_restore_neutron;
#line 109 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
    DETECTOR_OUT_2D(
        "TOF-wavelength monitor",
        "Time-of-flight [\\gms]", "Wavelength [AA]",
        tmin, tmax, Lmin, Lmax,
        nt, nL,
        &TOFL_N[0][0],&TOFL_p[0][0],&TOFL_p2[0][0],
        filename);
}
#line 72777 "BIFROST.c"
}   /* End of TofLambdaAfterPSC2=TOFLambda_monitor() SETTING parameter declarations. */
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_AfterPSC2'. */
  SIG_MESSAGE("PSD_AfterPSC2 (Save)");
#define mccompcurname  PSD_AfterPSC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 15
#define nx mccPSD_AfterPSC2_nx
#define ny mccPSD_AfterPSC2_ny
#define PSD_N mccPSD_AfterPSC2_PSD_N
#define PSD_p mccPSD_AfterPSC2_PSD_p
#define PSD_p2 mccPSD_AfterPSC2_PSD_p2
{   /* Declarations of PSD_AfterPSC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_AfterPSC2_filename;
MCNUM xmin = mccPSD_AfterPSC2_xmin;
MCNUM xmax = mccPSD_AfterPSC2_xmax;
MCNUM ymin = mccPSD_AfterPSC2_ymin;
MCNUM ymax = mccPSD_AfterPSC2_ymax;
MCNUM xwidth = mccPSD_AfterPSC2_xwidth;
MCNUM yheight = mccPSD_AfterPSC2_yheight;
MCNUM restore_neutron = mccPSD_AfterPSC2_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 72822 "BIFROST.c"
}   /* End of PSD_AfterPSC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFAfterPSC2'. */
  SIG_MESSAGE("ToFAfterPSC2 (Save)");
#define mccompcurname  ToFAfterPSC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 16
#define nt mccToFAfterPSC2_nt
#define TOF_N mccToFAfterPSC2_TOF_N
#define TOF_p mccToFAfterPSC2_TOF_p
#define TOF_p2 mccToFAfterPSC2_TOF_p2
#define t_min mccToFAfterPSC2_t_min
#define t_max mccToFAfterPSC2_t_max
#define delta_t mccToFAfterPSC2_delta_t
{   /* Declarations of ToFAfterPSC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterPSC2_filename;
MCNUM xmin = mccToFAfterPSC2_xmin;
MCNUM xmax = mccToFAfterPSC2_xmax;
MCNUM ymin = mccToFAfterPSC2_ymin;
MCNUM ymax = mccToFAfterPSC2_ymax;
MCNUM xwidth = mccToFAfterPSC2_xwidth;
MCNUM yheight = mccToFAfterPSC2_yheight;
MCNUM tmin = mccToFAfterPSC2_tmin;
MCNUM tmax = mccToFAfterPSC2_tmax;
MCNUM dt = mccToFAfterPSC2_dt;
MCNUM restore_neutron = mccToFAfterPSC2_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 72867 "BIFROST.c"
}   /* End of ToFAfterPSC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monAfterPSC2'. */
  SIG_MESSAGE("L_monAfterPSC2 (Save)");
#define mccompcurname  L_monAfterPSC2
#define mccompcurtype  L_monitor
#define mccompcurindex 17
#define nL mccL_monAfterPSC2_nL
#define L_N mccL_monAfterPSC2_L_N
#define L_p mccL_monAfterPSC2_L_p
#define L_p2 mccL_monAfterPSC2_L_p2
{   /* Declarations of L_monAfterPSC2=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterPSC2_filename;
MCNUM xmin = mccL_monAfterPSC2_xmin;
MCNUM xmax = mccL_monAfterPSC2_xmax;
MCNUM ymin = mccL_monAfterPSC2_ymin;
MCNUM ymax = mccL_monAfterPSC2_ymax;
MCNUM xwidth = mccL_monAfterPSC2_xwidth;
MCNUM yheight = mccL_monAfterPSC2_yheight;
MCNUM Lmin = mccL_monAfterPSC2_Lmin;
MCNUM Lmax = mccL_monAfterPSC2_Lmax;
MCNUM restore_neutron = mccL_monAfterPSC2_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 72910 "BIFROST.c"
}   /* End of L_monAfterPSC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monBeforeFOC1'. */
  SIG_MESSAGE("L_monBeforeFOC1 (Save)");
#define mccompcurname  L_monBeforeFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccL_monBeforeFOC1_nL
#define L_N mccL_monBeforeFOC1_L_N
#define L_p mccL_monBeforeFOC1_L_p
#define L_p2 mccL_monBeforeFOC1_L_p2
{   /* Declarations of L_monBeforeFOC1=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeFOC1_filename;
MCNUM xmin = mccL_monBeforeFOC1_xmin;
MCNUM xmax = mccL_monBeforeFOC1_xmax;
MCNUM ymin = mccL_monBeforeFOC1_ymin;
MCNUM ymax = mccL_monBeforeFOC1_ymax;
MCNUM xwidth = mccL_monBeforeFOC1_xwidth;
MCNUM yheight = mccL_monBeforeFOC1_yheight;
MCNUM Lmin = mccL_monBeforeFOC1_Lmin;
MCNUM Lmax = mccL_monBeforeFOC1_Lmax;
MCNUM restore_neutron = mccL_monBeforeFOC1_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 72950 "BIFROST.c"
}   /* End of L_monBeforeFOC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFBeforeFOC1'. */
  SIG_MESSAGE("ToFBeforeFOC1 (Save)");
#define mccompcurname  ToFBeforeFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 25
#define nt mccToFBeforeFOC1_nt
#define TOF_N mccToFBeforeFOC1_TOF_N
#define TOF_p mccToFBeforeFOC1_TOF_p
#define TOF_p2 mccToFBeforeFOC1_TOF_p2
#define t_min mccToFBeforeFOC1_t_min
#define t_max mccToFBeforeFOC1_t_max
#define delta_t mccToFBeforeFOC1_delta_t
{   /* Declarations of ToFBeforeFOC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeFOC1_filename;
MCNUM xmin = mccToFBeforeFOC1_xmin;
MCNUM xmax = mccToFBeforeFOC1_xmax;
MCNUM ymin = mccToFBeforeFOC1_ymin;
MCNUM ymax = mccToFBeforeFOC1_ymax;
MCNUM xwidth = mccToFBeforeFOC1_xwidth;
MCNUM yheight = mccToFBeforeFOC1_yheight;
MCNUM tmin = mccToFBeforeFOC1_tmin;
MCNUM tmax = mccToFBeforeFOC1_tmax;
MCNUM dt = mccToFBeforeFOC1_dt;
MCNUM restore_neutron = mccToFBeforeFOC1_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 72994 "BIFROST.c"
}   /* End of ToFBeforeFOC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_beforeFOC1'. */
  SIG_MESSAGE("PSD_beforeFOC1 (Save)");
#define mccompcurname  PSD_beforeFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 26
#define nx mccPSD_beforeFOC1_nx
#define ny mccPSD_beforeFOC1_ny
#define PSD_N mccPSD_beforeFOC1_PSD_N
#define PSD_p mccPSD_beforeFOC1_PSD_p
#define PSD_p2 mccPSD_beforeFOC1_PSD_p2
{   /* Declarations of PSD_beforeFOC1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforeFOC1_filename;
MCNUM xmin = mccPSD_beforeFOC1_xmin;
MCNUM xmax = mccPSD_beforeFOC1_xmax;
MCNUM ymin = mccPSD_beforeFOC1_ymin;
MCNUM ymax = mccPSD_beforeFOC1_ymax;
MCNUM xwidth = mccPSD_beforeFOC1_xwidth;
MCNUM yheight = mccPSD_beforeFOC1_yheight;
MCNUM restore_neutron = mccPSD_beforeFOC1_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 73037 "BIFROST.c"
}   /* End of PSD_beforeFOC1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_afterFOC1'. */
  SIG_MESSAGE("PSD_afterFOC1 (Save)");
#define mccompcurname  PSD_afterFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 28
#define nx mccPSD_afterFOC1_nx
#define ny mccPSD_afterFOC1_ny
#define PSD_N mccPSD_afterFOC1_PSD_N
#define PSD_p mccPSD_afterFOC1_PSD_p
#define PSD_p2 mccPSD_afterFOC1_PSD_p2
{   /* Declarations of PSD_afterFOC1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_afterFOC1_filename;
MCNUM xmin = mccPSD_afterFOC1_xmin;
MCNUM xmax = mccPSD_afterFOC1_xmax;
MCNUM ymin = mccPSD_afterFOC1_ymin;
MCNUM ymax = mccPSD_afterFOC1_ymax;
MCNUM xwidth = mccPSD_afterFOC1_xwidth;
MCNUM yheight = mccPSD_afterFOC1_yheight;
MCNUM restore_neutron = mccPSD_afterFOC1_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 73078 "BIFROST.c"
}   /* End of PSD_afterFOC1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFAfterFOC1'. */
  SIG_MESSAGE("ToFAfterFOC1 (Save)");
#define mccompcurname  ToFAfterFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 29
#define nt mccToFAfterFOC1_nt
#define TOF_N mccToFAfterFOC1_TOF_N
#define TOF_p mccToFAfterFOC1_TOF_p
#define TOF_p2 mccToFAfterFOC1_TOF_p2
#define t_min mccToFAfterFOC1_t_min
#define t_max mccToFAfterFOC1_t_max
#define delta_t mccToFAfterFOC1_delta_t
{   /* Declarations of ToFAfterFOC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterFOC1_filename;
MCNUM xmin = mccToFAfterFOC1_xmin;
MCNUM xmax = mccToFAfterFOC1_xmax;
MCNUM ymin = mccToFAfterFOC1_ymin;
MCNUM ymax = mccToFAfterFOC1_ymax;
MCNUM xwidth = mccToFAfterFOC1_xwidth;
MCNUM yheight = mccToFAfterFOC1_yheight;
MCNUM tmin = mccToFAfterFOC1_tmin;
MCNUM tmax = mccToFAfterFOC1_tmax;
MCNUM dt = mccToFAfterFOC1_dt;
MCNUM restore_neutron = mccToFAfterFOC1_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 73123 "BIFROST.c"
}   /* End of ToFAfterFOC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monAfterFOC1'. */
  SIG_MESSAGE("L_monAfterFOC1 (Save)");
#define mccompcurname  L_monAfterFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 30
#define nL mccL_monAfterFOC1_nL
#define L_N mccL_monAfterFOC1_L_N
#define L_p mccL_monAfterFOC1_L_p
#define L_p2 mccL_monAfterFOC1_L_p2
{   /* Declarations of L_monAfterFOC1=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterFOC1_filename;
MCNUM xmin = mccL_monAfterFOC1_xmin;
MCNUM xmax = mccL_monAfterFOC1_xmax;
MCNUM ymin = mccL_monAfterFOC1_ymin;
MCNUM ymax = mccL_monAfterFOC1_ymax;
MCNUM xwidth = mccL_monAfterFOC1_xwidth;
MCNUM yheight = mccL_monAfterFOC1_yheight;
MCNUM Lmin = mccL_monAfterFOC1_Lmin;
MCNUM Lmax = mccL_monAfterFOC1_Lmax;
MCNUM restore_neutron = mccL_monAfterFOC1_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 73166 "BIFROST.c"
}   /* End of L_monAfterFOC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monBeforeFOC2'. */
  SIG_MESSAGE("L_monBeforeFOC2 (Save)");
#define mccompcurname  L_monBeforeFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 45
#define nL mccL_monBeforeFOC2_nL
#define L_N mccL_monBeforeFOC2_L_N
#define L_p mccL_monBeforeFOC2_L_p
#define L_p2 mccL_monBeforeFOC2_L_p2
{   /* Declarations of L_monBeforeFOC2=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeFOC2_filename;
MCNUM xmin = mccL_monBeforeFOC2_xmin;
MCNUM xmax = mccL_monBeforeFOC2_xmax;
MCNUM ymin = mccL_monBeforeFOC2_ymin;
MCNUM ymax = mccL_monBeforeFOC2_ymax;
MCNUM xwidth = mccL_monBeforeFOC2_xwidth;
MCNUM yheight = mccL_monBeforeFOC2_yheight;
MCNUM Lmin = mccL_monBeforeFOC2_Lmin;
MCNUM Lmax = mccL_monBeforeFOC2_Lmax;
MCNUM restore_neutron = mccL_monBeforeFOC2_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 73206 "BIFROST.c"
}   /* End of L_monBeforeFOC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFBeforeFOC2'. */
  SIG_MESSAGE("ToFBeforeFOC2 (Save)");
#define mccompcurname  ToFBeforeFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccToFBeforeFOC2_nt
#define TOF_N mccToFBeforeFOC2_TOF_N
#define TOF_p mccToFBeforeFOC2_TOF_p
#define TOF_p2 mccToFBeforeFOC2_TOF_p2
#define t_min mccToFBeforeFOC2_t_min
#define t_max mccToFBeforeFOC2_t_max
#define delta_t mccToFBeforeFOC2_delta_t
{   /* Declarations of ToFBeforeFOC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeFOC2_filename;
MCNUM xmin = mccToFBeforeFOC2_xmin;
MCNUM xmax = mccToFBeforeFOC2_xmax;
MCNUM ymin = mccToFBeforeFOC2_ymin;
MCNUM ymax = mccToFBeforeFOC2_ymax;
MCNUM xwidth = mccToFBeforeFOC2_xwidth;
MCNUM yheight = mccToFBeforeFOC2_yheight;
MCNUM tmin = mccToFBeforeFOC2_tmin;
MCNUM tmax = mccToFBeforeFOC2_tmax;
MCNUM dt = mccToFBeforeFOC2_dt;
MCNUM restore_neutron = mccToFBeforeFOC2_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 73250 "BIFROST.c"
}   /* End of ToFBeforeFOC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_beforeFOC2'. */
  SIG_MESSAGE("PSD_beforeFOC2 (Save)");
#define mccompcurname  PSD_beforeFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 47
#define nx mccPSD_beforeFOC2_nx
#define ny mccPSD_beforeFOC2_ny
#define PSD_N mccPSD_beforeFOC2_PSD_N
#define PSD_p mccPSD_beforeFOC2_PSD_p
#define PSD_p2 mccPSD_beforeFOC2_PSD_p2
{   /* Declarations of PSD_beforeFOC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforeFOC2_filename;
MCNUM xmin = mccPSD_beforeFOC2_xmin;
MCNUM xmax = mccPSD_beforeFOC2_xmax;
MCNUM ymin = mccPSD_beforeFOC2_ymin;
MCNUM ymax = mccPSD_beforeFOC2_ymax;
MCNUM xwidth = mccPSD_beforeFOC2_xwidth;
MCNUM yheight = mccPSD_beforeFOC2_yheight;
MCNUM restore_neutron = mccPSD_beforeFOC2_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 73293 "BIFROST.c"
}   /* End of PSD_beforeFOC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_afterFOC2'. */
  SIG_MESSAGE("PSD_afterFOC2 (Save)");
#define mccompcurname  PSD_afterFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccPSD_afterFOC2_nx
#define ny mccPSD_afterFOC2_ny
#define PSD_N mccPSD_afterFOC2_PSD_N
#define PSD_p mccPSD_afterFOC2_PSD_p
#define PSD_p2 mccPSD_afterFOC2_PSD_p2
{   /* Declarations of PSD_afterFOC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_afterFOC2_filename;
MCNUM xmin = mccPSD_afterFOC2_xmin;
MCNUM xmax = mccPSD_afterFOC2_xmax;
MCNUM ymin = mccPSD_afterFOC2_ymin;
MCNUM ymax = mccPSD_afterFOC2_ymax;
MCNUM xwidth = mccPSD_afterFOC2_xwidth;
MCNUM yheight = mccPSD_afterFOC2_yheight;
MCNUM restore_neutron = mccPSD_afterFOC2_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 73334 "BIFROST.c"
}   /* End of PSD_afterFOC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFAfterFOC2'. */
  SIG_MESSAGE("ToFAfterFOC2 (Save)");
#define mccompcurname  ToFAfterFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 50
#define nt mccToFAfterFOC2_nt
#define TOF_N mccToFAfterFOC2_TOF_N
#define TOF_p mccToFAfterFOC2_TOF_p
#define TOF_p2 mccToFAfterFOC2_TOF_p2
#define t_min mccToFAfterFOC2_t_min
#define t_max mccToFAfterFOC2_t_max
#define delta_t mccToFAfterFOC2_delta_t
{   /* Declarations of ToFAfterFOC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterFOC2_filename;
MCNUM xmin = mccToFAfterFOC2_xmin;
MCNUM xmax = mccToFAfterFOC2_xmax;
MCNUM ymin = mccToFAfterFOC2_ymin;
MCNUM ymax = mccToFAfterFOC2_ymax;
MCNUM xwidth = mccToFAfterFOC2_xwidth;
MCNUM yheight = mccToFAfterFOC2_yheight;
MCNUM tmin = mccToFAfterFOC2_tmin;
MCNUM tmax = mccToFAfterFOC2_tmax;
MCNUM dt = mccToFAfterFOC2_dt;
MCNUM restore_neutron = mccToFAfterFOC2_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 73379 "BIFROST.c"
}   /* End of ToFAfterFOC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monAfterFOC2'. */
  SIG_MESSAGE("L_monAfterFOC2 (Save)");
#define mccompcurname  L_monAfterFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mccL_monAfterFOC2_nL
#define L_N mccL_monAfterFOC2_L_N
#define L_p mccL_monAfterFOC2_L_p
#define L_p2 mccL_monAfterFOC2_L_p2
{   /* Declarations of L_monAfterFOC2=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterFOC2_filename;
MCNUM xmin = mccL_monAfterFOC2_xmin;
MCNUM xmax = mccL_monAfterFOC2_xmax;
MCNUM ymin = mccL_monAfterFOC2_ymin;
MCNUM ymax = mccL_monAfterFOC2_ymax;
MCNUM xwidth = mccL_monAfterFOC2_xwidth;
MCNUM yheight = mccL_monAfterFOC2_yheight;
MCNUM Lmin = mccL_monAfterFOC2_Lmin;
MCNUM Lmax = mccL_monAfterFOC2_Lmax;
MCNUM restore_neutron = mccL_monAfterFOC2_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 73422 "BIFROST.c"
}   /* End of L_monAfterFOC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monBeforeBWC'. */
  SIG_MESSAGE("L_monBeforeBWC (Save)");
#define mccompcurname  L_monBeforeBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 75
#define nL mccL_monBeforeBWC_nL
#define L_N mccL_monBeforeBWC_L_N
#define L_p mccL_monBeforeBWC_L_p
#define L_p2 mccL_monBeforeBWC_L_p2
{   /* Declarations of L_monBeforeBWC=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeBWC_filename;
MCNUM xmin = mccL_monBeforeBWC_xmin;
MCNUM xmax = mccL_monBeforeBWC_xmax;
MCNUM ymin = mccL_monBeforeBWC_ymin;
MCNUM ymax = mccL_monBeforeBWC_ymax;
MCNUM xwidth = mccL_monBeforeBWC_xwidth;
MCNUM yheight = mccL_monBeforeBWC_yheight;
MCNUM Lmin = mccL_monBeforeBWC_Lmin;
MCNUM Lmax = mccL_monBeforeBWC_Lmax;
MCNUM restore_neutron = mccL_monBeforeBWC_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 73462 "BIFROST.c"
}   /* End of L_monBeforeBWC=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFBeforeBWC'. */
  SIG_MESSAGE("ToFBeforeBWC (Save)");
#define mccompcurname  ToFBeforeBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 76
#define nt mccToFBeforeBWC_nt
#define TOF_N mccToFBeforeBWC_TOF_N
#define TOF_p mccToFBeforeBWC_TOF_p
#define TOF_p2 mccToFBeforeBWC_TOF_p2
#define t_min mccToFBeforeBWC_t_min
#define t_max mccToFBeforeBWC_t_max
#define delta_t mccToFBeforeBWC_delta_t
{   /* Declarations of ToFBeforeBWC=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeBWC_filename;
MCNUM xmin = mccToFBeforeBWC_xmin;
MCNUM xmax = mccToFBeforeBWC_xmax;
MCNUM ymin = mccToFBeforeBWC_ymin;
MCNUM ymax = mccToFBeforeBWC_ymax;
MCNUM xwidth = mccToFBeforeBWC_xwidth;
MCNUM yheight = mccToFBeforeBWC_yheight;
MCNUM tmin = mccToFBeforeBWC_tmin;
MCNUM tmax = mccToFBeforeBWC_tmax;
MCNUM dt = mccToFBeforeBWC_dt;
MCNUM restore_neutron = mccToFBeforeBWC_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 73506 "BIFROST.c"
}   /* End of ToFBeforeBWC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'ToFAfterBWC'. */
  SIG_MESSAGE("ToFAfterBWC (Save)");
#define mccompcurname  ToFAfterBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 79
#define nt mccToFAfterBWC_nt
#define TOF_N mccToFAfterBWC_TOF_N
#define TOF_p mccToFAfterBWC_TOF_p
#define TOF_p2 mccToFAfterBWC_TOF_p2
#define t_min mccToFAfterBWC_t_min
#define t_max mccToFAfterBWC_t_max
#define delta_t mccToFAfterBWC_delta_t
{   /* Declarations of ToFAfterBWC=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterBWC_filename;
MCNUM xmin = mccToFAfterBWC_xmin;
MCNUM xmax = mccToFAfterBWC_xmax;
MCNUM ymin = mccToFAfterBWC_ymin;
MCNUM ymax = mccToFAfterBWC_ymax;
MCNUM xwidth = mccToFAfterBWC_xwidth;
MCNUM yheight = mccToFAfterBWC_yheight;
MCNUM tmin = mccToFAfterBWC_tmin;
MCNUM tmax = mccToFAfterBWC_tmax;
MCNUM dt = mccToFAfterBWC_dt;
MCNUM restore_neutron = mccToFAfterBWC_restore_neutron;
#line 114 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
}
#line 73553 "BIFROST.c"
}   /* End of ToFAfterBWC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'L_monAfterBWC'. */
  SIG_MESSAGE("L_monAfterBWC (Save)");
#define mccompcurname  L_monAfterBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 80
#define nL mccL_monAfterBWC_nL
#define L_N mccL_monAfterBWC_L_N
#define L_p mccL_monAfterBWC_L_p
#define L_p2 mccL_monAfterBWC_L_p2
{   /* Declarations of L_monAfterBWC=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterBWC_filename;
MCNUM xmin = mccL_monAfterBWC_xmin;
MCNUM xmax = mccL_monAfterBWC_xmax;
MCNUM ymin = mccL_monAfterBWC_ymin;
MCNUM ymax = mccL_monAfterBWC_ymax;
MCNUM xwidth = mccL_monAfterBWC_xwidth;
MCNUM yheight = mccL_monAfterBWC_yheight;
MCNUM Lmin = mccL_monAfterBWC_Lmin;
MCNUM Lmax = mccL_monAfterBWC_Lmax;
MCNUM restore_neutron = mccL_monAfterBWC_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 73596 "BIFROST.c"
}   /* End of L_monAfterBWC=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'VirtualOutput'. */
  SIG_MESSAGE("VirtualOutput (Save)");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 91
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
#line 139 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\Virtual_output.comp"
{

  Monitor_nD_Save(&DEFS, &Vars);

}
#line 73622 "BIFROST.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Lmon_guide_end'. */
  SIG_MESSAGE("Lmon_guide_end (Save)");
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
{   /* Declarations of Lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mccLmon_guide_end_filename;
MCNUM xmin = mccLmon_guide_end_xmin;
MCNUM xmax = mccLmon_guide_end_xmax;
MCNUM ymin = mccLmon_guide_end_ymin;
MCNUM ymax = mccLmon_guide_end_ymax;
MCNUM xwidth = mccLmon_guide_end_xwidth;
MCNUM yheight = mccLmon_guide_end_yheight;
MCNUM Lmin = mccLmon_guide_end_Lmin;
MCNUM Lmax = mccLmon_guide_end_Lmax;
MCNUM restore_neutron = mccLmon_guide_end_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 73660 "BIFROST.c"
}   /* End of Lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Div2d_sample_B'. */
  SIG_MESSAGE("Div2d_sample_B (Save)");
#define mccompcurname  Div2d_sample_B
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 94
#define nh mccDiv2d_sample_B_nh
#define nv mccDiv2d_sample_B_nv
#define Div_N mccDiv2d_sample_B_Div_N
#define Div_p mccDiv2d_sample_B_Div_p
#define Div_p2 mccDiv2d_sample_B_Div_p2
{   /* Declarations of Div2d_sample_B=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_B_filename;
MCNUM xmin = mccDiv2d_sample_B_xmin;
MCNUM xmax = mccDiv2d_sample_B_xmax;
MCNUM ymin = mccDiv2d_sample_B_ymin;
MCNUM ymax = mccDiv2d_sample_B_ymax;
MCNUM xwidth = mccDiv2d_sample_B_xwidth;
MCNUM yheight = mccDiv2d_sample_B_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_B_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_B_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_B_restore_neutron;
MCNUM nx = mccDiv2d_sample_B_nx;
MCNUM ny = mccDiv2d_sample_B_ny;
MCNUM nz = mccDiv2d_sample_B_nz;
#line 116 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    DETECTOR_OUT_2D(
        "Divergence monitor",
        "X divergence [deg]",
        "Y divergence [deg]",
        -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
        nh, nv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
}
#line 73705 "BIFROST.c"
}   /* End of Div2d_sample_B=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Div2d_sample'. */
  SIG_MESSAGE("Div2d_sample (Save)");
#define mccompcurname  Div2d_sample
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 95
#define nh mccDiv2d_sample_nh
#define nv mccDiv2d_sample_nv
#define Div_N mccDiv2d_sample_Div_N
#define Div_p mccDiv2d_sample_Div_p
#define Div_p2 mccDiv2d_sample_Div_p2
{   /* Declarations of Div2d_sample=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_filename;
MCNUM xmin = mccDiv2d_sample_xmin;
MCNUM xmax = mccDiv2d_sample_xmax;
MCNUM ymin = mccDiv2d_sample_ymin;
MCNUM ymax = mccDiv2d_sample_ymax;
MCNUM xwidth = mccDiv2d_sample_xwidth;
MCNUM yheight = mccDiv2d_sample_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_restore_neutron;
MCNUM nx = mccDiv2d_sample_nx;
MCNUM ny = mccDiv2d_sample_ny;
MCNUM nz = mccDiv2d_sample_nz;
#line 116 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    DETECTOR_OUT_2D(
        "Divergence monitor",
        "X divergence [deg]",
        "Y divergence [deg]",
        -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
        nh, nv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
}
#line 73751 "BIFROST.c"
}   /* End of Div2d_sample=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_sample'. */
  SIG_MESSAGE("PSD_sample (Save)");
#define mccompcurname  PSD_sample
#define mccompcurtype  PSD_monitor
#define mccompcurindex 96
#define nx mccPSD_sample_nx
#define ny mccPSD_sample_ny
#define PSD_N mccPSD_sample_PSD_N
#define PSD_p mccPSD_sample_PSD_p
#define PSD_p2 mccPSD_sample_PSD_p2
{   /* Declarations of PSD_sample=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_sample_filename;
MCNUM xmin = mccPSD_sample_xmin;
MCNUM xmax = mccPSD_sample_xmax;
MCNUM ymin = mccPSD_sample_ymin;
MCNUM ymax = mccPSD_sample_ymax;
MCNUM xwidth = mccPSD_sample_xwidth;
MCNUM yheight = mccPSD_sample_yheight;
MCNUM restore_neutron = mccPSD_sample_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 73792 "BIFROST.c"
}   /* End of PSD_sample=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'HPSD_sample'. */
  SIG_MESSAGE("HPSD_sample (Save)");
#define mccompcurname  HPSD_sample
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 97
#define nx mccHPSD_sample_nx
#define PSDlin_N mccHPSD_sample_PSDlin_N
#define PSDlin_p mccHPSD_sample_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_PSDlin_p2
{   /* Declarations of HPSD_sample=PSDlin_monitor() SETTING parameters. */
char* filename = mccHPSD_sample_filename;
MCNUM xmin = mccHPSD_sample_xmin;
MCNUM xmax = mccHPSD_sample_xmax;
MCNUM ymin = mccHPSD_sample_ymin;
MCNUM ymax = mccHPSD_sample_ymax;
MCNUM xwidth = mccHPSD_sample_xwidth;
MCNUM yheight = mccHPSD_sample_yheight;
MCNUM restore_neutron = mccHPSD_sample_restore_neutron;
#line 102 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Linear PSD monitor",
        "x-Position [m]",
        "Intensity",
        "x", xmin, xmax, nx,
        &PSDlin_N[0],&PSDlin_p[0],&PSDlin_p2[0],
        filename);
}
#line 73831 "BIFROST.c"
}   /* End of HPSD_sample=PSDlin_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'VPSD_sample'. */
  SIG_MESSAGE("VPSD_sample (Save)");
#define mccompcurname  VPSD_sample
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 98
#define ny mccVPSD_sample_ny
#define filename mccVPSD_sample_filename
#define PSDlin_N mccVPSD_sample_PSDlin_N
#define PSDlin_p mccVPSD_sample_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_PSDlin_p2
{   /* Declarations of VPSD_sample=PSDlin_y_monitor() SETTING parameters. */
MCNUM xmin = mccVPSD_sample_xmin;
MCNUM xmax = mccVPSD_sample_xmax;
MCNUM ymin = mccVPSD_sample_ymin;
MCNUM ymax = mccVPSD_sample_ymax;
MCNUM xwidth = mccVPSD_sample_xwidth;
MCNUM yheight = mccVPSD_sample_yheight;
MCNUM restore_neutron = mccVPSD_sample_restore_neutron;
#line 98 "PSDlin_y_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Linear PSD (y) monitor",
        "y-Position [m]",
        "Intensity",
        "y", ymin, ymax, ny,
        &PSDlin_N[0],&PSDlin_p[0],&PSDlin_p2[0],
        filename);
}
#line 73869 "BIFROST.c"
}   /* End of VPSD_sample=PSDlin_y_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Hdiv_sample'. */
  SIG_MESSAGE("Hdiv_sample (Save)");
#define mccompcurname  Hdiv_sample
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 99
#define nh mccHdiv_sample_nh
#define Div_N mccHdiv_sample_Div_N
#define Div_p mccHdiv_sample_Div_p
#define Div_p2 mccHdiv_sample_Div_p2
{   /* Declarations of Hdiv_sample=Hdiv_monitor() SETTING parameters. */
char* filename = mccHdiv_sample_filename;
MCNUM xmin = mccHdiv_sample_xmin;
MCNUM xmax = mccHdiv_sample_xmax;
MCNUM ymin = mccHdiv_sample_ymin;
MCNUM ymax = mccHdiv_sample_ymax;
MCNUM xwidth = mccHdiv_sample_xwidth;
MCNUM yheight = mccHdiv_sample_yheight;
MCNUM h_maxdiv = mccHdiv_sample_h_maxdiv;
MCNUM restore_neutron = mccHdiv_sample_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
    DETECTOR_OUT_1D(
        "horizontal divergence monitor",
        "horizontal divergence [deg]",
        "Intensity",
        "divergence", -h_maxdiv, h_maxdiv, nh,
        &Div_N[0],&Div_p[0],&Div_p2[0],
        filename);
}
#line 73909 "BIFROST.c"
}   /* End of Hdiv_sample=Hdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Vdiv_sample'. */
  SIG_MESSAGE("Vdiv_sample (Save)");
#define mccompcurname  Vdiv_sample
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 100
#define nv mccVdiv_sample_nv
#define filename mccVdiv_sample_filename
#define restore_neutron mccVdiv_sample_restore_neutron
#define Div_N mccVdiv_sample_Div_N
#define Div_p mccVdiv_sample_Div_p
#define Div_p2 mccVdiv_sample_Div_p2
{   /* Declarations of Vdiv_sample=Vdiv_monitor() SETTING parameters. */
MCNUM xmin = mccVdiv_sample_xmin;
MCNUM xmax = mccVdiv_sample_xmax;
MCNUM ymin = mccVdiv_sample_ymin;
MCNUM ymax = mccVdiv_sample_ymax;
MCNUM xwidth = mccVdiv_sample_xwidth;
MCNUM yheight = mccVdiv_sample_yheight;
MCNUM v_maxdiv = mccVdiv_sample_v_maxdiv;
#line 109 "Vdiv_monitor.comp"
{
    DETECTOR_OUT_1D(
        "vertical divergence monitor",
        "vertical divergence [deg]",
        "Intensity",
        "divergence", -v_maxdiv, v_maxdiv, nv,
        &Div_N[0],&Div_p[0],&Div_p2[0],
        filename);
}
#line 73948 "BIFROST.c"
}   /* End of Vdiv_sample=Vdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'acceptance_x_divx'. */
  SIG_MESSAGE("acceptance_x_divx (Save)");
#define mccompcurname  acceptance_x_divx
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 101
#define nh mccacceptance_x_divx_nh
#define ndiv mccacceptance_x_divx_ndiv
#define Div_N mccacceptance_x_divx_Div_N
#define Div_p mccacceptance_x_divx_Div_p
#define Div_p2 mccacceptance_x_divx_Div_p2
{   /* Declarations of acceptance_x_divx=DivPos_monitor() SETTING parameters. */
char* filename = mccacceptance_x_divx_filename;
MCNUM xmin = mccacceptance_x_divx_xmin;
MCNUM xmax = mccacceptance_x_divx_xmax;
MCNUM ymin = mccacceptance_x_divx_ymin;
MCNUM ymax = mccacceptance_x_divx_ymax;
MCNUM xwidth = mccacceptance_x_divx_xwidth;
MCNUM yheight = mccacceptance_x_divx_yheight;
MCNUM maxdiv_h = mccacceptance_x_divx_maxdiv_h;
MCNUM restore_neutron = mccacceptance_x_divx_restore_neutron;
MCNUM nx = mccacceptance_x_divx_nx;
MCNUM ny = mccacceptance_x_divx_ny;
MCNUM nz = mccacceptance_x_divx_nz;
#line 119 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
    DETECTOR_OUT_2D(
        "Position-divergence monitor",
        "pos [m]",
        "divergence [deg]",
        xmin, xmax, -maxdiv_h, maxdiv_h,
        nh, ndiv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
}
#line 73994 "BIFROST.c"
}   /* End of acceptance_x_divx=DivPos_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'acceptance_y_divy'. */
  SIG_MESSAGE("acceptance_y_divy (Save)");
#define mccompcurname  acceptance_y_divy
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 102
#define npos mccacceptance_y_divy_npos
#define ndiv mccacceptance_y_divy_ndiv
#define filename mccacceptance_y_divy_filename
#define restore_neutron mccacceptance_y_divy_restore_neutron
#define Div_N mccacceptance_y_divy_Div_N
#define Div_p mccacceptance_y_divy_Div_p
#define Div_p2 mccacceptance_y_divy_Div_p2
{   /* Declarations of acceptance_y_divy=DivPos_y_monitor() SETTING parameters. */
MCNUM xmin = mccacceptance_y_divy_xmin;
MCNUM xmax = mccacceptance_y_divy_xmax;
MCNUM ymin = mccacceptance_y_divy_ymin;
MCNUM ymax = mccacceptance_y_divy_ymax;
MCNUM xwidth = mccacceptance_y_divy_xwidth;
MCNUM yheight = mccacceptance_y_divy_yheight;
MCNUM maxdiv = mccacceptance_y_divy_maxdiv;
#line 108 "DivPos_y_monitor.comp"
{
    DETECTOR_OUT_2D(
        "Position-divergence (y) monitor",
        "pos [m]",
        "divergence [deg]",
        ymin, ymax, -maxdiv, maxdiv,
        npos, ndiv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
}
#line 74036 "BIFROST.c"
}   /* End of acceptance_y_divy=DivPos_y_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Lmon_sample_B'. */
  SIG_MESSAGE("Lmon_sample_B (Save)");
#define mccompcurname  Lmon_sample_B
#define mccompcurtype  L_monitor
#define mccompcurindex 103
#define nL mccLmon_sample_B_nL
#define L_N mccLmon_sample_B_L_N
#define L_p mccLmon_sample_B_L_p
#define L_p2 mccLmon_sample_B_L_p2
{   /* Declarations of Lmon_sample_B=L_monitor() SETTING parameters. */
char* filename = mccLmon_sample_B_filename;
MCNUM xmin = mccLmon_sample_B_xmin;
MCNUM xmax = mccLmon_sample_B_xmax;
MCNUM ymin = mccLmon_sample_B_ymin;
MCNUM ymax = mccLmon_sample_B_ymax;
MCNUM xwidth = mccLmon_sample_B_xwidth;
MCNUM yheight = mccLmon_sample_B_yheight;
MCNUM Lmin = mccLmon_sample_B_Lmin;
MCNUM Lmax = mccLmon_sample_B_Lmax;
MCNUM restore_neutron = mccLmon_sample_B_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 74079 "BIFROST.c"
}   /* End of Lmon_sample_B=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Div2d_sample_maxdiv'. */
  SIG_MESSAGE("Div2d_sample_maxdiv (Save)");
#define mccompcurname  Div2d_sample_maxdiv
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 104
#define nh mccDiv2d_sample_maxdiv_nh
#define nv mccDiv2d_sample_maxdiv_nv
#define Div_N mccDiv2d_sample_maxdiv_Div_N
#define Div_p mccDiv2d_sample_maxdiv_Div_p
#define Div_p2 mccDiv2d_sample_maxdiv_Div_p2
{   /* Declarations of Div2d_sample_maxdiv=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_maxdiv_filename;
MCNUM xmin = mccDiv2d_sample_maxdiv_xmin;
MCNUM xmax = mccDiv2d_sample_maxdiv_xmax;
MCNUM ymin = mccDiv2d_sample_maxdiv_ymin;
MCNUM ymax = mccDiv2d_sample_maxdiv_ymax;
MCNUM xwidth = mccDiv2d_sample_maxdiv_xwidth;
MCNUM yheight = mccDiv2d_sample_maxdiv_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_maxdiv_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_maxdiv_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_maxdiv_restore_neutron;
MCNUM nx = mccDiv2d_sample_maxdiv_nx;
MCNUM ny = mccDiv2d_sample_maxdiv_ny;
MCNUM nz = mccDiv2d_sample_maxdiv_nz;
#line 116 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    DETECTOR_OUT_2D(
        "Divergence monitor",
        "X divergence [deg]",
        "Y divergence [deg]",
        -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
        nh, nv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
}
#line 74124 "BIFROST.c"
}   /* End of Div2d_sample_maxdiv=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_sample_maxdiv'. */
  SIG_MESSAGE("PSD_sample_maxdiv (Save)");
#define mccompcurname  PSD_sample_maxdiv
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define nx mccPSD_sample_maxdiv_nx
#define ny mccPSD_sample_maxdiv_ny
#define PSD_N mccPSD_sample_maxdiv_PSD_N
#define PSD_p mccPSD_sample_maxdiv_PSD_p
#define PSD_p2 mccPSD_sample_maxdiv_PSD_p2
{   /* Declarations of PSD_sample_maxdiv=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_sample_maxdiv_filename;
MCNUM xmin = mccPSD_sample_maxdiv_xmin;
MCNUM xmax = mccPSD_sample_maxdiv_xmax;
MCNUM ymin = mccPSD_sample_maxdiv_ymin;
MCNUM ymax = mccPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccPSD_sample_maxdiv_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 74165 "BIFROST.c"
}   /* End of PSD_sample_maxdiv=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'HPSD_sample_maxdiv'. */
  SIG_MESSAGE("HPSD_sample_maxdiv (Save)");
#define mccompcurname  HPSD_sample_maxdiv
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 106
#define nx mccHPSD_sample_maxdiv_nx
#define PSDlin_N mccHPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccHPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_maxdiv_PSDlin_p2
{   /* Declarations of HPSD_sample_maxdiv=PSDlin_monitor() SETTING parameters. */
char* filename = mccHPSD_sample_maxdiv_filename;
MCNUM xmin = mccHPSD_sample_maxdiv_xmin;
MCNUM xmax = mccHPSD_sample_maxdiv_xmax;
MCNUM ymin = mccHPSD_sample_maxdiv_ymin;
MCNUM ymax = mccHPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccHPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccHPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccHPSD_sample_maxdiv_restore_neutron;
#line 102 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Linear PSD monitor",
        "x-Position [m]",
        "Intensity",
        "x", xmin, xmax, nx,
        &PSDlin_N[0],&PSDlin_p[0],&PSDlin_p2[0],
        filename);
}
#line 74204 "BIFROST.c"
}   /* End of HPSD_sample_maxdiv=PSDlin_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'VPSD_sample_maxdiv'. */
  SIG_MESSAGE("VPSD_sample_maxdiv (Save)");
#define mccompcurname  VPSD_sample_maxdiv
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 107
#define ny mccVPSD_sample_maxdiv_ny
#define filename mccVPSD_sample_maxdiv_filename
#define PSDlin_N mccVPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccVPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_maxdiv_PSDlin_p2
{   /* Declarations of VPSD_sample_maxdiv=PSDlin_y_monitor() SETTING parameters. */
MCNUM xmin = mccVPSD_sample_maxdiv_xmin;
MCNUM xmax = mccVPSD_sample_maxdiv_xmax;
MCNUM ymin = mccVPSD_sample_maxdiv_ymin;
MCNUM ymax = mccVPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccVPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccVPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccVPSD_sample_maxdiv_restore_neutron;
#line 98 "PSDlin_y_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Linear PSD (y) monitor",
        "y-Position [m]",
        "Intensity",
        "y", ymin, ymax, ny,
        &PSDlin_N[0],&PSDlin_p[0],&PSDlin_p2[0],
        filename);
}
#line 74242 "BIFROST.c"
}   /* End of VPSD_sample_maxdiv=PSDlin_y_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Hdiv_sample_maxdiv'. */
  SIG_MESSAGE("Hdiv_sample_maxdiv (Save)");
#define mccompcurname  Hdiv_sample_maxdiv
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 108
#define nh mccHdiv_sample_maxdiv_nh
#define Div_N mccHdiv_sample_maxdiv_Div_N
#define Div_p mccHdiv_sample_maxdiv_Div_p
#define Div_p2 mccHdiv_sample_maxdiv_Div_p2
{   /* Declarations of Hdiv_sample_maxdiv=Hdiv_monitor() SETTING parameters. */
char* filename = mccHdiv_sample_maxdiv_filename;
MCNUM xmin = mccHdiv_sample_maxdiv_xmin;
MCNUM xmax = mccHdiv_sample_maxdiv_xmax;
MCNUM ymin = mccHdiv_sample_maxdiv_ymin;
MCNUM ymax = mccHdiv_sample_maxdiv_ymax;
MCNUM xwidth = mccHdiv_sample_maxdiv_xwidth;
MCNUM yheight = mccHdiv_sample_maxdiv_yheight;
MCNUM h_maxdiv = mccHdiv_sample_maxdiv_h_maxdiv;
MCNUM restore_neutron = mccHdiv_sample_maxdiv_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
    DETECTOR_OUT_1D(
        "horizontal divergence monitor",
        "horizontal divergence [deg]",
        "Intensity",
        "divergence", -h_maxdiv, h_maxdiv, nh,
        &Div_N[0],&Div_p[0],&Div_p2[0],
        filename);
}
#line 74282 "BIFROST.c"
}   /* End of Hdiv_sample_maxdiv=Hdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Vdiv_sample_maxdiv'. */
  SIG_MESSAGE("Vdiv_sample_maxdiv (Save)");
#define mccompcurname  Vdiv_sample_maxdiv
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 109
#define nv mccVdiv_sample_maxdiv_nv
#define filename mccVdiv_sample_maxdiv_filename
#define restore_neutron mccVdiv_sample_maxdiv_restore_neutron
#define Div_N mccVdiv_sample_maxdiv_Div_N
#define Div_p mccVdiv_sample_maxdiv_Div_p
#define Div_p2 mccVdiv_sample_maxdiv_Div_p2
{   /* Declarations of Vdiv_sample_maxdiv=Vdiv_monitor() SETTING parameters. */
MCNUM xmin = mccVdiv_sample_maxdiv_xmin;
MCNUM xmax = mccVdiv_sample_maxdiv_xmax;
MCNUM ymin = mccVdiv_sample_maxdiv_ymin;
MCNUM ymax = mccVdiv_sample_maxdiv_ymax;
MCNUM xwidth = mccVdiv_sample_maxdiv_xwidth;
MCNUM yheight = mccVdiv_sample_maxdiv_yheight;
MCNUM v_maxdiv = mccVdiv_sample_maxdiv_v_maxdiv;
#line 109 "Vdiv_monitor.comp"
{
    DETECTOR_OUT_1D(
        "vertical divergence monitor",
        "vertical divergence [deg]",
        "Intensity",
        "divergence", -v_maxdiv, v_maxdiv, nv,
        &Div_N[0],&Div_p[0],&Div_p2[0],
        filename);
}
#line 74321 "BIFROST.c"
}   /* End of Vdiv_sample_maxdiv=Vdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'acceptance_x_divx_maxdiv'. */
  SIG_MESSAGE("acceptance_x_divx_maxdiv (Save)");
#define mccompcurname  acceptance_x_divx_maxdiv
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 110
#define nh mccacceptance_x_divx_maxdiv_nh
#define ndiv mccacceptance_x_divx_maxdiv_ndiv
#define Div_N mccacceptance_x_divx_maxdiv_Div_N
#define Div_p mccacceptance_x_divx_maxdiv_Div_p
#define Div_p2 mccacceptance_x_divx_maxdiv_Div_p2
{   /* Declarations of acceptance_x_divx_maxdiv=DivPos_monitor() SETTING parameters. */
char* filename = mccacceptance_x_divx_maxdiv_filename;
MCNUM xmin = mccacceptance_x_divx_maxdiv_xmin;
MCNUM xmax = mccacceptance_x_divx_maxdiv_xmax;
MCNUM ymin = mccacceptance_x_divx_maxdiv_ymin;
MCNUM ymax = mccacceptance_x_divx_maxdiv_ymax;
MCNUM xwidth = mccacceptance_x_divx_maxdiv_xwidth;
MCNUM yheight = mccacceptance_x_divx_maxdiv_yheight;
MCNUM maxdiv_h = mccacceptance_x_divx_maxdiv_maxdiv_h;
MCNUM restore_neutron = mccacceptance_x_divx_maxdiv_restore_neutron;
MCNUM nx = mccacceptance_x_divx_maxdiv_nx;
MCNUM ny = mccacceptance_x_divx_maxdiv_ny;
MCNUM nz = mccacceptance_x_divx_maxdiv_nz;
#line 119 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
    DETECTOR_OUT_2D(
        "Position-divergence monitor",
        "pos [m]",
        "divergence [deg]",
        xmin, xmax, -maxdiv_h, maxdiv_h,
        nh, ndiv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
}
#line 74367 "BIFROST.c"
}   /* End of acceptance_x_divx_maxdiv=DivPos_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'acceptance_y_divy_maxdiv'. */
  SIG_MESSAGE("acceptance_y_divy_maxdiv (Save)");
#define mccompcurname  acceptance_y_divy_maxdiv
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 111
#define npos mccacceptance_y_divy_maxdiv_npos
#define ndiv mccacceptance_y_divy_maxdiv_ndiv
#define filename mccacceptance_y_divy_maxdiv_filename
#define restore_neutron mccacceptance_y_divy_maxdiv_restore_neutron
#define Div_N mccacceptance_y_divy_maxdiv_Div_N
#define Div_p mccacceptance_y_divy_maxdiv_Div_p
#define Div_p2 mccacceptance_y_divy_maxdiv_Div_p2
{   /* Declarations of acceptance_y_divy_maxdiv=DivPos_y_monitor() SETTING parameters. */
MCNUM xmin = mccacceptance_y_divy_maxdiv_xmin;
MCNUM xmax = mccacceptance_y_divy_maxdiv_xmax;
MCNUM ymin = mccacceptance_y_divy_maxdiv_ymin;
MCNUM ymax = mccacceptance_y_divy_maxdiv_ymax;
MCNUM xwidth = mccacceptance_y_divy_maxdiv_xwidth;
MCNUM yheight = mccacceptance_y_divy_maxdiv_yheight;
MCNUM maxdiv = mccacceptance_y_divy_maxdiv_maxdiv;
#line 108 "DivPos_y_monitor.comp"
{
    DETECTOR_OUT_2D(
        "Position-divergence (y) monitor",
        "pos [m]",
        "divergence [deg]",
        ymin, ymax, -maxdiv, maxdiv,
        npos, ndiv,
        &Div_N[0][0],&Div_p[0][0],&Div_p2[0][0],
        filename);
}
#line 74409 "BIFROST.c"
}   /* End of acceptance_y_divy_maxdiv=DivPos_y_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Lmon_sample'. */
  SIG_MESSAGE("Lmon_sample (Save)");
#define mccompcurname  Lmon_sample
#define mccompcurtype  L_monitor
#define mccompcurindex 112
#define nL mccLmon_sample_nL
#define L_N mccLmon_sample_L_N
#define L_p mccLmon_sample_L_p
#define L_p2 mccLmon_sample_L_p2
{   /* Declarations of Lmon_sample=L_monitor() SETTING parameters. */
char* filename = mccLmon_sample_filename;
MCNUM xmin = mccLmon_sample_xmin;
MCNUM xmax = mccLmon_sample_xmax;
MCNUM ymin = mccLmon_sample_ymin;
MCNUM ymax = mccLmon_sample_ymax;
MCNUM xwidth = mccLmon_sample_xwidth;
MCNUM yheight = mccLmon_sample_yheight;
MCNUM Lmin = mccLmon_sample_Lmin;
MCNUM Lmax = mccLmon_sample_Lmax;
MCNUM restore_neutron = mccLmon_sample_restore_neutron;
#line 106 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
}
#line 74452 "BIFROST.c"
}   /* End of Lmon_sample=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'psd_monitor'. */
  SIG_MESSAGE("psd_monitor (Save)");
#define mccompcurname  psd_monitor
#define mccompcurtype  PSD_monitor
#define mccompcurindex 124
#define nx mccpsd_monitor_nx
#define ny mccpsd_monitor_ny
#define PSD_N mccpsd_monitor_PSD_N
#define PSD_p mccpsd_monitor_PSD_p
#define PSD_p2 mccpsd_monitor_PSD_p2
{   /* Declarations of psd_monitor=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_monitor_filename;
MCNUM xmin = mccpsd_monitor_xmin;
MCNUM xmax = mccpsd_monitor_xmax;
MCNUM ymin = mccpsd_monitor_ymin;
MCNUM ymax = mccpsd_monitor_ymax;
MCNUM xwidth = mccpsd_monitor_xwidth;
MCNUM yheight = mccpsd_monitor_yheight;
MCNUM restore_neutron = mccpsd_monitor_restore_neutron;
#line 100 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
    DETECTOR_OUT_2D(
        "PSD monitor",
        "X position [cm]",
        "Y position [cm]",
        xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
        nx, ny,
        &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
        filename);
}
#line 74492 "BIFROST.c"
}   /* End of psd_monitor=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'e_monitor'. */
  SIG_MESSAGE("e_monitor (Save)");
#define mccompcurname  e_monitor
#define mccompcurtype  E_monitor
#define mccompcurindex 125
#define nE mcce_monitor_nE
#define E_N mcce_monitor_E_N
#define E_p mcce_monitor_E_p
#define E_p2 mcce_monitor_E_p2
#define S_p mcce_monitor_S_p
#define S_pE mcce_monitor_S_pE
#define S_pE2 mcce_monitor_S_pE2
{   /* Declarations of e_monitor=E_monitor() SETTING parameters. */
char* filename = mcce_monitor_filename;
MCNUM xmin = mcce_monitor_xmin;
MCNUM xmax = mcce_monitor_xmax;
MCNUM ymin = mcce_monitor_ymin;
MCNUM ymax = mcce_monitor_ymax;
MCNUM xwidth = mcce_monitor_xwidth;
MCNUM yheight = mcce_monitor_yheight;
MCNUM Emin = mcce_monitor_Emin;
MCNUM Emax = mcce_monitor_Emax;
MCNUM restore_neutron = mcce_monitor_restore_neutron;
#line 116 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\E_monitor.comp"
{
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
}
#line 74538 "BIFROST.c"
}   /* End of e_monitor=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  if (!handle) mcsiminfo_close(); 
} /* end save */
void mcfinally(void) {
  /* User component FINALLY code. */
  mcsiminfo_init(NULL);
  mcsave(mcsiminfo_file); /* save data when simulation ends */

  /* User FINALLY code for component 'Origin'. */
  SIG_MESSAGE("Origin (Finally)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 133 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\misc\\Progress_bar.comp"
{
  time_t NowTime;
  time(&NowTime);
  fprintf(stdout, "\nFinally [%s: %s]. Time: ", mcinstrument_name, mcdirname ? mcdirname : ".");
  if (difftime(NowTime,StartTime) < 60.0)
    fprintf(stdout, "%g [s] ", difftime(NowTime,StartTime));
  else if (difftime(NowTime,StartTime) > 3600.0)
    fprintf(stdout, "%g [h] ", difftime(NowTime,StartTime)/3660.0);
  else
    fprintf(stdout, "%g [min] ", difftime(NowTime,StartTime)/60.0);
  fprintf(stdout, "\n");
}
#line 74585 "BIFROST.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[1]) fprintf(stderr, "Warning: No neutron could reach Component[1] Origin\n");
    if (mcAbsorbProp[1]) fprintf(stderr, "Warning: %g events were removed in Component[1] Origin=Progress_bar()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[1]);
    if (!mcNCounter[2]) fprintf(stderr, "Warning: No neutron could reach Component[2] ESS_source\n");
    if (mcAbsorbProp[2]) fprintf(stderr, "Warning: %g events were removed in Component[2] ESS_source=ESS_butterfly()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[2]);
    if (!mcNCounter[3]) fprintf(stderr, "Warning: No neutron could reach Component[3] StartOfGuide\n");
    if (mcAbsorbProp[3]) fprintf(stderr, "Warning: %g events were removed in Component[3] StartOfGuide=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[3]);
    if (!mcNCounter[4]) fprintf(stderr, "Warning: No neutron could reach Component[4] NBOA\n");
    if (mcAbsorbProp[4]) fprintf(stderr, "Warning: %g events were removed in Component[4] NBOA=Elliptic_guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[4]);
    if (!mcNCounter[5]) fprintf(stderr, "Warning: No neutron could reach Component[5] EndOfelement_6\n");
    if (mcAbsorbProp[5]) fprintf(stderr, "Warning: %g events were removed in Component[5] EndOfelement_6=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[5]);
    if (!mcNCounter[6]) fprintf(stderr, "Warning: No neutron could reach Component[6] L_monBeforePSC1\n");
    if (mcAbsorbProp[6]) fprintf(stderr, "Warning: %g events were removed in Component[6] L_monBeforePSC1=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[6]);
    if (!mcNCounter[7]) fprintf(stderr, "Warning: No neutron could reach Component[7] ToFBeforerPSC1\n");
    if (mcAbsorbProp[7]) fprintf(stderr, "Warning: %g events were removed in Component[7] ToFBeforerPSC1=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[7]);
    if (!mcNCounter[8]) fprintf(stderr, "Warning: No neutron could reach Component[8] PSD_beforePulseShapping1\n");
    if (mcAbsorbProp[8]) fprintf(stderr, "Warning: %g events were removed in Component[8] PSD_beforePulseShapping1=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[8]);
    if (!mcNCounter[9]) fprintf(stderr, "Warning: No neutron could reach Component[9] TofLambdaBeforePSC\n");
    if (mcAbsorbProp[9]) fprintf(stderr, "Warning: %g events were removed in Component[9] TofLambdaBeforePSC=TOFLambda_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[9]);
    if (!mcNCounter[10]) fprintf(stderr, "Warning: No neutron could reach Component[10] PulseShapingChopper\n");
    if (mcAbsorbProp[10]) fprintf(stderr, "Warning: %g events were removed in Component[10] PulseShapingChopper=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[10]);
    if (!mcNCounter[11]) fprintf(stderr, "Warning: No neutron could reach Component[11] PSD_AfterPulseShapping1\n");
    if (mcAbsorbProp[11]) fprintf(stderr, "Warning: %g events were removed in Component[11] PSD_AfterPulseShapping1=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[11]);
    if (!mcNCounter[12]) fprintf(stderr, "Warning: No neutron could reach Component[12] ToFInsidePSC\n");
    if (mcAbsorbProp[12]) fprintf(stderr, "Warning: %g events were removed in Component[12] ToFInsidePSC=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[12]);
    if (!mcNCounter[13]) fprintf(stderr, "Warning: No neutron could reach Component[13] PulseShapingChopper2\n");
    if (mcAbsorbProp[13]) fprintf(stderr, "Warning: %g events were removed in Component[13] PulseShapingChopper2=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[13]);
    if (!mcNCounter[14]) fprintf(stderr, "Warning: No neutron could reach Component[14] TofLambdaAfterPSC2\n");
    if (mcAbsorbProp[14]) fprintf(stderr, "Warning: %g events were removed in Component[14] TofLambdaAfterPSC2=TOFLambda_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[14]);
    if (!mcNCounter[15]) fprintf(stderr, "Warning: No neutron could reach Component[15] PSD_AfterPSC2\n");
    if (mcAbsorbProp[15]) fprintf(stderr, "Warning: %g events were removed in Component[15] PSD_AfterPSC2=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[15]);
    if (!mcNCounter[16]) fprintf(stderr, "Warning: No neutron could reach Component[16] ToFAfterPSC2\n");
    if (mcAbsorbProp[16]) fprintf(stderr, "Warning: %g events were removed in Component[16] ToFAfterPSC2=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[16]);
    if (!mcNCounter[17]) fprintf(stderr, "Warning: No neutron could reach Component[17] L_monAfterPSC2\n");
    if (mcAbsorbProp[17]) fprintf(stderr, "Warning: %g events were removed in Component[17] L_monAfterPSC2=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[17]);
    if (!mcNCounter[18]) fprintf(stderr, "Warning: No neutron could reach Component[18] EndOfelement_5\n");
    if (mcAbsorbProp[18]) fprintf(stderr, "Warning: %g events were removed in Component[18] EndOfelement_5=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[18]);
  /* User FINALLY code for component 'curved_guide_1_0'. */
  SIG_MESSAGE("curved_guide_1_0 (Finally)");
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
{   /* Declarations of curved_guide_1_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_1_0_w1;
MCNUM h1 = mcccurved_guide_1_0_h1;
MCNUM w2 = mcccurved_guide_1_0_w2;
MCNUM h2 = mcccurved_guide_1_0_h2;
MCNUM l = mcccurved_guide_1_0_l;
MCNUM R0 = mcccurved_guide_1_0_R0;
MCNUM Qc = mcccurved_guide_1_0_Qc;
MCNUM alpha = mcccurved_guide_1_0_alpha;
MCNUM m = mcccurved_guide_1_0_m;
MCNUM W = mcccurved_guide_1_0_W;
MCNUM nslit = mcccurved_guide_1_0_nslit;
MCNUM d = mcccurved_guide_1_0_d;
MCNUM mleft = mcccurved_guide_1_0_mleft;
MCNUM mright = mcccurved_guide_1_0_mright;
MCNUM mtop = mcccurved_guide_1_0_mtop;
MCNUM mbottom = mcccurved_guide_1_0_mbottom;
MCNUM nhslit = mcccurved_guide_1_0_nhslit;
MCNUM G = mcccurved_guide_1_0_G;
MCNUM aleft = mcccurved_guide_1_0_aleft;
MCNUM aright = mcccurved_guide_1_0_aright;
MCNUM atop = mcccurved_guide_1_0_atop;
MCNUM abottom = mcccurved_guide_1_0_abottom;
MCNUM wavy = mcccurved_guide_1_0_wavy;
MCNUM wavy_z = mcccurved_guide_1_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_1_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_1_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_1_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_1_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_1_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_1_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_1_0_nelements;
MCNUM nu = mcccurved_guide_1_0_nu;
MCNUM phase = mcccurved_guide_1_0_phase;
char* reflect = mcccurved_guide_1_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74680 "BIFROST.c"
}   /* End of curved_guide_1_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[19]) fprintf(stderr, "Warning: No neutron could reach Component[19] curved_guide_1_0\n");
    if (mcAbsorbProp[19]) fprintf(stderr, "Warning: %g events were removed in Component[19] curved_guide_1_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[19]);
  /* User FINALLY code for component 'curved_guide_2_0'. */
  SIG_MESSAGE("curved_guide_2_0 (Finally)");
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
{   /* Declarations of curved_guide_2_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_2_0_w1;
MCNUM h1 = mcccurved_guide_2_0_h1;
MCNUM w2 = mcccurved_guide_2_0_w2;
MCNUM h2 = mcccurved_guide_2_0_h2;
MCNUM l = mcccurved_guide_2_0_l;
MCNUM R0 = mcccurved_guide_2_0_R0;
MCNUM Qc = mcccurved_guide_2_0_Qc;
MCNUM alpha = mcccurved_guide_2_0_alpha;
MCNUM m = mcccurved_guide_2_0_m;
MCNUM W = mcccurved_guide_2_0_W;
MCNUM nslit = mcccurved_guide_2_0_nslit;
MCNUM d = mcccurved_guide_2_0_d;
MCNUM mleft = mcccurved_guide_2_0_mleft;
MCNUM mright = mcccurved_guide_2_0_mright;
MCNUM mtop = mcccurved_guide_2_0_mtop;
MCNUM mbottom = mcccurved_guide_2_0_mbottom;
MCNUM nhslit = mcccurved_guide_2_0_nhslit;
MCNUM G = mcccurved_guide_2_0_G;
MCNUM aleft = mcccurved_guide_2_0_aleft;
MCNUM aright = mcccurved_guide_2_0_aright;
MCNUM atop = mcccurved_guide_2_0_atop;
MCNUM abottom = mcccurved_guide_2_0_abottom;
MCNUM wavy = mcccurved_guide_2_0_wavy;
MCNUM wavy_z = mcccurved_guide_2_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_2_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_2_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_2_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_2_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_2_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_2_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_2_0_nelements;
MCNUM nu = mcccurved_guide_2_0_nu;
MCNUM phase = mcccurved_guide_2_0_phase;
char* reflect = mcccurved_guide_2_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74739 "BIFROST.c"
}   /* End of curved_guide_2_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[20]) fprintf(stderr, "Warning: No neutron could reach Component[20] curved_guide_2_0\n");
    if (mcAbsorbProp[20]) fprintf(stderr, "Warning: %g events were removed in Component[20] curved_guide_2_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[20]);
  /* User FINALLY code for component 'curved_guide_3_0'. */
  SIG_MESSAGE("curved_guide_3_0 (Finally)");
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
{   /* Declarations of curved_guide_3_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_3_0_w1;
MCNUM h1 = mcccurved_guide_3_0_h1;
MCNUM w2 = mcccurved_guide_3_0_w2;
MCNUM h2 = mcccurved_guide_3_0_h2;
MCNUM l = mcccurved_guide_3_0_l;
MCNUM R0 = mcccurved_guide_3_0_R0;
MCNUM Qc = mcccurved_guide_3_0_Qc;
MCNUM alpha = mcccurved_guide_3_0_alpha;
MCNUM m = mcccurved_guide_3_0_m;
MCNUM W = mcccurved_guide_3_0_W;
MCNUM nslit = mcccurved_guide_3_0_nslit;
MCNUM d = mcccurved_guide_3_0_d;
MCNUM mleft = mcccurved_guide_3_0_mleft;
MCNUM mright = mcccurved_guide_3_0_mright;
MCNUM mtop = mcccurved_guide_3_0_mtop;
MCNUM mbottom = mcccurved_guide_3_0_mbottom;
MCNUM nhslit = mcccurved_guide_3_0_nhslit;
MCNUM G = mcccurved_guide_3_0_G;
MCNUM aleft = mcccurved_guide_3_0_aleft;
MCNUM aright = mcccurved_guide_3_0_aright;
MCNUM atop = mcccurved_guide_3_0_atop;
MCNUM abottom = mcccurved_guide_3_0_abottom;
MCNUM wavy = mcccurved_guide_3_0_wavy;
MCNUM wavy_z = mcccurved_guide_3_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_3_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_3_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_3_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_3_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_3_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_3_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_3_0_nelements;
MCNUM nu = mcccurved_guide_3_0_nu;
MCNUM phase = mcccurved_guide_3_0_phase;
char* reflect = mcccurved_guide_3_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74798 "BIFROST.c"
}   /* End of curved_guide_3_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[21]) fprintf(stderr, "Warning: No neutron could reach Component[21] curved_guide_3_0\n");
    if (mcAbsorbProp[21]) fprintf(stderr, "Warning: %g events were removed in Component[21] curved_guide_3_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[21]);
  /* User FINALLY code for component 'curved_guide_4_0'. */
  SIG_MESSAGE("curved_guide_4_0 (Finally)");
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
{   /* Declarations of curved_guide_4_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_4_0_w1;
MCNUM h1 = mcccurved_guide_4_0_h1;
MCNUM w2 = mcccurved_guide_4_0_w2;
MCNUM h2 = mcccurved_guide_4_0_h2;
MCNUM l = mcccurved_guide_4_0_l;
MCNUM R0 = mcccurved_guide_4_0_R0;
MCNUM Qc = mcccurved_guide_4_0_Qc;
MCNUM alpha = mcccurved_guide_4_0_alpha;
MCNUM m = mcccurved_guide_4_0_m;
MCNUM W = mcccurved_guide_4_0_W;
MCNUM nslit = mcccurved_guide_4_0_nslit;
MCNUM d = mcccurved_guide_4_0_d;
MCNUM mleft = mcccurved_guide_4_0_mleft;
MCNUM mright = mcccurved_guide_4_0_mright;
MCNUM mtop = mcccurved_guide_4_0_mtop;
MCNUM mbottom = mcccurved_guide_4_0_mbottom;
MCNUM nhslit = mcccurved_guide_4_0_nhslit;
MCNUM G = mcccurved_guide_4_0_G;
MCNUM aleft = mcccurved_guide_4_0_aleft;
MCNUM aright = mcccurved_guide_4_0_aright;
MCNUM atop = mcccurved_guide_4_0_atop;
MCNUM abottom = mcccurved_guide_4_0_abottom;
MCNUM wavy = mcccurved_guide_4_0_wavy;
MCNUM wavy_z = mcccurved_guide_4_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_4_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_4_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_4_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_4_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_4_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_4_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_4_0_nelements;
MCNUM nu = mcccurved_guide_4_0_nu;
MCNUM phase = mcccurved_guide_4_0_phase;
char* reflect = mcccurved_guide_4_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74857 "BIFROST.c"
}   /* End of curved_guide_4_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[22]) fprintf(stderr, "Warning: No neutron could reach Component[22] curved_guide_4_0\n");
    if (mcAbsorbProp[22]) fprintf(stderr, "Warning: %g events were removed in Component[22] curved_guide_4_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[22]);
  /* User FINALLY code for component 'curved_guide_5_beforeChopper'. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (Finally)");
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
{   /* Declarations of curved_guide_5_beforeChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_5_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_5_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_5_beforeChopper_h2;
MCNUM l = mcccurved_guide_5_beforeChopper_l;
MCNUM R0 = mcccurved_guide_5_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_5_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_5_beforeChopper_alpha;
MCNUM m = mcccurved_guide_5_beforeChopper_m;
MCNUM W = mcccurved_guide_5_beforeChopper_W;
MCNUM nslit = mcccurved_guide_5_beforeChopper_nslit;
MCNUM d = mcccurved_guide_5_beforeChopper_d;
MCNUM mleft = mcccurved_guide_5_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_5_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_5_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_5_beforeChopper_G;
MCNUM aleft = mcccurved_guide_5_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_5_beforeChopper_aright;
MCNUM atop = mcccurved_guide_5_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_5_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_5_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_5_beforeChopper_nu;
MCNUM phase = mcccurved_guide_5_beforeChopper_phase;
char* reflect = mcccurved_guide_5_beforeChopper_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74916 "BIFROST.c"
}   /* End of curved_guide_5_beforeChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[23]) fprintf(stderr, "Warning: No neutron could reach Component[23] curved_guide_5_beforeChopper\n");
    if (mcAbsorbProp[23]) fprintf(stderr, "Warning: %g events were removed in Component[23] curved_guide_5_beforeChopper=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[23]);
    if (!mcNCounter[24]) fprintf(stderr, "Warning: No neutron could reach Component[24] L_monBeforeFOC1\n");
    if (mcAbsorbProp[24]) fprintf(stderr, "Warning: %g events were removed in Component[24] L_monBeforeFOC1=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[24]);
    if (!mcNCounter[25]) fprintf(stderr, "Warning: No neutron could reach Component[25] ToFBeforeFOC1\n");
    if (mcAbsorbProp[25]) fprintf(stderr, "Warning: %g events were removed in Component[25] ToFBeforeFOC1=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[25]);
    if (!mcNCounter[26]) fprintf(stderr, "Warning: No neutron could reach Component[26] PSD_beforeFOC1\n");
    if (mcAbsorbProp[26]) fprintf(stderr, "Warning: %g events were removed in Component[26] PSD_beforeFOC1=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[26]);
    if (!mcNCounter[27]) fprintf(stderr, "Warning: No neutron could reach Component[27] FOC1\n");
    if (mcAbsorbProp[27]) fprintf(stderr, "Warning: %g events were removed in Component[27] FOC1=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[27]);
    if (!mcNCounter[28]) fprintf(stderr, "Warning: No neutron could reach Component[28] PSD_afterFOC1\n");
    if (mcAbsorbProp[28]) fprintf(stderr, "Warning: %g events were removed in Component[28] PSD_afterFOC1=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[28]);
    if (!mcNCounter[29]) fprintf(stderr, "Warning: No neutron could reach Component[29] ToFAfterFOC1\n");
    if (mcAbsorbProp[29]) fprintf(stderr, "Warning: %g events were removed in Component[29] ToFAfterFOC1=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[29]);
    if (!mcNCounter[30]) fprintf(stderr, "Warning: No neutron could reach Component[30] L_monAfterFOC1\n");
    if (mcAbsorbProp[30]) fprintf(stderr, "Warning: %g events were removed in Component[30] L_monAfterFOC1=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[30]);
  /* User FINALLY code for component 'curved_guide_5_afterChopper'. */
  SIG_MESSAGE("curved_guide_5_afterChopper (Finally)");
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
{   /* Declarations of curved_guide_5_afterChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_afterChopper_w1;
MCNUM h1 = mcccurved_guide_5_afterChopper_h1;
MCNUM w2 = mcccurved_guide_5_afterChopper_w2;
MCNUM h2 = mcccurved_guide_5_afterChopper_h2;
MCNUM l = mcccurved_guide_5_afterChopper_l;
MCNUM R0 = mcccurved_guide_5_afterChopper_R0;
MCNUM Qc = mcccurved_guide_5_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_5_afterChopper_alpha;
MCNUM m = mcccurved_guide_5_afterChopper_m;
MCNUM W = mcccurved_guide_5_afterChopper_W;
MCNUM nslit = mcccurved_guide_5_afterChopper_nslit;
MCNUM d = mcccurved_guide_5_afterChopper_d;
MCNUM mleft = mcccurved_guide_5_afterChopper_mleft;
MCNUM mright = mcccurved_guide_5_afterChopper_mright;
MCNUM mtop = mcccurved_guide_5_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_afterChopper_nhslit;
MCNUM G = mcccurved_guide_5_afterChopper_G;
MCNUM aleft = mcccurved_guide_5_afterChopper_aleft;
MCNUM aright = mcccurved_guide_5_afterChopper_aright;
MCNUM atop = mcccurved_guide_5_afterChopper_atop;
MCNUM abottom = mcccurved_guide_5_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_5_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_afterChopper_nelements;
MCNUM nu = mcccurved_guide_5_afterChopper_nu;
MCNUM phase = mcccurved_guide_5_afterChopper_phase;
char* reflect = mcccurved_guide_5_afterChopper_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74989 "BIFROST.c"
}   /* End of curved_guide_5_afterChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[31]) fprintf(stderr, "Warning: No neutron could reach Component[31] curved_guide_5_afterChopper\n");
    if (mcAbsorbProp[31]) fprintf(stderr, "Warning: %g events were removed in Component[31] curved_guide_5_afterChopper=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[31]);
  /* User FINALLY code for component 'curved_guide_6_0'. */
  SIG_MESSAGE("curved_guide_6_0 (Finally)");
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
{   /* Declarations of curved_guide_6_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_6_0_w1;
MCNUM h1 = mcccurved_guide_6_0_h1;
MCNUM w2 = mcccurved_guide_6_0_w2;
MCNUM h2 = mcccurved_guide_6_0_h2;
MCNUM l = mcccurved_guide_6_0_l;
MCNUM R0 = mcccurved_guide_6_0_R0;
MCNUM Qc = mcccurved_guide_6_0_Qc;
MCNUM alpha = mcccurved_guide_6_0_alpha;
MCNUM m = mcccurved_guide_6_0_m;
MCNUM W = mcccurved_guide_6_0_W;
MCNUM nslit = mcccurved_guide_6_0_nslit;
MCNUM d = mcccurved_guide_6_0_d;
MCNUM mleft = mcccurved_guide_6_0_mleft;
MCNUM mright = mcccurved_guide_6_0_mright;
MCNUM mtop = mcccurved_guide_6_0_mtop;
MCNUM mbottom = mcccurved_guide_6_0_mbottom;
MCNUM nhslit = mcccurved_guide_6_0_nhslit;
MCNUM G = mcccurved_guide_6_0_G;
MCNUM aleft = mcccurved_guide_6_0_aleft;
MCNUM aright = mcccurved_guide_6_0_aright;
MCNUM atop = mcccurved_guide_6_0_atop;
MCNUM abottom = mcccurved_guide_6_0_abottom;
MCNUM wavy = mcccurved_guide_6_0_wavy;
MCNUM wavy_z = mcccurved_guide_6_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_6_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_6_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_6_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_6_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_6_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_6_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_6_0_nelements;
MCNUM nu = mcccurved_guide_6_0_nu;
MCNUM phase = mcccurved_guide_6_0_phase;
char* reflect = mcccurved_guide_6_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75048 "BIFROST.c"
}   /* End of curved_guide_6_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[32]) fprintf(stderr, "Warning: No neutron could reach Component[32] curved_guide_6_0\n");
    if (mcAbsorbProp[32]) fprintf(stderr, "Warning: %g events were removed in Component[32] curved_guide_6_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[32]);
  /* User FINALLY code for component 'curved_guide_7_0'. */
  SIG_MESSAGE("curved_guide_7_0 (Finally)");
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
{   /* Declarations of curved_guide_7_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_7_0_w1;
MCNUM h1 = mcccurved_guide_7_0_h1;
MCNUM w2 = mcccurved_guide_7_0_w2;
MCNUM h2 = mcccurved_guide_7_0_h2;
MCNUM l = mcccurved_guide_7_0_l;
MCNUM R0 = mcccurved_guide_7_0_R0;
MCNUM Qc = mcccurved_guide_7_0_Qc;
MCNUM alpha = mcccurved_guide_7_0_alpha;
MCNUM m = mcccurved_guide_7_0_m;
MCNUM W = mcccurved_guide_7_0_W;
MCNUM nslit = mcccurved_guide_7_0_nslit;
MCNUM d = mcccurved_guide_7_0_d;
MCNUM mleft = mcccurved_guide_7_0_mleft;
MCNUM mright = mcccurved_guide_7_0_mright;
MCNUM mtop = mcccurved_guide_7_0_mtop;
MCNUM mbottom = mcccurved_guide_7_0_mbottom;
MCNUM nhslit = mcccurved_guide_7_0_nhslit;
MCNUM G = mcccurved_guide_7_0_G;
MCNUM aleft = mcccurved_guide_7_0_aleft;
MCNUM aright = mcccurved_guide_7_0_aright;
MCNUM atop = mcccurved_guide_7_0_atop;
MCNUM abottom = mcccurved_guide_7_0_abottom;
MCNUM wavy = mcccurved_guide_7_0_wavy;
MCNUM wavy_z = mcccurved_guide_7_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_7_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_7_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_7_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_7_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_7_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_7_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_7_0_nelements;
MCNUM nu = mcccurved_guide_7_0_nu;
MCNUM phase = mcccurved_guide_7_0_phase;
char* reflect = mcccurved_guide_7_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75107 "BIFROST.c"
}   /* End of curved_guide_7_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[33]) fprintf(stderr, "Warning: No neutron could reach Component[33] curved_guide_7_0\n");
    if (mcAbsorbProp[33]) fprintf(stderr, "Warning: %g events were removed in Component[33] curved_guide_7_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[33]);
  /* User FINALLY code for component 'curved_guide_8_0'. */
  SIG_MESSAGE("curved_guide_8_0 (Finally)");
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
{   /* Declarations of curved_guide_8_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_8_0_w1;
MCNUM h1 = mcccurved_guide_8_0_h1;
MCNUM w2 = mcccurved_guide_8_0_w2;
MCNUM h2 = mcccurved_guide_8_0_h2;
MCNUM l = mcccurved_guide_8_0_l;
MCNUM R0 = mcccurved_guide_8_0_R0;
MCNUM Qc = mcccurved_guide_8_0_Qc;
MCNUM alpha = mcccurved_guide_8_0_alpha;
MCNUM m = mcccurved_guide_8_0_m;
MCNUM W = mcccurved_guide_8_0_W;
MCNUM nslit = mcccurved_guide_8_0_nslit;
MCNUM d = mcccurved_guide_8_0_d;
MCNUM mleft = mcccurved_guide_8_0_mleft;
MCNUM mright = mcccurved_guide_8_0_mright;
MCNUM mtop = mcccurved_guide_8_0_mtop;
MCNUM mbottom = mcccurved_guide_8_0_mbottom;
MCNUM nhslit = mcccurved_guide_8_0_nhslit;
MCNUM G = mcccurved_guide_8_0_G;
MCNUM aleft = mcccurved_guide_8_0_aleft;
MCNUM aright = mcccurved_guide_8_0_aright;
MCNUM atop = mcccurved_guide_8_0_atop;
MCNUM abottom = mcccurved_guide_8_0_abottom;
MCNUM wavy = mcccurved_guide_8_0_wavy;
MCNUM wavy_z = mcccurved_guide_8_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_8_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_8_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_8_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_8_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_8_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_8_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_8_0_nelements;
MCNUM nu = mcccurved_guide_8_0_nu;
MCNUM phase = mcccurved_guide_8_0_phase;
char* reflect = mcccurved_guide_8_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75166 "BIFROST.c"
}   /* End of curved_guide_8_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[34]) fprintf(stderr, "Warning: No neutron could reach Component[34] curved_guide_8_0\n");
    if (mcAbsorbProp[34]) fprintf(stderr, "Warning: %g events were removed in Component[34] curved_guide_8_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[34]);
  /* User FINALLY code for component 'curved_guide_9_0'. */
  SIG_MESSAGE("curved_guide_9_0 (Finally)");
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
{   /* Declarations of curved_guide_9_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_9_0_w1;
MCNUM h1 = mcccurved_guide_9_0_h1;
MCNUM w2 = mcccurved_guide_9_0_w2;
MCNUM h2 = mcccurved_guide_9_0_h2;
MCNUM l = mcccurved_guide_9_0_l;
MCNUM R0 = mcccurved_guide_9_0_R0;
MCNUM Qc = mcccurved_guide_9_0_Qc;
MCNUM alpha = mcccurved_guide_9_0_alpha;
MCNUM m = mcccurved_guide_9_0_m;
MCNUM W = mcccurved_guide_9_0_W;
MCNUM nslit = mcccurved_guide_9_0_nslit;
MCNUM d = mcccurved_guide_9_0_d;
MCNUM mleft = mcccurved_guide_9_0_mleft;
MCNUM mright = mcccurved_guide_9_0_mright;
MCNUM mtop = mcccurved_guide_9_0_mtop;
MCNUM mbottom = mcccurved_guide_9_0_mbottom;
MCNUM nhslit = mcccurved_guide_9_0_nhslit;
MCNUM G = mcccurved_guide_9_0_G;
MCNUM aleft = mcccurved_guide_9_0_aleft;
MCNUM aright = mcccurved_guide_9_0_aright;
MCNUM atop = mcccurved_guide_9_0_atop;
MCNUM abottom = mcccurved_guide_9_0_abottom;
MCNUM wavy = mcccurved_guide_9_0_wavy;
MCNUM wavy_z = mcccurved_guide_9_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_9_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_9_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_9_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_9_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_9_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_9_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_9_0_nelements;
MCNUM nu = mcccurved_guide_9_0_nu;
MCNUM phase = mcccurved_guide_9_0_phase;
char* reflect = mcccurved_guide_9_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75225 "BIFROST.c"
}   /* End of curved_guide_9_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[35]) fprintf(stderr, "Warning: No neutron could reach Component[35] curved_guide_9_0\n");
    if (mcAbsorbProp[35]) fprintf(stderr, "Warning: %g events were removed in Component[35] curved_guide_9_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[35]);
  /* User FINALLY code for component 'curved_guide_10_0'. */
  SIG_MESSAGE("curved_guide_10_0 (Finally)");
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
{   /* Declarations of curved_guide_10_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_10_0_w1;
MCNUM h1 = mcccurved_guide_10_0_h1;
MCNUM w2 = mcccurved_guide_10_0_w2;
MCNUM h2 = mcccurved_guide_10_0_h2;
MCNUM l = mcccurved_guide_10_0_l;
MCNUM R0 = mcccurved_guide_10_0_R0;
MCNUM Qc = mcccurved_guide_10_0_Qc;
MCNUM alpha = mcccurved_guide_10_0_alpha;
MCNUM m = mcccurved_guide_10_0_m;
MCNUM W = mcccurved_guide_10_0_W;
MCNUM nslit = mcccurved_guide_10_0_nslit;
MCNUM d = mcccurved_guide_10_0_d;
MCNUM mleft = mcccurved_guide_10_0_mleft;
MCNUM mright = mcccurved_guide_10_0_mright;
MCNUM mtop = mcccurved_guide_10_0_mtop;
MCNUM mbottom = mcccurved_guide_10_0_mbottom;
MCNUM nhslit = mcccurved_guide_10_0_nhslit;
MCNUM G = mcccurved_guide_10_0_G;
MCNUM aleft = mcccurved_guide_10_0_aleft;
MCNUM aright = mcccurved_guide_10_0_aright;
MCNUM atop = mcccurved_guide_10_0_atop;
MCNUM abottom = mcccurved_guide_10_0_abottom;
MCNUM wavy = mcccurved_guide_10_0_wavy;
MCNUM wavy_z = mcccurved_guide_10_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_10_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_10_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_10_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_10_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_10_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_10_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_10_0_nelements;
MCNUM nu = mcccurved_guide_10_0_nu;
MCNUM phase = mcccurved_guide_10_0_phase;
char* reflect = mcccurved_guide_10_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75284 "BIFROST.c"
}   /* End of curved_guide_10_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[36]) fprintf(stderr, "Warning: No neutron could reach Component[36] curved_guide_10_0\n");
    if (mcAbsorbProp[36]) fprintf(stderr, "Warning: %g events were removed in Component[36] curved_guide_10_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[36]);
  /* User FINALLY code for component 'curved_guide_11_0'. */
  SIG_MESSAGE("curved_guide_11_0 (Finally)");
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
{   /* Declarations of curved_guide_11_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_11_0_w1;
MCNUM h1 = mcccurved_guide_11_0_h1;
MCNUM w2 = mcccurved_guide_11_0_w2;
MCNUM h2 = mcccurved_guide_11_0_h2;
MCNUM l = mcccurved_guide_11_0_l;
MCNUM R0 = mcccurved_guide_11_0_R0;
MCNUM Qc = mcccurved_guide_11_0_Qc;
MCNUM alpha = mcccurved_guide_11_0_alpha;
MCNUM m = mcccurved_guide_11_0_m;
MCNUM W = mcccurved_guide_11_0_W;
MCNUM nslit = mcccurved_guide_11_0_nslit;
MCNUM d = mcccurved_guide_11_0_d;
MCNUM mleft = mcccurved_guide_11_0_mleft;
MCNUM mright = mcccurved_guide_11_0_mright;
MCNUM mtop = mcccurved_guide_11_0_mtop;
MCNUM mbottom = mcccurved_guide_11_0_mbottom;
MCNUM nhslit = mcccurved_guide_11_0_nhslit;
MCNUM G = mcccurved_guide_11_0_G;
MCNUM aleft = mcccurved_guide_11_0_aleft;
MCNUM aright = mcccurved_guide_11_0_aright;
MCNUM atop = mcccurved_guide_11_0_atop;
MCNUM abottom = mcccurved_guide_11_0_abottom;
MCNUM wavy = mcccurved_guide_11_0_wavy;
MCNUM wavy_z = mcccurved_guide_11_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_11_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_11_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_11_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_11_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_11_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_11_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_11_0_nelements;
MCNUM nu = mcccurved_guide_11_0_nu;
MCNUM phase = mcccurved_guide_11_0_phase;
char* reflect = mcccurved_guide_11_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75343 "BIFROST.c"
}   /* End of curved_guide_11_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[37]) fprintf(stderr, "Warning: No neutron could reach Component[37] curved_guide_11_0\n");
    if (mcAbsorbProp[37]) fprintf(stderr, "Warning: %g events were removed in Component[37] curved_guide_11_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[37]);
  /* User FINALLY code for component 'curved_guide_12_0'. */
  SIG_MESSAGE("curved_guide_12_0 (Finally)");
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
{   /* Declarations of curved_guide_12_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_12_0_w1;
MCNUM h1 = mcccurved_guide_12_0_h1;
MCNUM w2 = mcccurved_guide_12_0_w2;
MCNUM h2 = mcccurved_guide_12_0_h2;
MCNUM l = mcccurved_guide_12_0_l;
MCNUM R0 = mcccurved_guide_12_0_R0;
MCNUM Qc = mcccurved_guide_12_0_Qc;
MCNUM alpha = mcccurved_guide_12_0_alpha;
MCNUM m = mcccurved_guide_12_0_m;
MCNUM W = mcccurved_guide_12_0_W;
MCNUM nslit = mcccurved_guide_12_0_nslit;
MCNUM d = mcccurved_guide_12_0_d;
MCNUM mleft = mcccurved_guide_12_0_mleft;
MCNUM mright = mcccurved_guide_12_0_mright;
MCNUM mtop = mcccurved_guide_12_0_mtop;
MCNUM mbottom = mcccurved_guide_12_0_mbottom;
MCNUM nhslit = mcccurved_guide_12_0_nhslit;
MCNUM G = mcccurved_guide_12_0_G;
MCNUM aleft = mcccurved_guide_12_0_aleft;
MCNUM aright = mcccurved_guide_12_0_aright;
MCNUM atop = mcccurved_guide_12_0_atop;
MCNUM abottom = mcccurved_guide_12_0_abottom;
MCNUM wavy = mcccurved_guide_12_0_wavy;
MCNUM wavy_z = mcccurved_guide_12_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_12_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_12_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_12_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_12_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_12_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_12_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_12_0_nelements;
MCNUM nu = mcccurved_guide_12_0_nu;
MCNUM phase = mcccurved_guide_12_0_phase;
char* reflect = mcccurved_guide_12_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75402 "BIFROST.c"
}   /* End of curved_guide_12_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[38]) fprintf(stderr, "Warning: No neutron could reach Component[38] curved_guide_12_0\n");
    if (mcAbsorbProp[38]) fprintf(stderr, "Warning: %g events were removed in Component[38] curved_guide_12_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[38]);
  /* User FINALLY code for component 'curved_guide_13_0'. */
  SIG_MESSAGE("curved_guide_13_0 (Finally)");
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
{   /* Declarations of curved_guide_13_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_13_0_w1;
MCNUM h1 = mcccurved_guide_13_0_h1;
MCNUM w2 = mcccurved_guide_13_0_w2;
MCNUM h2 = mcccurved_guide_13_0_h2;
MCNUM l = mcccurved_guide_13_0_l;
MCNUM R0 = mcccurved_guide_13_0_R0;
MCNUM Qc = mcccurved_guide_13_0_Qc;
MCNUM alpha = mcccurved_guide_13_0_alpha;
MCNUM m = mcccurved_guide_13_0_m;
MCNUM W = mcccurved_guide_13_0_W;
MCNUM nslit = mcccurved_guide_13_0_nslit;
MCNUM d = mcccurved_guide_13_0_d;
MCNUM mleft = mcccurved_guide_13_0_mleft;
MCNUM mright = mcccurved_guide_13_0_mright;
MCNUM mtop = mcccurved_guide_13_0_mtop;
MCNUM mbottom = mcccurved_guide_13_0_mbottom;
MCNUM nhslit = mcccurved_guide_13_0_nhslit;
MCNUM G = mcccurved_guide_13_0_G;
MCNUM aleft = mcccurved_guide_13_0_aleft;
MCNUM aright = mcccurved_guide_13_0_aright;
MCNUM atop = mcccurved_guide_13_0_atop;
MCNUM abottom = mcccurved_guide_13_0_abottom;
MCNUM wavy = mcccurved_guide_13_0_wavy;
MCNUM wavy_z = mcccurved_guide_13_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_13_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_13_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_13_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_13_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_13_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_13_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_13_0_nelements;
MCNUM nu = mcccurved_guide_13_0_nu;
MCNUM phase = mcccurved_guide_13_0_phase;
char* reflect = mcccurved_guide_13_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75461 "BIFROST.c"
}   /* End of curved_guide_13_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[39]) fprintf(stderr, "Warning: No neutron could reach Component[39] curved_guide_13_0\n");
    if (mcAbsorbProp[39]) fprintf(stderr, "Warning: %g events were removed in Component[39] curved_guide_13_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[39]);
  /* User FINALLY code for component 'curved_guide_14_0'. */
  SIG_MESSAGE("curved_guide_14_0 (Finally)");
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
{   /* Declarations of curved_guide_14_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_14_0_w1;
MCNUM h1 = mcccurved_guide_14_0_h1;
MCNUM w2 = mcccurved_guide_14_0_w2;
MCNUM h2 = mcccurved_guide_14_0_h2;
MCNUM l = mcccurved_guide_14_0_l;
MCNUM R0 = mcccurved_guide_14_0_R0;
MCNUM Qc = mcccurved_guide_14_0_Qc;
MCNUM alpha = mcccurved_guide_14_0_alpha;
MCNUM m = mcccurved_guide_14_0_m;
MCNUM W = mcccurved_guide_14_0_W;
MCNUM nslit = mcccurved_guide_14_0_nslit;
MCNUM d = mcccurved_guide_14_0_d;
MCNUM mleft = mcccurved_guide_14_0_mleft;
MCNUM mright = mcccurved_guide_14_0_mright;
MCNUM mtop = mcccurved_guide_14_0_mtop;
MCNUM mbottom = mcccurved_guide_14_0_mbottom;
MCNUM nhslit = mcccurved_guide_14_0_nhslit;
MCNUM G = mcccurved_guide_14_0_G;
MCNUM aleft = mcccurved_guide_14_0_aleft;
MCNUM aright = mcccurved_guide_14_0_aright;
MCNUM atop = mcccurved_guide_14_0_atop;
MCNUM abottom = mcccurved_guide_14_0_abottom;
MCNUM wavy = mcccurved_guide_14_0_wavy;
MCNUM wavy_z = mcccurved_guide_14_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_14_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_14_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_14_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_14_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_14_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_14_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_14_0_nelements;
MCNUM nu = mcccurved_guide_14_0_nu;
MCNUM phase = mcccurved_guide_14_0_phase;
char* reflect = mcccurved_guide_14_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75520 "BIFROST.c"
}   /* End of curved_guide_14_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[40]) fprintf(stderr, "Warning: No neutron could reach Component[40] curved_guide_14_0\n");
    if (mcAbsorbProp[40]) fprintf(stderr, "Warning: %g events were removed in Component[40] curved_guide_14_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[40]);
  /* User FINALLY code for component 'curved_guide_15_0'. */
  SIG_MESSAGE("curved_guide_15_0 (Finally)");
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
{   /* Declarations of curved_guide_15_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_15_0_w1;
MCNUM h1 = mcccurved_guide_15_0_h1;
MCNUM w2 = mcccurved_guide_15_0_w2;
MCNUM h2 = mcccurved_guide_15_0_h2;
MCNUM l = mcccurved_guide_15_0_l;
MCNUM R0 = mcccurved_guide_15_0_R0;
MCNUM Qc = mcccurved_guide_15_0_Qc;
MCNUM alpha = mcccurved_guide_15_0_alpha;
MCNUM m = mcccurved_guide_15_0_m;
MCNUM W = mcccurved_guide_15_0_W;
MCNUM nslit = mcccurved_guide_15_0_nslit;
MCNUM d = mcccurved_guide_15_0_d;
MCNUM mleft = mcccurved_guide_15_0_mleft;
MCNUM mright = mcccurved_guide_15_0_mright;
MCNUM mtop = mcccurved_guide_15_0_mtop;
MCNUM mbottom = mcccurved_guide_15_0_mbottom;
MCNUM nhslit = mcccurved_guide_15_0_nhslit;
MCNUM G = mcccurved_guide_15_0_G;
MCNUM aleft = mcccurved_guide_15_0_aleft;
MCNUM aright = mcccurved_guide_15_0_aright;
MCNUM atop = mcccurved_guide_15_0_atop;
MCNUM abottom = mcccurved_guide_15_0_abottom;
MCNUM wavy = mcccurved_guide_15_0_wavy;
MCNUM wavy_z = mcccurved_guide_15_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_15_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_15_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_15_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_15_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_15_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_15_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_15_0_nelements;
MCNUM nu = mcccurved_guide_15_0_nu;
MCNUM phase = mcccurved_guide_15_0_phase;
char* reflect = mcccurved_guide_15_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75579 "BIFROST.c"
}   /* End of curved_guide_15_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[41]) fprintf(stderr, "Warning: No neutron could reach Component[41] curved_guide_15_0\n");
    if (mcAbsorbProp[41]) fprintf(stderr, "Warning: %g events were removed in Component[41] curved_guide_15_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[41]);
  /* User FINALLY code for component 'curved_guide_16_0'. */
  SIG_MESSAGE("curved_guide_16_0 (Finally)");
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
{   /* Declarations of curved_guide_16_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_16_0_w1;
MCNUM h1 = mcccurved_guide_16_0_h1;
MCNUM w2 = mcccurved_guide_16_0_w2;
MCNUM h2 = mcccurved_guide_16_0_h2;
MCNUM l = mcccurved_guide_16_0_l;
MCNUM R0 = mcccurved_guide_16_0_R0;
MCNUM Qc = mcccurved_guide_16_0_Qc;
MCNUM alpha = mcccurved_guide_16_0_alpha;
MCNUM m = mcccurved_guide_16_0_m;
MCNUM W = mcccurved_guide_16_0_W;
MCNUM nslit = mcccurved_guide_16_0_nslit;
MCNUM d = mcccurved_guide_16_0_d;
MCNUM mleft = mcccurved_guide_16_0_mleft;
MCNUM mright = mcccurved_guide_16_0_mright;
MCNUM mtop = mcccurved_guide_16_0_mtop;
MCNUM mbottom = mcccurved_guide_16_0_mbottom;
MCNUM nhslit = mcccurved_guide_16_0_nhslit;
MCNUM G = mcccurved_guide_16_0_G;
MCNUM aleft = mcccurved_guide_16_0_aleft;
MCNUM aright = mcccurved_guide_16_0_aright;
MCNUM atop = mcccurved_guide_16_0_atop;
MCNUM abottom = mcccurved_guide_16_0_abottom;
MCNUM wavy = mcccurved_guide_16_0_wavy;
MCNUM wavy_z = mcccurved_guide_16_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_16_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_16_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_16_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_16_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_16_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_16_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_16_0_nelements;
MCNUM nu = mcccurved_guide_16_0_nu;
MCNUM phase = mcccurved_guide_16_0_phase;
char* reflect = mcccurved_guide_16_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75638 "BIFROST.c"
}   /* End of curved_guide_16_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[42]) fprintf(stderr, "Warning: No neutron could reach Component[42] curved_guide_16_0\n");
    if (mcAbsorbProp[42]) fprintf(stderr, "Warning: %g events were removed in Component[42] curved_guide_16_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[42]);
  /* User FINALLY code for component 'curved_guide_17_0'. */
  SIG_MESSAGE("curved_guide_17_0 (Finally)");
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
{   /* Declarations of curved_guide_17_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_17_0_w1;
MCNUM h1 = mcccurved_guide_17_0_h1;
MCNUM w2 = mcccurved_guide_17_0_w2;
MCNUM h2 = mcccurved_guide_17_0_h2;
MCNUM l = mcccurved_guide_17_0_l;
MCNUM R0 = mcccurved_guide_17_0_R0;
MCNUM Qc = mcccurved_guide_17_0_Qc;
MCNUM alpha = mcccurved_guide_17_0_alpha;
MCNUM m = mcccurved_guide_17_0_m;
MCNUM W = mcccurved_guide_17_0_W;
MCNUM nslit = mcccurved_guide_17_0_nslit;
MCNUM d = mcccurved_guide_17_0_d;
MCNUM mleft = mcccurved_guide_17_0_mleft;
MCNUM mright = mcccurved_guide_17_0_mright;
MCNUM mtop = mcccurved_guide_17_0_mtop;
MCNUM mbottom = mcccurved_guide_17_0_mbottom;
MCNUM nhslit = mcccurved_guide_17_0_nhslit;
MCNUM G = mcccurved_guide_17_0_G;
MCNUM aleft = mcccurved_guide_17_0_aleft;
MCNUM aright = mcccurved_guide_17_0_aright;
MCNUM atop = mcccurved_guide_17_0_atop;
MCNUM abottom = mcccurved_guide_17_0_abottom;
MCNUM wavy = mcccurved_guide_17_0_wavy;
MCNUM wavy_z = mcccurved_guide_17_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_17_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_17_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_17_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_17_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_17_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_17_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_17_0_nelements;
MCNUM nu = mcccurved_guide_17_0_nu;
MCNUM phase = mcccurved_guide_17_0_phase;
char* reflect = mcccurved_guide_17_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75697 "BIFROST.c"
}   /* End of curved_guide_17_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[43]) fprintf(stderr, "Warning: No neutron could reach Component[43] curved_guide_17_0\n");
    if (mcAbsorbProp[43]) fprintf(stderr, "Warning: %g events were removed in Component[43] curved_guide_17_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[43]);
  /* User FINALLY code for component 'curved_guide_18_beforeChopper'. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (Finally)");
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
{   /* Declarations of curved_guide_18_beforeChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_18_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_18_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_18_beforeChopper_h2;
MCNUM l = mcccurved_guide_18_beforeChopper_l;
MCNUM R0 = mcccurved_guide_18_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_18_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_18_beforeChopper_alpha;
MCNUM m = mcccurved_guide_18_beforeChopper_m;
MCNUM W = mcccurved_guide_18_beforeChopper_W;
MCNUM nslit = mcccurved_guide_18_beforeChopper_nslit;
MCNUM d = mcccurved_guide_18_beforeChopper_d;
MCNUM mleft = mcccurved_guide_18_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_18_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_18_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_18_beforeChopper_G;
MCNUM aleft = mcccurved_guide_18_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_18_beforeChopper_aright;
MCNUM atop = mcccurved_guide_18_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_18_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_18_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_18_beforeChopper_nu;
MCNUM phase = mcccurved_guide_18_beforeChopper_phase;
char* reflect = mcccurved_guide_18_beforeChopper_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75756 "BIFROST.c"
}   /* End of curved_guide_18_beforeChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[44]) fprintf(stderr, "Warning: No neutron could reach Component[44] curved_guide_18_beforeChopper\n");
    if (mcAbsorbProp[44]) fprintf(stderr, "Warning: %g events were removed in Component[44] curved_guide_18_beforeChopper=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[44]);
    if (!mcNCounter[45]) fprintf(stderr, "Warning: No neutron could reach Component[45] L_monBeforeFOC2\n");
    if (mcAbsorbProp[45]) fprintf(stderr, "Warning: %g events were removed in Component[45] L_monBeforeFOC2=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[45]);
    if (!mcNCounter[46]) fprintf(stderr, "Warning: No neutron could reach Component[46] ToFBeforeFOC2\n");
    if (mcAbsorbProp[46]) fprintf(stderr, "Warning: %g events were removed in Component[46] ToFBeforeFOC2=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[46]);
    if (!mcNCounter[47]) fprintf(stderr, "Warning: No neutron could reach Component[47] PSD_beforeFOC2\n");
    if (mcAbsorbProp[47]) fprintf(stderr, "Warning: %g events were removed in Component[47] PSD_beforeFOC2=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[47]);
    if (!mcNCounter[48]) fprintf(stderr, "Warning: No neutron could reach Component[48] FOC2\n");
    if (mcAbsorbProp[48]) fprintf(stderr, "Warning: %g events were removed in Component[48] FOC2=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[48]);
    if (!mcNCounter[49]) fprintf(stderr, "Warning: No neutron could reach Component[49] PSD_afterFOC2\n");
    if (mcAbsorbProp[49]) fprintf(stderr, "Warning: %g events were removed in Component[49] PSD_afterFOC2=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[49]);
    if (!mcNCounter[50]) fprintf(stderr, "Warning: No neutron could reach Component[50] ToFAfterFOC2\n");
    if (mcAbsorbProp[50]) fprintf(stderr, "Warning: %g events were removed in Component[50] ToFAfterFOC2=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[50]);
    if (!mcNCounter[51]) fprintf(stderr, "Warning: No neutron could reach Component[51] L_monAfterFOC2\n");
    if (mcAbsorbProp[51]) fprintf(stderr, "Warning: %g events were removed in Component[51] L_monAfterFOC2=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[51]);
  /* User FINALLY code for component 'curved_guide_18_afterChopper'. */
  SIG_MESSAGE("curved_guide_18_afterChopper (Finally)");
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
{   /* Declarations of curved_guide_18_afterChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_afterChopper_w1;
MCNUM h1 = mcccurved_guide_18_afterChopper_h1;
MCNUM w2 = mcccurved_guide_18_afterChopper_w2;
MCNUM h2 = mcccurved_guide_18_afterChopper_h2;
MCNUM l = mcccurved_guide_18_afterChopper_l;
MCNUM R0 = mcccurved_guide_18_afterChopper_R0;
MCNUM Qc = mcccurved_guide_18_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_18_afterChopper_alpha;
MCNUM m = mcccurved_guide_18_afterChopper_m;
MCNUM W = mcccurved_guide_18_afterChopper_W;
MCNUM nslit = mcccurved_guide_18_afterChopper_nslit;
MCNUM d = mcccurved_guide_18_afterChopper_d;
MCNUM mleft = mcccurved_guide_18_afterChopper_mleft;
MCNUM mright = mcccurved_guide_18_afterChopper_mright;
MCNUM mtop = mcccurved_guide_18_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_afterChopper_nhslit;
MCNUM G = mcccurved_guide_18_afterChopper_G;
MCNUM aleft = mcccurved_guide_18_afterChopper_aleft;
MCNUM aright = mcccurved_guide_18_afterChopper_aright;
MCNUM atop = mcccurved_guide_18_afterChopper_atop;
MCNUM abottom = mcccurved_guide_18_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_18_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_afterChopper_nelements;
MCNUM nu = mcccurved_guide_18_afterChopper_nu;
MCNUM phase = mcccurved_guide_18_afterChopper_phase;
char* reflect = mcccurved_guide_18_afterChopper_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75829 "BIFROST.c"
}   /* End of curved_guide_18_afterChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[52]) fprintf(stderr, "Warning: No neutron could reach Component[52] curved_guide_18_afterChopper\n");
    if (mcAbsorbProp[52]) fprintf(stderr, "Warning: %g events were removed in Component[52] curved_guide_18_afterChopper=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[52]);
  /* User FINALLY code for component 'curved_guide_19_0'. */
  SIG_MESSAGE("curved_guide_19_0 (Finally)");
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
{   /* Declarations of curved_guide_19_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_19_0_w1;
MCNUM h1 = mcccurved_guide_19_0_h1;
MCNUM w2 = mcccurved_guide_19_0_w2;
MCNUM h2 = mcccurved_guide_19_0_h2;
MCNUM l = mcccurved_guide_19_0_l;
MCNUM R0 = mcccurved_guide_19_0_R0;
MCNUM Qc = mcccurved_guide_19_0_Qc;
MCNUM alpha = mcccurved_guide_19_0_alpha;
MCNUM m = mcccurved_guide_19_0_m;
MCNUM W = mcccurved_guide_19_0_W;
MCNUM nslit = mcccurved_guide_19_0_nslit;
MCNUM d = mcccurved_guide_19_0_d;
MCNUM mleft = mcccurved_guide_19_0_mleft;
MCNUM mright = mcccurved_guide_19_0_mright;
MCNUM mtop = mcccurved_guide_19_0_mtop;
MCNUM mbottom = mcccurved_guide_19_0_mbottom;
MCNUM nhslit = mcccurved_guide_19_0_nhslit;
MCNUM G = mcccurved_guide_19_0_G;
MCNUM aleft = mcccurved_guide_19_0_aleft;
MCNUM aright = mcccurved_guide_19_0_aright;
MCNUM atop = mcccurved_guide_19_0_atop;
MCNUM abottom = mcccurved_guide_19_0_abottom;
MCNUM wavy = mcccurved_guide_19_0_wavy;
MCNUM wavy_z = mcccurved_guide_19_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_19_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_19_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_19_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_19_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_19_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_19_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_19_0_nelements;
MCNUM nu = mcccurved_guide_19_0_nu;
MCNUM phase = mcccurved_guide_19_0_phase;
char* reflect = mcccurved_guide_19_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75888 "BIFROST.c"
}   /* End of curved_guide_19_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[53]) fprintf(stderr, "Warning: No neutron could reach Component[53] curved_guide_19_0\n");
    if (mcAbsorbProp[53]) fprintf(stderr, "Warning: %g events were removed in Component[53] curved_guide_19_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[53]);
  /* User FINALLY code for component 'curved_guide_20_0'. */
  SIG_MESSAGE("curved_guide_20_0 (Finally)");
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
{   /* Declarations of curved_guide_20_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_20_0_w1;
MCNUM h1 = mcccurved_guide_20_0_h1;
MCNUM w2 = mcccurved_guide_20_0_w2;
MCNUM h2 = mcccurved_guide_20_0_h2;
MCNUM l = mcccurved_guide_20_0_l;
MCNUM R0 = mcccurved_guide_20_0_R0;
MCNUM Qc = mcccurved_guide_20_0_Qc;
MCNUM alpha = mcccurved_guide_20_0_alpha;
MCNUM m = mcccurved_guide_20_0_m;
MCNUM W = mcccurved_guide_20_0_W;
MCNUM nslit = mcccurved_guide_20_0_nslit;
MCNUM d = mcccurved_guide_20_0_d;
MCNUM mleft = mcccurved_guide_20_0_mleft;
MCNUM mright = mcccurved_guide_20_0_mright;
MCNUM mtop = mcccurved_guide_20_0_mtop;
MCNUM mbottom = mcccurved_guide_20_0_mbottom;
MCNUM nhslit = mcccurved_guide_20_0_nhslit;
MCNUM G = mcccurved_guide_20_0_G;
MCNUM aleft = mcccurved_guide_20_0_aleft;
MCNUM aright = mcccurved_guide_20_0_aright;
MCNUM atop = mcccurved_guide_20_0_atop;
MCNUM abottom = mcccurved_guide_20_0_abottom;
MCNUM wavy = mcccurved_guide_20_0_wavy;
MCNUM wavy_z = mcccurved_guide_20_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_20_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_20_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_20_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_20_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_20_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_20_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_20_0_nelements;
MCNUM nu = mcccurved_guide_20_0_nu;
MCNUM phase = mcccurved_guide_20_0_phase;
char* reflect = mcccurved_guide_20_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 75947 "BIFROST.c"
}   /* End of curved_guide_20_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[54]) fprintf(stderr, "Warning: No neutron could reach Component[54] curved_guide_20_0\n");
    if (mcAbsorbProp[54]) fprintf(stderr, "Warning: %g events were removed in Component[54] curved_guide_20_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[54]);
  /* User FINALLY code for component 'curved_guide_21_0'. */
  SIG_MESSAGE("curved_guide_21_0 (Finally)");
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
{   /* Declarations of curved_guide_21_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_21_0_w1;
MCNUM h1 = mcccurved_guide_21_0_h1;
MCNUM w2 = mcccurved_guide_21_0_w2;
MCNUM h2 = mcccurved_guide_21_0_h2;
MCNUM l = mcccurved_guide_21_0_l;
MCNUM R0 = mcccurved_guide_21_0_R0;
MCNUM Qc = mcccurved_guide_21_0_Qc;
MCNUM alpha = mcccurved_guide_21_0_alpha;
MCNUM m = mcccurved_guide_21_0_m;
MCNUM W = mcccurved_guide_21_0_W;
MCNUM nslit = mcccurved_guide_21_0_nslit;
MCNUM d = mcccurved_guide_21_0_d;
MCNUM mleft = mcccurved_guide_21_0_mleft;
MCNUM mright = mcccurved_guide_21_0_mright;
MCNUM mtop = mcccurved_guide_21_0_mtop;
MCNUM mbottom = mcccurved_guide_21_0_mbottom;
MCNUM nhslit = mcccurved_guide_21_0_nhslit;
MCNUM G = mcccurved_guide_21_0_G;
MCNUM aleft = mcccurved_guide_21_0_aleft;
MCNUM aright = mcccurved_guide_21_0_aright;
MCNUM atop = mcccurved_guide_21_0_atop;
MCNUM abottom = mcccurved_guide_21_0_abottom;
MCNUM wavy = mcccurved_guide_21_0_wavy;
MCNUM wavy_z = mcccurved_guide_21_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_21_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_21_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_21_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_21_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_21_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_21_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_21_0_nelements;
MCNUM nu = mcccurved_guide_21_0_nu;
MCNUM phase = mcccurved_guide_21_0_phase;
char* reflect = mcccurved_guide_21_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76006 "BIFROST.c"
}   /* End of curved_guide_21_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[55]) fprintf(stderr, "Warning: No neutron could reach Component[55] curved_guide_21_0\n");
    if (mcAbsorbProp[55]) fprintf(stderr, "Warning: %g events were removed in Component[55] curved_guide_21_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[55]);
  /* User FINALLY code for component 'curved_guide_22_0'. */
  SIG_MESSAGE("curved_guide_22_0 (Finally)");
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
{   /* Declarations of curved_guide_22_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_22_0_w1;
MCNUM h1 = mcccurved_guide_22_0_h1;
MCNUM w2 = mcccurved_guide_22_0_w2;
MCNUM h2 = mcccurved_guide_22_0_h2;
MCNUM l = mcccurved_guide_22_0_l;
MCNUM R0 = mcccurved_guide_22_0_R0;
MCNUM Qc = mcccurved_guide_22_0_Qc;
MCNUM alpha = mcccurved_guide_22_0_alpha;
MCNUM m = mcccurved_guide_22_0_m;
MCNUM W = mcccurved_guide_22_0_W;
MCNUM nslit = mcccurved_guide_22_0_nslit;
MCNUM d = mcccurved_guide_22_0_d;
MCNUM mleft = mcccurved_guide_22_0_mleft;
MCNUM mright = mcccurved_guide_22_0_mright;
MCNUM mtop = mcccurved_guide_22_0_mtop;
MCNUM mbottom = mcccurved_guide_22_0_mbottom;
MCNUM nhslit = mcccurved_guide_22_0_nhslit;
MCNUM G = mcccurved_guide_22_0_G;
MCNUM aleft = mcccurved_guide_22_0_aleft;
MCNUM aright = mcccurved_guide_22_0_aright;
MCNUM atop = mcccurved_guide_22_0_atop;
MCNUM abottom = mcccurved_guide_22_0_abottom;
MCNUM wavy = mcccurved_guide_22_0_wavy;
MCNUM wavy_z = mcccurved_guide_22_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_22_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_22_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_22_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_22_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_22_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_22_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_22_0_nelements;
MCNUM nu = mcccurved_guide_22_0_nu;
MCNUM phase = mcccurved_guide_22_0_phase;
char* reflect = mcccurved_guide_22_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76065 "BIFROST.c"
}   /* End of curved_guide_22_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[56]) fprintf(stderr, "Warning: No neutron could reach Component[56] curved_guide_22_0\n");
    if (mcAbsorbProp[56]) fprintf(stderr, "Warning: %g events were removed in Component[56] curved_guide_22_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[56]);
  /* User FINALLY code for component 'curved_guide_23_0'. */
  SIG_MESSAGE("curved_guide_23_0 (Finally)");
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
{   /* Declarations of curved_guide_23_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_23_0_w1;
MCNUM h1 = mcccurved_guide_23_0_h1;
MCNUM w2 = mcccurved_guide_23_0_w2;
MCNUM h2 = mcccurved_guide_23_0_h2;
MCNUM l = mcccurved_guide_23_0_l;
MCNUM R0 = mcccurved_guide_23_0_R0;
MCNUM Qc = mcccurved_guide_23_0_Qc;
MCNUM alpha = mcccurved_guide_23_0_alpha;
MCNUM m = mcccurved_guide_23_0_m;
MCNUM W = mcccurved_guide_23_0_W;
MCNUM nslit = mcccurved_guide_23_0_nslit;
MCNUM d = mcccurved_guide_23_0_d;
MCNUM mleft = mcccurved_guide_23_0_mleft;
MCNUM mright = mcccurved_guide_23_0_mright;
MCNUM mtop = mcccurved_guide_23_0_mtop;
MCNUM mbottom = mcccurved_guide_23_0_mbottom;
MCNUM nhslit = mcccurved_guide_23_0_nhslit;
MCNUM G = mcccurved_guide_23_0_G;
MCNUM aleft = mcccurved_guide_23_0_aleft;
MCNUM aright = mcccurved_guide_23_0_aright;
MCNUM atop = mcccurved_guide_23_0_atop;
MCNUM abottom = mcccurved_guide_23_0_abottom;
MCNUM wavy = mcccurved_guide_23_0_wavy;
MCNUM wavy_z = mcccurved_guide_23_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_23_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_23_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_23_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_23_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_23_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_23_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_23_0_nelements;
MCNUM nu = mcccurved_guide_23_0_nu;
MCNUM phase = mcccurved_guide_23_0_phase;
char* reflect = mcccurved_guide_23_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76124 "BIFROST.c"
}   /* End of curved_guide_23_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[57]) fprintf(stderr, "Warning: No neutron could reach Component[57] curved_guide_23_0\n");
    if (mcAbsorbProp[57]) fprintf(stderr, "Warning: %g events were removed in Component[57] curved_guide_23_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[57]);
  /* User FINALLY code for component 'curved_guide_24_0'. */
  SIG_MESSAGE("curved_guide_24_0 (Finally)");
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
{   /* Declarations of curved_guide_24_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_24_0_w1;
MCNUM h1 = mcccurved_guide_24_0_h1;
MCNUM w2 = mcccurved_guide_24_0_w2;
MCNUM h2 = mcccurved_guide_24_0_h2;
MCNUM l = mcccurved_guide_24_0_l;
MCNUM R0 = mcccurved_guide_24_0_R0;
MCNUM Qc = mcccurved_guide_24_0_Qc;
MCNUM alpha = mcccurved_guide_24_0_alpha;
MCNUM m = mcccurved_guide_24_0_m;
MCNUM W = mcccurved_guide_24_0_W;
MCNUM nslit = mcccurved_guide_24_0_nslit;
MCNUM d = mcccurved_guide_24_0_d;
MCNUM mleft = mcccurved_guide_24_0_mleft;
MCNUM mright = mcccurved_guide_24_0_mright;
MCNUM mtop = mcccurved_guide_24_0_mtop;
MCNUM mbottom = mcccurved_guide_24_0_mbottom;
MCNUM nhslit = mcccurved_guide_24_0_nhslit;
MCNUM G = mcccurved_guide_24_0_G;
MCNUM aleft = mcccurved_guide_24_0_aleft;
MCNUM aright = mcccurved_guide_24_0_aright;
MCNUM atop = mcccurved_guide_24_0_atop;
MCNUM abottom = mcccurved_guide_24_0_abottom;
MCNUM wavy = mcccurved_guide_24_0_wavy;
MCNUM wavy_z = mcccurved_guide_24_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_24_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_24_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_24_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_24_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_24_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_24_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_24_0_nelements;
MCNUM nu = mcccurved_guide_24_0_nu;
MCNUM phase = mcccurved_guide_24_0_phase;
char* reflect = mcccurved_guide_24_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76183 "BIFROST.c"
}   /* End of curved_guide_24_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[58]) fprintf(stderr, "Warning: No neutron could reach Component[58] curved_guide_24_0\n");
    if (mcAbsorbProp[58]) fprintf(stderr, "Warning: %g events were removed in Component[58] curved_guide_24_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[58]);
  /* User FINALLY code for component 'curved_guide_25_0'. */
  SIG_MESSAGE("curved_guide_25_0 (Finally)");
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
{   /* Declarations of curved_guide_25_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_25_0_w1;
MCNUM h1 = mcccurved_guide_25_0_h1;
MCNUM w2 = mcccurved_guide_25_0_w2;
MCNUM h2 = mcccurved_guide_25_0_h2;
MCNUM l = mcccurved_guide_25_0_l;
MCNUM R0 = mcccurved_guide_25_0_R0;
MCNUM Qc = mcccurved_guide_25_0_Qc;
MCNUM alpha = mcccurved_guide_25_0_alpha;
MCNUM m = mcccurved_guide_25_0_m;
MCNUM W = mcccurved_guide_25_0_W;
MCNUM nslit = mcccurved_guide_25_0_nslit;
MCNUM d = mcccurved_guide_25_0_d;
MCNUM mleft = mcccurved_guide_25_0_mleft;
MCNUM mright = mcccurved_guide_25_0_mright;
MCNUM mtop = mcccurved_guide_25_0_mtop;
MCNUM mbottom = mcccurved_guide_25_0_mbottom;
MCNUM nhslit = mcccurved_guide_25_0_nhslit;
MCNUM G = mcccurved_guide_25_0_G;
MCNUM aleft = mcccurved_guide_25_0_aleft;
MCNUM aright = mcccurved_guide_25_0_aright;
MCNUM atop = mcccurved_guide_25_0_atop;
MCNUM abottom = mcccurved_guide_25_0_abottom;
MCNUM wavy = mcccurved_guide_25_0_wavy;
MCNUM wavy_z = mcccurved_guide_25_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_25_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_25_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_25_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_25_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_25_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_25_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_25_0_nelements;
MCNUM nu = mcccurved_guide_25_0_nu;
MCNUM phase = mcccurved_guide_25_0_phase;
char* reflect = mcccurved_guide_25_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76242 "BIFROST.c"
}   /* End of curved_guide_25_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[59]) fprintf(stderr, "Warning: No neutron could reach Component[59] curved_guide_25_0\n");
    if (mcAbsorbProp[59]) fprintf(stderr, "Warning: %g events were removed in Component[59] curved_guide_25_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[59]);
  /* User FINALLY code for component 'curved_guide_26_0'. */
  SIG_MESSAGE("curved_guide_26_0 (Finally)");
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 60
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
{   /* Declarations of curved_guide_26_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_26_0_w1;
MCNUM h1 = mcccurved_guide_26_0_h1;
MCNUM w2 = mcccurved_guide_26_0_w2;
MCNUM h2 = mcccurved_guide_26_0_h2;
MCNUM l = mcccurved_guide_26_0_l;
MCNUM R0 = mcccurved_guide_26_0_R0;
MCNUM Qc = mcccurved_guide_26_0_Qc;
MCNUM alpha = mcccurved_guide_26_0_alpha;
MCNUM m = mcccurved_guide_26_0_m;
MCNUM W = mcccurved_guide_26_0_W;
MCNUM nslit = mcccurved_guide_26_0_nslit;
MCNUM d = mcccurved_guide_26_0_d;
MCNUM mleft = mcccurved_guide_26_0_mleft;
MCNUM mright = mcccurved_guide_26_0_mright;
MCNUM mtop = mcccurved_guide_26_0_mtop;
MCNUM mbottom = mcccurved_guide_26_0_mbottom;
MCNUM nhslit = mcccurved_guide_26_0_nhslit;
MCNUM G = mcccurved_guide_26_0_G;
MCNUM aleft = mcccurved_guide_26_0_aleft;
MCNUM aright = mcccurved_guide_26_0_aright;
MCNUM atop = mcccurved_guide_26_0_atop;
MCNUM abottom = mcccurved_guide_26_0_abottom;
MCNUM wavy = mcccurved_guide_26_0_wavy;
MCNUM wavy_z = mcccurved_guide_26_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_26_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_26_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_26_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_26_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_26_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_26_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_26_0_nelements;
MCNUM nu = mcccurved_guide_26_0_nu;
MCNUM phase = mcccurved_guide_26_0_phase;
char* reflect = mcccurved_guide_26_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76301 "BIFROST.c"
}   /* End of curved_guide_26_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[60]) fprintf(stderr, "Warning: No neutron could reach Component[60] curved_guide_26_0\n");
    if (mcAbsorbProp[60]) fprintf(stderr, "Warning: %g events were removed in Component[60] curved_guide_26_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[60]);
  /* User FINALLY code for component 'curved_guide_27_0'. */
  SIG_MESSAGE("curved_guide_27_0 (Finally)");
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 61
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
{   /* Declarations of curved_guide_27_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_27_0_w1;
MCNUM h1 = mcccurved_guide_27_0_h1;
MCNUM w2 = mcccurved_guide_27_0_w2;
MCNUM h2 = mcccurved_guide_27_0_h2;
MCNUM l = mcccurved_guide_27_0_l;
MCNUM R0 = mcccurved_guide_27_0_R0;
MCNUM Qc = mcccurved_guide_27_0_Qc;
MCNUM alpha = mcccurved_guide_27_0_alpha;
MCNUM m = mcccurved_guide_27_0_m;
MCNUM W = mcccurved_guide_27_0_W;
MCNUM nslit = mcccurved_guide_27_0_nslit;
MCNUM d = mcccurved_guide_27_0_d;
MCNUM mleft = mcccurved_guide_27_0_mleft;
MCNUM mright = mcccurved_guide_27_0_mright;
MCNUM mtop = mcccurved_guide_27_0_mtop;
MCNUM mbottom = mcccurved_guide_27_0_mbottom;
MCNUM nhslit = mcccurved_guide_27_0_nhslit;
MCNUM G = mcccurved_guide_27_0_G;
MCNUM aleft = mcccurved_guide_27_0_aleft;
MCNUM aright = mcccurved_guide_27_0_aright;
MCNUM atop = mcccurved_guide_27_0_atop;
MCNUM abottom = mcccurved_guide_27_0_abottom;
MCNUM wavy = mcccurved_guide_27_0_wavy;
MCNUM wavy_z = mcccurved_guide_27_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_27_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_27_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_27_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_27_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_27_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_27_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_27_0_nelements;
MCNUM nu = mcccurved_guide_27_0_nu;
MCNUM phase = mcccurved_guide_27_0_phase;
char* reflect = mcccurved_guide_27_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76360 "BIFROST.c"
}   /* End of curved_guide_27_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[61]) fprintf(stderr, "Warning: No neutron could reach Component[61] curved_guide_27_0\n");
    if (mcAbsorbProp[61]) fprintf(stderr, "Warning: %g events were removed in Component[61] curved_guide_27_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[61]);
  /* User FINALLY code for component 'curved_guide_28_0'. */
  SIG_MESSAGE("curved_guide_28_0 (Finally)");
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 62
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
{   /* Declarations of curved_guide_28_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_28_0_w1;
MCNUM h1 = mcccurved_guide_28_0_h1;
MCNUM w2 = mcccurved_guide_28_0_w2;
MCNUM h2 = mcccurved_guide_28_0_h2;
MCNUM l = mcccurved_guide_28_0_l;
MCNUM R0 = mcccurved_guide_28_0_R0;
MCNUM Qc = mcccurved_guide_28_0_Qc;
MCNUM alpha = mcccurved_guide_28_0_alpha;
MCNUM m = mcccurved_guide_28_0_m;
MCNUM W = mcccurved_guide_28_0_W;
MCNUM nslit = mcccurved_guide_28_0_nslit;
MCNUM d = mcccurved_guide_28_0_d;
MCNUM mleft = mcccurved_guide_28_0_mleft;
MCNUM mright = mcccurved_guide_28_0_mright;
MCNUM mtop = mcccurved_guide_28_0_mtop;
MCNUM mbottom = mcccurved_guide_28_0_mbottom;
MCNUM nhslit = mcccurved_guide_28_0_nhslit;
MCNUM G = mcccurved_guide_28_0_G;
MCNUM aleft = mcccurved_guide_28_0_aleft;
MCNUM aright = mcccurved_guide_28_0_aright;
MCNUM atop = mcccurved_guide_28_0_atop;
MCNUM abottom = mcccurved_guide_28_0_abottom;
MCNUM wavy = mcccurved_guide_28_0_wavy;
MCNUM wavy_z = mcccurved_guide_28_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_28_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_28_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_28_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_28_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_28_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_28_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_28_0_nelements;
MCNUM nu = mcccurved_guide_28_0_nu;
MCNUM phase = mcccurved_guide_28_0_phase;
char* reflect = mcccurved_guide_28_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76419 "BIFROST.c"
}   /* End of curved_guide_28_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[62]) fprintf(stderr, "Warning: No neutron could reach Component[62] curved_guide_28_0\n");
    if (mcAbsorbProp[62]) fprintf(stderr, "Warning: %g events were removed in Component[62] curved_guide_28_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[62]);
  /* User FINALLY code for component 'curved_guide_29_0'. */
  SIG_MESSAGE("curved_guide_29_0 (Finally)");
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 63
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
{   /* Declarations of curved_guide_29_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_29_0_w1;
MCNUM h1 = mcccurved_guide_29_0_h1;
MCNUM w2 = mcccurved_guide_29_0_w2;
MCNUM h2 = mcccurved_guide_29_0_h2;
MCNUM l = mcccurved_guide_29_0_l;
MCNUM R0 = mcccurved_guide_29_0_R0;
MCNUM Qc = mcccurved_guide_29_0_Qc;
MCNUM alpha = mcccurved_guide_29_0_alpha;
MCNUM m = mcccurved_guide_29_0_m;
MCNUM W = mcccurved_guide_29_0_W;
MCNUM nslit = mcccurved_guide_29_0_nslit;
MCNUM d = mcccurved_guide_29_0_d;
MCNUM mleft = mcccurved_guide_29_0_mleft;
MCNUM mright = mcccurved_guide_29_0_mright;
MCNUM mtop = mcccurved_guide_29_0_mtop;
MCNUM mbottom = mcccurved_guide_29_0_mbottom;
MCNUM nhslit = mcccurved_guide_29_0_nhslit;
MCNUM G = mcccurved_guide_29_0_G;
MCNUM aleft = mcccurved_guide_29_0_aleft;
MCNUM aright = mcccurved_guide_29_0_aright;
MCNUM atop = mcccurved_guide_29_0_atop;
MCNUM abottom = mcccurved_guide_29_0_abottom;
MCNUM wavy = mcccurved_guide_29_0_wavy;
MCNUM wavy_z = mcccurved_guide_29_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_29_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_29_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_29_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_29_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_29_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_29_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_29_0_nelements;
MCNUM nu = mcccurved_guide_29_0_nu;
MCNUM phase = mcccurved_guide_29_0_phase;
char* reflect = mcccurved_guide_29_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76478 "BIFROST.c"
}   /* End of curved_guide_29_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[63]) fprintf(stderr, "Warning: No neutron could reach Component[63] curved_guide_29_0\n");
    if (mcAbsorbProp[63]) fprintf(stderr, "Warning: %g events were removed in Component[63] curved_guide_29_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[63]);
  /* User FINALLY code for component 'curved_guide_30_0'. */
  SIG_MESSAGE("curved_guide_30_0 (Finally)");
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
{   /* Declarations of curved_guide_30_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_30_0_w1;
MCNUM h1 = mcccurved_guide_30_0_h1;
MCNUM w2 = mcccurved_guide_30_0_w2;
MCNUM h2 = mcccurved_guide_30_0_h2;
MCNUM l = mcccurved_guide_30_0_l;
MCNUM R0 = mcccurved_guide_30_0_R0;
MCNUM Qc = mcccurved_guide_30_0_Qc;
MCNUM alpha = mcccurved_guide_30_0_alpha;
MCNUM m = mcccurved_guide_30_0_m;
MCNUM W = mcccurved_guide_30_0_W;
MCNUM nslit = mcccurved_guide_30_0_nslit;
MCNUM d = mcccurved_guide_30_0_d;
MCNUM mleft = mcccurved_guide_30_0_mleft;
MCNUM mright = mcccurved_guide_30_0_mright;
MCNUM mtop = mcccurved_guide_30_0_mtop;
MCNUM mbottom = mcccurved_guide_30_0_mbottom;
MCNUM nhslit = mcccurved_guide_30_0_nhslit;
MCNUM G = mcccurved_guide_30_0_G;
MCNUM aleft = mcccurved_guide_30_0_aleft;
MCNUM aright = mcccurved_guide_30_0_aright;
MCNUM atop = mcccurved_guide_30_0_atop;
MCNUM abottom = mcccurved_guide_30_0_abottom;
MCNUM wavy = mcccurved_guide_30_0_wavy;
MCNUM wavy_z = mcccurved_guide_30_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_30_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_30_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_30_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_30_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_30_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_30_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_30_0_nelements;
MCNUM nu = mcccurved_guide_30_0_nu;
MCNUM phase = mcccurved_guide_30_0_phase;
char* reflect = mcccurved_guide_30_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76537 "BIFROST.c"
}   /* End of curved_guide_30_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[64]) fprintf(stderr, "Warning: No neutron could reach Component[64] curved_guide_30_0\n");
    if (mcAbsorbProp[64]) fprintf(stderr, "Warning: %g events were removed in Component[64] curved_guide_30_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[64]);
  /* User FINALLY code for component 'curved_guide_31_0'. */
  SIG_MESSAGE("curved_guide_31_0 (Finally)");
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
{   /* Declarations of curved_guide_31_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_31_0_w1;
MCNUM h1 = mcccurved_guide_31_0_h1;
MCNUM w2 = mcccurved_guide_31_0_w2;
MCNUM h2 = mcccurved_guide_31_0_h2;
MCNUM l = mcccurved_guide_31_0_l;
MCNUM R0 = mcccurved_guide_31_0_R0;
MCNUM Qc = mcccurved_guide_31_0_Qc;
MCNUM alpha = mcccurved_guide_31_0_alpha;
MCNUM m = mcccurved_guide_31_0_m;
MCNUM W = mcccurved_guide_31_0_W;
MCNUM nslit = mcccurved_guide_31_0_nslit;
MCNUM d = mcccurved_guide_31_0_d;
MCNUM mleft = mcccurved_guide_31_0_mleft;
MCNUM mright = mcccurved_guide_31_0_mright;
MCNUM mtop = mcccurved_guide_31_0_mtop;
MCNUM mbottom = mcccurved_guide_31_0_mbottom;
MCNUM nhslit = mcccurved_guide_31_0_nhslit;
MCNUM G = mcccurved_guide_31_0_G;
MCNUM aleft = mcccurved_guide_31_0_aleft;
MCNUM aright = mcccurved_guide_31_0_aright;
MCNUM atop = mcccurved_guide_31_0_atop;
MCNUM abottom = mcccurved_guide_31_0_abottom;
MCNUM wavy = mcccurved_guide_31_0_wavy;
MCNUM wavy_z = mcccurved_guide_31_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_31_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_31_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_31_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_31_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_31_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_31_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_31_0_nelements;
MCNUM nu = mcccurved_guide_31_0_nu;
MCNUM phase = mcccurved_guide_31_0_phase;
char* reflect = mcccurved_guide_31_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76596 "BIFROST.c"
}   /* End of curved_guide_31_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[65]) fprintf(stderr, "Warning: No neutron could reach Component[65] curved_guide_31_0\n");
    if (mcAbsorbProp[65]) fprintf(stderr, "Warning: %g events were removed in Component[65] curved_guide_31_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[65]);
  /* User FINALLY code for component 'curved_guide_32_0'. */
  SIG_MESSAGE("curved_guide_32_0 (Finally)");
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
{   /* Declarations of curved_guide_32_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_32_0_w1;
MCNUM h1 = mcccurved_guide_32_0_h1;
MCNUM w2 = mcccurved_guide_32_0_w2;
MCNUM h2 = mcccurved_guide_32_0_h2;
MCNUM l = mcccurved_guide_32_0_l;
MCNUM R0 = mcccurved_guide_32_0_R0;
MCNUM Qc = mcccurved_guide_32_0_Qc;
MCNUM alpha = mcccurved_guide_32_0_alpha;
MCNUM m = mcccurved_guide_32_0_m;
MCNUM W = mcccurved_guide_32_0_W;
MCNUM nslit = mcccurved_guide_32_0_nslit;
MCNUM d = mcccurved_guide_32_0_d;
MCNUM mleft = mcccurved_guide_32_0_mleft;
MCNUM mright = mcccurved_guide_32_0_mright;
MCNUM mtop = mcccurved_guide_32_0_mtop;
MCNUM mbottom = mcccurved_guide_32_0_mbottom;
MCNUM nhslit = mcccurved_guide_32_0_nhslit;
MCNUM G = mcccurved_guide_32_0_G;
MCNUM aleft = mcccurved_guide_32_0_aleft;
MCNUM aright = mcccurved_guide_32_0_aright;
MCNUM atop = mcccurved_guide_32_0_atop;
MCNUM abottom = mcccurved_guide_32_0_abottom;
MCNUM wavy = mcccurved_guide_32_0_wavy;
MCNUM wavy_z = mcccurved_guide_32_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_32_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_32_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_32_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_32_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_32_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_32_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_32_0_nelements;
MCNUM nu = mcccurved_guide_32_0_nu;
MCNUM phase = mcccurved_guide_32_0_phase;
char* reflect = mcccurved_guide_32_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76655 "BIFROST.c"
}   /* End of curved_guide_32_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[66]) fprintf(stderr, "Warning: No neutron could reach Component[66] curved_guide_32_0\n");
    if (mcAbsorbProp[66]) fprintf(stderr, "Warning: %g events were removed in Component[66] curved_guide_32_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[66]);
  /* User FINALLY code for component 'curved_guide_33_0'. */
  SIG_MESSAGE("curved_guide_33_0 (Finally)");
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
{   /* Declarations of curved_guide_33_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_33_0_w1;
MCNUM h1 = mcccurved_guide_33_0_h1;
MCNUM w2 = mcccurved_guide_33_0_w2;
MCNUM h2 = mcccurved_guide_33_0_h2;
MCNUM l = mcccurved_guide_33_0_l;
MCNUM R0 = mcccurved_guide_33_0_R0;
MCNUM Qc = mcccurved_guide_33_0_Qc;
MCNUM alpha = mcccurved_guide_33_0_alpha;
MCNUM m = mcccurved_guide_33_0_m;
MCNUM W = mcccurved_guide_33_0_W;
MCNUM nslit = mcccurved_guide_33_0_nslit;
MCNUM d = mcccurved_guide_33_0_d;
MCNUM mleft = mcccurved_guide_33_0_mleft;
MCNUM mright = mcccurved_guide_33_0_mright;
MCNUM mtop = mcccurved_guide_33_0_mtop;
MCNUM mbottom = mcccurved_guide_33_0_mbottom;
MCNUM nhslit = mcccurved_guide_33_0_nhslit;
MCNUM G = mcccurved_guide_33_0_G;
MCNUM aleft = mcccurved_guide_33_0_aleft;
MCNUM aright = mcccurved_guide_33_0_aright;
MCNUM atop = mcccurved_guide_33_0_atop;
MCNUM abottom = mcccurved_guide_33_0_abottom;
MCNUM wavy = mcccurved_guide_33_0_wavy;
MCNUM wavy_z = mcccurved_guide_33_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_33_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_33_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_33_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_33_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_33_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_33_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_33_0_nelements;
MCNUM nu = mcccurved_guide_33_0_nu;
MCNUM phase = mcccurved_guide_33_0_phase;
char* reflect = mcccurved_guide_33_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76714 "BIFROST.c"
}   /* End of curved_guide_33_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[67]) fprintf(stderr, "Warning: No neutron could reach Component[67] curved_guide_33_0\n");
    if (mcAbsorbProp[67]) fprintf(stderr, "Warning: %g events were removed in Component[67] curved_guide_33_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[67]);
  /* User FINALLY code for component 'curved_guide_34_0'. */
  SIG_MESSAGE("curved_guide_34_0 (Finally)");
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
{   /* Declarations of curved_guide_34_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_34_0_w1;
MCNUM h1 = mcccurved_guide_34_0_h1;
MCNUM w2 = mcccurved_guide_34_0_w2;
MCNUM h2 = mcccurved_guide_34_0_h2;
MCNUM l = mcccurved_guide_34_0_l;
MCNUM R0 = mcccurved_guide_34_0_R0;
MCNUM Qc = mcccurved_guide_34_0_Qc;
MCNUM alpha = mcccurved_guide_34_0_alpha;
MCNUM m = mcccurved_guide_34_0_m;
MCNUM W = mcccurved_guide_34_0_W;
MCNUM nslit = mcccurved_guide_34_0_nslit;
MCNUM d = mcccurved_guide_34_0_d;
MCNUM mleft = mcccurved_guide_34_0_mleft;
MCNUM mright = mcccurved_guide_34_0_mright;
MCNUM mtop = mcccurved_guide_34_0_mtop;
MCNUM mbottom = mcccurved_guide_34_0_mbottom;
MCNUM nhslit = mcccurved_guide_34_0_nhslit;
MCNUM G = mcccurved_guide_34_0_G;
MCNUM aleft = mcccurved_guide_34_0_aleft;
MCNUM aright = mcccurved_guide_34_0_aright;
MCNUM atop = mcccurved_guide_34_0_atop;
MCNUM abottom = mcccurved_guide_34_0_abottom;
MCNUM wavy = mcccurved_guide_34_0_wavy;
MCNUM wavy_z = mcccurved_guide_34_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_34_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_34_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_34_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_34_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_34_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_34_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_34_0_nelements;
MCNUM nu = mcccurved_guide_34_0_nu;
MCNUM phase = mcccurved_guide_34_0_phase;
char* reflect = mcccurved_guide_34_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76773 "BIFROST.c"
}   /* End of curved_guide_34_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[68]) fprintf(stderr, "Warning: No neutron could reach Component[68] curved_guide_34_0\n");
    if (mcAbsorbProp[68]) fprintf(stderr, "Warning: %g events were removed in Component[68] curved_guide_34_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[68]);
  /* User FINALLY code for component 'curved_guide_35_0'. */
  SIG_MESSAGE("curved_guide_35_0 (Finally)");
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 69
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
{   /* Declarations of curved_guide_35_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_35_0_w1;
MCNUM h1 = mcccurved_guide_35_0_h1;
MCNUM w2 = mcccurved_guide_35_0_w2;
MCNUM h2 = mcccurved_guide_35_0_h2;
MCNUM l = mcccurved_guide_35_0_l;
MCNUM R0 = mcccurved_guide_35_0_R0;
MCNUM Qc = mcccurved_guide_35_0_Qc;
MCNUM alpha = mcccurved_guide_35_0_alpha;
MCNUM m = mcccurved_guide_35_0_m;
MCNUM W = mcccurved_guide_35_0_W;
MCNUM nslit = mcccurved_guide_35_0_nslit;
MCNUM d = mcccurved_guide_35_0_d;
MCNUM mleft = mcccurved_guide_35_0_mleft;
MCNUM mright = mcccurved_guide_35_0_mright;
MCNUM mtop = mcccurved_guide_35_0_mtop;
MCNUM mbottom = mcccurved_guide_35_0_mbottom;
MCNUM nhslit = mcccurved_guide_35_0_nhslit;
MCNUM G = mcccurved_guide_35_0_G;
MCNUM aleft = mcccurved_guide_35_0_aleft;
MCNUM aright = mcccurved_guide_35_0_aright;
MCNUM atop = mcccurved_guide_35_0_atop;
MCNUM abottom = mcccurved_guide_35_0_abottom;
MCNUM wavy = mcccurved_guide_35_0_wavy;
MCNUM wavy_z = mcccurved_guide_35_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_35_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_35_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_35_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_35_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_35_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_35_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_35_0_nelements;
MCNUM nu = mcccurved_guide_35_0_nu;
MCNUM phase = mcccurved_guide_35_0_phase;
char* reflect = mcccurved_guide_35_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76832 "BIFROST.c"
}   /* End of curved_guide_35_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[69]) fprintf(stderr, "Warning: No neutron could reach Component[69] curved_guide_35_0\n");
    if (mcAbsorbProp[69]) fprintf(stderr, "Warning: %g events were removed in Component[69] curved_guide_35_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[69]);
  /* User FINALLY code for component 'curved_guide_36_0'. */
  SIG_MESSAGE("curved_guide_36_0 (Finally)");
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
{   /* Declarations of curved_guide_36_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_36_0_w1;
MCNUM h1 = mcccurved_guide_36_0_h1;
MCNUM w2 = mcccurved_guide_36_0_w2;
MCNUM h2 = mcccurved_guide_36_0_h2;
MCNUM l = mcccurved_guide_36_0_l;
MCNUM R0 = mcccurved_guide_36_0_R0;
MCNUM Qc = mcccurved_guide_36_0_Qc;
MCNUM alpha = mcccurved_guide_36_0_alpha;
MCNUM m = mcccurved_guide_36_0_m;
MCNUM W = mcccurved_guide_36_0_W;
MCNUM nslit = mcccurved_guide_36_0_nslit;
MCNUM d = mcccurved_guide_36_0_d;
MCNUM mleft = mcccurved_guide_36_0_mleft;
MCNUM mright = mcccurved_guide_36_0_mright;
MCNUM mtop = mcccurved_guide_36_0_mtop;
MCNUM mbottom = mcccurved_guide_36_0_mbottom;
MCNUM nhslit = mcccurved_guide_36_0_nhslit;
MCNUM G = mcccurved_guide_36_0_G;
MCNUM aleft = mcccurved_guide_36_0_aleft;
MCNUM aright = mcccurved_guide_36_0_aright;
MCNUM atop = mcccurved_guide_36_0_atop;
MCNUM abottom = mcccurved_guide_36_0_abottom;
MCNUM wavy = mcccurved_guide_36_0_wavy;
MCNUM wavy_z = mcccurved_guide_36_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_36_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_36_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_36_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_36_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_36_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_36_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_36_0_nelements;
MCNUM nu = mcccurved_guide_36_0_nu;
MCNUM phase = mcccurved_guide_36_0_phase;
char* reflect = mcccurved_guide_36_0_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76891 "BIFROST.c"
}   /* End of curved_guide_36_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[70]) fprintf(stderr, "Warning: No neutron could reach Component[70] curved_guide_36_0\n");
    if (mcAbsorbProp[70]) fprintf(stderr, "Warning: %g events were removed in Component[70] curved_guide_36_0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[70]);
    if (!mcNCounter[71]) fprintf(stderr, "Warning: No neutron could reach Component[71] EndOfelement_4\n");
    if (mcAbsorbProp[71]) fprintf(stderr, "Warning: %g events were removed in Component[71] EndOfelement_4=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[71]);
    if (!mcNCounter[72]) fprintf(stderr, "Warning: No neutron could reach Component[72] elliptical_guide_gravity3\n");
    if (mcAbsorbProp[72]) fprintf(stderr, "Warning: %g events were removed in Component[72] elliptical_guide_gravity3=Elliptic_guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[72]);
    if (!mcNCounter[73]) fprintf(stderr, "Warning: No neutron could reach Component[73] EndOfelement_3\n");
    if (mcAbsorbProp[73]) fprintf(stderr, "Warning: %g events were removed in Component[73] EndOfelement_3=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[73]);
  /* User FINALLY code for component 'straight_guide_2_1'. */
  SIG_MESSAGE("straight_guide_2_1 (Finally)");
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
{   /* Declarations of straight_guide_2_1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_1_w1;
MCNUM h1 = mccstraight_guide_2_1_h1;
MCNUM w2 = mccstraight_guide_2_1_w2;
MCNUM h2 = mccstraight_guide_2_1_h2;
MCNUM l = mccstraight_guide_2_1_l;
MCNUM R0 = mccstraight_guide_2_1_R0;
MCNUM Qc = mccstraight_guide_2_1_Qc;
MCNUM alpha = mccstraight_guide_2_1_alpha;
MCNUM m = mccstraight_guide_2_1_m;
MCNUM W = mccstraight_guide_2_1_W;
MCNUM nslit = mccstraight_guide_2_1_nslit;
MCNUM d = mccstraight_guide_2_1_d;
MCNUM mleft = mccstraight_guide_2_1_mleft;
MCNUM mright = mccstraight_guide_2_1_mright;
MCNUM mtop = mccstraight_guide_2_1_mtop;
MCNUM mbottom = mccstraight_guide_2_1_mbottom;
MCNUM nhslit = mccstraight_guide_2_1_nhslit;
MCNUM G = mccstraight_guide_2_1_G;
MCNUM aleft = mccstraight_guide_2_1_aleft;
MCNUM aright = mccstraight_guide_2_1_aright;
MCNUM atop = mccstraight_guide_2_1_atop;
MCNUM abottom = mccstraight_guide_2_1_abottom;
MCNUM wavy = mccstraight_guide_2_1_wavy;
MCNUM wavy_z = mccstraight_guide_2_1_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_1_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_1_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_1_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_1_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_1_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_1_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_1_nelements;
MCNUM nu = mccstraight_guide_2_1_nu;
MCNUM phase = mccstraight_guide_2_1_phase;
char* reflect = mccstraight_guide_2_1_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 76956 "BIFROST.c"
}   /* End of straight_guide_2_1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[74]) fprintf(stderr, "Warning: No neutron could reach Component[74] straight_guide_2_1\n");
    if (mcAbsorbProp[74]) fprintf(stderr, "Warning: %g events were removed in Component[74] straight_guide_2_1=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[74]);
    if (!mcNCounter[75]) fprintf(stderr, "Warning: No neutron could reach Component[75] L_monBeforeBWC\n");
    if (mcAbsorbProp[75]) fprintf(stderr, "Warning: %g events were removed in Component[75] L_monBeforeBWC=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[75]);
    if (!mcNCounter[76]) fprintf(stderr, "Warning: No neutron could reach Component[76] ToFBeforeBWC\n");
    if (mcAbsorbProp[76]) fprintf(stderr, "Warning: %g events were removed in Component[76] ToFBeforeBWC=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[76]);
    if (!mcNCounter[77]) fprintf(stderr, "Warning: No neutron could reach Component[77] BWC1\n");
    if (mcAbsorbProp[77]) fprintf(stderr, "Warning: %g events were removed in Component[77] BWC1=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[77]);
    if (!mcNCounter[78]) fprintf(stderr, "Warning: No neutron could reach Component[78] BWC2\n");
    if (mcAbsorbProp[78]) fprintf(stderr, "Warning: %g events were removed in Component[78] BWC2=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[78]);
    if (!mcNCounter[79]) fprintf(stderr, "Warning: No neutron could reach Component[79] ToFAfterBWC\n");
    if (mcAbsorbProp[79]) fprintf(stderr, "Warning: %g events were removed in Component[79] ToFAfterBWC=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[79]);
    if (!mcNCounter[80]) fprintf(stderr, "Warning: No neutron could reach Component[80] L_monAfterBWC\n");
    if (mcAbsorbProp[80]) fprintf(stderr, "Warning: %g events were removed in Component[80] L_monAfterBWC=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[80]);
  /* User FINALLY code for component 'straight_guide_2_2'. */
  SIG_MESSAGE("straight_guide_2_2 (Finally)");
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 81
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
{   /* Declarations of straight_guide_2_2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_2_w1;
MCNUM h1 = mccstraight_guide_2_2_h1;
MCNUM w2 = mccstraight_guide_2_2_w2;
MCNUM h2 = mccstraight_guide_2_2_h2;
MCNUM l = mccstraight_guide_2_2_l;
MCNUM R0 = mccstraight_guide_2_2_R0;
MCNUM Qc = mccstraight_guide_2_2_Qc;
MCNUM alpha = mccstraight_guide_2_2_alpha;
MCNUM m = mccstraight_guide_2_2_m;
MCNUM W = mccstraight_guide_2_2_W;
MCNUM nslit = mccstraight_guide_2_2_nslit;
MCNUM d = mccstraight_guide_2_2_d;
MCNUM mleft = mccstraight_guide_2_2_mleft;
MCNUM mright = mccstraight_guide_2_2_mright;
MCNUM mtop = mccstraight_guide_2_2_mtop;
MCNUM mbottom = mccstraight_guide_2_2_mbottom;
MCNUM nhslit = mccstraight_guide_2_2_nhslit;
MCNUM G = mccstraight_guide_2_2_G;
MCNUM aleft = mccstraight_guide_2_2_aleft;
MCNUM aright = mccstraight_guide_2_2_aright;
MCNUM atop = mccstraight_guide_2_2_atop;
MCNUM abottom = mccstraight_guide_2_2_abottom;
MCNUM wavy = mccstraight_guide_2_2_wavy;
MCNUM wavy_z = mccstraight_guide_2_2_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_2_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_2_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_2_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_2_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_2_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_2_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_2_nelements;
MCNUM nu = mccstraight_guide_2_2_nu;
MCNUM phase = mccstraight_guide_2_2_phase;
char* reflect = mccstraight_guide_2_2_reflect;
#line 563 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 77027 "BIFROST.c"
}   /* End of straight_guide_2_2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[81]) fprintf(stderr, "Warning: No neutron could reach Component[81] straight_guide_2_2\n");
    if (mcAbsorbProp[81]) fprintf(stderr, "Warning: %g events were removed in Component[81] straight_guide_2_2=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[81]);
    if (!mcNCounter[82]) fprintf(stderr, "Warning: No neutron could reach Component[82] EndOfelement_2\n");
    if (mcAbsorbProp[82]) fprintf(stderr, "Warning: %g events were removed in Component[82] EndOfelement_2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[82]);
    if (!mcNCounter[83]) fprintf(stderr, "Warning: No neutron could reach Component[83] elliptical_guide_gravity1_1\n");
    if (mcAbsorbProp[83]) fprintf(stderr, "Warning: %g events were removed in Component[83] elliptical_guide_gravity1_1=Elliptic_guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[83]);
    if (!mcNCounter[84]) fprintf(stderr, "Warning: No neutron could reach Component[84] DiwJaw3\n");
    if (mcAbsorbProp[84]) fprintf(stderr, "Warning: %g events were removed in Component[84] DiwJaw3=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[84]);
    if (!mcNCounter[85]) fprintf(stderr, "Warning: No neutron could reach Component[85] elliptical_guide_gravity1_2\n");
    if (mcAbsorbProp[85]) fprintf(stderr, "Warning: %g events were removed in Component[85] elliptical_guide_gravity1_2=Elliptic_guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[85]);
    if (!mcNCounter[86]) fprintf(stderr, "Warning: No neutron could reach Component[86] DiwJaw2\n");
    if (mcAbsorbProp[86]) fprintf(stderr, "Warning: %g events were removed in Component[86] DiwJaw2=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[86]);
    if (!mcNCounter[87]) fprintf(stderr, "Warning: No neutron could reach Component[87] elliptical_guide_gravity1_3\n");
    if (mcAbsorbProp[87]) fprintf(stderr, "Warning: %g events were removed in Component[87] elliptical_guide_gravity1_3=Elliptic_guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[87]);
    if (!mcNCounter[88]) fprintf(stderr, "Warning: No neutron could reach Component[88] DiwJaw1\n");
    if (mcAbsorbProp[88]) fprintf(stderr, "Warning: %g events were removed in Component[88] DiwJaw1=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[88]);
    if (!mcNCounter[89]) fprintf(stderr, "Warning: No neutron could reach Component[89] elliptical_guide_gravity1_4\n");
    if (mcAbsorbProp[89]) fprintf(stderr, "Warning: %g events were removed in Component[89] elliptical_guide_gravity1_4=Elliptic_guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[89]);
    if (!mcNCounter[90]) fprintf(stderr, "Warning: No neutron could reach Component[90] EndOfelement_1\n");
    if (mcAbsorbProp[90]) fprintf(stderr, "Warning: %g events were removed in Component[90] EndOfelement_1=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[90]);
  /* User FINALLY code for component 'VirtualOutput'. */
  SIG_MESSAGE("VirtualOutput (Finally)");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 91
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
#line 146 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\Virtual_output.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
  if (bufsize) {
    printf("Virtual_output: %s: Saved %Li events (from buffer) in file %s\n",
           NAME_CURRENT_COMP, Vars.Nsum, Vars.Mon_File);
    if (bufsize < Vars.Nsum)
      printf("WARNING         When using this source, intensities must be multiplied\n"
             "                by a factor %g\n", (double)Vars.Nsum/(double)bufsize);
  } else printf("Virtual_output: %s: Saved %Li events (all) in file %s\n", NAME_CURRENT_COMP, Vars.Nsum, Vars.Mon_File);
}
#line 77077 "BIFROST.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[91]) fprintf(stderr, "Warning: No neutron could reach Component[91] VirtualOutput\n");
    if (mcAbsorbProp[91]) fprintf(stderr, "Warning: %g events were removed in Component[91] VirtualOutput=Virtual_output()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[91]);
    if (!mcNCounter[92]) fprintf(stderr, "Warning: No neutron could reach Component[92] DiwJaw0\n");
    if (mcAbsorbProp[92]) fprintf(stderr, "Warning: %g events were removed in Component[92] DiwJaw0=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[92]);
    if (!mcNCounter[93]) fprintf(stderr, "Warning: No neutron could reach Component[93] Lmon_guide_end\n");
    if (mcAbsorbProp[93]) fprintf(stderr, "Warning: %g events were removed in Component[93] Lmon_guide_end=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[93]);
    if (!mcNCounter[94]) fprintf(stderr, "Warning: No neutron could reach Component[94] Div2d_sample_B\n");
    if (mcAbsorbProp[94]) fprintf(stderr, "Warning: %g events were removed in Component[94] Div2d_sample_B=Divergence_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[94]);
    if (!mcNCounter[95]) fprintf(stderr, "Warning: No neutron could reach Component[95] Div2d_sample\n");
    if (mcAbsorbProp[95]) fprintf(stderr, "Warning: %g events were removed in Component[95] Div2d_sample=Divergence_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[95]);
    if (!mcNCounter[96]) fprintf(stderr, "Warning: No neutron could reach Component[96] PSD_sample\n");
    if (mcAbsorbProp[96]) fprintf(stderr, "Warning: %g events were removed in Component[96] PSD_sample=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[96]);
    if (!mcNCounter[97]) fprintf(stderr, "Warning: No neutron could reach Component[97] HPSD_sample\n");
    if (mcAbsorbProp[97]) fprintf(stderr, "Warning: %g events were removed in Component[97] HPSD_sample=PSDlin_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[97]);
    if (!mcNCounter[98]) fprintf(stderr, "Warning: No neutron could reach Component[98] VPSD_sample\n");
    if (mcAbsorbProp[98]) fprintf(stderr, "Warning: %g events were removed in Component[98] VPSD_sample=PSDlin_y_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[98]);
    if (!mcNCounter[99]) fprintf(stderr, "Warning: No neutron could reach Component[99] Hdiv_sample\n");
    if (mcAbsorbProp[99]) fprintf(stderr, "Warning: %g events were removed in Component[99] Hdiv_sample=Hdiv_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[99]);
    if (!mcNCounter[100]) fprintf(stderr, "Warning: No neutron could reach Component[100] Vdiv_sample\n");
    if (mcAbsorbProp[100]) fprintf(stderr, "Warning: %g events were removed in Component[100] Vdiv_sample=Vdiv_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[100]);
    if (!mcNCounter[101]) fprintf(stderr, "Warning: No neutron could reach Component[101] acceptance_x_divx\n");
    if (mcAbsorbProp[101]) fprintf(stderr, "Warning: %g events were removed in Component[101] acceptance_x_divx=DivPos_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[101]);
    if (!mcNCounter[102]) fprintf(stderr, "Warning: No neutron could reach Component[102] acceptance_y_divy\n");
    if (mcAbsorbProp[102]) fprintf(stderr, "Warning: %g events were removed in Component[102] acceptance_y_divy=DivPos_y_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[102]);
    if (!mcNCounter[103]) fprintf(stderr, "Warning: No neutron could reach Component[103] Lmon_sample_B\n");
    if (mcAbsorbProp[103]) fprintf(stderr, "Warning: %g events were removed in Component[103] Lmon_sample_B=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[103]);
    if (!mcNCounter[104]) fprintf(stderr, "Warning: No neutron could reach Component[104] Div2d_sample_maxdiv\n");
    if (mcAbsorbProp[104]) fprintf(stderr, "Warning: %g events were removed in Component[104] Div2d_sample_maxdiv=Divergence_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[104]);
    if (!mcNCounter[105]) fprintf(stderr, "Warning: No neutron could reach Component[105] PSD_sample_maxdiv\n");
    if (mcAbsorbProp[105]) fprintf(stderr, "Warning: %g events were removed in Component[105] PSD_sample_maxdiv=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[105]);
    if (!mcNCounter[106]) fprintf(stderr, "Warning: No neutron could reach Component[106] HPSD_sample_maxdiv\n");
    if (mcAbsorbProp[106]) fprintf(stderr, "Warning: %g events were removed in Component[106] HPSD_sample_maxdiv=PSDlin_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[106]);
    if (!mcNCounter[107]) fprintf(stderr, "Warning: No neutron could reach Component[107] VPSD_sample_maxdiv\n");
    if (mcAbsorbProp[107]) fprintf(stderr, "Warning: %g events were removed in Component[107] VPSD_sample_maxdiv=PSDlin_y_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[107]);
    if (!mcNCounter[108]) fprintf(stderr, "Warning: No neutron could reach Component[108] Hdiv_sample_maxdiv\n");
    if (mcAbsorbProp[108]) fprintf(stderr, "Warning: %g events were removed in Component[108] Hdiv_sample_maxdiv=Hdiv_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[108]);
    if (!mcNCounter[109]) fprintf(stderr, "Warning: No neutron could reach Component[109] Vdiv_sample_maxdiv\n");
    if (mcAbsorbProp[109]) fprintf(stderr, "Warning: %g events were removed in Component[109] Vdiv_sample_maxdiv=Vdiv_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[109]);
    if (!mcNCounter[110]) fprintf(stderr, "Warning: No neutron could reach Component[110] acceptance_x_divx_maxdiv\n");
    if (mcAbsorbProp[110]) fprintf(stderr, "Warning: %g events were removed in Component[110] acceptance_x_divx_maxdiv=DivPos_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[110]);
    if (!mcNCounter[111]) fprintf(stderr, "Warning: No neutron could reach Component[111] acceptance_y_divy_maxdiv\n");
    if (mcAbsorbProp[111]) fprintf(stderr, "Warning: %g events were removed in Component[111] acceptance_y_divy_maxdiv=DivPos_y_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[111]);
    if (!mcNCounter[112]) fprintf(stderr, "Warning: No neutron could reach Component[112] Lmon_sample\n");
    if (mcAbsorbProp[112]) fprintf(stderr, "Warning: %g events were removed in Component[112] Lmon_sample=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[112]);
    if (!mcNCounter[113]) fprintf(stderr, "Warning: No neutron could reach Component[113] v_sample\n");
    if (mcAbsorbProp[113]) fprintf(stderr, "Warning: %g events were removed in Component[113] v_sample=V_sample()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[113]);
    if (!mcNCounter[114]) fprintf(stderr, "Warning: No neutron could reach Component[114] Mono_Cradle\n");
    if (mcAbsorbProp[114]) fprintf(stderr, "Warning: %g events were removed in Component[114] Mono_Cradle=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[114]);
    if (!mcNCounter[115]) fprintf(stderr, "Warning: No neutron could reach Component[115] XY_ARM\n");
    if (mcAbsorbProp[115]) fprintf(stderr, "Warning: %g events were removed in Component[115] XY_ARM=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[115]);
  /* User FINALLY code for component 'monochromator_flat'. */
  SIG_MESSAGE("monochromator_flat (Finally)");
#define mccompcurname  monochromator_flat
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 116
#define mos_rms_y mccmonochromator_flat_mos_rms_y
#define mos_rms_z mccmonochromator_flat_mos_rms_z
#define mos_rms_max mccmonochromator_flat_mos_rms_max
#define mono_Q mccmonochromator_flat_mono_Q
#define SlabWidth mccmonochromator_flat_SlabWidth
#define SlabHeight mccmonochromator_flat_SlabHeight
#define rTable mccmonochromator_flat_rTable
#define tTable mccmonochromator_flat_tTable
#define row mccmonochromator_flat_row
#define col mccmonochromator_flat_col
#define tiltH mccmonochromator_flat_tiltH
#define tiltV mccmonochromator_flat_tiltV
{   /* Declarations of monochromator_flat=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator_flat_reflect;
char* transmit = mccmonochromator_flat_transmit;
MCNUM zwidth = mccmonochromator_flat_zwidth;
MCNUM yheight = mccmonochromator_flat_yheight;
MCNUM gap = mccmonochromator_flat_gap;
MCNUM NH = mccmonochromator_flat_NH;
MCNUM NV = mccmonochromator_flat_NV;
MCNUM mosaich = mccmonochromator_flat_mosaich;
MCNUM mosaicv = mccmonochromator_flat_mosaicv;
MCNUM r0 = mccmonochromator_flat_r0;
MCNUM t0 = mccmonochromator_flat_t0;
MCNUM Q = mccmonochromator_flat_Q;
MCNUM RV = mccmonochromator_flat_RV;
MCNUM RH = mccmonochromator_flat_RH;
MCNUM DM = mccmonochromator_flat_DM;
MCNUM mosaic = mccmonochromator_flat_mosaic;
MCNUM width = mccmonochromator_flat_width;
MCNUM height = mccmonochromator_flat_height;
MCNUM verbose = mccmonochromator_flat_verbose;
MCNUM order = mccmonochromator_flat_order;
#line 456 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 77180 "BIFROST.c"
}   /* End of monochromator_flat=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[116]) fprintf(stderr, "Warning: No neutron could reach Component[116] monochromator_flat\n");
    if (mcAbsorbProp[116]) fprintf(stderr, "Warning: %g events were removed in Component[116] monochromator_flat=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[116]);
  /* User FINALLY code for component 'monochromator2'. */
  SIG_MESSAGE("monochromator2 (Finally)");
#define mccompcurname  monochromator2
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 117
#define mos_rms_y mccmonochromator2_mos_rms_y
#define mos_rms_z mccmonochromator2_mos_rms_z
#define mos_rms_max mccmonochromator2_mos_rms_max
#define mono_Q mccmonochromator2_mono_Q
#define SlabWidth mccmonochromator2_SlabWidth
#define SlabHeight mccmonochromator2_SlabHeight
#define rTable mccmonochromator2_rTable
#define tTable mccmonochromator2_tTable
#define row mccmonochromator2_row
#define col mccmonochromator2_col
#define tiltH mccmonochromator2_tiltH
#define tiltV mccmonochromator2_tiltV
{   /* Declarations of monochromator2=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator2_reflect;
char* transmit = mccmonochromator2_transmit;
MCNUM zwidth = mccmonochromator2_zwidth;
MCNUM yheight = mccmonochromator2_yheight;
MCNUM gap = mccmonochromator2_gap;
MCNUM NH = mccmonochromator2_NH;
MCNUM NV = mccmonochromator2_NV;
MCNUM mosaich = mccmonochromator2_mosaich;
MCNUM mosaicv = mccmonochromator2_mosaicv;
MCNUM r0 = mccmonochromator2_r0;
MCNUM t0 = mccmonochromator2_t0;
MCNUM Q = mccmonochromator2_Q;
MCNUM RV = mccmonochromator2_RV;
MCNUM RH = mccmonochromator2_RH;
MCNUM DM = mccmonochromator2_DM;
MCNUM mosaic = mccmonochromator2_mosaic;
MCNUM width = mccmonochromator2_width;
MCNUM height = mccmonochromator2_height;
MCNUM verbose = mccmonochromator2_verbose;
MCNUM order = mccmonochromator2_order;
#line 456 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 77245 "BIFROST.c"
}   /* End of monochromator2=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[117]) fprintf(stderr, "Warning: No neutron could reach Component[117] monochromator2\n");
    if (mcAbsorbProp[117]) fprintf(stderr, "Warning: %g events were removed in Component[117] monochromator2=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[117]);
  /* User FINALLY code for component 'monochromator3'. */
  SIG_MESSAGE("monochromator3 (Finally)");
#define mccompcurname  monochromator3
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 118
#define mos_rms_y mccmonochromator3_mos_rms_y
#define mos_rms_z mccmonochromator3_mos_rms_z
#define mos_rms_max mccmonochromator3_mos_rms_max
#define mono_Q mccmonochromator3_mono_Q
#define SlabWidth mccmonochromator3_SlabWidth
#define SlabHeight mccmonochromator3_SlabHeight
#define rTable mccmonochromator3_rTable
#define tTable mccmonochromator3_tTable
#define row mccmonochromator3_row
#define col mccmonochromator3_col
#define tiltH mccmonochromator3_tiltH
#define tiltV mccmonochromator3_tiltV
{   /* Declarations of monochromator3=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator3_reflect;
char* transmit = mccmonochromator3_transmit;
MCNUM zwidth = mccmonochromator3_zwidth;
MCNUM yheight = mccmonochromator3_yheight;
MCNUM gap = mccmonochromator3_gap;
MCNUM NH = mccmonochromator3_NH;
MCNUM NV = mccmonochromator3_NV;
MCNUM mosaich = mccmonochromator3_mosaich;
MCNUM mosaicv = mccmonochromator3_mosaicv;
MCNUM r0 = mccmonochromator3_r0;
MCNUM t0 = mccmonochromator3_t0;
MCNUM Q = mccmonochromator3_Q;
MCNUM RV = mccmonochromator3_RV;
MCNUM RH = mccmonochromator3_RH;
MCNUM DM = mccmonochromator3_DM;
MCNUM mosaic = mccmonochromator3_mosaic;
MCNUM width = mccmonochromator3_width;
MCNUM height = mccmonochromator3_height;
MCNUM verbose = mccmonochromator3_verbose;
MCNUM order = mccmonochromator3_order;
#line 456 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 77310 "BIFROST.c"
}   /* End of monochromator3=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[118]) fprintf(stderr, "Warning: No neutron could reach Component[118] monochromator3\n");
    if (mcAbsorbProp[118]) fprintf(stderr, "Warning: %g events were removed in Component[118] monochromator3=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[118]);
  /* User FINALLY code for component 'monochromator4'. */
  SIG_MESSAGE("monochromator4 (Finally)");
#define mccompcurname  monochromator4
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 119
#define mos_rms_y mccmonochromator4_mos_rms_y
#define mos_rms_z mccmonochromator4_mos_rms_z
#define mos_rms_max mccmonochromator4_mos_rms_max
#define mono_Q mccmonochromator4_mono_Q
#define SlabWidth mccmonochromator4_SlabWidth
#define SlabHeight mccmonochromator4_SlabHeight
#define rTable mccmonochromator4_rTable
#define tTable mccmonochromator4_tTable
#define row mccmonochromator4_row
#define col mccmonochromator4_col
#define tiltH mccmonochromator4_tiltH
#define tiltV mccmonochromator4_tiltV
{   /* Declarations of monochromator4=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator4_reflect;
char* transmit = mccmonochromator4_transmit;
MCNUM zwidth = mccmonochromator4_zwidth;
MCNUM yheight = mccmonochromator4_yheight;
MCNUM gap = mccmonochromator4_gap;
MCNUM NH = mccmonochromator4_NH;
MCNUM NV = mccmonochromator4_NV;
MCNUM mosaich = mccmonochromator4_mosaich;
MCNUM mosaicv = mccmonochromator4_mosaicv;
MCNUM r0 = mccmonochromator4_r0;
MCNUM t0 = mccmonochromator4_t0;
MCNUM Q = mccmonochromator4_Q;
MCNUM RV = mccmonochromator4_RV;
MCNUM RH = mccmonochromator4_RH;
MCNUM DM = mccmonochromator4_DM;
MCNUM mosaic = mccmonochromator4_mosaic;
MCNUM width = mccmonochromator4_width;
MCNUM height = mccmonochromator4_height;
MCNUM verbose = mccmonochromator4_verbose;
MCNUM order = mccmonochromator4_order;
#line 456 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 77375 "BIFROST.c"
}   /* End of monochromator4=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[119]) fprintf(stderr, "Warning: No neutron could reach Component[119] monochromator4\n");
    if (mcAbsorbProp[119]) fprintf(stderr, "Warning: %g events were removed in Component[119] monochromator4=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[119]);
  /* User FINALLY code for component 'monochromator5'. */
  SIG_MESSAGE("monochromator5 (Finally)");
#define mccompcurname  monochromator5
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 120
#define mos_rms_y mccmonochromator5_mos_rms_y
#define mos_rms_z mccmonochromator5_mos_rms_z
#define mos_rms_max mccmonochromator5_mos_rms_max
#define mono_Q mccmonochromator5_mono_Q
#define SlabWidth mccmonochromator5_SlabWidth
#define SlabHeight mccmonochromator5_SlabHeight
#define rTable mccmonochromator5_rTable
#define tTable mccmonochromator5_tTable
#define row mccmonochromator5_row
#define col mccmonochromator5_col
#define tiltH mccmonochromator5_tiltH
#define tiltV mccmonochromator5_tiltV
{   /* Declarations of monochromator5=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator5_reflect;
char* transmit = mccmonochromator5_transmit;
MCNUM zwidth = mccmonochromator5_zwidth;
MCNUM yheight = mccmonochromator5_yheight;
MCNUM gap = mccmonochromator5_gap;
MCNUM NH = mccmonochromator5_NH;
MCNUM NV = mccmonochromator5_NV;
MCNUM mosaich = mccmonochromator5_mosaich;
MCNUM mosaicv = mccmonochromator5_mosaicv;
MCNUM r0 = mccmonochromator5_r0;
MCNUM t0 = mccmonochromator5_t0;
MCNUM Q = mccmonochromator5_Q;
MCNUM RV = mccmonochromator5_RV;
MCNUM RH = mccmonochromator5_RH;
MCNUM DM = mccmonochromator5_DM;
MCNUM mosaic = mccmonochromator5_mosaic;
MCNUM width = mccmonochromator5_width;
MCNUM height = mccmonochromator5_height;
MCNUM verbose = mccmonochromator5_verbose;
MCNUM order = mccmonochromator5_order;
#line 456 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 77440 "BIFROST.c"
}   /* End of monochromator5=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[120]) fprintf(stderr, "Warning: No neutron could reach Component[120] monochromator5\n");
    if (mcAbsorbProp[120]) fprintf(stderr, "Warning: %g events were removed in Component[120] monochromator5=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[120]);
  /* User FINALLY code for component 'monochromator6'. */
  SIG_MESSAGE("monochromator6 (Finally)");
#define mccompcurname  monochromator6
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 121
#define mos_rms_y mccmonochromator6_mos_rms_y
#define mos_rms_z mccmonochromator6_mos_rms_z
#define mos_rms_max mccmonochromator6_mos_rms_max
#define mono_Q mccmonochromator6_mono_Q
#define SlabWidth mccmonochromator6_SlabWidth
#define SlabHeight mccmonochromator6_SlabHeight
#define rTable mccmonochromator6_rTable
#define tTable mccmonochromator6_tTable
#define row mccmonochromator6_row
#define col mccmonochromator6_col
#define tiltH mccmonochromator6_tiltH
#define tiltV mccmonochromator6_tiltV
{   /* Declarations of monochromator6=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator6_reflect;
char* transmit = mccmonochromator6_transmit;
MCNUM zwidth = mccmonochromator6_zwidth;
MCNUM yheight = mccmonochromator6_yheight;
MCNUM gap = mccmonochromator6_gap;
MCNUM NH = mccmonochromator6_NH;
MCNUM NV = mccmonochromator6_NV;
MCNUM mosaich = mccmonochromator6_mosaich;
MCNUM mosaicv = mccmonochromator6_mosaicv;
MCNUM r0 = mccmonochromator6_r0;
MCNUM t0 = mccmonochromator6_t0;
MCNUM Q = mccmonochromator6_Q;
MCNUM RV = mccmonochromator6_RV;
MCNUM RH = mccmonochromator6_RH;
MCNUM DM = mccmonochromator6_DM;
MCNUM mosaic = mccmonochromator6_mosaic;
MCNUM width = mccmonochromator6_width;
MCNUM height = mccmonochromator6_height;
MCNUM verbose = mccmonochromator6_verbose;
MCNUM order = mccmonochromator6_order;
#line 456 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 77505 "BIFROST.c"
}   /* End of monochromator6=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[121]) fprintf(stderr, "Warning: No neutron could reach Component[121] monochromator6\n");
    if (mcAbsorbProp[121]) fprintf(stderr, "Warning: %g events were removed in Component[121] monochromator6=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[121]);
  /* User FINALLY code for component 'monochromator7'. */
  SIG_MESSAGE("monochromator7 (Finally)");
#define mccompcurname  monochromator7
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 122
#define mos_rms_y mccmonochromator7_mos_rms_y
#define mos_rms_z mccmonochromator7_mos_rms_z
#define mos_rms_max mccmonochromator7_mos_rms_max
#define mono_Q mccmonochromator7_mono_Q
#define SlabWidth mccmonochromator7_SlabWidth
#define SlabHeight mccmonochromator7_SlabHeight
#define rTable mccmonochromator7_rTable
#define tTable mccmonochromator7_tTable
#define row mccmonochromator7_row
#define col mccmonochromator7_col
#define tiltH mccmonochromator7_tiltH
#define tiltV mccmonochromator7_tiltV
{   /* Declarations of monochromator7=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator7_reflect;
char* transmit = mccmonochromator7_transmit;
MCNUM zwidth = mccmonochromator7_zwidth;
MCNUM yheight = mccmonochromator7_yheight;
MCNUM gap = mccmonochromator7_gap;
MCNUM NH = mccmonochromator7_NH;
MCNUM NV = mccmonochromator7_NV;
MCNUM mosaich = mccmonochromator7_mosaich;
MCNUM mosaicv = mccmonochromator7_mosaicv;
MCNUM r0 = mccmonochromator7_r0;
MCNUM t0 = mccmonochromator7_t0;
MCNUM Q = mccmonochromator7_Q;
MCNUM RV = mccmonochromator7_RV;
MCNUM RH = mccmonochromator7_RH;
MCNUM DM = mccmonochromator7_DM;
MCNUM mosaic = mccmonochromator7_mosaic;
MCNUM width = mccmonochromator7_width;
MCNUM height = mccmonochromator7_height;
MCNUM verbose = mccmonochromator7_verbose;
MCNUM order = mccmonochromator7_order;
#line 456 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  Table_Free(&rTable);
  Table_Free(&tTable);
  if (tiltH) free(tiltH);
  if (tiltV) free(tiltV);
}
#line 77570 "BIFROST.c"
}   /* End of monochromator7=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[122]) fprintf(stderr, "Warning: No neutron could reach Component[122] monochromator7\n");
    if (mcAbsorbProp[122]) fprintf(stderr, "Warning: %g events were removed in Component[122] monochromator7=Monochromator_curved()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[122]);
    if (!mcNCounter[123]) fprintf(stderr, "Warning: No neutron could reach Component[123] Mono_Out\n");
    if (mcAbsorbProp[123]) fprintf(stderr, "Warning: %g events were removed in Component[123] Mono_Out=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[123]);
    if (!mcNCounter[124]) fprintf(stderr, "Warning: No neutron could reach Component[124] psd_monitor\n");
    if (mcAbsorbProp[124]) fprintf(stderr, "Warning: %g events were removed in Component[124] psd_monitor=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[124]);
    if (!mcNCounter[125]) fprintf(stderr, "Warning: No neutron could reach Component[125] e_monitor\n");
    if (mcAbsorbProp[125]) fprintf(stderr, "Warning: %g events were removed in Component[125] e_monitor=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[125]);
  mcsiminfo_close(); 
} /* end finally */
#define magnify mcdis_magnify
#define line mcdis_line
#define dashed_line mcdis_dashed_line
#define multiline mcdis_multiline
#define rectangle mcdis_rectangle
#define box mcdis_box
#define circle mcdis_circle
void mcdisplay(void) {
  printf("MCDISPLAY: start\n");
  /* Components MCDISPLAY code. */

  /* MCDISPLAY code for component 'Origin'. */
  SIG_MESSAGE("Origin (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Origin");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 147 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\misc\\Progress_bar.comp"
{
  magnify("");
}
#line 77628 "BIFROST.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ESS_source'. */
  SIG_MESSAGE("ESS_source (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ESS_source");
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
{   /* Declarations of ESS_source=ESS_butterfly() SETTING parameters. */
char* sector = mccESS_source_sector;
int beamline = mccESS_source_beamline;
MCNUM yheight = mccESS_source_yheight;
MCNUM cold_frac = mccESS_source_cold_frac;
int target_index = mccESS_source_target_index;
MCNUM dist = mccESS_source_dist;
MCNUM focus_xw = mccESS_source_focus_xw;
MCNUM focus_yh = mccESS_source_focus_yh;
MCNUM c_performance = mccESS_source_c_performance;
MCNUM t_performance = mccESS_source_t_performance;
MCNUM Lmin = mccESS_source_Lmin;
MCNUM Lmax = mccESS_source_Lmax;
MCNUM tmax_multiplier = mccESS_source_tmax_multiplier;
int n_pulses = mccESS_source_n_pulses;
MCNUM acc_power = mccESS_source_acc_power;
MCNUM tfocus_dist = mccESS_source_tfocus_dist;
MCNUM tfocus_time = mccESS_source_tfocus_time;
MCNUM tfocus_width = mccESS_source_tfocus_width;
#line 540 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\ESS_butterfly.comp"
{
/* MCDISPLAY-section for the ESS butterfly moderator */

/* Define the positioning of the buttefly sketch */

/* Point sets for the butterfly */
double butterfly_z[] = {-1.9922764e-01, -1.8484553e-01, -2.0252845e-01, -2.0795122e-01, -2.1054471e-01, -2.1030894e-01, -2.0889431e-01, -2.0535772e-01, -2.0134959e-01, -1.9639837e-01, -1.9026829e-01, -1.8390244e-01, -1.7565041e-01, -1.7093496e-01, -1.4617886e-01, -1.2873171e-01, -9.2658537e-02, -4.0552845e-02, -1.7682927e-02, -9.1951221e-03, -2.3577231e-03, 5.1869889e-03, 1.1788619e-02, 1.7918699e-02, 2.3105689e-02, 2.4991869e-02, 2.4756099e-02, 2.2162599e-02, 1.8154469e-02, 1.2731709e-02, 5.6585389e-03, -2.3577214e-04, 1.4146339e-02, -2.9707317e-02, 1.4146339e-02, -4.7154514e-04, 1.5325199e-02, 2.1691059e-02, 2.4991869e-02, 2.4991869e-02, 2.2634149e-02, 1.8154469e-02, 1.1552849e-02, 3.3008089e-03, -6.1300811e-03, -9.1951221e-03, -6.0593496e-02, -9.2658537e-02, -1.7541463e-01, -1.8508130e-01, -1.9309756e-01, -1.9899187e-01, -2.0182114e-01, -2.0582927e-01, -2.0913008e-01, -2.1078049e-01, -2.1007317e-01, -2.0630081e-01, -2.0229268e-01, -1.9828455e-01, -1.8484553e-01, -1.9922764e-01, -1.5584553e-01, -1.9922764e-01};

double butterfly_x[] = {1.4279319e-02, 3.1692034e-10, -1.7654432e-02, -2.5962400e-02, -3.4789615e-02, -4.3876452e-02, -5.1665172e-02, -5.8934642e-02, -6.4646372e-02, -6.9059982e-02, -7.2694722e-02, -7.5031332e-02, -7.6589082e-02, -7.6589082e-02, -7.6848702e-02, -7.6589082e-02, -7.6589082e-02, -7.6589082e-02, -7.6589082e-02, -7.6848702e-02, -7.5290962e-02, -7.2694722e-02, -6.8281112e-02, -6.1790512e-02, -5.3482542e-02, -4.4136082e-02, -3.3491495e-02, -2.5443152e-02, -1.9212176e-02, -1.2981200e-02, -6.2309757e-03, -2.5962368e-04, 1.4538943e-02, 5.8415398e-02, 1.0229185e-01, 1.1709042e-01, 1.3266786e-01, 1.4149508e-01, 1.5213966e-01, 1.6200537e-01, 1.7135184e-01, 1.7888093e-01, 1.8589078e-01, 1.9082364e-01, 1.9290063e-01, 1.9341988e-01, 1.9341988e-01, 1.9341988e-01, 1.9341988e-01, 1.9186213e-01, 1.8822740e-01, 1.8459266e-01, 1.8069830e-01, 1.7602507e-01, 1.6849597e-01, 1.5811101e-01, 1.4928380e-01, 1.3993733e-01, 1.3370636e-01, 1.2981200e-01, 1.1709042e-01, 1.0229185e-01, 5.8415398e-02, 1.4279319e-02};

double butterfly_e_z1[]= {-3.0488e-04,  -5.5017e-02, -3.0488e-04};
double butterfly_e_x1[]= {-4.3103e-04,   5.8521e-02,  1.1701e-01};
double butterfly_e_z2[]= {-1.8501e-01, -1.2719e-01, -1.8501e-01};
double butterfly_e_x2[]= {3.3156e-05,  5.8985e-02,  1.1701e-01};
   


/* Draw the two butterfly shapes at top and bottom level */
magnify("");
double y0;
int j;
double rAx,rAz,rBx,rBz;

for (y0=-delta_y; y0<2*delta_y; y0+=2*delta_y) {
  for (j=0; j<63; j++) {
    
    rAx = r11*(butterfly_z[j]-cz) + r12*(butterfly_x[j]-cx);
    rAz = r21*(butterfly_z[j]-cz) + r22*(butterfly_x[j]-cx);

    rBx = r11*(butterfly_z[j+1]-cz) + r12*(butterfly_x[j+1]-cx);
    rBz = r21*(butterfly_z[j+1]-cz) + r22*(butterfly_x[j+1]-cx);

    line(rAx, y0, rAz, rBx, y0, rBz);

  }
}

/* Draw the "border" between the thermal and cold areas */
for (y0=-delta_y; y0<2*delta_y; y0+=2*delta_y) {
  for (j=0; j<2; j++) {
    
    rAx = r11*(butterfly_e_z1[j]-cz) + r12*(butterfly_e_x1[j]-cx);
    rAz = r21*(butterfly_e_z1[j]-cz) + r22*(butterfly_e_x1[j]-cx);

    rBx = r11*(butterfly_e_z1[j+1]-cz) + r12*(butterfly_e_x1[j+1]-cx);
    rBz = r21*(butterfly_e_z1[j+1]-cz) + r22*(butterfly_e_x1[j+1]-cx);

    line(rAx, y0, rAz, rBx, y0, rBz);

    rAx = r11*(butterfly_e_z2[j]-cz) + r12*(butterfly_e_x2[j]-cx);
    rAz = r21*(butterfly_e_z2[j]-cz) + r22*(butterfly_e_x2[j]-cx);

    rBx = r11*(butterfly_e_z2[j+1]-cz) + r12*(butterfly_e_x2[j+1]-cx);
    rBz = r21*(butterfly_e_z2[j+1]-cz) + r22*(butterfly_e_x2[j+1]-cx);

    line(rAx, y0, rAz, rBx, y0, rBz);
  }
}

/* Indicate the emission planes of cold/thermal moderator */
for (y0=-delta_y; y0<2*delta_y; y0+=2*delta_y) {
  dashed_line(rC1_x, y0, rC1_z, rC2_x, y0, rC2_z, 11);
  dashed_line(rC1_x, y0, rC1_z, rC3_x, y0, rC3_z, 11);
  dashed_line(rT1_x, y0, rT1_z, rT2_x, y0, rT2_z, 11);
  dashed_line(rT1_x, y0, rT1_z, rT3_x, y0, rT3_z, 11);
}
dashed_line(rC1_x, -delta_y, rC1_z, rC1_x, delta_y, rC1_z, 11);
dashed_line(rC2_x, -delta_y, rC2_z, rC2_x, delta_y, rC2_z, 11);
dashed_line(rC3_x, -delta_y, rC3_z, rC3_x, delta_y, rC3_z, 11);
dashed_line(rT1_x, -delta_y, rT1_z, rT1_x, delta_y, rT1_z, 11);
dashed_line(rT2_x, -delta_y, rT2_z, rT2_x, delta_y, rT2_z, 11);
dashed_line(rT3_x, -delta_y, rT3_z, rT3_x, delta_y, rT3_z, 11);


/* Arrow indicating proton beam direction */
double ax,az,bx,bz,bbx,bbz,ccx,ccz;
az = -0.0925-cz;
ax = 0.0585-cx;
bz = -0.0925-cz;
bx = 0.0585+6-cx;
bbx = 0.0585+0.1-cx;
bbz = -0.0925+0.03-cz;
ccx = 0.0585+0.1-cx;
ccz = -0.0925-0.03-cz;
/* rAx,0,rAz is the centre of the moderator */
rAx = r11*(az) + r12*(ax);
rAz = r21*(az) + r22*(ax);
rBx = r11*(bz) + r12*(bx);
rBz = r21*(bz) + r22*(bx);
/* Main part of the arrow */
line(rAx, 0, rAz, rBx, 0, rBz);
/* Inclined lines for arrow head */
rBx = r11*(bbz) + r12*(bbx);
rBz = r21*(bbz) + r22*(bbx);
line(rAx, 0, rAz, rBx, 0, rBz);
rBx = r11*(ccz) + r12*(ccx);
rBz = r21*(ccz) + r22*(ccx);
line(rAx, 0, rAz, rBx, 0, rBz);

/* 120 degree "end of sector" lines */
bbz = 2 * cos(DEG2RAD*61);
bbx = 2 * sin(DEG2RAD*61);
ccz = 2 * cos(-DEG2RAD*61);
ccx = 2 * sin(-DEG2RAD*61);
rBx = r11*(bbz) + r12*(bbx);
rBz = r21*(bbz) + r22*(bbx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
rBx = r11*(ccz) + r12*(ccx);
rBz = r21*(ccz) + r22*(ccx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
bbz = 2 * cos(DEG2RAD*119);
bbx = 2 * sin(DEG2RAD*119);
ccz = 2 * cos(-DEG2RAD*119);
ccx = 2 * sin(-DEG2RAD*119);
rBx = r11*(bbz) + r12*(bbx);
rBz = r21*(bbz) + r22*(bbx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
rBx = r11*(ccz) + r12*(ccx);
rBz = r21*(ccz) + r22*(ccx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
/* Circles indicating extent of the "empty" zone where optics is not allowed */
circle("xz", rAx, 0, rAz, 2.0);
circle("xz", rAx, -0.1, rAz, 2.0);
circle("xz", rAx, 0.1, rAz, 2.0);

/* Circles indicating extent of the target monolith */
circle("xz", rAx, 0, rAz, 5.5);
circle("xz", rAx, -1, rAz, 5.5);
circle("xz", rAx, 1, rAz, 5.5);

/* Beamport "plug" dimensions */
double w1=0.206/2.0, w2=0.276/2.0, l1=2.0+rAz, l2=2.0+rAz+1.75, l3=2.0+rAz+3.5;
line(w1, 0, l1, w1, 0, l2);
line(-w1, 0, l1, -w1, 0, l2);
line(w1, 0, l2, w2, 0, l2);
line(-w1, 0, l2, -w2, 0, l2);
line(w2, 0, l2, w2, 0, l3);
line(-w2, 0, l2, -w2, 0, l3);

/* Draw all the beamlines in "this sector" +1 */
double xx1, yy1, zz1, xx2, yy2, zz2, delta_omega;
for (j=0; j<jmax+1; j++) {
  delta_omega = orientation_angle - Beamlines[j];
  r11 = cos(DEG2RAD*delta_omega);
  r12 = -sin(DEG2RAD*delta_omega);
  r21 = sin(DEG2RAD*delta_omega);
  r22 = cos(DEG2RAD*delta_omega);
  xx1 = r11*(w1) + r12*(l1);
  zz1 = r21*(w1) + r22*(l1);
  xx2 = r11*(w1) + r12*(l2);
  zz2 = r21*(w1) + r22*(l2);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
  xx1 = r11*(-w1) + r12*(l1);
  zz1 = r21*(-w1) + r22*(l1);
  xx2 = r11*(-w1) + r12*(l2);
  zz2 = r21*(-w1) + r22*(l2);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
  xx1 = r11*(w2) + r12*(l2);
  zz1 = r21*(w2) + r22*(l2);
  xx2 = r11*(w2) + r12*(l3);
  zz2 = r21*(w2) + r22*(l3);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
  xx1 = r11*(-w2) + r12*(l2);
  zz1 = r21*(-w2) + r22*(l2);
  xx2 = r11*(-w2) + r12*(l3);
  zz2 = r21*(-w2) + r22*(l3);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
}

/* Show instrument axis... */
dashed_line(0,0,0,0,0,2+rAz,21);

/* Draw up the "focusing rectangle" */ 
/* Horizontal direction vector @ focusing area */
vec_prod(xx1,yy1,zz1,tx,ty,tz,0.0,1.0,0.0);
NORM(xx1,yy1,zz1);
vec_prod(xx2,yy2,zz2,tx,ty,tz,xx1,yy1,zz1);
NORM(xx2,yy2,zz2);
xx1*=focus_xw/2.0; yy1*=focus_xw/2.0; zz1*=focus_xw/2.0;
xx2*=focus_yh/2.0; yy2*=focus_yh/2.0; zz2*=focus_yh/2.0;
printf("Normal vectors pointing in directions\n %g %g %g and \n %g %g %g \n",xx1,yy1,zz1,xx2,yy2,zz2);
dashed_line(tx -xx1 -xx2, ty -yy1 -yy2, tz -zz1 -zz2,
	    tx +xx1 -xx2, ty +yy1 -yy2, tz +zz1 -zz2,5);
dashed_line(tx -xx1 +xx2, ty -yy1 +yy2, tz -zz1 +zz2,
	    tx +xx1 +xx2, ty +yy1 +yy2, tz +zz1 +zz2,5);

dashed_line(tx -xx1 -xx2, ty -yy1 -yy2, tz -zz1 -zz2,
	    tx -xx1 +xx2, ty -yy1 +yy2, tz -zz1 +zz2,5);
dashed_line(tx +xx1 -xx2, ty +yy1 -yy2, tz +zz1 -zz2,
	    tx +xx1 +xx2, ty +yy1 +yy2, tz +zz1 +zz2,5);

}
#line 77923 "BIFROST.c"
}   /* End of ESS_source=ESS_butterfly() SETTING parameter declarations. */
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'StartOfGuide'. */
  SIG_MESSAGE("StartOfGuide (McDisplay)");
  printf("MCDISPLAY: component %s\n", "StartOfGuide");
#define mccompcurname  StartOfGuide
#define mccompcurtype  Arm
#define mccompcurindex 3
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 78010 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'NBOA'. */
  SIG_MESSAGE("NBOA (McDisplay)");
  printf("MCDISPLAY: component %s\n", "NBOA");
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
{   /* Declarations of NBOA=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccNBOA_l;
MCNUM xwidth = mccNBOA_xwidth;
MCNUM yheight = mccNBOA_yheight;
MCNUM linxw = mccNBOA_linxw;
MCNUM loutxw = mccNBOA_loutxw;
MCNUM linyh = mccNBOA_linyh;
MCNUM loutyh = mccNBOA_loutyh;
MCNUM majorAxisxw = mccNBOA_majorAxisxw;
MCNUM minorAxisxw = mccNBOA_minorAxisxw;
MCNUM majorAxisyh = mccNBOA_majorAxisyh;
MCNUM minorAxisyh = mccNBOA_minorAxisyh;
MCNUM majorAxisoffsetxw = mccNBOA_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccNBOA_majorAxisoffsetyh;
char* dimensionsAt = mccNBOA_dimensionsAt;
char* option = mccNBOA_option;
MCNUM R0 = mccNBOA_R0;
MCNUM Qc = mccNBOA_Qc;
MCNUM alpha = mccNBOA_alpha;
MCNUM m = mccNBOA_m;
MCNUM W = mccNBOA_W;
MCNUM alpharight = mccNBOA_alpharight;
MCNUM mright = mccNBOA_mright;
MCNUM alphaleft = mccNBOA_alphaleft;
MCNUM mleft = mccNBOA_mleft;
MCNUM alphatop = mccNBOA_alphatop;
MCNUM mtop = mccNBOA_mtop;
MCNUM alphabottom = mccNBOA_alphabottom;
MCNUM mbottom = mccNBOA_mbottom;
char* verbose = mccNBOA_verbose;
MCNUM enableGravity = mccNBOA_enableGravity;
MCNUM curvature = mccNBOA_curvature;
#line 1496 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 78258 "BIFROST.c"
}   /* End of NBOA=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_6'. */
  SIG_MESSAGE("EndOfelement_6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_6");
#define mccompcurname  EndOfelement_6
#define mccompcurtype  Arm
#define mccompcurindex 5
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 78293 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monBeforePSC1'. */
  SIG_MESSAGE("L_monBeforePSC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monBeforePSC1");
#define mccompcurname  L_monBeforePSC1
#define mccompcurtype  L_monitor
#define mccompcurindex 6
#define nL mccL_monBeforePSC1_nL
#define L_N mccL_monBeforePSC1_L_N
#define L_p mccL_monBeforePSC1_L_p
#define L_p2 mccL_monBeforePSC1_L_p2
{   /* Declarations of L_monBeforePSC1=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforePSC1_filename;
MCNUM xmin = mccL_monBeforePSC1_xmin;
MCNUM xmax = mccL_monBeforePSC1_xmax;
MCNUM ymin = mccL_monBeforePSC1_ymin;
MCNUM ymax = mccL_monBeforePSC1_ymax;
MCNUM xwidth = mccL_monBeforePSC1_xwidth;
MCNUM yheight = mccL_monBeforePSC1_yheight;
MCNUM Lmin = mccL_monBeforePSC1_Lmin;
MCNUM Lmax = mccL_monBeforePSC1_Lmax;
MCNUM restore_neutron = mccL_monBeforePSC1_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78328 "BIFROST.c"
}   /* End of L_monBeforePSC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFBeforerPSC1'. */
  SIG_MESSAGE("ToFBeforerPSC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFBeforerPSC1");
#define mccompcurname  ToFBeforerPSC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 7
#define nt mccToFBeforerPSC1_nt
#define TOF_N mccToFBeforerPSC1_TOF_N
#define TOF_p mccToFBeforerPSC1_TOF_p
#define TOF_p2 mccToFBeforerPSC1_TOF_p2
#define t_min mccToFBeforerPSC1_t_min
#define t_max mccToFBeforerPSC1_t_max
#define delta_t mccToFBeforerPSC1_delta_t
{   /* Declarations of ToFBeforerPSC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforerPSC1_filename;
MCNUM xmin = mccToFBeforerPSC1_xmin;
MCNUM xmax = mccToFBeforerPSC1_xmax;
MCNUM ymin = mccToFBeforerPSC1_ymin;
MCNUM ymax = mccToFBeforerPSC1_ymax;
MCNUM xwidth = mccToFBeforerPSC1_xwidth;
MCNUM yheight = mccToFBeforerPSC1_yheight;
MCNUM tmin = mccToFBeforerPSC1_tmin;
MCNUM tmax = mccToFBeforerPSC1_tmax;
MCNUM dt = mccToFBeforerPSC1_dt;
MCNUM restore_neutron = mccToFBeforerPSC1_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78372 "BIFROST.c"
}   /* End of ToFBeforerPSC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_beforePulseShapping1'. */
  SIG_MESSAGE("PSD_beforePulseShapping1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_beforePulseShapping1");
#define mccompcurname  PSD_beforePulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 8
#define nx mccPSD_beforePulseShapping1_nx
#define ny mccPSD_beforePulseShapping1_ny
#define PSD_N mccPSD_beforePulseShapping1_PSD_N
#define PSD_p mccPSD_beforePulseShapping1_PSD_p
#define PSD_p2 mccPSD_beforePulseShapping1_PSD_p2
{   /* Declarations of PSD_beforePulseShapping1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforePulseShapping1_filename;
MCNUM xmin = mccPSD_beforePulseShapping1_xmin;
MCNUM xmax = mccPSD_beforePulseShapping1_xmax;
MCNUM ymin = mccPSD_beforePulseShapping1_ymin;
MCNUM ymax = mccPSD_beforePulseShapping1_ymax;
MCNUM xwidth = mccPSD_beforePulseShapping1_xwidth;
MCNUM yheight = mccPSD_beforePulseShapping1_yheight;
MCNUM restore_neutron = mccPSD_beforePulseShapping1_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78414 "BIFROST.c"
}   /* End of PSD_beforePulseShapping1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'TofLambdaBeforePSC'. */
  SIG_MESSAGE("TofLambdaBeforePSC (McDisplay)");
  printf("MCDISPLAY: component %s\n", "TofLambdaBeforePSC");
#define mccompcurname  TofLambdaBeforePSC
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 9
#define nL mccTofLambdaBeforePSC_nL
#define nt mccTofLambdaBeforePSC_nt
#define tmin mccTofLambdaBeforePSC_tmin
#define tmax mccTofLambdaBeforePSC_tmax
#define tt_0 mccTofLambdaBeforePSC_tt_0
#define tt_1 mccTofLambdaBeforePSC_tt_1
#define TOFL_N mccTofLambdaBeforePSC_TOFL_N
#define TOFL_p mccTofLambdaBeforePSC_TOFL_p
#define TOFL_p2 mccTofLambdaBeforePSC_TOFL_p2
{   /* Declarations of TofLambdaBeforePSC=TOFLambda_monitor() SETTING parameters. */
char* filename = mccTofLambdaBeforePSC_filename;
MCNUM xmin = mccTofLambdaBeforePSC_xmin;
MCNUM xmax = mccTofLambdaBeforePSC_xmax;
MCNUM ymin = mccTofLambdaBeforePSC_ymin;
MCNUM ymax = mccTofLambdaBeforePSC_ymax;
MCNUM xwidth = mccTofLambdaBeforePSC_xwidth;
MCNUM yheight = mccTofLambdaBeforePSC_yheight;
MCNUM Lmin = mccTofLambdaBeforePSC_Lmin;
MCNUM Lmax = mccTofLambdaBeforePSC_Lmax;
MCNUM restore_neutron = mccTofLambdaBeforePSC_restore_neutron;
#line 120 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 78460 "BIFROST.c"
}   /* End of TofLambdaBeforePSC=TOFLambda_monitor() SETTING parameter declarations. */
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PulseShapingChopper'. */
  SIG_MESSAGE("PulseShapingChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PulseShapingChopper");
#define mccompcurname  PulseShapingChopper
#define mccompcurtype  DiskChopper
#define mccompcurindex 10
#define Tg mccPulseShapingChopper_Tg
#define To mccPulseShapingChopper_To
#define delta_y mccPulseShapingChopper_delta_y
#define height mccPulseShapingChopper_height
#define omega mccPulseShapingChopper_omega
{   /* Declarations of PulseShapingChopper=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccPulseShapingChopper_theta_0;
MCNUM radius = mccPulseShapingChopper_radius;
MCNUM yheight = mccPulseShapingChopper_yheight;
MCNUM nu = mccPulseShapingChopper_nu;
MCNUM nslit = mccPulseShapingChopper_nslit;
MCNUM jitter = mccPulseShapingChopper_jitter;
MCNUM delay = mccPulseShapingChopper_delay;
MCNUM isfirst = mccPulseShapingChopper_isfirst;
MCNUM n_pulse = mccPulseShapingChopper_n_pulse;
MCNUM abs_out = mccPulseShapingChopper_abs_out;
MCNUM phase = mccPulseShapingChopper_phase;
MCNUM xwidth = mccPulseShapingChopper_xwidth;
MCNUM verbose = mccPulseShapingChopper_verbose;
#line 165 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  magnify("xy");
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 78527 "BIFROST.c"
}   /* End of PulseShapingChopper=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_AfterPulseShapping1'. */
  SIG_MESSAGE("PSD_AfterPulseShapping1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_AfterPulseShapping1");
#define mccompcurname  PSD_AfterPulseShapping1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 11
#define nx mccPSD_AfterPulseShapping1_nx
#define ny mccPSD_AfterPulseShapping1_ny
#define PSD_N mccPSD_AfterPulseShapping1_PSD_N
#define PSD_p mccPSD_AfterPulseShapping1_PSD_p
#define PSD_p2 mccPSD_AfterPulseShapping1_PSD_p2
{   /* Declarations of PSD_AfterPulseShapping1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_AfterPulseShapping1_filename;
MCNUM xmin = mccPSD_AfterPulseShapping1_xmin;
MCNUM xmax = mccPSD_AfterPulseShapping1_xmax;
MCNUM ymin = mccPSD_AfterPulseShapping1_ymin;
MCNUM ymax = mccPSD_AfterPulseShapping1_ymax;
MCNUM xwidth = mccPSD_AfterPulseShapping1_xwidth;
MCNUM yheight = mccPSD_AfterPulseShapping1_yheight;
MCNUM restore_neutron = mccPSD_AfterPulseShapping1_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78567 "BIFROST.c"
}   /* End of PSD_AfterPulseShapping1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFInsidePSC'. */
  SIG_MESSAGE("ToFInsidePSC (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFInsidePSC");
#define mccompcurname  ToFInsidePSC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 12
#define nt mccToFInsidePSC_nt
#define TOF_N mccToFInsidePSC_TOF_N
#define TOF_p mccToFInsidePSC_TOF_p
#define TOF_p2 mccToFInsidePSC_TOF_p2
#define t_min mccToFInsidePSC_t_min
#define t_max mccToFInsidePSC_t_max
#define delta_t mccToFInsidePSC_delta_t
{   /* Declarations of ToFInsidePSC=TOF_monitor() SETTING parameters. */
char* filename = mccToFInsidePSC_filename;
MCNUM xmin = mccToFInsidePSC_xmin;
MCNUM xmax = mccToFInsidePSC_xmax;
MCNUM ymin = mccToFInsidePSC_ymin;
MCNUM ymax = mccToFInsidePSC_ymax;
MCNUM xwidth = mccToFInsidePSC_xwidth;
MCNUM yheight = mccToFInsidePSC_yheight;
MCNUM tmin = mccToFInsidePSC_tmin;
MCNUM tmax = mccToFInsidePSC_tmax;
MCNUM dt = mccToFInsidePSC_dt;
MCNUM restore_neutron = mccToFInsidePSC_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78612 "BIFROST.c"
}   /* End of ToFInsidePSC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PulseShapingChopper2'. */
  SIG_MESSAGE("PulseShapingChopper2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PulseShapingChopper2");
#define mccompcurname  PulseShapingChopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 13
#define Tg mccPulseShapingChopper2_Tg
#define To mccPulseShapingChopper2_To
#define delta_y mccPulseShapingChopper2_delta_y
#define height mccPulseShapingChopper2_height
#define omega mccPulseShapingChopper2_omega
{   /* Declarations of PulseShapingChopper2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccPulseShapingChopper2_theta_0;
MCNUM radius = mccPulseShapingChopper2_radius;
MCNUM yheight = mccPulseShapingChopper2_yheight;
MCNUM nu = mccPulseShapingChopper2_nu;
MCNUM nslit = mccPulseShapingChopper2_nslit;
MCNUM jitter = mccPulseShapingChopper2_jitter;
MCNUM delay = mccPulseShapingChopper2_delay;
MCNUM isfirst = mccPulseShapingChopper2_isfirst;
MCNUM n_pulse = mccPulseShapingChopper2_n_pulse;
MCNUM abs_out = mccPulseShapingChopper2_abs_out;
MCNUM phase = mccPulseShapingChopper2_phase;
MCNUM xwidth = mccPulseShapingChopper2_xwidth;
MCNUM verbose = mccPulseShapingChopper2_verbose;
#line 165 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  magnify("xy");
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 78677 "BIFROST.c"
}   /* End of PulseShapingChopper2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'TofLambdaAfterPSC2'. */
  SIG_MESSAGE("TofLambdaAfterPSC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "TofLambdaAfterPSC2");
#define mccompcurname  TofLambdaAfterPSC2
#define mccompcurtype  TOFLambda_monitor
#define mccompcurindex 14
#define nL mccTofLambdaAfterPSC2_nL
#define nt mccTofLambdaAfterPSC2_nt
#define tmin mccTofLambdaAfterPSC2_tmin
#define tmax mccTofLambdaAfterPSC2_tmax
#define tt_0 mccTofLambdaAfterPSC2_tt_0
#define tt_1 mccTofLambdaAfterPSC2_tt_1
#define TOFL_N mccTofLambdaAfterPSC2_TOFL_N
#define TOFL_p mccTofLambdaAfterPSC2_TOFL_p
#define TOFL_p2 mccTofLambdaAfterPSC2_TOFL_p2
{   /* Declarations of TofLambdaAfterPSC2=TOFLambda_monitor() SETTING parameters. */
char* filename = mccTofLambdaAfterPSC2_filename;
MCNUM xmin = mccTofLambdaAfterPSC2_xmin;
MCNUM xmax = mccTofLambdaAfterPSC2_xmax;
MCNUM ymin = mccTofLambdaAfterPSC2_ymin;
MCNUM ymax = mccTofLambdaAfterPSC2_ymax;
MCNUM xwidth = mccTofLambdaAfterPSC2_xwidth;
MCNUM yheight = mccTofLambdaAfterPSC2_yheight;
MCNUM Lmin = mccTofLambdaAfterPSC2_Lmin;
MCNUM Lmax = mccTofLambdaAfterPSC2_Lmax;
MCNUM restore_neutron = mccTofLambdaAfterPSC2_restore_neutron;
#line 120 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOFLambda_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 78723 "BIFROST.c"
}   /* End of TofLambdaAfterPSC2=TOFLambda_monitor() SETTING parameter declarations. */
#undef TOFL_p2
#undef TOFL_p
#undef TOFL_N
#undef tt_1
#undef tt_0
#undef tmax
#undef tmin
#undef nt
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_AfterPSC2'. */
  SIG_MESSAGE("PSD_AfterPSC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_AfterPSC2");
#define mccompcurname  PSD_AfterPSC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 15
#define nx mccPSD_AfterPSC2_nx
#define ny mccPSD_AfterPSC2_ny
#define PSD_N mccPSD_AfterPSC2_PSD_N
#define PSD_p mccPSD_AfterPSC2_PSD_p
#define PSD_p2 mccPSD_AfterPSC2_PSD_p2
{   /* Declarations of PSD_AfterPSC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_AfterPSC2_filename;
MCNUM xmin = mccPSD_AfterPSC2_xmin;
MCNUM xmax = mccPSD_AfterPSC2_xmax;
MCNUM ymin = mccPSD_AfterPSC2_ymin;
MCNUM ymax = mccPSD_AfterPSC2_ymax;
MCNUM xwidth = mccPSD_AfterPSC2_xwidth;
MCNUM yheight = mccPSD_AfterPSC2_yheight;
MCNUM restore_neutron = mccPSD_AfterPSC2_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78767 "BIFROST.c"
}   /* End of PSD_AfterPSC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFAfterPSC2'. */
  SIG_MESSAGE("ToFAfterPSC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFAfterPSC2");
#define mccompcurname  ToFAfterPSC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 16
#define nt mccToFAfterPSC2_nt
#define TOF_N mccToFAfterPSC2_TOF_N
#define TOF_p mccToFAfterPSC2_TOF_p
#define TOF_p2 mccToFAfterPSC2_TOF_p2
#define t_min mccToFAfterPSC2_t_min
#define t_max mccToFAfterPSC2_t_max
#define delta_t mccToFAfterPSC2_delta_t
{   /* Declarations of ToFAfterPSC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterPSC2_filename;
MCNUM xmin = mccToFAfterPSC2_xmin;
MCNUM xmax = mccToFAfterPSC2_xmax;
MCNUM ymin = mccToFAfterPSC2_ymin;
MCNUM ymax = mccToFAfterPSC2_ymax;
MCNUM xwidth = mccToFAfterPSC2_xwidth;
MCNUM yheight = mccToFAfterPSC2_yheight;
MCNUM tmin = mccToFAfterPSC2_tmin;
MCNUM tmax = mccToFAfterPSC2_tmax;
MCNUM dt = mccToFAfterPSC2_dt;
MCNUM restore_neutron = mccToFAfterPSC2_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78812 "BIFROST.c"
}   /* End of ToFAfterPSC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monAfterPSC2'. */
  SIG_MESSAGE("L_monAfterPSC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monAfterPSC2");
#define mccompcurname  L_monAfterPSC2
#define mccompcurtype  L_monitor
#define mccompcurindex 17
#define nL mccL_monAfterPSC2_nL
#define L_N mccL_monAfterPSC2_L_N
#define L_p mccL_monAfterPSC2_L_p
#define L_p2 mccL_monAfterPSC2_L_p2
{   /* Declarations of L_monAfterPSC2=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterPSC2_filename;
MCNUM xmin = mccL_monAfterPSC2_xmin;
MCNUM xmax = mccL_monAfterPSC2_xmax;
MCNUM ymin = mccL_monAfterPSC2_ymin;
MCNUM ymax = mccL_monAfterPSC2_ymax;
MCNUM xwidth = mccL_monAfterPSC2_xwidth;
MCNUM yheight = mccL_monAfterPSC2_yheight;
MCNUM Lmin = mccL_monAfterPSC2_Lmin;
MCNUM Lmax = mccL_monAfterPSC2_Lmax;
MCNUM restore_neutron = mccL_monAfterPSC2_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 78855 "BIFROST.c"
}   /* End of L_monAfterPSC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_5'. */
  SIG_MESSAGE("EndOfelement_5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_5");
#define mccompcurname  EndOfelement_5
#define mccompcurtype  Arm
#define mccompcurindex 18
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 78879 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_1_0'. */
  SIG_MESSAGE("curved_guide_1_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_1_0");
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
{   /* Declarations of curved_guide_1_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_1_0_w1;
MCNUM h1 = mcccurved_guide_1_0_h1;
MCNUM w2 = mcccurved_guide_1_0_w2;
MCNUM h2 = mcccurved_guide_1_0_h2;
MCNUM l = mcccurved_guide_1_0_l;
MCNUM R0 = mcccurved_guide_1_0_R0;
MCNUM Qc = mcccurved_guide_1_0_Qc;
MCNUM alpha = mcccurved_guide_1_0_alpha;
MCNUM m = mcccurved_guide_1_0_m;
MCNUM W = mcccurved_guide_1_0_W;
MCNUM nslit = mcccurved_guide_1_0_nslit;
MCNUM d = mcccurved_guide_1_0_d;
MCNUM mleft = mcccurved_guide_1_0_mleft;
MCNUM mright = mcccurved_guide_1_0_mright;
MCNUM mtop = mcccurved_guide_1_0_mtop;
MCNUM mbottom = mcccurved_guide_1_0_mbottom;
MCNUM nhslit = mcccurved_guide_1_0_nhslit;
MCNUM G = mcccurved_guide_1_0_G;
MCNUM aleft = mcccurved_guide_1_0_aleft;
MCNUM aright = mcccurved_guide_1_0_aright;
MCNUM atop = mcccurved_guide_1_0_atop;
MCNUM abottom = mcccurved_guide_1_0_abottom;
MCNUM wavy = mcccurved_guide_1_0_wavy;
MCNUM wavy_z = mcccurved_guide_1_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_1_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_1_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_1_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_1_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_1_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_1_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_1_0_nelements;
MCNUM nu = mcccurved_guide_1_0_nu;
MCNUM phase = mcccurved_guide_1_0_phase;
char* reflect = mcccurved_guide_1_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78990 "BIFROST.c"
}   /* End of curved_guide_1_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_2_0'. */
  SIG_MESSAGE("curved_guide_2_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_2_0");
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
{   /* Declarations of curved_guide_2_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_2_0_w1;
MCNUM h1 = mcccurved_guide_2_0_h1;
MCNUM w2 = mcccurved_guide_2_0_w2;
MCNUM h2 = mcccurved_guide_2_0_h2;
MCNUM l = mcccurved_guide_2_0_l;
MCNUM R0 = mcccurved_guide_2_0_R0;
MCNUM Qc = mcccurved_guide_2_0_Qc;
MCNUM alpha = mcccurved_guide_2_0_alpha;
MCNUM m = mcccurved_guide_2_0_m;
MCNUM W = mcccurved_guide_2_0_W;
MCNUM nslit = mcccurved_guide_2_0_nslit;
MCNUM d = mcccurved_guide_2_0_d;
MCNUM mleft = mcccurved_guide_2_0_mleft;
MCNUM mright = mcccurved_guide_2_0_mright;
MCNUM mtop = mcccurved_guide_2_0_mtop;
MCNUM mbottom = mcccurved_guide_2_0_mbottom;
MCNUM nhslit = mcccurved_guide_2_0_nhslit;
MCNUM G = mcccurved_guide_2_0_G;
MCNUM aleft = mcccurved_guide_2_0_aleft;
MCNUM aright = mcccurved_guide_2_0_aright;
MCNUM atop = mcccurved_guide_2_0_atop;
MCNUM abottom = mcccurved_guide_2_0_abottom;
MCNUM wavy = mcccurved_guide_2_0_wavy;
MCNUM wavy_z = mcccurved_guide_2_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_2_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_2_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_2_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_2_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_2_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_2_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_2_0_nelements;
MCNUM nu = mcccurved_guide_2_0_nu;
MCNUM phase = mcccurved_guide_2_0_phase;
char* reflect = mcccurved_guide_2_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79104 "BIFROST.c"
}   /* End of curved_guide_2_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_3_0'. */
  SIG_MESSAGE("curved_guide_3_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_3_0");
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
{   /* Declarations of curved_guide_3_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_3_0_w1;
MCNUM h1 = mcccurved_guide_3_0_h1;
MCNUM w2 = mcccurved_guide_3_0_w2;
MCNUM h2 = mcccurved_guide_3_0_h2;
MCNUM l = mcccurved_guide_3_0_l;
MCNUM R0 = mcccurved_guide_3_0_R0;
MCNUM Qc = mcccurved_guide_3_0_Qc;
MCNUM alpha = mcccurved_guide_3_0_alpha;
MCNUM m = mcccurved_guide_3_0_m;
MCNUM W = mcccurved_guide_3_0_W;
MCNUM nslit = mcccurved_guide_3_0_nslit;
MCNUM d = mcccurved_guide_3_0_d;
MCNUM mleft = mcccurved_guide_3_0_mleft;
MCNUM mright = mcccurved_guide_3_0_mright;
MCNUM mtop = mcccurved_guide_3_0_mtop;
MCNUM mbottom = mcccurved_guide_3_0_mbottom;
MCNUM nhslit = mcccurved_guide_3_0_nhslit;
MCNUM G = mcccurved_guide_3_0_G;
MCNUM aleft = mcccurved_guide_3_0_aleft;
MCNUM aright = mcccurved_guide_3_0_aright;
MCNUM atop = mcccurved_guide_3_0_atop;
MCNUM abottom = mcccurved_guide_3_0_abottom;
MCNUM wavy = mcccurved_guide_3_0_wavy;
MCNUM wavy_z = mcccurved_guide_3_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_3_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_3_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_3_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_3_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_3_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_3_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_3_0_nelements;
MCNUM nu = mcccurved_guide_3_0_nu;
MCNUM phase = mcccurved_guide_3_0_phase;
char* reflect = mcccurved_guide_3_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79218 "BIFROST.c"
}   /* End of curved_guide_3_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_4_0'. */
  SIG_MESSAGE("curved_guide_4_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_4_0");
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
{   /* Declarations of curved_guide_4_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_4_0_w1;
MCNUM h1 = mcccurved_guide_4_0_h1;
MCNUM w2 = mcccurved_guide_4_0_w2;
MCNUM h2 = mcccurved_guide_4_0_h2;
MCNUM l = mcccurved_guide_4_0_l;
MCNUM R0 = mcccurved_guide_4_0_R0;
MCNUM Qc = mcccurved_guide_4_0_Qc;
MCNUM alpha = mcccurved_guide_4_0_alpha;
MCNUM m = mcccurved_guide_4_0_m;
MCNUM W = mcccurved_guide_4_0_W;
MCNUM nslit = mcccurved_guide_4_0_nslit;
MCNUM d = mcccurved_guide_4_0_d;
MCNUM mleft = mcccurved_guide_4_0_mleft;
MCNUM mright = mcccurved_guide_4_0_mright;
MCNUM mtop = mcccurved_guide_4_0_mtop;
MCNUM mbottom = mcccurved_guide_4_0_mbottom;
MCNUM nhslit = mcccurved_guide_4_0_nhslit;
MCNUM G = mcccurved_guide_4_0_G;
MCNUM aleft = mcccurved_guide_4_0_aleft;
MCNUM aright = mcccurved_guide_4_0_aright;
MCNUM atop = mcccurved_guide_4_0_atop;
MCNUM abottom = mcccurved_guide_4_0_abottom;
MCNUM wavy = mcccurved_guide_4_0_wavy;
MCNUM wavy_z = mcccurved_guide_4_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_4_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_4_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_4_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_4_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_4_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_4_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_4_0_nelements;
MCNUM nu = mcccurved_guide_4_0_nu;
MCNUM phase = mcccurved_guide_4_0_phase;
char* reflect = mcccurved_guide_4_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79332 "BIFROST.c"
}   /* End of curved_guide_4_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_5_beforeChopper'. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_5_beforeChopper");
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
{   /* Declarations of curved_guide_5_beforeChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_5_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_5_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_5_beforeChopper_h2;
MCNUM l = mcccurved_guide_5_beforeChopper_l;
MCNUM R0 = mcccurved_guide_5_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_5_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_5_beforeChopper_alpha;
MCNUM m = mcccurved_guide_5_beforeChopper_m;
MCNUM W = mcccurved_guide_5_beforeChopper_W;
MCNUM nslit = mcccurved_guide_5_beforeChopper_nslit;
MCNUM d = mcccurved_guide_5_beforeChopper_d;
MCNUM mleft = mcccurved_guide_5_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_5_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_5_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_5_beforeChopper_G;
MCNUM aleft = mcccurved_guide_5_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_5_beforeChopper_aright;
MCNUM atop = mcccurved_guide_5_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_5_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_5_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_5_beforeChopper_nu;
MCNUM phase = mcccurved_guide_5_beforeChopper_phase;
char* reflect = mcccurved_guide_5_beforeChopper_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79446 "BIFROST.c"
}   /* End of curved_guide_5_beforeChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monBeforeFOC1'. */
  SIG_MESSAGE("L_monBeforeFOC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monBeforeFOC1");
#define mccompcurname  L_monBeforeFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccL_monBeforeFOC1_nL
#define L_N mccL_monBeforeFOC1_L_N
#define L_p mccL_monBeforeFOC1_L_p
#define L_p2 mccL_monBeforeFOC1_L_p2
{   /* Declarations of L_monBeforeFOC1=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeFOC1_filename;
MCNUM xmin = mccL_monBeforeFOC1_xmin;
MCNUM xmax = mccL_monBeforeFOC1_xmax;
MCNUM ymin = mccL_monBeforeFOC1_ymin;
MCNUM ymax = mccL_monBeforeFOC1_ymax;
MCNUM xwidth = mccL_monBeforeFOC1_xwidth;
MCNUM yheight = mccL_monBeforeFOC1_yheight;
MCNUM Lmin = mccL_monBeforeFOC1_Lmin;
MCNUM Lmax = mccL_monBeforeFOC1_Lmax;
MCNUM restore_neutron = mccL_monBeforeFOC1_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 79484 "BIFROST.c"
}   /* End of L_monBeforeFOC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFBeforeFOC1'. */
  SIG_MESSAGE("ToFBeforeFOC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFBeforeFOC1");
#define mccompcurname  ToFBeforeFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 25
#define nt mccToFBeforeFOC1_nt
#define TOF_N mccToFBeforeFOC1_TOF_N
#define TOF_p mccToFBeforeFOC1_TOF_p
#define TOF_p2 mccToFBeforeFOC1_TOF_p2
#define t_min mccToFBeforeFOC1_t_min
#define t_max mccToFBeforeFOC1_t_max
#define delta_t mccToFBeforeFOC1_delta_t
{   /* Declarations of ToFBeforeFOC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeFOC1_filename;
MCNUM xmin = mccToFBeforeFOC1_xmin;
MCNUM xmax = mccToFBeforeFOC1_xmax;
MCNUM ymin = mccToFBeforeFOC1_ymin;
MCNUM ymax = mccToFBeforeFOC1_ymax;
MCNUM xwidth = mccToFBeforeFOC1_xwidth;
MCNUM yheight = mccToFBeforeFOC1_yheight;
MCNUM tmin = mccToFBeforeFOC1_tmin;
MCNUM tmax = mccToFBeforeFOC1_tmax;
MCNUM dt = mccToFBeforeFOC1_dt;
MCNUM restore_neutron = mccToFBeforeFOC1_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 79528 "BIFROST.c"
}   /* End of ToFBeforeFOC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_beforeFOC1'. */
  SIG_MESSAGE("PSD_beforeFOC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_beforeFOC1");
#define mccompcurname  PSD_beforeFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 26
#define nx mccPSD_beforeFOC1_nx
#define ny mccPSD_beforeFOC1_ny
#define PSD_N mccPSD_beforeFOC1_PSD_N
#define PSD_p mccPSD_beforeFOC1_PSD_p
#define PSD_p2 mccPSD_beforeFOC1_PSD_p2
{   /* Declarations of PSD_beforeFOC1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforeFOC1_filename;
MCNUM xmin = mccPSD_beforeFOC1_xmin;
MCNUM xmax = mccPSD_beforeFOC1_xmax;
MCNUM ymin = mccPSD_beforeFOC1_ymin;
MCNUM ymax = mccPSD_beforeFOC1_ymax;
MCNUM xwidth = mccPSD_beforeFOC1_xwidth;
MCNUM yheight = mccPSD_beforeFOC1_yheight;
MCNUM restore_neutron = mccPSD_beforeFOC1_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 79570 "BIFROST.c"
}   /* End of PSD_beforeFOC1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'FOC1'. */
  SIG_MESSAGE("FOC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "FOC1");
#define mccompcurname  FOC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 27
#define Tg mccFOC1_Tg
#define To mccFOC1_To
#define delta_y mccFOC1_delta_y
#define height mccFOC1_height
#define omega mccFOC1_omega
{   /* Declarations of FOC1=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccFOC1_theta_0;
MCNUM radius = mccFOC1_radius;
MCNUM yheight = mccFOC1_yheight;
MCNUM nu = mccFOC1_nu;
MCNUM nslit = mccFOC1_nslit;
MCNUM jitter = mccFOC1_jitter;
MCNUM delay = mccFOC1_delay;
MCNUM isfirst = mccFOC1_isfirst;
MCNUM n_pulse = mccFOC1_n_pulse;
MCNUM abs_out = mccFOC1_abs_out;
MCNUM phase = mccFOC1_phase;
MCNUM xwidth = mccFOC1_xwidth;
MCNUM verbose = mccFOC1_verbose;
#line 165 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  magnify("xy");
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 79633 "BIFROST.c"
}   /* End of FOC1=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_afterFOC1'. */
  SIG_MESSAGE("PSD_afterFOC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_afterFOC1");
#define mccompcurname  PSD_afterFOC1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 28
#define nx mccPSD_afterFOC1_nx
#define ny mccPSD_afterFOC1_ny
#define PSD_N mccPSD_afterFOC1_PSD_N
#define PSD_p mccPSD_afterFOC1_PSD_p
#define PSD_p2 mccPSD_afterFOC1_PSD_p2
{   /* Declarations of PSD_afterFOC1=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_afterFOC1_filename;
MCNUM xmin = mccPSD_afterFOC1_xmin;
MCNUM xmax = mccPSD_afterFOC1_xmax;
MCNUM ymin = mccPSD_afterFOC1_ymin;
MCNUM ymax = mccPSD_afterFOC1_ymax;
MCNUM xwidth = mccPSD_afterFOC1_xwidth;
MCNUM yheight = mccPSD_afterFOC1_yheight;
MCNUM restore_neutron = mccPSD_afterFOC1_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 79673 "BIFROST.c"
}   /* End of PSD_afterFOC1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFAfterFOC1'. */
  SIG_MESSAGE("ToFAfterFOC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFAfterFOC1");
#define mccompcurname  ToFAfterFOC1
#define mccompcurtype  TOF_monitor
#define mccompcurindex 29
#define nt mccToFAfterFOC1_nt
#define TOF_N mccToFAfterFOC1_TOF_N
#define TOF_p mccToFAfterFOC1_TOF_p
#define TOF_p2 mccToFAfterFOC1_TOF_p2
#define t_min mccToFAfterFOC1_t_min
#define t_max mccToFAfterFOC1_t_max
#define delta_t mccToFAfterFOC1_delta_t
{   /* Declarations of ToFAfterFOC1=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterFOC1_filename;
MCNUM xmin = mccToFAfterFOC1_xmin;
MCNUM xmax = mccToFAfterFOC1_xmax;
MCNUM ymin = mccToFAfterFOC1_ymin;
MCNUM ymax = mccToFAfterFOC1_ymax;
MCNUM xwidth = mccToFAfterFOC1_xwidth;
MCNUM yheight = mccToFAfterFOC1_yheight;
MCNUM tmin = mccToFAfterFOC1_tmin;
MCNUM tmax = mccToFAfterFOC1_tmax;
MCNUM dt = mccToFAfterFOC1_dt;
MCNUM restore_neutron = mccToFAfterFOC1_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 79718 "BIFROST.c"
}   /* End of ToFAfterFOC1=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monAfterFOC1'. */
  SIG_MESSAGE("L_monAfterFOC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monAfterFOC1");
#define mccompcurname  L_monAfterFOC1
#define mccompcurtype  L_monitor
#define mccompcurindex 30
#define nL mccL_monAfterFOC1_nL
#define L_N mccL_monAfterFOC1_L_N
#define L_p mccL_monAfterFOC1_L_p
#define L_p2 mccL_monAfterFOC1_L_p2
{   /* Declarations of L_monAfterFOC1=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterFOC1_filename;
MCNUM xmin = mccL_monAfterFOC1_xmin;
MCNUM xmax = mccL_monAfterFOC1_xmax;
MCNUM ymin = mccL_monAfterFOC1_ymin;
MCNUM ymax = mccL_monAfterFOC1_ymax;
MCNUM xwidth = mccL_monAfterFOC1_xwidth;
MCNUM yheight = mccL_monAfterFOC1_yheight;
MCNUM Lmin = mccL_monAfterFOC1_Lmin;
MCNUM Lmax = mccL_monAfterFOC1_Lmax;
MCNUM restore_neutron = mccL_monAfterFOC1_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 79761 "BIFROST.c"
}   /* End of L_monAfterFOC1=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_5_afterChopper'. */
  SIG_MESSAGE("curved_guide_5_afterChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_5_afterChopper");
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
{   /* Declarations of curved_guide_5_afterChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_afterChopper_w1;
MCNUM h1 = mcccurved_guide_5_afterChopper_h1;
MCNUM w2 = mcccurved_guide_5_afterChopper_w2;
MCNUM h2 = mcccurved_guide_5_afterChopper_h2;
MCNUM l = mcccurved_guide_5_afterChopper_l;
MCNUM R0 = mcccurved_guide_5_afterChopper_R0;
MCNUM Qc = mcccurved_guide_5_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_5_afterChopper_alpha;
MCNUM m = mcccurved_guide_5_afterChopper_m;
MCNUM W = mcccurved_guide_5_afterChopper_W;
MCNUM nslit = mcccurved_guide_5_afterChopper_nslit;
MCNUM d = mcccurved_guide_5_afterChopper_d;
MCNUM mleft = mcccurved_guide_5_afterChopper_mleft;
MCNUM mright = mcccurved_guide_5_afterChopper_mright;
MCNUM mtop = mcccurved_guide_5_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_afterChopper_nhslit;
MCNUM G = mcccurved_guide_5_afterChopper_G;
MCNUM aleft = mcccurved_guide_5_afterChopper_aleft;
MCNUM aright = mcccurved_guide_5_afterChopper_aright;
MCNUM atop = mcccurved_guide_5_afterChopper_atop;
MCNUM abottom = mcccurved_guide_5_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_5_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_afterChopper_nelements;
MCNUM nu = mcccurved_guide_5_afterChopper_nu;
MCNUM phase = mcccurved_guide_5_afterChopper_phase;
char* reflect = mcccurved_guide_5_afterChopper_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79877 "BIFROST.c"
}   /* End of curved_guide_5_afterChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_6_0'. */
  SIG_MESSAGE("curved_guide_6_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_6_0");
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
{   /* Declarations of curved_guide_6_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_6_0_w1;
MCNUM h1 = mcccurved_guide_6_0_h1;
MCNUM w2 = mcccurved_guide_6_0_w2;
MCNUM h2 = mcccurved_guide_6_0_h2;
MCNUM l = mcccurved_guide_6_0_l;
MCNUM R0 = mcccurved_guide_6_0_R0;
MCNUM Qc = mcccurved_guide_6_0_Qc;
MCNUM alpha = mcccurved_guide_6_0_alpha;
MCNUM m = mcccurved_guide_6_0_m;
MCNUM W = mcccurved_guide_6_0_W;
MCNUM nslit = mcccurved_guide_6_0_nslit;
MCNUM d = mcccurved_guide_6_0_d;
MCNUM mleft = mcccurved_guide_6_0_mleft;
MCNUM mright = mcccurved_guide_6_0_mright;
MCNUM mtop = mcccurved_guide_6_0_mtop;
MCNUM mbottom = mcccurved_guide_6_0_mbottom;
MCNUM nhslit = mcccurved_guide_6_0_nhslit;
MCNUM G = mcccurved_guide_6_0_G;
MCNUM aleft = mcccurved_guide_6_0_aleft;
MCNUM aright = mcccurved_guide_6_0_aright;
MCNUM atop = mcccurved_guide_6_0_atop;
MCNUM abottom = mcccurved_guide_6_0_abottom;
MCNUM wavy = mcccurved_guide_6_0_wavy;
MCNUM wavy_z = mcccurved_guide_6_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_6_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_6_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_6_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_6_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_6_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_6_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_6_0_nelements;
MCNUM nu = mcccurved_guide_6_0_nu;
MCNUM phase = mcccurved_guide_6_0_phase;
char* reflect = mcccurved_guide_6_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79991 "BIFROST.c"
}   /* End of curved_guide_6_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_7_0'. */
  SIG_MESSAGE("curved_guide_7_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_7_0");
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
{   /* Declarations of curved_guide_7_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_7_0_w1;
MCNUM h1 = mcccurved_guide_7_0_h1;
MCNUM w2 = mcccurved_guide_7_0_w2;
MCNUM h2 = mcccurved_guide_7_0_h2;
MCNUM l = mcccurved_guide_7_0_l;
MCNUM R0 = mcccurved_guide_7_0_R0;
MCNUM Qc = mcccurved_guide_7_0_Qc;
MCNUM alpha = mcccurved_guide_7_0_alpha;
MCNUM m = mcccurved_guide_7_0_m;
MCNUM W = mcccurved_guide_7_0_W;
MCNUM nslit = mcccurved_guide_7_0_nslit;
MCNUM d = mcccurved_guide_7_0_d;
MCNUM mleft = mcccurved_guide_7_0_mleft;
MCNUM mright = mcccurved_guide_7_0_mright;
MCNUM mtop = mcccurved_guide_7_0_mtop;
MCNUM mbottom = mcccurved_guide_7_0_mbottom;
MCNUM nhslit = mcccurved_guide_7_0_nhslit;
MCNUM G = mcccurved_guide_7_0_G;
MCNUM aleft = mcccurved_guide_7_0_aleft;
MCNUM aright = mcccurved_guide_7_0_aright;
MCNUM atop = mcccurved_guide_7_0_atop;
MCNUM abottom = mcccurved_guide_7_0_abottom;
MCNUM wavy = mcccurved_guide_7_0_wavy;
MCNUM wavy_z = mcccurved_guide_7_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_7_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_7_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_7_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_7_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_7_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_7_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_7_0_nelements;
MCNUM nu = mcccurved_guide_7_0_nu;
MCNUM phase = mcccurved_guide_7_0_phase;
char* reflect = mcccurved_guide_7_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80105 "BIFROST.c"
}   /* End of curved_guide_7_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_8_0'. */
  SIG_MESSAGE("curved_guide_8_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_8_0");
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
{   /* Declarations of curved_guide_8_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_8_0_w1;
MCNUM h1 = mcccurved_guide_8_0_h1;
MCNUM w2 = mcccurved_guide_8_0_w2;
MCNUM h2 = mcccurved_guide_8_0_h2;
MCNUM l = mcccurved_guide_8_0_l;
MCNUM R0 = mcccurved_guide_8_0_R0;
MCNUM Qc = mcccurved_guide_8_0_Qc;
MCNUM alpha = mcccurved_guide_8_0_alpha;
MCNUM m = mcccurved_guide_8_0_m;
MCNUM W = mcccurved_guide_8_0_W;
MCNUM nslit = mcccurved_guide_8_0_nslit;
MCNUM d = mcccurved_guide_8_0_d;
MCNUM mleft = mcccurved_guide_8_0_mleft;
MCNUM mright = mcccurved_guide_8_0_mright;
MCNUM mtop = mcccurved_guide_8_0_mtop;
MCNUM mbottom = mcccurved_guide_8_0_mbottom;
MCNUM nhslit = mcccurved_guide_8_0_nhslit;
MCNUM G = mcccurved_guide_8_0_G;
MCNUM aleft = mcccurved_guide_8_0_aleft;
MCNUM aright = mcccurved_guide_8_0_aright;
MCNUM atop = mcccurved_guide_8_0_atop;
MCNUM abottom = mcccurved_guide_8_0_abottom;
MCNUM wavy = mcccurved_guide_8_0_wavy;
MCNUM wavy_z = mcccurved_guide_8_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_8_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_8_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_8_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_8_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_8_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_8_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_8_0_nelements;
MCNUM nu = mcccurved_guide_8_0_nu;
MCNUM phase = mcccurved_guide_8_0_phase;
char* reflect = mcccurved_guide_8_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80219 "BIFROST.c"
}   /* End of curved_guide_8_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_9_0'. */
  SIG_MESSAGE("curved_guide_9_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_9_0");
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
{   /* Declarations of curved_guide_9_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_9_0_w1;
MCNUM h1 = mcccurved_guide_9_0_h1;
MCNUM w2 = mcccurved_guide_9_0_w2;
MCNUM h2 = mcccurved_guide_9_0_h2;
MCNUM l = mcccurved_guide_9_0_l;
MCNUM R0 = mcccurved_guide_9_0_R0;
MCNUM Qc = mcccurved_guide_9_0_Qc;
MCNUM alpha = mcccurved_guide_9_0_alpha;
MCNUM m = mcccurved_guide_9_0_m;
MCNUM W = mcccurved_guide_9_0_W;
MCNUM nslit = mcccurved_guide_9_0_nslit;
MCNUM d = mcccurved_guide_9_0_d;
MCNUM mleft = mcccurved_guide_9_0_mleft;
MCNUM mright = mcccurved_guide_9_0_mright;
MCNUM mtop = mcccurved_guide_9_0_mtop;
MCNUM mbottom = mcccurved_guide_9_0_mbottom;
MCNUM nhslit = mcccurved_guide_9_0_nhslit;
MCNUM G = mcccurved_guide_9_0_G;
MCNUM aleft = mcccurved_guide_9_0_aleft;
MCNUM aright = mcccurved_guide_9_0_aright;
MCNUM atop = mcccurved_guide_9_0_atop;
MCNUM abottom = mcccurved_guide_9_0_abottom;
MCNUM wavy = mcccurved_guide_9_0_wavy;
MCNUM wavy_z = mcccurved_guide_9_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_9_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_9_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_9_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_9_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_9_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_9_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_9_0_nelements;
MCNUM nu = mcccurved_guide_9_0_nu;
MCNUM phase = mcccurved_guide_9_0_phase;
char* reflect = mcccurved_guide_9_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80333 "BIFROST.c"
}   /* End of curved_guide_9_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_10_0'. */
  SIG_MESSAGE("curved_guide_10_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_10_0");
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
{   /* Declarations of curved_guide_10_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_10_0_w1;
MCNUM h1 = mcccurved_guide_10_0_h1;
MCNUM w2 = mcccurved_guide_10_0_w2;
MCNUM h2 = mcccurved_guide_10_0_h2;
MCNUM l = mcccurved_guide_10_0_l;
MCNUM R0 = mcccurved_guide_10_0_R0;
MCNUM Qc = mcccurved_guide_10_0_Qc;
MCNUM alpha = mcccurved_guide_10_0_alpha;
MCNUM m = mcccurved_guide_10_0_m;
MCNUM W = mcccurved_guide_10_0_W;
MCNUM nslit = mcccurved_guide_10_0_nslit;
MCNUM d = mcccurved_guide_10_0_d;
MCNUM mleft = mcccurved_guide_10_0_mleft;
MCNUM mright = mcccurved_guide_10_0_mright;
MCNUM mtop = mcccurved_guide_10_0_mtop;
MCNUM mbottom = mcccurved_guide_10_0_mbottom;
MCNUM nhslit = mcccurved_guide_10_0_nhslit;
MCNUM G = mcccurved_guide_10_0_G;
MCNUM aleft = mcccurved_guide_10_0_aleft;
MCNUM aright = mcccurved_guide_10_0_aright;
MCNUM atop = mcccurved_guide_10_0_atop;
MCNUM abottom = mcccurved_guide_10_0_abottom;
MCNUM wavy = mcccurved_guide_10_0_wavy;
MCNUM wavy_z = mcccurved_guide_10_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_10_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_10_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_10_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_10_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_10_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_10_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_10_0_nelements;
MCNUM nu = mcccurved_guide_10_0_nu;
MCNUM phase = mcccurved_guide_10_0_phase;
char* reflect = mcccurved_guide_10_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80447 "BIFROST.c"
}   /* End of curved_guide_10_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_11_0'. */
  SIG_MESSAGE("curved_guide_11_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_11_0");
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
{   /* Declarations of curved_guide_11_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_11_0_w1;
MCNUM h1 = mcccurved_guide_11_0_h1;
MCNUM w2 = mcccurved_guide_11_0_w2;
MCNUM h2 = mcccurved_guide_11_0_h2;
MCNUM l = mcccurved_guide_11_0_l;
MCNUM R0 = mcccurved_guide_11_0_R0;
MCNUM Qc = mcccurved_guide_11_0_Qc;
MCNUM alpha = mcccurved_guide_11_0_alpha;
MCNUM m = mcccurved_guide_11_0_m;
MCNUM W = mcccurved_guide_11_0_W;
MCNUM nslit = mcccurved_guide_11_0_nslit;
MCNUM d = mcccurved_guide_11_0_d;
MCNUM mleft = mcccurved_guide_11_0_mleft;
MCNUM mright = mcccurved_guide_11_0_mright;
MCNUM mtop = mcccurved_guide_11_0_mtop;
MCNUM mbottom = mcccurved_guide_11_0_mbottom;
MCNUM nhslit = mcccurved_guide_11_0_nhslit;
MCNUM G = mcccurved_guide_11_0_G;
MCNUM aleft = mcccurved_guide_11_0_aleft;
MCNUM aright = mcccurved_guide_11_0_aright;
MCNUM atop = mcccurved_guide_11_0_atop;
MCNUM abottom = mcccurved_guide_11_0_abottom;
MCNUM wavy = mcccurved_guide_11_0_wavy;
MCNUM wavy_z = mcccurved_guide_11_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_11_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_11_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_11_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_11_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_11_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_11_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_11_0_nelements;
MCNUM nu = mcccurved_guide_11_0_nu;
MCNUM phase = mcccurved_guide_11_0_phase;
char* reflect = mcccurved_guide_11_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80561 "BIFROST.c"
}   /* End of curved_guide_11_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_12_0'. */
  SIG_MESSAGE("curved_guide_12_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_12_0");
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
{   /* Declarations of curved_guide_12_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_12_0_w1;
MCNUM h1 = mcccurved_guide_12_0_h1;
MCNUM w2 = mcccurved_guide_12_0_w2;
MCNUM h2 = mcccurved_guide_12_0_h2;
MCNUM l = mcccurved_guide_12_0_l;
MCNUM R0 = mcccurved_guide_12_0_R0;
MCNUM Qc = mcccurved_guide_12_0_Qc;
MCNUM alpha = mcccurved_guide_12_0_alpha;
MCNUM m = mcccurved_guide_12_0_m;
MCNUM W = mcccurved_guide_12_0_W;
MCNUM nslit = mcccurved_guide_12_0_nslit;
MCNUM d = mcccurved_guide_12_0_d;
MCNUM mleft = mcccurved_guide_12_0_mleft;
MCNUM mright = mcccurved_guide_12_0_mright;
MCNUM mtop = mcccurved_guide_12_0_mtop;
MCNUM mbottom = mcccurved_guide_12_0_mbottom;
MCNUM nhslit = mcccurved_guide_12_0_nhslit;
MCNUM G = mcccurved_guide_12_0_G;
MCNUM aleft = mcccurved_guide_12_0_aleft;
MCNUM aright = mcccurved_guide_12_0_aright;
MCNUM atop = mcccurved_guide_12_0_atop;
MCNUM abottom = mcccurved_guide_12_0_abottom;
MCNUM wavy = mcccurved_guide_12_0_wavy;
MCNUM wavy_z = mcccurved_guide_12_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_12_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_12_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_12_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_12_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_12_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_12_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_12_0_nelements;
MCNUM nu = mcccurved_guide_12_0_nu;
MCNUM phase = mcccurved_guide_12_0_phase;
char* reflect = mcccurved_guide_12_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80675 "BIFROST.c"
}   /* End of curved_guide_12_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_13_0'. */
  SIG_MESSAGE("curved_guide_13_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_13_0");
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
{   /* Declarations of curved_guide_13_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_13_0_w1;
MCNUM h1 = mcccurved_guide_13_0_h1;
MCNUM w2 = mcccurved_guide_13_0_w2;
MCNUM h2 = mcccurved_guide_13_0_h2;
MCNUM l = mcccurved_guide_13_0_l;
MCNUM R0 = mcccurved_guide_13_0_R0;
MCNUM Qc = mcccurved_guide_13_0_Qc;
MCNUM alpha = mcccurved_guide_13_0_alpha;
MCNUM m = mcccurved_guide_13_0_m;
MCNUM W = mcccurved_guide_13_0_W;
MCNUM nslit = mcccurved_guide_13_0_nslit;
MCNUM d = mcccurved_guide_13_0_d;
MCNUM mleft = mcccurved_guide_13_0_mleft;
MCNUM mright = mcccurved_guide_13_0_mright;
MCNUM mtop = mcccurved_guide_13_0_mtop;
MCNUM mbottom = mcccurved_guide_13_0_mbottom;
MCNUM nhslit = mcccurved_guide_13_0_nhslit;
MCNUM G = mcccurved_guide_13_0_G;
MCNUM aleft = mcccurved_guide_13_0_aleft;
MCNUM aright = mcccurved_guide_13_0_aright;
MCNUM atop = mcccurved_guide_13_0_atop;
MCNUM abottom = mcccurved_guide_13_0_abottom;
MCNUM wavy = mcccurved_guide_13_0_wavy;
MCNUM wavy_z = mcccurved_guide_13_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_13_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_13_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_13_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_13_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_13_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_13_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_13_0_nelements;
MCNUM nu = mcccurved_guide_13_0_nu;
MCNUM phase = mcccurved_guide_13_0_phase;
char* reflect = mcccurved_guide_13_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80789 "BIFROST.c"
}   /* End of curved_guide_13_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_14_0'. */
  SIG_MESSAGE("curved_guide_14_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_14_0");
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
{   /* Declarations of curved_guide_14_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_14_0_w1;
MCNUM h1 = mcccurved_guide_14_0_h1;
MCNUM w2 = mcccurved_guide_14_0_w2;
MCNUM h2 = mcccurved_guide_14_0_h2;
MCNUM l = mcccurved_guide_14_0_l;
MCNUM R0 = mcccurved_guide_14_0_R0;
MCNUM Qc = mcccurved_guide_14_0_Qc;
MCNUM alpha = mcccurved_guide_14_0_alpha;
MCNUM m = mcccurved_guide_14_0_m;
MCNUM W = mcccurved_guide_14_0_W;
MCNUM nslit = mcccurved_guide_14_0_nslit;
MCNUM d = mcccurved_guide_14_0_d;
MCNUM mleft = mcccurved_guide_14_0_mleft;
MCNUM mright = mcccurved_guide_14_0_mright;
MCNUM mtop = mcccurved_guide_14_0_mtop;
MCNUM mbottom = mcccurved_guide_14_0_mbottom;
MCNUM nhslit = mcccurved_guide_14_0_nhslit;
MCNUM G = mcccurved_guide_14_0_G;
MCNUM aleft = mcccurved_guide_14_0_aleft;
MCNUM aright = mcccurved_guide_14_0_aright;
MCNUM atop = mcccurved_guide_14_0_atop;
MCNUM abottom = mcccurved_guide_14_0_abottom;
MCNUM wavy = mcccurved_guide_14_0_wavy;
MCNUM wavy_z = mcccurved_guide_14_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_14_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_14_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_14_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_14_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_14_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_14_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_14_0_nelements;
MCNUM nu = mcccurved_guide_14_0_nu;
MCNUM phase = mcccurved_guide_14_0_phase;
char* reflect = mcccurved_guide_14_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80903 "BIFROST.c"
}   /* End of curved_guide_14_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_15_0'. */
  SIG_MESSAGE("curved_guide_15_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_15_0");
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
{   /* Declarations of curved_guide_15_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_15_0_w1;
MCNUM h1 = mcccurved_guide_15_0_h1;
MCNUM w2 = mcccurved_guide_15_0_w2;
MCNUM h2 = mcccurved_guide_15_0_h2;
MCNUM l = mcccurved_guide_15_0_l;
MCNUM R0 = mcccurved_guide_15_0_R0;
MCNUM Qc = mcccurved_guide_15_0_Qc;
MCNUM alpha = mcccurved_guide_15_0_alpha;
MCNUM m = mcccurved_guide_15_0_m;
MCNUM W = mcccurved_guide_15_0_W;
MCNUM nslit = mcccurved_guide_15_0_nslit;
MCNUM d = mcccurved_guide_15_0_d;
MCNUM mleft = mcccurved_guide_15_0_mleft;
MCNUM mright = mcccurved_guide_15_0_mright;
MCNUM mtop = mcccurved_guide_15_0_mtop;
MCNUM mbottom = mcccurved_guide_15_0_mbottom;
MCNUM nhslit = mcccurved_guide_15_0_nhslit;
MCNUM G = mcccurved_guide_15_0_G;
MCNUM aleft = mcccurved_guide_15_0_aleft;
MCNUM aright = mcccurved_guide_15_0_aright;
MCNUM atop = mcccurved_guide_15_0_atop;
MCNUM abottom = mcccurved_guide_15_0_abottom;
MCNUM wavy = mcccurved_guide_15_0_wavy;
MCNUM wavy_z = mcccurved_guide_15_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_15_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_15_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_15_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_15_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_15_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_15_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_15_0_nelements;
MCNUM nu = mcccurved_guide_15_0_nu;
MCNUM phase = mcccurved_guide_15_0_phase;
char* reflect = mcccurved_guide_15_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81017 "BIFROST.c"
}   /* End of curved_guide_15_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_16_0'. */
  SIG_MESSAGE("curved_guide_16_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_16_0");
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
{   /* Declarations of curved_guide_16_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_16_0_w1;
MCNUM h1 = mcccurved_guide_16_0_h1;
MCNUM w2 = mcccurved_guide_16_0_w2;
MCNUM h2 = mcccurved_guide_16_0_h2;
MCNUM l = mcccurved_guide_16_0_l;
MCNUM R0 = mcccurved_guide_16_0_R0;
MCNUM Qc = mcccurved_guide_16_0_Qc;
MCNUM alpha = mcccurved_guide_16_0_alpha;
MCNUM m = mcccurved_guide_16_0_m;
MCNUM W = mcccurved_guide_16_0_W;
MCNUM nslit = mcccurved_guide_16_0_nslit;
MCNUM d = mcccurved_guide_16_0_d;
MCNUM mleft = mcccurved_guide_16_0_mleft;
MCNUM mright = mcccurved_guide_16_0_mright;
MCNUM mtop = mcccurved_guide_16_0_mtop;
MCNUM mbottom = mcccurved_guide_16_0_mbottom;
MCNUM nhslit = mcccurved_guide_16_0_nhslit;
MCNUM G = mcccurved_guide_16_0_G;
MCNUM aleft = mcccurved_guide_16_0_aleft;
MCNUM aright = mcccurved_guide_16_0_aright;
MCNUM atop = mcccurved_guide_16_0_atop;
MCNUM abottom = mcccurved_guide_16_0_abottom;
MCNUM wavy = mcccurved_guide_16_0_wavy;
MCNUM wavy_z = mcccurved_guide_16_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_16_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_16_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_16_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_16_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_16_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_16_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_16_0_nelements;
MCNUM nu = mcccurved_guide_16_0_nu;
MCNUM phase = mcccurved_guide_16_0_phase;
char* reflect = mcccurved_guide_16_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81131 "BIFROST.c"
}   /* End of curved_guide_16_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_17_0'. */
  SIG_MESSAGE("curved_guide_17_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_17_0");
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
{   /* Declarations of curved_guide_17_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_17_0_w1;
MCNUM h1 = mcccurved_guide_17_0_h1;
MCNUM w2 = mcccurved_guide_17_0_w2;
MCNUM h2 = mcccurved_guide_17_0_h2;
MCNUM l = mcccurved_guide_17_0_l;
MCNUM R0 = mcccurved_guide_17_0_R0;
MCNUM Qc = mcccurved_guide_17_0_Qc;
MCNUM alpha = mcccurved_guide_17_0_alpha;
MCNUM m = mcccurved_guide_17_0_m;
MCNUM W = mcccurved_guide_17_0_W;
MCNUM nslit = mcccurved_guide_17_0_nslit;
MCNUM d = mcccurved_guide_17_0_d;
MCNUM mleft = mcccurved_guide_17_0_mleft;
MCNUM mright = mcccurved_guide_17_0_mright;
MCNUM mtop = mcccurved_guide_17_0_mtop;
MCNUM mbottom = mcccurved_guide_17_0_mbottom;
MCNUM nhslit = mcccurved_guide_17_0_nhslit;
MCNUM G = mcccurved_guide_17_0_G;
MCNUM aleft = mcccurved_guide_17_0_aleft;
MCNUM aright = mcccurved_guide_17_0_aright;
MCNUM atop = mcccurved_guide_17_0_atop;
MCNUM abottom = mcccurved_guide_17_0_abottom;
MCNUM wavy = mcccurved_guide_17_0_wavy;
MCNUM wavy_z = mcccurved_guide_17_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_17_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_17_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_17_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_17_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_17_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_17_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_17_0_nelements;
MCNUM nu = mcccurved_guide_17_0_nu;
MCNUM phase = mcccurved_guide_17_0_phase;
char* reflect = mcccurved_guide_17_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81245 "BIFROST.c"
}   /* End of curved_guide_17_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_18_beforeChopper'. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_18_beforeChopper");
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
{   /* Declarations of curved_guide_18_beforeChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_18_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_18_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_18_beforeChopper_h2;
MCNUM l = mcccurved_guide_18_beforeChopper_l;
MCNUM R0 = mcccurved_guide_18_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_18_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_18_beforeChopper_alpha;
MCNUM m = mcccurved_guide_18_beforeChopper_m;
MCNUM W = mcccurved_guide_18_beforeChopper_W;
MCNUM nslit = mcccurved_guide_18_beforeChopper_nslit;
MCNUM d = mcccurved_guide_18_beforeChopper_d;
MCNUM mleft = mcccurved_guide_18_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_18_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_18_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_18_beforeChopper_G;
MCNUM aleft = mcccurved_guide_18_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_18_beforeChopper_aright;
MCNUM atop = mcccurved_guide_18_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_18_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_18_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_18_beforeChopper_nu;
MCNUM phase = mcccurved_guide_18_beforeChopper_phase;
char* reflect = mcccurved_guide_18_beforeChopper_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81359 "BIFROST.c"
}   /* End of curved_guide_18_beforeChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monBeforeFOC2'. */
  SIG_MESSAGE("L_monBeforeFOC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monBeforeFOC2");
#define mccompcurname  L_monBeforeFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 45
#define nL mccL_monBeforeFOC2_nL
#define L_N mccL_monBeforeFOC2_L_N
#define L_p mccL_monBeforeFOC2_L_p
#define L_p2 mccL_monBeforeFOC2_L_p2
{   /* Declarations of L_monBeforeFOC2=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeFOC2_filename;
MCNUM xmin = mccL_monBeforeFOC2_xmin;
MCNUM xmax = mccL_monBeforeFOC2_xmax;
MCNUM ymin = mccL_monBeforeFOC2_ymin;
MCNUM ymax = mccL_monBeforeFOC2_ymax;
MCNUM xwidth = mccL_monBeforeFOC2_xwidth;
MCNUM yheight = mccL_monBeforeFOC2_yheight;
MCNUM Lmin = mccL_monBeforeFOC2_Lmin;
MCNUM Lmax = mccL_monBeforeFOC2_Lmax;
MCNUM restore_neutron = mccL_monBeforeFOC2_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81397 "BIFROST.c"
}   /* End of L_monBeforeFOC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFBeforeFOC2'. */
  SIG_MESSAGE("ToFBeforeFOC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFBeforeFOC2");
#define mccompcurname  ToFBeforeFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccToFBeforeFOC2_nt
#define TOF_N mccToFBeforeFOC2_TOF_N
#define TOF_p mccToFBeforeFOC2_TOF_p
#define TOF_p2 mccToFBeforeFOC2_TOF_p2
#define t_min mccToFBeforeFOC2_t_min
#define t_max mccToFBeforeFOC2_t_max
#define delta_t mccToFBeforeFOC2_delta_t
{   /* Declarations of ToFBeforeFOC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeFOC2_filename;
MCNUM xmin = mccToFBeforeFOC2_xmin;
MCNUM xmax = mccToFBeforeFOC2_xmax;
MCNUM ymin = mccToFBeforeFOC2_ymin;
MCNUM ymax = mccToFBeforeFOC2_ymax;
MCNUM xwidth = mccToFBeforeFOC2_xwidth;
MCNUM yheight = mccToFBeforeFOC2_yheight;
MCNUM tmin = mccToFBeforeFOC2_tmin;
MCNUM tmax = mccToFBeforeFOC2_tmax;
MCNUM dt = mccToFBeforeFOC2_dt;
MCNUM restore_neutron = mccToFBeforeFOC2_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81441 "BIFROST.c"
}   /* End of ToFBeforeFOC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_beforeFOC2'. */
  SIG_MESSAGE("PSD_beforeFOC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_beforeFOC2");
#define mccompcurname  PSD_beforeFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 47
#define nx mccPSD_beforeFOC2_nx
#define ny mccPSD_beforeFOC2_ny
#define PSD_N mccPSD_beforeFOC2_PSD_N
#define PSD_p mccPSD_beforeFOC2_PSD_p
#define PSD_p2 mccPSD_beforeFOC2_PSD_p2
{   /* Declarations of PSD_beforeFOC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_beforeFOC2_filename;
MCNUM xmin = mccPSD_beforeFOC2_xmin;
MCNUM xmax = mccPSD_beforeFOC2_xmax;
MCNUM ymin = mccPSD_beforeFOC2_ymin;
MCNUM ymax = mccPSD_beforeFOC2_ymax;
MCNUM xwidth = mccPSD_beforeFOC2_xwidth;
MCNUM yheight = mccPSD_beforeFOC2_yheight;
MCNUM restore_neutron = mccPSD_beforeFOC2_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81483 "BIFROST.c"
}   /* End of PSD_beforeFOC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'FOC2'. */
  SIG_MESSAGE("FOC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "FOC2");
#define mccompcurname  FOC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 48
#define Tg mccFOC2_Tg
#define To mccFOC2_To
#define delta_y mccFOC2_delta_y
#define height mccFOC2_height
#define omega mccFOC2_omega
{   /* Declarations of FOC2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccFOC2_theta_0;
MCNUM radius = mccFOC2_radius;
MCNUM yheight = mccFOC2_yheight;
MCNUM nu = mccFOC2_nu;
MCNUM nslit = mccFOC2_nslit;
MCNUM jitter = mccFOC2_jitter;
MCNUM delay = mccFOC2_delay;
MCNUM isfirst = mccFOC2_isfirst;
MCNUM n_pulse = mccFOC2_n_pulse;
MCNUM abs_out = mccFOC2_abs_out;
MCNUM phase = mccFOC2_phase;
MCNUM xwidth = mccFOC2_xwidth;
MCNUM verbose = mccFOC2_verbose;
#line 165 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  magnify("xy");
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 81546 "BIFROST.c"
}   /* End of FOC2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_afterFOC2'. */
  SIG_MESSAGE("PSD_afterFOC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_afterFOC2");
#define mccompcurname  PSD_afterFOC2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define nx mccPSD_afterFOC2_nx
#define ny mccPSD_afterFOC2_ny
#define PSD_N mccPSD_afterFOC2_PSD_N
#define PSD_p mccPSD_afterFOC2_PSD_p
#define PSD_p2 mccPSD_afterFOC2_PSD_p2
{   /* Declarations of PSD_afterFOC2=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_afterFOC2_filename;
MCNUM xmin = mccPSD_afterFOC2_xmin;
MCNUM xmax = mccPSD_afterFOC2_xmax;
MCNUM ymin = mccPSD_afterFOC2_ymin;
MCNUM ymax = mccPSD_afterFOC2_ymax;
MCNUM xwidth = mccPSD_afterFOC2_xwidth;
MCNUM yheight = mccPSD_afterFOC2_yheight;
MCNUM restore_neutron = mccPSD_afterFOC2_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81586 "BIFROST.c"
}   /* End of PSD_afterFOC2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFAfterFOC2'. */
  SIG_MESSAGE("ToFAfterFOC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFAfterFOC2");
#define mccompcurname  ToFAfterFOC2
#define mccompcurtype  TOF_monitor
#define mccompcurindex 50
#define nt mccToFAfterFOC2_nt
#define TOF_N mccToFAfterFOC2_TOF_N
#define TOF_p mccToFAfterFOC2_TOF_p
#define TOF_p2 mccToFAfterFOC2_TOF_p2
#define t_min mccToFAfterFOC2_t_min
#define t_max mccToFAfterFOC2_t_max
#define delta_t mccToFAfterFOC2_delta_t
{   /* Declarations of ToFAfterFOC2=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterFOC2_filename;
MCNUM xmin = mccToFAfterFOC2_xmin;
MCNUM xmax = mccToFAfterFOC2_xmax;
MCNUM ymin = mccToFAfterFOC2_ymin;
MCNUM ymax = mccToFAfterFOC2_ymax;
MCNUM xwidth = mccToFAfterFOC2_xwidth;
MCNUM yheight = mccToFAfterFOC2_yheight;
MCNUM tmin = mccToFAfterFOC2_tmin;
MCNUM tmax = mccToFAfterFOC2_tmax;
MCNUM dt = mccToFAfterFOC2_dt;
MCNUM restore_neutron = mccToFAfterFOC2_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81631 "BIFROST.c"
}   /* End of ToFAfterFOC2=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monAfterFOC2'. */
  SIG_MESSAGE("L_monAfterFOC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monAfterFOC2");
#define mccompcurname  L_monAfterFOC2
#define mccompcurtype  L_monitor
#define mccompcurindex 51
#define nL mccL_monAfterFOC2_nL
#define L_N mccL_monAfterFOC2_L_N
#define L_p mccL_monAfterFOC2_L_p
#define L_p2 mccL_monAfterFOC2_L_p2
{   /* Declarations of L_monAfterFOC2=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterFOC2_filename;
MCNUM xmin = mccL_monAfterFOC2_xmin;
MCNUM xmax = mccL_monAfterFOC2_xmax;
MCNUM ymin = mccL_monAfterFOC2_ymin;
MCNUM ymax = mccL_monAfterFOC2_ymax;
MCNUM xwidth = mccL_monAfterFOC2_xwidth;
MCNUM yheight = mccL_monAfterFOC2_yheight;
MCNUM Lmin = mccL_monAfterFOC2_Lmin;
MCNUM Lmax = mccL_monAfterFOC2_Lmax;
MCNUM restore_neutron = mccL_monAfterFOC2_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81674 "BIFROST.c"
}   /* End of L_monAfterFOC2=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_18_afterChopper'. */
  SIG_MESSAGE("curved_guide_18_afterChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_18_afterChopper");
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
{   /* Declarations of curved_guide_18_afterChopper=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_afterChopper_w1;
MCNUM h1 = mcccurved_guide_18_afterChopper_h1;
MCNUM w2 = mcccurved_guide_18_afterChopper_w2;
MCNUM h2 = mcccurved_guide_18_afterChopper_h2;
MCNUM l = mcccurved_guide_18_afterChopper_l;
MCNUM R0 = mcccurved_guide_18_afterChopper_R0;
MCNUM Qc = mcccurved_guide_18_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_18_afterChopper_alpha;
MCNUM m = mcccurved_guide_18_afterChopper_m;
MCNUM W = mcccurved_guide_18_afterChopper_W;
MCNUM nslit = mcccurved_guide_18_afterChopper_nslit;
MCNUM d = mcccurved_guide_18_afterChopper_d;
MCNUM mleft = mcccurved_guide_18_afterChopper_mleft;
MCNUM mright = mcccurved_guide_18_afterChopper_mright;
MCNUM mtop = mcccurved_guide_18_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_afterChopper_nhslit;
MCNUM G = mcccurved_guide_18_afterChopper_G;
MCNUM aleft = mcccurved_guide_18_afterChopper_aleft;
MCNUM aright = mcccurved_guide_18_afterChopper_aright;
MCNUM atop = mcccurved_guide_18_afterChopper_atop;
MCNUM abottom = mcccurved_guide_18_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_18_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_afterChopper_nelements;
MCNUM nu = mcccurved_guide_18_afterChopper_nu;
MCNUM phase = mcccurved_guide_18_afterChopper_phase;
char* reflect = mcccurved_guide_18_afterChopper_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81790 "BIFROST.c"
}   /* End of curved_guide_18_afterChopper=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_19_0'. */
  SIG_MESSAGE("curved_guide_19_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_19_0");
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
{   /* Declarations of curved_guide_19_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_19_0_w1;
MCNUM h1 = mcccurved_guide_19_0_h1;
MCNUM w2 = mcccurved_guide_19_0_w2;
MCNUM h2 = mcccurved_guide_19_0_h2;
MCNUM l = mcccurved_guide_19_0_l;
MCNUM R0 = mcccurved_guide_19_0_R0;
MCNUM Qc = mcccurved_guide_19_0_Qc;
MCNUM alpha = mcccurved_guide_19_0_alpha;
MCNUM m = mcccurved_guide_19_0_m;
MCNUM W = mcccurved_guide_19_0_W;
MCNUM nslit = mcccurved_guide_19_0_nslit;
MCNUM d = mcccurved_guide_19_0_d;
MCNUM mleft = mcccurved_guide_19_0_mleft;
MCNUM mright = mcccurved_guide_19_0_mright;
MCNUM mtop = mcccurved_guide_19_0_mtop;
MCNUM mbottom = mcccurved_guide_19_0_mbottom;
MCNUM nhslit = mcccurved_guide_19_0_nhslit;
MCNUM G = mcccurved_guide_19_0_G;
MCNUM aleft = mcccurved_guide_19_0_aleft;
MCNUM aright = mcccurved_guide_19_0_aright;
MCNUM atop = mcccurved_guide_19_0_atop;
MCNUM abottom = mcccurved_guide_19_0_abottom;
MCNUM wavy = mcccurved_guide_19_0_wavy;
MCNUM wavy_z = mcccurved_guide_19_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_19_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_19_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_19_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_19_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_19_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_19_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_19_0_nelements;
MCNUM nu = mcccurved_guide_19_0_nu;
MCNUM phase = mcccurved_guide_19_0_phase;
char* reflect = mcccurved_guide_19_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81904 "BIFROST.c"
}   /* End of curved_guide_19_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_20_0'. */
  SIG_MESSAGE("curved_guide_20_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_20_0");
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
{   /* Declarations of curved_guide_20_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_20_0_w1;
MCNUM h1 = mcccurved_guide_20_0_h1;
MCNUM w2 = mcccurved_guide_20_0_w2;
MCNUM h2 = mcccurved_guide_20_0_h2;
MCNUM l = mcccurved_guide_20_0_l;
MCNUM R0 = mcccurved_guide_20_0_R0;
MCNUM Qc = mcccurved_guide_20_0_Qc;
MCNUM alpha = mcccurved_guide_20_0_alpha;
MCNUM m = mcccurved_guide_20_0_m;
MCNUM W = mcccurved_guide_20_0_W;
MCNUM nslit = mcccurved_guide_20_0_nslit;
MCNUM d = mcccurved_guide_20_0_d;
MCNUM mleft = mcccurved_guide_20_0_mleft;
MCNUM mright = mcccurved_guide_20_0_mright;
MCNUM mtop = mcccurved_guide_20_0_mtop;
MCNUM mbottom = mcccurved_guide_20_0_mbottom;
MCNUM nhslit = mcccurved_guide_20_0_nhslit;
MCNUM G = mcccurved_guide_20_0_G;
MCNUM aleft = mcccurved_guide_20_0_aleft;
MCNUM aright = mcccurved_guide_20_0_aright;
MCNUM atop = mcccurved_guide_20_0_atop;
MCNUM abottom = mcccurved_guide_20_0_abottom;
MCNUM wavy = mcccurved_guide_20_0_wavy;
MCNUM wavy_z = mcccurved_guide_20_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_20_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_20_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_20_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_20_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_20_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_20_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_20_0_nelements;
MCNUM nu = mcccurved_guide_20_0_nu;
MCNUM phase = mcccurved_guide_20_0_phase;
char* reflect = mcccurved_guide_20_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82018 "BIFROST.c"
}   /* End of curved_guide_20_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_21_0'. */
  SIG_MESSAGE("curved_guide_21_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_21_0");
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
{   /* Declarations of curved_guide_21_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_21_0_w1;
MCNUM h1 = mcccurved_guide_21_0_h1;
MCNUM w2 = mcccurved_guide_21_0_w2;
MCNUM h2 = mcccurved_guide_21_0_h2;
MCNUM l = mcccurved_guide_21_0_l;
MCNUM R0 = mcccurved_guide_21_0_R0;
MCNUM Qc = mcccurved_guide_21_0_Qc;
MCNUM alpha = mcccurved_guide_21_0_alpha;
MCNUM m = mcccurved_guide_21_0_m;
MCNUM W = mcccurved_guide_21_0_W;
MCNUM nslit = mcccurved_guide_21_0_nslit;
MCNUM d = mcccurved_guide_21_0_d;
MCNUM mleft = mcccurved_guide_21_0_mleft;
MCNUM mright = mcccurved_guide_21_0_mright;
MCNUM mtop = mcccurved_guide_21_0_mtop;
MCNUM mbottom = mcccurved_guide_21_0_mbottom;
MCNUM nhslit = mcccurved_guide_21_0_nhslit;
MCNUM G = mcccurved_guide_21_0_G;
MCNUM aleft = mcccurved_guide_21_0_aleft;
MCNUM aright = mcccurved_guide_21_0_aright;
MCNUM atop = mcccurved_guide_21_0_atop;
MCNUM abottom = mcccurved_guide_21_0_abottom;
MCNUM wavy = mcccurved_guide_21_0_wavy;
MCNUM wavy_z = mcccurved_guide_21_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_21_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_21_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_21_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_21_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_21_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_21_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_21_0_nelements;
MCNUM nu = mcccurved_guide_21_0_nu;
MCNUM phase = mcccurved_guide_21_0_phase;
char* reflect = mcccurved_guide_21_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82132 "BIFROST.c"
}   /* End of curved_guide_21_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_22_0'. */
  SIG_MESSAGE("curved_guide_22_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_22_0");
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
{   /* Declarations of curved_guide_22_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_22_0_w1;
MCNUM h1 = mcccurved_guide_22_0_h1;
MCNUM w2 = mcccurved_guide_22_0_w2;
MCNUM h2 = mcccurved_guide_22_0_h2;
MCNUM l = mcccurved_guide_22_0_l;
MCNUM R0 = mcccurved_guide_22_0_R0;
MCNUM Qc = mcccurved_guide_22_0_Qc;
MCNUM alpha = mcccurved_guide_22_0_alpha;
MCNUM m = mcccurved_guide_22_0_m;
MCNUM W = mcccurved_guide_22_0_W;
MCNUM nslit = mcccurved_guide_22_0_nslit;
MCNUM d = mcccurved_guide_22_0_d;
MCNUM mleft = mcccurved_guide_22_0_mleft;
MCNUM mright = mcccurved_guide_22_0_mright;
MCNUM mtop = mcccurved_guide_22_0_mtop;
MCNUM mbottom = mcccurved_guide_22_0_mbottom;
MCNUM nhslit = mcccurved_guide_22_0_nhslit;
MCNUM G = mcccurved_guide_22_0_G;
MCNUM aleft = mcccurved_guide_22_0_aleft;
MCNUM aright = mcccurved_guide_22_0_aright;
MCNUM atop = mcccurved_guide_22_0_atop;
MCNUM abottom = mcccurved_guide_22_0_abottom;
MCNUM wavy = mcccurved_guide_22_0_wavy;
MCNUM wavy_z = mcccurved_guide_22_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_22_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_22_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_22_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_22_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_22_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_22_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_22_0_nelements;
MCNUM nu = mcccurved_guide_22_0_nu;
MCNUM phase = mcccurved_guide_22_0_phase;
char* reflect = mcccurved_guide_22_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82246 "BIFROST.c"
}   /* End of curved_guide_22_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_23_0'. */
  SIG_MESSAGE("curved_guide_23_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_23_0");
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
{   /* Declarations of curved_guide_23_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_23_0_w1;
MCNUM h1 = mcccurved_guide_23_0_h1;
MCNUM w2 = mcccurved_guide_23_0_w2;
MCNUM h2 = mcccurved_guide_23_0_h2;
MCNUM l = mcccurved_guide_23_0_l;
MCNUM R0 = mcccurved_guide_23_0_R0;
MCNUM Qc = mcccurved_guide_23_0_Qc;
MCNUM alpha = mcccurved_guide_23_0_alpha;
MCNUM m = mcccurved_guide_23_0_m;
MCNUM W = mcccurved_guide_23_0_W;
MCNUM nslit = mcccurved_guide_23_0_nslit;
MCNUM d = mcccurved_guide_23_0_d;
MCNUM mleft = mcccurved_guide_23_0_mleft;
MCNUM mright = mcccurved_guide_23_0_mright;
MCNUM mtop = mcccurved_guide_23_0_mtop;
MCNUM mbottom = mcccurved_guide_23_0_mbottom;
MCNUM nhslit = mcccurved_guide_23_0_nhslit;
MCNUM G = mcccurved_guide_23_0_G;
MCNUM aleft = mcccurved_guide_23_0_aleft;
MCNUM aright = mcccurved_guide_23_0_aright;
MCNUM atop = mcccurved_guide_23_0_atop;
MCNUM abottom = mcccurved_guide_23_0_abottom;
MCNUM wavy = mcccurved_guide_23_0_wavy;
MCNUM wavy_z = mcccurved_guide_23_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_23_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_23_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_23_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_23_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_23_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_23_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_23_0_nelements;
MCNUM nu = mcccurved_guide_23_0_nu;
MCNUM phase = mcccurved_guide_23_0_phase;
char* reflect = mcccurved_guide_23_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82360 "BIFROST.c"
}   /* End of curved_guide_23_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_24_0'. */
  SIG_MESSAGE("curved_guide_24_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_24_0");
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
{   /* Declarations of curved_guide_24_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_24_0_w1;
MCNUM h1 = mcccurved_guide_24_0_h1;
MCNUM w2 = mcccurved_guide_24_0_w2;
MCNUM h2 = mcccurved_guide_24_0_h2;
MCNUM l = mcccurved_guide_24_0_l;
MCNUM R0 = mcccurved_guide_24_0_R0;
MCNUM Qc = mcccurved_guide_24_0_Qc;
MCNUM alpha = mcccurved_guide_24_0_alpha;
MCNUM m = mcccurved_guide_24_0_m;
MCNUM W = mcccurved_guide_24_0_W;
MCNUM nslit = mcccurved_guide_24_0_nslit;
MCNUM d = mcccurved_guide_24_0_d;
MCNUM mleft = mcccurved_guide_24_0_mleft;
MCNUM mright = mcccurved_guide_24_0_mright;
MCNUM mtop = mcccurved_guide_24_0_mtop;
MCNUM mbottom = mcccurved_guide_24_0_mbottom;
MCNUM nhslit = mcccurved_guide_24_0_nhslit;
MCNUM G = mcccurved_guide_24_0_G;
MCNUM aleft = mcccurved_guide_24_0_aleft;
MCNUM aright = mcccurved_guide_24_0_aright;
MCNUM atop = mcccurved_guide_24_0_atop;
MCNUM abottom = mcccurved_guide_24_0_abottom;
MCNUM wavy = mcccurved_guide_24_0_wavy;
MCNUM wavy_z = mcccurved_guide_24_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_24_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_24_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_24_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_24_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_24_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_24_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_24_0_nelements;
MCNUM nu = mcccurved_guide_24_0_nu;
MCNUM phase = mcccurved_guide_24_0_phase;
char* reflect = mcccurved_guide_24_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82474 "BIFROST.c"
}   /* End of curved_guide_24_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_25_0'. */
  SIG_MESSAGE("curved_guide_25_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_25_0");
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
{   /* Declarations of curved_guide_25_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_25_0_w1;
MCNUM h1 = mcccurved_guide_25_0_h1;
MCNUM w2 = mcccurved_guide_25_0_w2;
MCNUM h2 = mcccurved_guide_25_0_h2;
MCNUM l = mcccurved_guide_25_0_l;
MCNUM R0 = mcccurved_guide_25_0_R0;
MCNUM Qc = mcccurved_guide_25_0_Qc;
MCNUM alpha = mcccurved_guide_25_0_alpha;
MCNUM m = mcccurved_guide_25_0_m;
MCNUM W = mcccurved_guide_25_0_W;
MCNUM nslit = mcccurved_guide_25_0_nslit;
MCNUM d = mcccurved_guide_25_0_d;
MCNUM mleft = mcccurved_guide_25_0_mleft;
MCNUM mright = mcccurved_guide_25_0_mright;
MCNUM mtop = mcccurved_guide_25_0_mtop;
MCNUM mbottom = mcccurved_guide_25_0_mbottom;
MCNUM nhslit = mcccurved_guide_25_0_nhslit;
MCNUM G = mcccurved_guide_25_0_G;
MCNUM aleft = mcccurved_guide_25_0_aleft;
MCNUM aright = mcccurved_guide_25_0_aright;
MCNUM atop = mcccurved_guide_25_0_atop;
MCNUM abottom = mcccurved_guide_25_0_abottom;
MCNUM wavy = mcccurved_guide_25_0_wavy;
MCNUM wavy_z = mcccurved_guide_25_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_25_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_25_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_25_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_25_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_25_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_25_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_25_0_nelements;
MCNUM nu = mcccurved_guide_25_0_nu;
MCNUM phase = mcccurved_guide_25_0_phase;
char* reflect = mcccurved_guide_25_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82588 "BIFROST.c"
}   /* End of curved_guide_25_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_26_0'. */
  SIG_MESSAGE("curved_guide_26_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_26_0");
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 60
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
{   /* Declarations of curved_guide_26_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_26_0_w1;
MCNUM h1 = mcccurved_guide_26_0_h1;
MCNUM w2 = mcccurved_guide_26_0_w2;
MCNUM h2 = mcccurved_guide_26_0_h2;
MCNUM l = mcccurved_guide_26_0_l;
MCNUM R0 = mcccurved_guide_26_0_R0;
MCNUM Qc = mcccurved_guide_26_0_Qc;
MCNUM alpha = mcccurved_guide_26_0_alpha;
MCNUM m = mcccurved_guide_26_0_m;
MCNUM W = mcccurved_guide_26_0_W;
MCNUM nslit = mcccurved_guide_26_0_nslit;
MCNUM d = mcccurved_guide_26_0_d;
MCNUM mleft = mcccurved_guide_26_0_mleft;
MCNUM mright = mcccurved_guide_26_0_mright;
MCNUM mtop = mcccurved_guide_26_0_mtop;
MCNUM mbottom = mcccurved_guide_26_0_mbottom;
MCNUM nhslit = mcccurved_guide_26_0_nhslit;
MCNUM G = mcccurved_guide_26_0_G;
MCNUM aleft = mcccurved_guide_26_0_aleft;
MCNUM aright = mcccurved_guide_26_0_aright;
MCNUM atop = mcccurved_guide_26_0_atop;
MCNUM abottom = mcccurved_guide_26_0_abottom;
MCNUM wavy = mcccurved_guide_26_0_wavy;
MCNUM wavy_z = mcccurved_guide_26_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_26_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_26_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_26_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_26_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_26_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_26_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_26_0_nelements;
MCNUM nu = mcccurved_guide_26_0_nu;
MCNUM phase = mcccurved_guide_26_0_phase;
char* reflect = mcccurved_guide_26_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82702 "BIFROST.c"
}   /* End of curved_guide_26_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_27_0'. */
  SIG_MESSAGE("curved_guide_27_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_27_0");
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 61
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
{   /* Declarations of curved_guide_27_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_27_0_w1;
MCNUM h1 = mcccurved_guide_27_0_h1;
MCNUM w2 = mcccurved_guide_27_0_w2;
MCNUM h2 = mcccurved_guide_27_0_h2;
MCNUM l = mcccurved_guide_27_0_l;
MCNUM R0 = mcccurved_guide_27_0_R0;
MCNUM Qc = mcccurved_guide_27_0_Qc;
MCNUM alpha = mcccurved_guide_27_0_alpha;
MCNUM m = mcccurved_guide_27_0_m;
MCNUM W = mcccurved_guide_27_0_W;
MCNUM nslit = mcccurved_guide_27_0_nslit;
MCNUM d = mcccurved_guide_27_0_d;
MCNUM mleft = mcccurved_guide_27_0_mleft;
MCNUM mright = mcccurved_guide_27_0_mright;
MCNUM mtop = mcccurved_guide_27_0_mtop;
MCNUM mbottom = mcccurved_guide_27_0_mbottom;
MCNUM nhslit = mcccurved_guide_27_0_nhslit;
MCNUM G = mcccurved_guide_27_0_G;
MCNUM aleft = mcccurved_guide_27_0_aleft;
MCNUM aright = mcccurved_guide_27_0_aright;
MCNUM atop = mcccurved_guide_27_0_atop;
MCNUM abottom = mcccurved_guide_27_0_abottom;
MCNUM wavy = mcccurved_guide_27_0_wavy;
MCNUM wavy_z = mcccurved_guide_27_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_27_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_27_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_27_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_27_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_27_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_27_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_27_0_nelements;
MCNUM nu = mcccurved_guide_27_0_nu;
MCNUM phase = mcccurved_guide_27_0_phase;
char* reflect = mcccurved_guide_27_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82816 "BIFROST.c"
}   /* End of curved_guide_27_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_28_0'. */
  SIG_MESSAGE("curved_guide_28_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_28_0");
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 62
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
{   /* Declarations of curved_guide_28_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_28_0_w1;
MCNUM h1 = mcccurved_guide_28_0_h1;
MCNUM w2 = mcccurved_guide_28_0_w2;
MCNUM h2 = mcccurved_guide_28_0_h2;
MCNUM l = mcccurved_guide_28_0_l;
MCNUM R0 = mcccurved_guide_28_0_R0;
MCNUM Qc = mcccurved_guide_28_0_Qc;
MCNUM alpha = mcccurved_guide_28_0_alpha;
MCNUM m = mcccurved_guide_28_0_m;
MCNUM W = mcccurved_guide_28_0_W;
MCNUM nslit = mcccurved_guide_28_0_nslit;
MCNUM d = mcccurved_guide_28_0_d;
MCNUM mleft = mcccurved_guide_28_0_mleft;
MCNUM mright = mcccurved_guide_28_0_mright;
MCNUM mtop = mcccurved_guide_28_0_mtop;
MCNUM mbottom = mcccurved_guide_28_0_mbottom;
MCNUM nhslit = mcccurved_guide_28_0_nhslit;
MCNUM G = mcccurved_guide_28_0_G;
MCNUM aleft = mcccurved_guide_28_0_aleft;
MCNUM aright = mcccurved_guide_28_0_aright;
MCNUM atop = mcccurved_guide_28_0_atop;
MCNUM abottom = mcccurved_guide_28_0_abottom;
MCNUM wavy = mcccurved_guide_28_0_wavy;
MCNUM wavy_z = mcccurved_guide_28_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_28_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_28_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_28_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_28_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_28_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_28_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_28_0_nelements;
MCNUM nu = mcccurved_guide_28_0_nu;
MCNUM phase = mcccurved_guide_28_0_phase;
char* reflect = mcccurved_guide_28_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82930 "BIFROST.c"
}   /* End of curved_guide_28_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_29_0'. */
  SIG_MESSAGE("curved_guide_29_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_29_0");
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 63
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
{   /* Declarations of curved_guide_29_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_29_0_w1;
MCNUM h1 = mcccurved_guide_29_0_h1;
MCNUM w2 = mcccurved_guide_29_0_w2;
MCNUM h2 = mcccurved_guide_29_0_h2;
MCNUM l = mcccurved_guide_29_0_l;
MCNUM R0 = mcccurved_guide_29_0_R0;
MCNUM Qc = mcccurved_guide_29_0_Qc;
MCNUM alpha = mcccurved_guide_29_0_alpha;
MCNUM m = mcccurved_guide_29_0_m;
MCNUM W = mcccurved_guide_29_0_W;
MCNUM nslit = mcccurved_guide_29_0_nslit;
MCNUM d = mcccurved_guide_29_0_d;
MCNUM mleft = mcccurved_guide_29_0_mleft;
MCNUM mright = mcccurved_guide_29_0_mright;
MCNUM mtop = mcccurved_guide_29_0_mtop;
MCNUM mbottom = mcccurved_guide_29_0_mbottom;
MCNUM nhslit = mcccurved_guide_29_0_nhslit;
MCNUM G = mcccurved_guide_29_0_G;
MCNUM aleft = mcccurved_guide_29_0_aleft;
MCNUM aright = mcccurved_guide_29_0_aright;
MCNUM atop = mcccurved_guide_29_0_atop;
MCNUM abottom = mcccurved_guide_29_0_abottom;
MCNUM wavy = mcccurved_guide_29_0_wavy;
MCNUM wavy_z = mcccurved_guide_29_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_29_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_29_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_29_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_29_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_29_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_29_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_29_0_nelements;
MCNUM nu = mcccurved_guide_29_0_nu;
MCNUM phase = mcccurved_guide_29_0_phase;
char* reflect = mcccurved_guide_29_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83044 "BIFROST.c"
}   /* End of curved_guide_29_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_30_0'. */
  SIG_MESSAGE("curved_guide_30_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_30_0");
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
{   /* Declarations of curved_guide_30_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_30_0_w1;
MCNUM h1 = mcccurved_guide_30_0_h1;
MCNUM w2 = mcccurved_guide_30_0_w2;
MCNUM h2 = mcccurved_guide_30_0_h2;
MCNUM l = mcccurved_guide_30_0_l;
MCNUM R0 = mcccurved_guide_30_0_R0;
MCNUM Qc = mcccurved_guide_30_0_Qc;
MCNUM alpha = mcccurved_guide_30_0_alpha;
MCNUM m = mcccurved_guide_30_0_m;
MCNUM W = mcccurved_guide_30_0_W;
MCNUM nslit = mcccurved_guide_30_0_nslit;
MCNUM d = mcccurved_guide_30_0_d;
MCNUM mleft = mcccurved_guide_30_0_mleft;
MCNUM mright = mcccurved_guide_30_0_mright;
MCNUM mtop = mcccurved_guide_30_0_mtop;
MCNUM mbottom = mcccurved_guide_30_0_mbottom;
MCNUM nhslit = mcccurved_guide_30_0_nhslit;
MCNUM G = mcccurved_guide_30_0_G;
MCNUM aleft = mcccurved_guide_30_0_aleft;
MCNUM aright = mcccurved_guide_30_0_aright;
MCNUM atop = mcccurved_guide_30_0_atop;
MCNUM abottom = mcccurved_guide_30_0_abottom;
MCNUM wavy = mcccurved_guide_30_0_wavy;
MCNUM wavy_z = mcccurved_guide_30_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_30_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_30_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_30_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_30_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_30_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_30_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_30_0_nelements;
MCNUM nu = mcccurved_guide_30_0_nu;
MCNUM phase = mcccurved_guide_30_0_phase;
char* reflect = mcccurved_guide_30_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83158 "BIFROST.c"
}   /* End of curved_guide_30_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_31_0'. */
  SIG_MESSAGE("curved_guide_31_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_31_0");
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
{   /* Declarations of curved_guide_31_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_31_0_w1;
MCNUM h1 = mcccurved_guide_31_0_h1;
MCNUM w2 = mcccurved_guide_31_0_w2;
MCNUM h2 = mcccurved_guide_31_0_h2;
MCNUM l = mcccurved_guide_31_0_l;
MCNUM R0 = mcccurved_guide_31_0_R0;
MCNUM Qc = mcccurved_guide_31_0_Qc;
MCNUM alpha = mcccurved_guide_31_0_alpha;
MCNUM m = mcccurved_guide_31_0_m;
MCNUM W = mcccurved_guide_31_0_W;
MCNUM nslit = mcccurved_guide_31_0_nslit;
MCNUM d = mcccurved_guide_31_0_d;
MCNUM mleft = mcccurved_guide_31_0_mleft;
MCNUM mright = mcccurved_guide_31_0_mright;
MCNUM mtop = mcccurved_guide_31_0_mtop;
MCNUM mbottom = mcccurved_guide_31_0_mbottom;
MCNUM nhslit = mcccurved_guide_31_0_nhslit;
MCNUM G = mcccurved_guide_31_0_G;
MCNUM aleft = mcccurved_guide_31_0_aleft;
MCNUM aright = mcccurved_guide_31_0_aright;
MCNUM atop = mcccurved_guide_31_0_atop;
MCNUM abottom = mcccurved_guide_31_0_abottom;
MCNUM wavy = mcccurved_guide_31_0_wavy;
MCNUM wavy_z = mcccurved_guide_31_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_31_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_31_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_31_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_31_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_31_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_31_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_31_0_nelements;
MCNUM nu = mcccurved_guide_31_0_nu;
MCNUM phase = mcccurved_guide_31_0_phase;
char* reflect = mcccurved_guide_31_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83272 "BIFROST.c"
}   /* End of curved_guide_31_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_32_0'. */
  SIG_MESSAGE("curved_guide_32_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_32_0");
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
{   /* Declarations of curved_guide_32_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_32_0_w1;
MCNUM h1 = mcccurved_guide_32_0_h1;
MCNUM w2 = mcccurved_guide_32_0_w2;
MCNUM h2 = mcccurved_guide_32_0_h2;
MCNUM l = mcccurved_guide_32_0_l;
MCNUM R0 = mcccurved_guide_32_0_R0;
MCNUM Qc = mcccurved_guide_32_0_Qc;
MCNUM alpha = mcccurved_guide_32_0_alpha;
MCNUM m = mcccurved_guide_32_0_m;
MCNUM W = mcccurved_guide_32_0_W;
MCNUM nslit = mcccurved_guide_32_0_nslit;
MCNUM d = mcccurved_guide_32_0_d;
MCNUM mleft = mcccurved_guide_32_0_mleft;
MCNUM mright = mcccurved_guide_32_0_mright;
MCNUM mtop = mcccurved_guide_32_0_mtop;
MCNUM mbottom = mcccurved_guide_32_0_mbottom;
MCNUM nhslit = mcccurved_guide_32_0_nhslit;
MCNUM G = mcccurved_guide_32_0_G;
MCNUM aleft = mcccurved_guide_32_0_aleft;
MCNUM aright = mcccurved_guide_32_0_aright;
MCNUM atop = mcccurved_guide_32_0_atop;
MCNUM abottom = mcccurved_guide_32_0_abottom;
MCNUM wavy = mcccurved_guide_32_0_wavy;
MCNUM wavy_z = mcccurved_guide_32_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_32_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_32_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_32_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_32_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_32_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_32_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_32_0_nelements;
MCNUM nu = mcccurved_guide_32_0_nu;
MCNUM phase = mcccurved_guide_32_0_phase;
char* reflect = mcccurved_guide_32_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83386 "BIFROST.c"
}   /* End of curved_guide_32_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_33_0'. */
  SIG_MESSAGE("curved_guide_33_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_33_0");
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
{   /* Declarations of curved_guide_33_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_33_0_w1;
MCNUM h1 = mcccurved_guide_33_0_h1;
MCNUM w2 = mcccurved_guide_33_0_w2;
MCNUM h2 = mcccurved_guide_33_0_h2;
MCNUM l = mcccurved_guide_33_0_l;
MCNUM R0 = mcccurved_guide_33_0_R0;
MCNUM Qc = mcccurved_guide_33_0_Qc;
MCNUM alpha = mcccurved_guide_33_0_alpha;
MCNUM m = mcccurved_guide_33_0_m;
MCNUM W = mcccurved_guide_33_0_W;
MCNUM nslit = mcccurved_guide_33_0_nslit;
MCNUM d = mcccurved_guide_33_0_d;
MCNUM mleft = mcccurved_guide_33_0_mleft;
MCNUM mright = mcccurved_guide_33_0_mright;
MCNUM mtop = mcccurved_guide_33_0_mtop;
MCNUM mbottom = mcccurved_guide_33_0_mbottom;
MCNUM nhslit = mcccurved_guide_33_0_nhslit;
MCNUM G = mcccurved_guide_33_0_G;
MCNUM aleft = mcccurved_guide_33_0_aleft;
MCNUM aright = mcccurved_guide_33_0_aright;
MCNUM atop = mcccurved_guide_33_0_atop;
MCNUM abottom = mcccurved_guide_33_0_abottom;
MCNUM wavy = mcccurved_guide_33_0_wavy;
MCNUM wavy_z = mcccurved_guide_33_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_33_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_33_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_33_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_33_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_33_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_33_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_33_0_nelements;
MCNUM nu = mcccurved_guide_33_0_nu;
MCNUM phase = mcccurved_guide_33_0_phase;
char* reflect = mcccurved_guide_33_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83500 "BIFROST.c"
}   /* End of curved_guide_33_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_34_0'. */
  SIG_MESSAGE("curved_guide_34_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_34_0");
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
{   /* Declarations of curved_guide_34_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_34_0_w1;
MCNUM h1 = mcccurved_guide_34_0_h1;
MCNUM w2 = mcccurved_guide_34_0_w2;
MCNUM h2 = mcccurved_guide_34_0_h2;
MCNUM l = mcccurved_guide_34_0_l;
MCNUM R0 = mcccurved_guide_34_0_R0;
MCNUM Qc = mcccurved_guide_34_0_Qc;
MCNUM alpha = mcccurved_guide_34_0_alpha;
MCNUM m = mcccurved_guide_34_0_m;
MCNUM W = mcccurved_guide_34_0_W;
MCNUM nslit = mcccurved_guide_34_0_nslit;
MCNUM d = mcccurved_guide_34_0_d;
MCNUM mleft = mcccurved_guide_34_0_mleft;
MCNUM mright = mcccurved_guide_34_0_mright;
MCNUM mtop = mcccurved_guide_34_0_mtop;
MCNUM mbottom = mcccurved_guide_34_0_mbottom;
MCNUM nhslit = mcccurved_guide_34_0_nhslit;
MCNUM G = mcccurved_guide_34_0_G;
MCNUM aleft = mcccurved_guide_34_0_aleft;
MCNUM aright = mcccurved_guide_34_0_aright;
MCNUM atop = mcccurved_guide_34_0_atop;
MCNUM abottom = mcccurved_guide_34_0_abottom;
MCNUM wavy = mcccurved_guide_34_0_wavy;
MCNUM wavy_z = mcccurved_guide_34_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_34_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_34_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_34_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_34_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_34_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_34_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_34_0_nelements;
MCNUM nu = mcccurved_guide_34_0_nu;
MCNUM phase = mcccurved_guide_34_0_phase;
char* reflect = mcccurved_guide_34_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83614 "BIFROST.c"
}   /* End of curved_guide_34_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_35_0'. */
  SIG_MESSAGE("curved_guide_35_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_35_0");
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 69
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
{   /* Declarations of curved_guide_35_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_35_0_w1;
MCNUM h1 = mcccurved_guide_35_0_h1;
MCNUM w2 = mcccurved_guide_35_0_w2;
MCNUM h2 = mcccurved_guide_35_0_h2;
MCNUM l = mcccurved_guide_35_0_l;
MCNUM R0 = mcccurved_guide_35_0_R0;
MCNUM Qc = mcccurved_guide_35_0_Qc;
MCNUM alpha = mcccurved_guide_35_0_alpha;
MCNUM m = mcccurved_guide_35_0_m;
MCNUM W = mcccurved_guide_35_0_W;
MCNUM nslit = mcccurved_guide_35_0_nslit;
MCNUM d = mcccurved_guide_35_0_d;
MCNUM mleft = mcccurved_guide_35_0_mleft;
MCNUM mright = mcccurved_guide_35_0_mright;
MCNUM mtop = mcccurved_guide_35_0_mtop;
MCNUM mbottom = mcccurved_guide_35_0_mbottom;
MCNUM nhslit = mcccurved_guide_35_0_nhslit;
MCNUM G = mcccurved_guide_35_0_G;
MCNUM aleft = mcccurved_guide_35_0_aleft;
MCNUM aright = mcccurved_guide_35_0_aright;
MCNUM atop = mcccurved_guide_35_0_atop;
MCNUM abottom = mcccurved_guide_35_0_abottom;
MCNUM wavy = mcccurved_guide_35_0_wavy;
MCNUM wavy_z = mcccurved_guide_35_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_35_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_35_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_35_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_35_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_35_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_35_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_35_0_nelements;
MCNUM nu = mcccurved_guide_35_0_nu;
MCNUM phase = mcccurved_guide_35_0_phase;
char* reflect = mcccurved_guide_35_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83728 "BIFROST.c"
}   /* End of curved_guide_35_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_36_0'. */
  SIG_MESSAGE("curved_guide_36_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_36_0");
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
{   /* Declarations of curved_guide_36_0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccurved_guide_36_0_w1;
MCNUM h1 = mcccurved_guide_36_0_h1;
MCNUM w2 = mcccurved_guide_36_0_w2;
MCNUM h2 = mcccurved_guide_36_0_h2;
MCNUM l = mcccurved_guide_36_0_l;
MCNUM R0 = mcccurved_guide_36_0_R0;
MCNUM Qc = mcccurved_guide_36_0_Qc;
MCNUM alpha = mcccurved_guide_36_0_alpha;
MCNUM m = mcccurved_guide_36_0_m;
MCNUM W = mcccurved_guide_36_0_W;
MCNUM nslit = mcccurved_guide_36_0_nslit;
MCNUM d = mcccurved_guide_36_0_d;
MCNUM mleft = mcccurved_guide_36_0_mleft;
MCNUM mright = mcccurved_guide_36_0_mright;
MCNUM mtop = mcccurved_guide_36_0_mtop;
MCNUM mbottom = mcccurved_guide_36_0_mbottom;
MCNUM nhslit = mcccurved_guide_36_0_nhslit;
MCNUM G = mcccurved_guide_36_0_G;
MCNUM aleft = mcccurved_guide_36_0_aleft;
MCNUM aright = mcccurved_guide_36_0_aright;
MCNUM atop = mcccurved_guide_36_0_atop;
MCNUM abottom = mcccurved_guide_36_0_abottom;
MCNUM wavy = mcccurved_guide_36_0_wavy;
MCNUM wavy_z = mcccurved_guide_36_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_36_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_36_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_36_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_36_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_36_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_36_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_36_0_nelements;
MCNUM nu = mcccurved_guide_36_0_nu;
MCNUM phase = mcccurved_guide_36_0_phase;
char* reflect = mcccurved_guide_36_0_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83842 "BIFROST.c"
}   /* End of curved_guide_36_0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_4'. */
  SIG_MESSAGE("EndOfelement_4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_4");
#define mccompcurname  EndOfelement_4
#define mccompcurtype  Arm
#define mccompcurindex 71
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 83864 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity3'. */
  SIG_MESSAGE("elliptical_guide_gravity3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity3");
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 72
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity3=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity3_l;
MCNUM xwidth = mccelliptical_guide_gravity3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity3_yheight;
MCNUM linxw = mccelliptical_guide_gravity3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity3_dimensionsAt;
char* option = mccelliptical_guide_gravity3_option;
MCNUM R0 = mccelliptical_guide_gravity3_R0;
MCNUM Qc = mccelliptical_guide_gravity3_Qc;
MCNUM alpha = mccelliptical_guide_gravity3_alpha;
MCNUM m = mccelliptical_guide_gravity3_m;
MCNUM W = mccelliptical_guide_gravity3_W;
MCNUM alpharight = mccelliptical_guide_gravity3_alpharight;
MCNUM mright = mccelliptical_guide_gravity3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity3_mbottom;
char* verbose = mccelliptical_guide_gravity3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity3_curvature;
#line 1496 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 84112 "BIFROST.c"
}   /* End of elliptical_guide_gravity3=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_3'. */
  SIG_MESSAGE("EndOfelement_3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_3");
#define mccompcurname  EndOfelement_3
#define mccompcurtype  Arm
#define mccompcurindex 73
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 84147 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'straight_guide_2_1'. */
  SIG_MESSAGE("straight_guide_2_1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "straight_guide_2_1");
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
{   /* Declarations of straight_guide_2_1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_1_w1;
MCNUM h1 = mccstraight_guide_2_1_h1;
MCNUM w2 = mccstraight_guide_2_1_w2;
MCNUM h2 = mccstraight_guide_2_1_h2;
MCNUM l = mccstraight_guide_2_1_l;
MCNUM R0 = mccstraight_guide_2_1_R0;
MCNUM Qc = mccstraight_guide_2_1_Qc;
MCNUM alpha = mccstraight_guide_2_1_alpha;
MCNUM m = mccstraight_guide_2_1_m;
MCNUM W = mccstraight_guide_2_1_W;
MCNUM nslit = mccstraight_guide_2_1_nslit;
MCNUM d = mccstraight_guide_2_1_d;
MCNUM mleft = mccstraight_guide_2_1_mleft;
MCNUM mright = mccstraight_guide_2_1_mright;
MCNUM mtop = mccstraight_guide_2_1_mtop;
MCNUM mbottom = mccstraight_guide_2_1_mbottom;
MCNUM nhslit = mccstraight_guide_2_1_nhslit;
MCNUM G = mccstraight_guide_2_1_G;
MCNUM aleft = mccstraight_guide_2_1_aleft;
MCNUM aright = mccstraight_guide_2_1_aright;
MCNUM atop = mccstraight_guide_2_1_atop;
MCNUM abottom = mccstraight_guide_2_1_abottom;
MCNUM wavy = mccstraight_guide_2_1_wavy;
MCNUM wavy_z = mccstraight_guide_2_1_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_1_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_1_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_1_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_1_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_1_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_1_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_1_nelements;
MCNUM nu = mccstraight_guide_2_1_nu;
MCNUM phase = mccstraight_guide_2_1_phase;
char* reflect = mccstraight_guide_2_1_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 84258 "BIFROST.c"
}   /* End of straight_guide_2_1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monBeforeBWC'. */
  SIG_MESSAGE("L_monBeforeBWC (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monBeforeBWC");
#define mccompcurname  L_monBeforeBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 75
#define nL mccL_monBeforeBWC_nL
#define L_N mccL_monBeforeBWC_L_N
#define L_p mccL_monBeforeBWC_L_p
#define L_p2 mccL_monBeforeBWC_L_p2
{   /* Declarations of L_monBeforeBWC=L_monitor() SETTING parameters. */
char* filename = mccL_monBeforeBWC_filename;
MCNUM xmin = mccL_monBeforeBWC_xmin;
MCNUM xmax = mccL_monBeforeBWC_xmax;
MCNUM ymin = mccL_monBeforeBWC_ymin;
MCNUM ymax = mccL_monBeforeBWC_ymax;
MCNUM xwidth = mccL_monBeforeBWC_xwidth;
MCNUM yheight = mccL_monBeforeBWC_yheight;
MCNUM Lmin = mccL_monBeforeBWC_Lmin;
MCNUM Lmax = mccL_monBeforeBWC_Lmax;
MCNUM restore_neutron = mccL_monBeforeBWC_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84296 "BIFROST.c"
}   /* End of L_monBeforeBWC=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFBeforeBWC'. */
  SIG_MESSAGE("ToFBeforeBWC (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFBeforeBWC");
#define mccompcurname  ToFBeforeBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 76
#define nt mccToFBeforeBWC_nt
#define TOF_N mccToFBeforeBWC_TOF_N
#define TOF_p mccToFBeforeBWC_TOF_p
#define TOF_p2 mccToFBeforeBWC_TOF_p2
#define t_min mccToFBeforeBWC_t_min
#define t_max mccToFBeforeBWC_t_max
#define delta_t mccToFBeforeBWC_delta_t
{   /* Declarations of ToFBeforeBWC=TOF_monitor() SETTING parameters. */
char* filename = mccToFBeforeBWC_filename;
MCNUM xmin = mccToFBeforeBWC_xmin;
MCNUM xmax = mccToFBeforeBWC_xmax;
MCNUM ymin = mccToFBeforeBWC_ymin;
MCNUM ymax = mccToFBeforeBWC_ymax;
MCNUM xwidth = mccToFBeforeBWC_xwidth;
MCNUM yheight = mccToFBeforeBWC_yheight;
MCNUM tmin = mccToFBeforeBWC_tmin;
MCNUM tmax = mccToFBeforeBWC_tmax;
MCNUM dt = mccToFBeforeBWC_dt;
MCNUM restore_neutron = mccToFBeforeBWC_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84340 "BIFROST.c"
}   /* End of ToFBeforeBWC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BWC1'. */
  SIG_MESSAGE("BWC1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BWC1");
#define mccompcurname  BWC1
#define mccompcurtype  DiskChopper
#define mccompcurindex 77
#define Tg mccBWC1_Tg
#define To mccBWC1_To
#define delta_y mccBWC1_delta_y
#define height mccBWC1_height
#define omega mccBWC1_omega
{   /* Declarations of BWC1=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccBWC1_theta_0;
MCNUM radius = mccBWC1_radius;
MCNUM yheight = mccBWC1_yheight;
MCNUM nu = mccBWC1_nu;
MCNUM nslit = mccBWC1_nslit;
MCNUM jitter = mccBWC1_jitter;
MCNUM delay = mccBWC1_delay;
MCNUM isfirst = mccBWC1_isfirst;
MCNUM n_pulse = mccBWC1_n_pulse;
MCNUM abs_out = mccBWC1_abs_out;
MCNUM phase = mccBWC1_phase;
MCNUM xwidth = mccBWC1_xwidth;
MCNUM verbose = mccBWC1_verbose;
#line 165 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  magnify("xy");
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 84405 "BIFROST.c"
}   /* End of BWC1=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'BWC2'. */
  SIG_MESSAGE("BWC2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "BWC2");
#define mccompcurname  BWC2
#define mccompcurtype  DiskChopper
#define mccompcurindex 78
#define Tg mccBWC2_Tg
#define To mccBWC2_To
#define delta_y mccBWC2_delta_y
#define height mccBWC2_height
#define omega mccBWC2_omega
{   /* Declarations of BWC2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccBWC2_theta_0;
MCNUM radius = mccBWC2_radius;
MCNUM yheight = mccBWC2_yheight;
MCNUM nu = mccBWC2_nu;
MCNUM nslit = mccBWC2_nslit;
MCNUM jitter = mccBWC2_jitter;
MCNUM delay = mccBWC2_delay;
MCNUM isfirst = mccBWC2_isfirst;
MCNUM n_pulse = mccBWC2_n_pulse;
MCNUM abs_out = mccBWC2_abs_out;
MCNUM phase = mccBWC2_phase;
MCNUM xwidth = mccBWC2_xwidth;
MCNUM verbose = mccBWC2_verbose;
#line 165 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  magnify("xy");
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 84468 "BIFROST.c"
}   /* End of BWC2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ToFAfterBWC'. */
  SIG_MESSAGE("ToFAfterBWC (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ToFAfterBWC");
#define mccompcurname  ToFAfterBWC
#define mccompcurtype  TOF_monitor
#define mccompcurindex 79
#define nt mccToFAfterBWC_nt
#define TOF_N mccToFAfterBWC_TOF_N
#define TOF_p mccToFAfterBWC_TOF_p
#define TOF_p2 mccToFAfterBWC_TOF_p2
#define t_min mccToFAfterBWC_t_min
#define t_max mccToFAfterBWC_t_max
#define delta_t mccToFAfterBWC_delta_t
{   /* Declarations of ToFAfterBWC=TOF_monitor() SETTING parameters. */
char* filename = mccToFAfterBWC_filename;
MCNUM xmin = mccToFAfterBWC_xmin;
MCNUM xmax = mccToFAfterBWC_xmax;
MCNUM ymin = mccToFAfterBWC_ymin;
MCNUM ymax = mccToFAfterBWC_ymax;
MCNUM xwidth = mccToFAfterBWC_xwidth;
MCNUM yheight = mccToFAfterBWC_yheight;
MCNUM tmin = mccToFAfterBWC_tmin;
MCNUM tmax = mccToFAfterBWC_tmax;
MCNUM dt = mccToFAfterBWC_dt;
MCNUM restore_neutron = mccToFAfterBWC_restore_neutron;
#line 125 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\TOF_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84513 "BIFROST.c"
}   /* End of ToFAfterBWC=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'L_monAfterBWC'. */
  SIG_MESSAGE("L_monAfterBWC (McDisplay)");
  printf("MCDISPLAY: component %s\n", "L_monAfterBWC");
#define mccompcurname  L_monAfterBWC
#define mccompcurtype  L_monitor
#define mccompcurindex 80
#define nL mccL_monAfterBWC_nL
#define L_N mccL_monAfterBWC_L_N
#define L_p mccL_monAfterBWC_L_p
#define L_p2 mccL_monAfterBWC_L_p2
{   /* Declarations of L_monAfterBWC=L_monitor() SETTING parameters. */
char* filename = mccL_monAfterBWC_filename;
MCNUM xmin = mccL_monAfterBWC_xmin;
MCNUM xmax = mccL_monAfterBWC_xmax;
MCNUM ymin = mccL_monAfterBWC_ymin;
MCNUM ymax = mccL_monAfterBWC_ymax;
MCNUM xwidth = mccL_monAfterBWC_xwidth;
MCNUM yheight = mccL_monAfterBWC_yheight;
MCNUM Lmin = mccL_monAfterBWC_Lmin;
MCNUM Lmax = mccL_monAfterBWC_Lmax;
MCNUM restore_neutron = mccL_monAfterBWC_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84556 "BIFROST.c"
}   /* End of L_monAfterBWC=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'straight_guide_2_2'. */
  SIG_MESSAGE("straight_guide_2_2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "straight_guide_2_2");
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 81
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
{   /* Declarations of straight_guide_2_2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_2_w1;
MCNUM h1 = mccstraight_guide_2_2_h1;
MCNUM w2 = mccstraight_guide_2_2_w2;
MCNUM h2 = mccstraight_guide_2_2_h2;
MCNUM l = mccstraight_guide_2_2_l;
MCNUM R0 = mccstraight_guide_2_2_R0;
MCNUM Qc = mccstraight_guide_2_2_Qc;
MCNUM alpha = mccstraight_guide_2_2_alpha;
MCNUM m = mccstraight_guide_2_2_m;
MCNUM W = mccstraight_guide_2_2_W;
MCNUM nslit = mccstraight_guide_2_2_nslit;
MCNUM d = mccstraight_guide_2_2_d;
MCNUM mleft = mccstraight_guide_2_2_mleft;
MCNUM mright = mccstraight_guide_2_2_mright;
MCNUM mtop = mccstraight_guide_2_2_mtop;
MCNUM mbottom = mccstraight_guide_2_2_mbottom;
MCNUM nhslit = mccstraight_guide_2_2_nhslit;
MCNUM G = mccstraight_guide_2_2_G;
MCNUM aleft = mccstraight_guide_2_2_aleft;
MCNUM aright = mccstraight_guide_2_2_aright;
MCNUM atop = mccstraight_guide_2_2_atop;
MCNUM abottom = mccstraight_guide_2_2_abottom;
MCNUM wavy = mccstraight_guide_2_2_wavy;
MCNUM wavy_z = mccstraight_guide_2_2_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_2_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_2_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_2_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_2_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_2_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_2_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_2_nelements;
MCNUM nu = mccstraight_guide_2_2_nu;
MCNUM phase = mccstraight_guide_2_2_phase;
char* reflect = mccstraight_guide_2_2_reflect;
#line 572 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 84672 "BIFROST.c"
}   /* End of straight_guide_2_2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_2'. */
  SIG_MESSAGE("EndOfelement_2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_2");
#define mccompcurname  EndOfelement_2
#define mccompcurtype  Arm
#define mccompcurindex 82
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 84694 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_1'. */
  SIG_MESSAGE("elliptical_guide_gravity1_1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_1");
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 83
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_1=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_1_l;
MCNUM xwidth = mccelliptical_guide_gravity1_1_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_1_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_1_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_1_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_1_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_1_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_1_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_1_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_1_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_1_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_1_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_1_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_1_dimensionsAt;
char* option = mccelliptical_guide_gravity1_1_option;
MCNUM R0 = mccelliptical_guide_gravity1_1_R0;
MCNUM Qc = mccelliptical_guide_gravity1_1_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_1_alpha;
MCNUM m = mccelliptical_guide_gravity1_1_m;
MCNUM W = mccelliptical_guide_gravity1_1_W;
MCNUM alpharight = mccelliptical_guide_gravity1_1_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_1_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_1_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_1_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_1_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_1_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_1_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_1_mbottom;
char* verbose = mccelliptical_guide_gravity1_1_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_1_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_1_curvature;
#line 1496 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 84942 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_1=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw3'. */
  SIG_MESSAGE("DiwJaw3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw3");
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 84
{   /* Declarations of DiwJaw3=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw3_xmin;
MCNUM xmax = mccDiwJaw3_xmax;
MCNUM ymin = mccDiwJaw3_ymin;
MCNUM ymax = mccDiwJaw3_ymax;
MCNUM radius = mccDiwJaw3_radius;
MCNUM xwidth = mccDiwJaw3_xwidth;
MCNUM yheight = mccDiwJaw3_yheight;
#line 66 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
  magnify("xy");
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 85000 "BIFROST.c"
}   /* End of DiwJaw3=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_2'. */
  SIG_MESSAGE("elliptical_guide_gravity1_2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_2");
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 85
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_2=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_2_l;
MCNUM xwidth = mccelliptical_guide_gravity1_2_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_2_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_2_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_2_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_2_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_2_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_2_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_2_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_2_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_2_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_2_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_2_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_2_dimensionsAt;
char* option = mccelliptical_guide_gravity1_2_option;
MCNUM R0 = mccelliptical_guide_gravity1_2_R0;
MCNUM Qc = mccelliptical_guide_gravity1_2_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_2_alpha;
MCNUM m = mccelliptical_guide_gravity1_2_m;
MCNUM W = mccelliptical_guide_gravity1_2_W;
MCNUM alpharight = mccelliptical_guide_gravity1_2_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_2_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_2_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_2_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_2_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_2_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_2_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_2_mbottom;
char* verbose = mccelliptical_guide_gravity1_2_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_2_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_2_curvature;
#line 1496 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 85249 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_2=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw2'. */
  SIG_MESSAGE("DiwJaw2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw2");
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 86
{   /* Declarations of DiwJaw2=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw2_xmin;
MCNUM xmax = mccDiwJaw2_xmax;
MCNUM ymin = mccDiwJaw2_ymin;
MCNUM ymax = mccDiwJaw2_ymax;
MCNUM radius = mccDiwJaw2_radius;
MCNUM xwidth = mccDiwJaw2_xwidth;
MCNUM yheight = mccDiwJaw2_yheight;
#line 66 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
  magnify("xy");
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 85307 "BIFROST.c"
}   /* End of DiwJaw2=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_3'. */
  SIG_MESSAGE("elliptical_guide_gravity1_3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_3");
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 87
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_3=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_3_l;
MCNUM xwidth = mccelliptical_guide_gravity1_3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_3_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_3_dimensionsAt;
char* option = mccelliptical_guide_gravity1_3_option;
MCNUM R0 = mccelliptical_guide_gravity1_3_R0;
MCNUM Qc = mccelliptical_guide_gravity1_3_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_3_alpha;
MCNUM m = mccelliptical_guide_gravity1_3_m;
MCNUM W = mccelliptical_guide_gravity1_3_W;
MCNUM alpharight = mccelliptical_guide_gravity1_3_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_3_mbottom;
char* verbose = mccelliptical_guide_gravity1_3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_3_curvature;
#line 1496 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 85556 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_3=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw1'. */
  SIG_MESSAGE("DiwJaw1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw1");
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 88
{   /* Declarations of DiwJaw1=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw1_xmin;
MCNUM xmax = mccDiwJaw1_xmax;
MCNUM ymin = mccDiwJaw1_ymin;
MCNUM ymax = mccDiwJaw1_ymax;
MCNUM radius = mccDiwJaw1_radius;
MCNUM xwidth = mccDiwJaw1_xwidth;
MCNUM yheight = mccDiwJaw1_yheight;
#line 66 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
  magnify("xy");
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 85614 "BIFROST.c"
}   /* End of DiwJaw1=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_4'. */
  SIG_MESSAGE("elliptical_guide_gravity1_4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_4");
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity
#define mccompcurindex 89
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_4=Elliptic_guide_gravity() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_4_l;
MCNUM xwidth = mccelliptical_guide_gravity1_4_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_4_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_4_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_4_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_4_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_4_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_4_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_4_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_4_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_4_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_4_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_4_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_4_dimensionsAt;
char* option = mccelliptical_guide_gravity1_4_option;
MCNUM R0 = mccelliptical_guide_gravity1_4_R0;
MCNUM Qc = mccelliptical_guide_gravity1_4_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_4_alpha;
MCNUM m = mccelliptical_guide_gravity1_4_m;
MCNUM W = mccelliptical_guide_gravity1_4_W;
MCNUM alpharight = mccelliptical_guide_gravity1_4_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_4_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_4_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_4_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_4_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_4_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_4_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_4_mbottom;
char* verbose = mccelliptical_guide_gravity1_4_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_4_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_4_curvature;
#line 1496 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\contrib\\Elliptic_guide_gravity.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 85863 "BIFROST.c"
}   /* End of elliptical_guide_gravity1_4=Elliptic_guide_gravity() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_1'. */
  SIG_MESSAGE("EndOfelement_1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_1");
#define mccompcurname  EndOfelement_1
#define mccompcurtype  Arm
#define mccompcurindex 90
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 85898 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'VirtualOutput'. */
  SIG_MESSAGE("VirtualOutput (McDisplay)");
  printf("MCDISPLAY: component %s\n", "VirtualOutput");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 91
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
#line 159 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\sources\\Virtual_output.comp"
{
  Monitor_nD_McDisplay(&DEFS, &Vars);
}
#line 85918 "BIFROST.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw0'. */
  SIG_MESSAGE("DiwJaw0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw0");
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 92
{   /* Declarations of DiwJaw0=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw0_xmin;
MCNUM xmax = mccDiwJaw0_xmax;
MCNUM ymin = mccDiwJaw0_ymin;
MCNUM ymax = mccDiwJaw0_ymax;
MCNUM radius = mccDiwJaw0_radius;
MCNUM xwidth = mccDiwJaw0_xwidth;
MCNUM yheight = mccDiwJaw0_yheight;
#line 66 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Slit.comp"
{
  magnify("xy");
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 85963 "BIFROST.c"
}   /* End of DiwJaw0=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Lmon_guide_end'. */
  SIG_MESSAGE("Lmon_guide_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Lmon_guide_end");
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
{   /* Declarations of Lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mccLmon_guide_end_filename;
MCNUM xmin = mccLmon_guide_end_xmin;
MCNUM xmax = mccLmon_guide_end_xmax;
MCNUM ymin = mccLmon_guide_end_ymin;
MCNUM ymax = mccLmon_guide_end_ymax;
MCNUM xwidth = mccLmon_guide_end_xwidth;
MCNUM yheight = mccLmon_guide_end_yheight;
MCNUM Lmin = mccLmon_guide_end_Lmin;
MCNUM Lmax = mccLmon_guide_end_Lmax;
MCNUM restore_neutron = mccLmon_guide_end_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 85999 "BIFROST.c"
}   /* End of Lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Div2d_sample_B'. */
  SIG_MESSAGE("Div2d_sample_B (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Div2d_sample_B");
#define mccompcurname  Div2d_sample_B
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 94
#define nh mccDiv2d_sample_B_nh
#define nv mccDiv2d_sample_B_nv
#define Div_N mccDiv2d_sample_B_Div_N
#define Div_p mccDiv2d_sample_B_Div_p
#define Div_p2 mccDiv2d_sample_B_Div_p2
{   /* Declarations of Div2d_sample_B=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_B_filename;
MCNUM xmin = mccDiv2d_sample_B_xmin;
MCNUM xmax = mccDiv2d_sample_B_xmax;
MCNUM ymin = mccDiv2d_sample_B_ymin;
MCNUM ymax = mccDiv2d_sample_B_ymax;
MCNUM xwidth = mccDiv2d_sample_B_xwidth;
MCNUM yheight = mccDiv2d_sample_B_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_B_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_B_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_B_restore_neutron;
MCNUM nx = mccDiv2d_sample_B_nx;
MCNUM ny = mccDiv2d_sample_B_ny;
MCNUM nz = mccDiv2d_sample_B_nz;
#line 128 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86043 "BIFROST.c"
}   /* End of Div2d_sample_B=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Div2d_sample'. */
  SIG_MESSAGE("Div2d_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Div2d_sample");
#define mccompcurname  Div2d_sample
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 95
#define nh mccDiv2d_sample_nh
#define nv mccDiv2d_sample_nv
#define Div_N mccDiv2d_sample_Div_N
#define Div_p mccDiv2d_sample_Div_p
#define Div_p2 mccDiv2d_sample_Div_p2
{   /* Declarations of Div2d_sample=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_filename;
MCNUM xmin = mccDiv2d_sample_xmin;
MCNUM xmax = mccDiv2d_sample_xmax;
MCNUM ymin = mccDiv2d_sample_ymin;
MCNUM ymax = mccDiv2d_sample_ymax;
MCNUM xwidth = mccDiv2d_sample_xwidth;
MCNUM yheight = mccDiv2d_sample_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_restore_neutron;
MCNUM nx = mccDiv2d_sample_nx;
MCNUM ny = mccDiv2d_sample_ny;
MCNUM nz = mccDiv2d_sample_nz;
#line 128 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86088 "BIFROST.c"
}   /* End of Div2d_sample=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_sample'. */
  SIG_MESSAGE("PSD_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_sample");
#define mccompcurname  PSD_sample
#define mccompcurtype  PSD_monitor
#define mccompcurindex 96
#define nx mccPSD_sample_nx
#define ny mccPSD_sample_ny
#define PSD_N mccPSD_sample_PSD_N
#define PSD_p mccPSD_sample_PSD_p
#define PSD_p2 mccPSD_sample_PSD_p2
{   /* Declarations of PSD_sample=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_sample_filename;
MCNUM xmin = mccPSD_sample_xmin;
MCNUM xmax = mccPSD_sample_xmax;
MCNUM ymin = mccPSD_sample_ymin;
MCNUM ymax = mccPSD_sample_ymax;
MCNUM xwidth = mccPSD_sample_xwidth;
MCNUM yheight = mccPSD_sample_yheight;
MCNUM restore_neutron = mccPSD_sample_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86128 "BIFROST.c"
}   /* End of PSD_sample=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'HPSD_sample'. */
  SIG_MESSAGE("HPSD_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "HPSD_sample");
#define mccompcurname  HPSD_sample
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 97
#define nx mccHPSD_sample_nx
#define PSDlin_N mccHPSD_sample_PSDlin_N
#define PSDlin_p mccHPSD_sample_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_PSDlin_p2
{   /* Declarations of HPSD_sample=PSDlin_monitor() SETTING parameters. */
char* filename = mccHPSD_sample_filename;
MCNUM xmin = mccHPSD_sample_xmin;
MCNUM xmax = mccHPSD_sample_xmax;
MCNUM ymin = mccHPSD_sample_ymin;
MCNUM ymax = mccHPSD_sample_ymax;
MCNUM xwidth = mccHPSD_sample_xwidth;
MCNUM yheight = mccHPSD_sample_yheight;
MCNUM restore_neutron = mccHPSD_sample_restore_neutron;
#line 113 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86167 "BIFROST.c"
}   /* End of HPSD_sample=PSDlin_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'VPSD_sample'. */
  SIG_MESSAGE("VPSD_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "VPSD_sample");
#define mccompcurname  VPSD_sample
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 98
#define ny mccVPSD_sample_ny
#define filename mccVPSD_sample_filename
#define PSDlin_N mccVPSD_sample_PSDlin_N
#define PSDlin_p mccVPSD_sample_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_PSDlin_p2
{   /* Declarations of VPSD_sample=PSDlin_y_monitor() SETTING parameters. */
MCNUM xmin = mccVPSD_sample_xmin;
MCNUM xmax = mccVPSD_sample_xmax;
MCNUM ymin = mccVPSD_sample_ymin;
MCNUM ymax = mccVPSD_sample_ymax;
MCNUM xwidth = mccVPSD_sample_xwidth;
MCNUM yheight = mccVPSD_sample_yheight;
MCNUM restore_neutron = mccVPSD_sample_restore_neutron;
#line 109 "PSDlin_y_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86205 "BIFROST.c"
}   /* End of VPSD_sample=PSDlin_y_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Hdiv_sample'. */
  SIG_MESSAGE("Hdiv_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Hdiv_sample");
#define mccompcurname  Hdiv_sample
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 99
#define nh mccHdiv_sample_nh
#define Div_N mccHdiv_sample_Div_N
#define Div_p mccHdiv_sample_Div_p
#define Div_p2 mccHdiv_sample_Div_p2
{   /* Declarations of Hdiv_sample=Hdiv_monitor() SETTING parameters. */
char* filename = mccHdiv_sample_filename;
MCNUM xmin = mccHdiv_sample_xmin;
MCNUM xmax = mccHdiv_sample_xmax;
MCNUM ymin = mccHdiv_sample_ymin;
MCNUM ymax = mccHdiv_sample_ymax;
MCNUM xwidth = mccHdiv_sample_xwidth;
MCNUM yheight = mccHdiv_sample_yheight;
MCNUM h_maxdiv = mccHdiv_sample_h_maxdiv;
MCNUM restore_neutron = mccHdiv_sample_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86245 "BIFROST.c"
}   /* End of Hdiv_sample=Hdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Vdiv_sample'. */
  SIG_MESSAGE("Vdiv_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Vdiv_sample");
#define mccompcurname  Vdiv_sample
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 100
#define nv mccVdiv_sample_nv
#define filename mccVdiv_sample_filename
#define restore_neutron mccVdiv_sample_restore_neutron
#define Div_N mccVdiv_sample_Div_N
#define Div_p mccVdiv_sample_Div_p
#define Div_p2 mccVdiv_sample_Div_p2
{   /* Declarations of Vdiv_sample=Vdiv_monitor() SETTING parameters. */
MCNUM xmin = mccVdiv_sample_xmin;
MCNUM xmax = mccVdiv_sample_xmax;
MCNUM ymin = mccVdiv_sample_ymin;
MCNUM ymax = mccVdiv_sample_ymax;
MCNUM xwidth = mccVdiv_sample_xwidth;
MCNUM yheight = mccVdiv_sample_yheight;
MCNUM v_maxdiv = mccVdiv_sample_v_maxdiv;
#line 120 "Vdiv_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86284 "BIFROST.c"
}   /* End of Vdiv_sample=Vdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'acceptance_x_divx'. */
  SIG_MESSAGE("acceptance_x_divx (McDisplay)");
  printf("MCDISPLAY: component %s\n", "acceptance_x_divx");
#define mccompcurname  acceptance_x_divx
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 101
#define nh mccacceptance_x_divx_nh
#define ndiv mccacceptance_x_divx_ndiv
#define Div_N mccacceptance_x_divx_Div_N
#define Div_p mccacceptance_x_divx_Div_p
#define Div_p2 mccacceptance_x_divx_Div_p2
{   /* Declarations of acceptance_x_divx=DivPos_monitor() SETTING parameters. */
char* filename = mccacceptance_x_divx_filename;
MCNUM xmin = mccacceptance_x_divx_xmin;
MCNUM xmax = mccacceptance_x_divx_xmax;
MCNUM ymin = mccacceptance_x_divx_ymin;
MCNUM ymax = mccacceptance_x_divx_ymax;
MCNUM xwidth = mccacceptance_x_divx_xwidth;
MCNUM yheight = mccacceptance_x_divx_yheight;
MCNUM maxdiv_h = mccacceptance_x_divx_maxdiv_h;
MCNUM restore_neutron = mccacceptance_x_divx_restore_neutron;
MCNUM nx = mccacceptance_x_divx_nx;
MCNUM ny = mccacceptance_x_divx_ny;
MCNUM nz = mccacceptance_x_divx_nz;
#line 131 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86329 "BIFROST.c"
}   /* End of acceptance_x_divx=DivPos_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'acceptance_y_divy'. */
  SIG_MESSAGE("acceptance_y_divy (McDisplay)");
  printf("MCDISPLAY: component %s\n", "acceptance_y_divy");
#define mccompcurname  acceptance_y_divy
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 102
#define npos mccacceptance_y_divy_npos
#define ndiv mccacceptance_y_divy_ndiv
#define filename mccacceptance_y_divy_filename
#define restore_neutron mccacceptance_y_divy_restore_neutron
#define Div_N mccacceptance_y_divy_Div_N
#define Div_p mccacceptance_y_divy_Div_p
#define Div_p2 mccacceptance_y_divy_Div_p2
{   /* Declarations of acceptance_y_divy=DivPos_y_monitor() SETTING parameters. */
MCNUM xmin = mccacceptance_y_divy_xmin;
MCNUM xmax = mccacceptance_y_divy_xmax;
MCNUM ymin = mccacceptance_y_divy_ymin;
MCNUM ymax = mccacceptance_y_divy_ymax;
MCNUM xwidth = mccacceptance_y_divy_xwidth;
MCNUM yheight = mccacceptance_y_divy_yheight;
MCNUM maxdiv = mccacceptance_y_divy_maxdiv;
#line 120 "DivPos_y_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86370 "BIFROST.c"
}   /* End of acceptance_y_divy=DivPos_y_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Lmon_sample_B'. */
  SIG_MESSAGE("Lmon_sample_B (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Lmon_sample_B");
#define mccompcurname  Lmon_sample_B
#define mccompcurtype  L_monitor
#define mccompcurindex 103
#define nL mccLmon_sample_B_nL
#define L_N mccLmon_sample_B_L_N
#define L_p mccLmon_sample_B_L_p
#define L_p2 mccLmon_sample_B_L_p2
{   /* Declarations of Lmon_sample_B=L_monitor() SETTING parameters. */
char* filename = mccLmon_sample_B_filename;
MCNUM xmin = mccLmon_sample_B_xmin;
MCNUM xmax = mccLmon_sample_B_xmax;
MCNUM ymin = mccLmon_sample_B_ymin;
MCNUM ymax = mccLmon_sample_B_ymax;
MCNUM xwidth = mccLmon_sample_B_xwidth;
MCNUM yheight = mccLmon_sample_B_yheight;
MCNUM Lmin = mccLmon_sample_B_Lmin;
MCNUM Lmax = mccLmon_sample_B_Lmax;
MCNUM restore_neutron = mccLmon_sample_B_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86413 "BIFROST.c"
}   /* End of Lmon_sample_B=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Div2d_sample_maxdiv'. */
  SIG_MESSAGE("Div2d_sample_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Div2d_sample_maxdiv");
#define mccompcurname  Div2d_sample_maxdiv
#define mccompcurtype  Divergence_monitor
#define mccompcurindex 104
#define nh mccDiv2d_sample_maxdiv_nh
#define nv mccDiv2d_sample_maxdiv_nv
#define Div_N mccDiv2d_sample_maxdiv_Div_N
#define Div_p mccDiv2d_sample_maxdiv_Div_p
#define Div_p2 mccDiv2d_sample_maxdiv_Div_p2
{   /* Declarations of Div2d_sample_maxdiv=Divergence_monitor() SETTING parameters. */
char* filename = mccDiv2d_sample_maxdiv_filename;
MCNUM xmin = mccDiv2d_sample_maxdiv_xmin;
MCNUM xmax = mccDiv2d_sample_maxdiv_xmax;
MCNUM ymin = mccDiv2d_sample_maxdiv_ymin;
MCNUM ymax = mccDiv2d_sample_maxdiv_ymax;
MCNUM xwidth = mccDiv2d_sample_maxdiv_xwidth;
MCNUM yheight = mccDiv2d_sample_maxdiv_yheight;
MCNUM maxdiv_h = mccDiv2d_sample_maxdiv_maxdiv_h;
MCNUM maxdiv_v = mccDiv2d_sample_maxdiv_maxdiv_v;
MCNUM restore_neutron = mccDiv2d_sample_maxdiv_restore_neutron;
MCNUM nx = mccDiv2d_sample_maxdiv_nx;
MCNUM ny = mccDiv2d_sample_maxdiv_ny;
MCNUM nz = mccDiv2d_sample_maxdiv_nz;
#line 128 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Divergence_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86457 "BIFROST.c"
}   /* End of Div2d_sample_maxdiv=Divergence_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_sample_maxdiv'. */
  SIG_MESSAGE("PSD_sample_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_sample_maxdiv");
#define mccompcurname  PSD_sample_maxdiv
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define nx mccPSD_sample_maxdiv_nx
#define ny mccPSD_sample_maxdiv_ny
#define PSD_N mccPSD_sample_maxdiv_PSD_N
#define PSD_p mccPSD_sample_maxdiv_PSD_p
#define PSD_p2 mccPSD_sample_maxdiv_PSD_p2
{   /* Declarations of PSD_sample_maxdiv=PSD_monitor() SETTING parameters. */
char* filename = mccPSD_sample_maxdiv_filename;
MCNUM xmin = mccPSD_sample_maxdiv_xmin;
MCNUM xmax = mccPSD_sample_maxdiv_xmax;
MCNUM ymin = mccPSD_sample_maxdiv_ymin;
MCNUM ymax = mccPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccPSD_sample_maxdiv_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86497 "BIFROST.c"
}   /* End of PSD_sample_maxdiv=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'HPSD_sample_maxdiv'. */
  SIG_MESSAGE("HPSD_sample_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "HPSD_sample_maxdiv");
#define mccompcurname  HPSD_sample_maxdiv
#define mccompcurtype  PSDlin_monitor
#define mccompcurindex 106
#define nx mccHPSD_sample_maxdiv_nx
#define PSDlin_N mccHPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccHPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccHPSD_sample_maxdiv_PSDlin_p2
{   /* Declarations of HPSD_sample_maxdiv=PSDlin_monitor() SETTING parameters. */
char* filename = mccHPSD_sample_maxdiv_filename;
MCNUM xmin = mccHPSD_sample_maxdiv_xmin;
MCNUM xmax = mccHPSD_sample_maxdiv_xmax;
MCNUM ymin = mccHPSD_sample_maxdiv_ymin;
MCNUM ymax = mccHPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccHPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccHPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccHPSD_sample_maxdiv_restore_neutron;
#line 113 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSDlin_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86536 "BIFROST.c"
}   /* End of HPSD_sample_maxdiv=PSDlin_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'VPSD_sample_maxdiv'. */
  SIG_MESSAGE("VPSD_sample_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "VPSD_sample_maxdiv");
#define mccompcurname  VPSD_sample_maxdiv
#define mccompcurtype  PSDlin_y_monitor
#define mccompcurindex 107
#define ny mccVPSD_sample_maxdiv_ny
#define filename mccVPSD_sample_maxdiv_filename
#define PSDlin_N mccVPSD_sample_maxdiv_PSDlin_N
#define PSDlin_p mccVPSD_sample_maxdiv_PSDlin_p
#define PSDlin_p2 mccVPSD_sample_maxdiv_PSDlin_p2
{   /* Declarations of VPSD_sample_maxdiv=PSDlin_y_monitor() SETTING parameters. */
MCNUM xmin = mccVPSD_sample_maxdiv_xmin;
MCNUM xmax = mccVPSD_sample_maxdiv_xmax;
MCNUM ymin = mccVPSD_sample_maxdiv_ymin;
MCNUM ymax = mccVPSD_sample_maxdiv_ymax;
MCNUM xwidth = mccVPSD_sample_maxdiv_xwidth;
MCNUM yheight = mccVPSD_sample_maxdiv_yheight;
MCNUM restore_neutron = mccVPSD_sample_maxdiv_restore_neutron;
#line 109 "PSDlin_y_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86574 "BIFROST.c"
}   /* End of VPSD_sample_maxdiv=PSDlin_y_monitor() SETTING parameter declarations. */
#undef PSDlin_p2
#undef PSDlin_p
#undef PSDlin_N
#undef filename
#undef ny
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Hdiv_sample_maxdiv'. */
  SIG_MESSAGE("Hdiv_sample_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Hdiv_sample_maxdiv");
#define mccompcurname  Hdiv_sample_maxdiv
#define mccompcurtype  Hdiv_monitor
#define mccompcurindex 108
#define nh mccHdiv_sample_maxdiv_nh
#define Div_N mccHdiv_sample_maxdiv_Div_N
#define Div_p mccHdiv_sample_maxdiv_Div_p
#define Div_p2 mccHdiv_sample_maxdiv_Div_p2
{   /* Declarations of Hdiv_sample_maxdiv=Hdiv_monitor() SETTING parameters. */
char* filename = mccHdiv_sample_maxdiv_filename;
MCNUM xmin = mccHdiv_sample_maxdiv_xmin;
MCNUM xmax = mccHdiv_sample_maxdiv_xmax;
MCNUM ymin = mccHdiv_sample_maxdiv_ymin;
MCNUM ymax = mccHdiv_sample_maxdiv_ymax;
MCNUM xwidth = mccHdiv_sample_maxdiv_xwidth;
MCNUM yheight = mccHdiv_sample_maxdiv_yheight;
MCNUM h_maxdiv = mccHdiv_sample_maxdiv_h_maxdiv;
MCNUM restore_neutron = mccHdiv_sample_maxdiv_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\Hdiv_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86614 "BIFROST.c"
}   /* End of Hdiv_sample_maxdiv=Hdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Vdiv_sample_maxdiv'. */
  SIG_MESSAGE("Vdiv_sample_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Vdiv_sample_maxdiv");
#define mccompcurname  Vdiv_sample_maxdiv
#define mccompcurtype  Vdiv_monitor
#define mccompcurindex 109
#define nv mccVdiv_sample_maxdiv_nv
#define filename mccVdiv_sample_maxdiv_filename
#define restore_neutron mccVdiv_sample_maxdiv_restore_neutron
#define Div_N mccVdiv_sample_maxdiv_Div_N
#define Div_p mccVdiv_sample_maxdiv_Div_p
#define Div_p2 mccVdiv_sample_maxdiv_Div_p2
{   /* Declarations of Vdiv_sample_maxdiv=Vdiv_monitor() SETTING parameters. */
MCNUM xmin = mccVdiv_sample_maxdiv_xmin;
MCNUM xmax = mccVdiv_sample_maxdiv_xmax;
MCNUM ymin = mccVdiv_sample_maxdiv_ymin;
MCNUM ymax = mccVdiv_sample_maxdiv_ymax;
MCNUM xwidth = mccVdiv_sample_maxdiv_xwidth;
MCNUM yheight = mccVdiv_sample_maxdiv_yheight;
MCNUM v_maxdiv = mccVdiv_sample_maxdiv_v_maxdiv;
#line 120 "Vdiv_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86653 "BIFROST.c"
}   /* End of Vdiv_sample_maxdiv=Vdiv_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef nv
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'acceptance_x_divx_maxdiv'. */
  SIG_MESSAGE("acceptance_x_divx_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "acceptance_x_divx_maxdiv");
#define mccompcurname  acceptance_x_divx_maxdiv
#define mccompcurtype  DivPos_monitor
#define mccompcurindex 110
#define nh mccacceptance_x_divx_maxdiv_nh
#define ndiv mccacceptance_x_divx_maxdiv_ndiv
#define Div_N mccacceptance_x_divx_maxdiv_Div_N
#define Div_p mccacceptance_x_divx_maxdiv_Div_p
#define Div_p2 mccacceptance_x_divx_maxdiv_Div_p2
{   /* Declarations of acceptance_x_divx_maxdiv=DivPos_monitor() SETTING parameters. */
char* filename = mccacceptance_x_divx_maxdiv_filename;
MCNUM xmin = mccacceptance_x_divx_maxdiv_xmin;
MCNUM xmax = mccacceptance_x_divx_maxdiv_xmax;
MCNUM ymin = mccacceptance_x_divx_maxdiv_ymin;
MCNUM ymax = mccacceptance_x_divx_maxdiv_ymax;
MCNUM xwidth = mccacceptance_x_divx_maxdiv_xwidth;
MCNUM yheight = mccacceptance_x_divx_maxdiv_yheight;
MCNUM maxdiv_h = mccacceptance_x_divx_maxdiv_maxdiv_h;
MCNUM restore_neutron = mccacceptance_x_divx_maxdiv_restore_neutron;
MCNUM nx = mccacceptance_x_divx_maxdiv_nx;
MCNUM ny = mccacceptance_x_divx_maxdiv_ny;
MCNUM nz = mccacceptance_x_divx_maxdiv_nz;
#line 131 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\DivPos_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86698 "BIFROST.c"
}   /* End of acceptance_x_divx_maxdiv=DivPos_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef ndiv
#undef nh
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'acceptance_y_divy_maxdiv'. */
  SIG_MESSAGE("acceptance_y_divy_maxdiv (McDisplay)");
  printf("MCDISPLAY: component %s\n", "acceptance_y_divy_maxdiv");
#define mccompcurname  acceptance_y_divy_maxdiv
#define mccompcurtype  DivPos_y_monitor
#define mccompcurindex 111
#define npos mccacceptance_y_divy_maxdiv_npos
#define ndiv mccacceptance_y_divy_maxdiv_ndiv
#define filename mccacceptance_y_divy_maxdiv_filename
#define restore_neutron mccacceptance_y_divy_maxdiv_restore_neutron
#define Div_N mccacceptance_y_divy_maxdiv_Div_N
#define Div_p mccacceptance_y_divy_maxdiv_Div_p
#define Div_p2 mccacceptance_y_divy_maxdiv_Div_p2
{   /* Declarations of acceptance_y_divy_maxdiv=DivPos_y_monitor() SETTING parameters. */
MCNUM xmin = mccacceptance_y_divy_maxdiv_xmin;
MCNUM xmax = mccacceptance_y_divy_maxdiv_xmax;
MCNUM ymin = mccacceptance_y_divy_maxdiv_ymin;
MCNUM ymax = mccacceptance_y_divy_maxdiv_ymax;
MCNUM xwidth = mccacceptance_y_divy_maxdiv_xwidth;
MCNUM yheight = mccacceptance_y_divy_maxdiv_yheight;
MCNUM maxdiv = mccacceptance_y_divy_maxdiv_maxdiv;
#line 120 "DivPos_y_monitor.comp"
{
    magnify("xy");
    multiline(5, (double)xmin, (double)ymin, 0.0,
                 (double)xmax, (double)ymin, 0.0,
                 (double)xmax, (double)ymax, 0.0,
                 (double)xmin, (double)ymax, 0.0,
                 (double)xmin, (double)ymin, 0.0);
}
#line 86739 "BIFROST.c"
}   /* End of acceptance_y_divy_maxdiv=DivPos_y_monitor() SETTING parameter declarations. */
#undef Div_p2
#undef Div_p
#undef Div_N
#undef restore_neutron
#undef filename
#undef ndiv
#undef npos
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Lmon_sample'. */
  SIG_MESSAGE("Lmon_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Lmon_sample");
#define mccompcurname  Lmon_sample
#define mccompcurtype  L_monitor
#define mccompcurindex 112
#define nL mccLmon_sample_nL
#define L_N mccLmon_sample_L_N
#define L_p mccLmon_sample_L_p
#define L_p2 mccLmon_sample_L_p2
{   /* Declarations of Lmon_sample=L_monitor() SETTING parameters. */
char* filename = mccLmon_sample_filename;
MCNUM xmin = mccLmon_sample_xmin;
MCNUM xmax = mccLmon_sample_xmax;
MCNUM ymin = mccLmon_sample_ymin;
MCNUM ymax = mccLmon_sample_ymax;
MCNUM xwidth = mccLmon_sample_xwidth;
MCNUM yheight = mccLmon_sample_yheight;
MCNUM Lmin = mccLmon_sample_Lmin;
MCNUM Lmax = mccLmon_sample_Lmax;
MCNUM restore_neutron = mccLmon_sample_restore_neutron;
#line 117 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\L_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 86782 "BIFROST.c"
}   /* End of Lmon_sample=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'v_sample'. */
  SIG_MESSAGE("v_sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "v_sample");
#define mccompcurname  v_sample
#define mccompcurtype  V_sample
#define mccompcurindex 113
#define VarsV mccv_sample_VarsV
{   /* Declarations of v_sample=V_sample() SETTING parameters. */
MCNUM radius = mccv_sample_radius;
MCNUM thickness = mccv_sample_thickness;
MCNUM zdepth = mccv_sample_zdepth;
MCNUM Vc = mccv_sample_Vc;
MCNUM sigma_abs = mccv_sample_sigma_abs;
MCNUM sigma_inc = mccv_sample_sigma_inc;
MCNUM radius_i = mccv_sample_radius_i;
MCNUM radius_o = mccv_sample_radius_o;
MCNUM h = mccv_sample_h;
MCNUM focus_r = mccv_sample_focus_r;
MCNUM pack = mccv_sample_pack;
MCNUM frac = mccv_sample_frac;
MCNUM f_QE = mccv_sample_f_QE;
MCNUM gamma = mccv_sample_gamma;
MCNUM target_x = mccv_sample_target_x;
MCNUM target_y = mccv_sample_target_y;
MCNUM target_z = mccv_sample_target_z;
MCNUM focus_xw = mccv_sample_focus_xw;
MCNUM focus_yh = mccv_sample_focus_yh;
MCNUM focus_aw = mccv_sample_focus_aw;
MCNUM focus_ah = mccv_sample_focus_ah;
MCNUM xwidth = mccv_sample_xwidth;
MCNUM yheight = mccv_sample_yheight;
MCNUM zthick = mccv_sample_zthick;
MCNUM rad_sphere = mccv_sample_rad_sphere;
MCNUM sig_a = mccv_sample_sig_a;
MCNUM sig_i = mccv_sample_sig_i;
MCNUM V0 = mccv_sample_V0;
int target_index = mccv_sample_target_index;
MCNUM multiples = mccv_sample_multiples;
#line 320 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\obsolete\\V_sample.comp"
{
  magnify("xyz");
  if (VarsV.shapetyp == 0) {
    circle("xz", 0,  h/2.0, 0, radius_i);
    circle("xz", 0,  h/2.0, 0, radius_o);
    circle("xz", 0, -h/2.0, 0, radius_i);
    circle("xz", 0, -h/2.0, 0, radius_o);
    line(-radius_i, -h/2.0, 0, -radius_i, +h/2.0, 0);
    line(+radius_i, -h/2.0, 0, +radius_i, +h/2.0, 0);
    line(0, -h/2.0, -radius_i, 0, +h/2.0, -radius_i);
    line(0, -h/2.0, +radius_i, 0, +h/2.0, +radius_i);
    line(-radius_o, -h/2.0, 0, -radius_o, +h/2.0, 0);
    line(+radius_o, -h/2.0, 0, +radius_o, +h/2.0, 0);
    line(0, -h/2.0, -radius_o, 0, +h/2.0, -radius_o);
    line(0, -h/2.0, +radius_o, 0, +h/2.0, +radius_o);
  }
  else { 
	if (VarsV.shapetyp == 1) {
      double xmin = -0.5*xwidth;
      double xmax =  0.5*xwidth;
      double ymin = -0.5*yheight;
      double ymax =  0.5*yheight;
      double zmin = -0.5*zthick;
      double zmax =  0.5*zthick;
      multiline(5, xmin, ymin, zmin,
                   xmax, ymin, zmin,
                   xmax, ymax, zmin,
                   xmin, ymax, zmin,
                   xmin, ymin, zmin);
      multiline(5, xmin, ymin, zmax,
                   xmax, ymin, zmax,
                   xmax, ymax, zmax,
                   xmin, ymax, zmax,
                   xmin, ymin, zmax);
      line(xmin, ymin, zmin, xmin, ymin, zmax);
      line(xmax, ymin, zmin, xmax, ymin, zmax);
      line(xmin, ymax, zmin, xmin, ymax, zmax);
      line(xmax, ymax, zmin, xmax, ymax, zmax);
    }
    else {
      circle("xy", 0,  0.0, 0, rad_sphere);
      circle("xz", 0,  0.0, 0, rad_sphere);
      circle("yz", 0,  0.0, 0, rad_sphere);        
    }
  }
}
#line 86877 "BIFROST.c"
}   /* End of v_sample=V_sample() SETTING parameter declarations. */
#undef VarsV
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Mono_Cradle'. */
  SIG_MESSAGE("Mono_Cradle (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Mono_Cradle");
#define mccompcurname  Mono_Cradle
#define mccompcurtype  Arm
#define mccompcurindex 114
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 86898 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'XY_ARM'. */
  SIG_MESSAGE("XY_ARM (McDisplay)");
  printf("MCDISPLAY: component %s\n", "XY_ARM");
#define mccompcurname  XY_ARM
#define mccompcurtype  Arm
#define mccompcurindex 115
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 86917 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator_flat'. */
  SIG_MESSAGE("monochromator_flat (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator_flat");
#define mccompcurname  monochromator_flat
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 116
#define mos_rms_y mccmonochromator_flat_mos_rms_y
#define mos_rms_z mccmonochromator_flat_mos_rms_z
#define mos_rms_max mccmonochromator_flat_mos_rms_max
#define mono_Q mccmonochromator_flat_mono_Q
#define SlabWidth mccmonochromator_flat_SlabWidth
#define SlabHeight mccmonochromator_flat_SlabHeight
#define rTable mccmonochromator_flat_rTable
#define tTable mccmonochromator_flat_tTable
#define row mccmonochromator_flat_row
#define col mccmonochromator_flat_col
#define tiltH mccmonochromator_flat_tiltH
#define tiltV mccmonochromator_flat_tiltV
{   /* Declarations of monochromator_flat=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator_flat_reflect;
char* transmit = mccmonochromator_flat_transmit;
MCNUM zwidth = mccmonochromator_flat_zwidth;
MCNUM yheight = mccmonochromator_flat_yheight;
MCNUM gap = mccmonochromator_flat_gap;
MCNUM NH = mccmonochromator_flat_NH;
MCNUM NV = mccmonochromator_flat_NV;
MCNUM mosaich = mccmonochromator_flat_mosaich;
MCNUM mosaicv = mccmonochromator_flat_mosaicv;
MCNUM r0 = mccmonochromator_flat_r0;
MCNUM t0 = mccmonochromator_flat_t0;
MCNUM Q = mccmonochromator_flat_Q;
MCNUM RV = mccmonochromator_flat_RV;
MCNUM RH = mccmonochromator_flat_RH;
MCNUM DM = mccmonochromator_flat_DM;
MCNUM mosaic = mccmonochromator_flat_mosaic;
MCNUM width = mccmonochromator_flat_width;
MCNUM height = mccmonochromator_flat_height;
MCNUM verbose = mccmonochromator_flat_verbose;
MCNUM order = mccmonochromator_flat_order;
#line 464 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int ih;

  magnify("xy");
  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 86992 "BIFROST.c"
}   /* End of monochromator_flat=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator2'. */
  SIG_MESSAGE("monochromator2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator2");
#define mccompcurname  monochromator2
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 117
#define mos_rms_y mccmonochromator2_mos_rms_y
#define mos_rms_z mccmonochromator2_mos_rms_z
#define mos_rms_max mccmonochromator2_mos_rms_max
#define mono_Q mccmonochromator2_mono_Q
#define SlabWidth mccmonochromator2_SlabWidth
#define SlabHeight mccmonochromator2_SlabHeight
#define rTable mccmonochromator2_rTable
#define tTable mccmonochromator2_tTable
#define row mccmonochromator2_row
#define col mccmonochromator2_col
#define tiltH mccmonochromator2_tiltH
#define tiltV mccmonochromator2_tiltV
{   /* Declarations of monochromator2=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator2_reflect;
char* transmit = mccmonochromator2_transmit;
MCNUM zwidth = mccmonochromator2_zwidth;
MCNUM yheight = mccmonochromator2_yheight;
MCNUM gap = mccmonochromator2_gap;
MCNUM NH = mccmonochromator2_NH;
MCNUM NV = mccmonochromator2_NV;
MCNUM mosaich = mccmonochromator2_mosaich;
MCNUM mosaicv = mccmonochromator2_mosaicv;
MCNUM r0 = mccmonochromator2_r0;
MCNUM t0 = mccmonochromator2_t0;
MCNUM Q = mccmonochromator2_Q;
MCNUM RV = mccmonochromator2_RV;
MCNUM RH = mccmonochromator2_RH;
MCNUM DM = mccmonochromator2_DM;
MCNUM mosaic = mccmonochromator2_mosaic;
MCNUM width = mccmonochromator2_width;
MCNUM height = mccmonochromator2_height;
MCNUM verbose = mccmonochromator2_verbose;
MCNUM order = mccmonochromator2_order;
#line 464 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int ih;

  magnify("xy");
  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 87080 "BIFROST.c"
}   /* End of monochromator2=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator3'. */
  SIG_MESSAGE("monochromator3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator3");
#define mccompcurname  monochromator3
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 118
#define mos_rms_y mccmonochromator3_mos_rms_y
#define mos_rms_z mccmonochromator3_mos_rms_z
#define mos_rms_max mccmonochromator3_mos_rms_max
#define mono_Q mccmonochromator3_mono_Q
#define SlabWidth mccmonochromator3_SlabWidth
#define SlabHeight mccmonochromator3_SlabHeight
#define rTable mccmonochromator3_rTable
#define tTable mccmonochromator3_tTable
#define row mccmonochromator3_row
#define col mccmonochromator3_col
#define tiltH mccmonochromator3_tiltH
#define tiltV mccmonochromator3_tiltV
{   /* Declarations of monochromator3=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator3_reflect;
char* transmit = mccmonochromator3_transmit;
MCNUM zwidth = mccmonochromator3_zwidth;
MCNUM yheight = mccmonochromator3_yheight;
MCNUM gap = mccmonochromator3_gap;
MCNUM NH = mccmonochromator3_NH;
MCNUM NV = mccmonochromator3_NV;
MCNUM mosaich = mccmonochromator3_mosaich;
MCNUM mosaicv = mccmonochromator3_mosaicv;
MCNUM r0 = mccmonochromator3_r0;
MCNUM t0 = mccmonochromator3_t0;
MCNUM Q = mccmonochromator3_Q;
MCNUM RV = mccmonochromator3_RV;
MCNUM RH = mccmonochromator3_RH;
MCNUM DM = mccmonochromator3_DM;
MCNUM mosaic = mccmonochromator3_mosaic;
MCNUM width = mccmonochromator3_width;
MCNUM height = mccmonochromator3_height;
MCNUM verbose = mccmonochromator3_verbose;
MCNUM order = mccmonochromator3_order;
#line 464 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int ih;

  magnify("xy");
  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 87168 "BIFROST.c"
}   /* End of monochromator3=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator4'. */
  SIG_MESSAGE("monochromator4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator4");
#define mccompcurname  monochromator4
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 119
#define mos_rms_y mccmonochromator4_mos_rms_y
#define mos_rms_z mccmonochromator4_mos_rms_z
#define mos_rms_max mccmonochromator4_mos_rms_max
#define mono_Q mccmonochromator4_mono_Q
#define SlabWidth mccmonochromator4_SlabWidth
#define SlabHeight mccmonochromator4_SlabHeight
#define rTable mccmonochromator4_rTable
#define tTable mccmonochromator4_tTable
#define row mccmonochromator4_row
#define col mccmonochromator4_col
#define tiltH mccmonochromator4_tiltH
#define tiltV mccmonochromator4_tiltV
{   /* Declarations of monochromator4=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator4_reflect;
char* transmit = mccmonochromator4_transmit;
MCNUM zwidth = mccmonochromator4_zwidth;
MCNUM yheight = mccmonochromator4_yheight;
MCNUM gap = mccmonochromator4_gap;
MCNUM NH = mccmonochromator4_NH;
MCNUM NV = mccmonochromator4_NV;
MCNUM mosaich = mccmonochromator4_mosaich;
MCNUM mosaicv = mccmonochromator4_mosaicv;
MCNUM r0 = mccmonochromator4_r0;
MCNUM t0 = mccmonochromator4_t0;
MCNUM Q = mccmonochromator4_Q;
MCNUM RV = mccmonochromator4_RV;
MCNUM RH = mccmonochromator4_RH;
MCNUM DM = mccmonochromator4_DM;
MCNUM mosaic = mccmonochromator4_mosaic;
MCNUM width = mccmonochromator4_width;
MCNUM height = mccmonochromator4_height;
MCNUM verbose = mccmonochromator4_verbose;
MCNUM order = mccmonochromator4_order;
#line 464 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int ih;

  magnify("xy");
  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 87256 "BIFROST.c"
}   /* End of monochromator4=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator5'. */
  SIG_MESSAGE("monochromator5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator5");
#define mccompcurname  monochromator5
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 120
#define mos_rms_y mccmonochromator5_mos_rms_y
#define mos_rms_z mccmonochromator5_mos_rms_z
#define mos_rms_max mccmonochromator5_mos_rms_max
#define mono_Q mccmonochromator5_mono_Q
#define SlabWidth mccmonochromator5_SlabWidth
#define SlabHeight mccmonochromator5_SlabHeight
#define rTable mccmonochromator5_rTable
#define tTable mccmonochromator5_tTable
#define row mccmonochromator5_row
#define col mccmonochromator5_col
#define tiltH mccmonochromator5_tiltH
#define tiltV mccmonochromator5_tiltV
{   /* Declarations of monochromator5=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator5_reflect;
char* transmit = mccmonochromator5_transmit;
MCNUM zwidth = mccmonochromator5_zwidth;
MCNUM yheight = mccmonochromator5_yheight;
MCNUM gap = mccmonochromator5_gap;
MCNUM NH = mccmonochromator5_NH;
MCNUM NV = mccmonochromator5_NV;
MCNUM mosaich = mccmonochromator5_mosaich;
MCNUM mosaicv = mccmonochromator5_mosaicv;
MCNUM r0 = mccmonochromator5_r0;
MCNUM t0 = mccmonochromator5_t0;
MCNUM Q = mccmonochromator5_Q;
MCNUM RV = mccmonochromator5_RV;
MCNUM RH = mccmonochromator5_RH;
MCNUM DM = mccmonochromator5_DM;
MCNUM mosaic = mccmonochromator5_mosaic;
MCNUM width = mccmonochromator5_width;
MCNUM height = mccmonochromator5_height;
MCNUM verbose = mccmonochromator5_verbose;
MCNUM order = mccmonochromator5_order;
#line 464 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int ih;

  magnify("xy");
  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 87344 "BIFROST.c"
}   /* End of monochromator5=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator6'. */
  SIG_MESSAGE("monochromator6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator6");
#define mccompcurname  monochromator6
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 121
#define mos_rms_y mccmonochromator6_mos_rms_y
#define mos_rms_z mccmonochromator6_mos_rms_z
#define mos_rms_max mccmonochromator6_mos_rms_max
#define mono_Q mccmonochromator6_mono_Q
#define SlabWidth mccmonochromator6_SlabWidth
#define SlabHeight mccmonochromator6_SlabHeight
#define rTable mccmonochromator6_rTable
#define tTable mccmonochromator6_tTable
#define row mccmonochromator6_row
#define col mccmonochromator6_col
#define tiltH mccmonochromator6_tiltH
#define tiltV mccmonochromator6_tiltV
{   /* Declarations of monochromator6=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator6_reflect;
char* transmit = mccmonochromator6_transmit;
MCNUM zwidth = mccmonochromator6_zwidth;
MCNUM yheight = mccmonochromator6_yheight;
MCNUM gap = mccmonochromator6_gap;
MCNUM NH = mccmonochromator6_NH;
MCNUM NV = mccmonochromator6_NV;
MCNUM mosaich = mccmonochromator6_mosaich;
MCNUM mosaicv = mccmonochromator6_mosaicv;
MCNUM r0 = mccmonochromator6_r0;
MCNUM t0 = mccmonochromator6_t0;
MCNUM Q = mccmonochromator6_Q;
MCNUM RV = mccmonochromator6_RV;
MCNUM RH = mccmonochromator6_RH;
MCNUM DM = mccmonochromator6_DM;
MCNUM mosaic = mccmonochromator6_mosaic;
MCNUM width = mccmonochromator6_width;
MCNUM height = mccmonochromator6_height;
MCNUM verbose = mccmonochromator6_verbose;
MCNUM order = mccmonochromator6_order;
#line 464 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int ih;

  magnify("xy");
  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 87432 "BIFROST.c"
}   /* End of monochromator6=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'monochromator7'. */
  SIG_MESSAGE("monochromator7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "monochromator7");
#define mccompcurname  monochromator7
#define mccompcurtype  Monochromator_curved
#define mccompcurindex 122
#define mos_rms_y mccmonochromator7_mos_rms_y
#define mos_rms_z mccmonochromator7_mos_rms_z
#define mos_rms_max mccmonochromator7_mos_rms_max
#define mono_Q mccmonochromator7_mono_Q
#define SlabWidth mccmonochromator7_SlabWidth
#define SlabHeight mccmonochromator7_SlabHeight
#define rTable mccmonochromator7_rTable
#define tTable mccmonochromator7_tTable
#define row mccmonochromator7_row
#define col mccmonochromator7_col
#define tiltH mccmonochromator7_tiltH
#define tiltV mccmonochromator7_tiltV
{   /* Declarations of monochromator7=Monochromator_curved() SETTING parameters. */
char* reflect = mccmonochromator7_reflect;
char* transmit = mccmonochromator7_transmit;
MCNUM zwidth = mccmonochromator7_zwidth;
MCNUM yheight = mccmonochromator7_yheight;
MCNUM gap = mccmonochromator7_gap;
MCNUM NH = mccmonochromator7_NH;
MCNUM NV = mccmonochromator7_NV;
MCNUM mosaich = mccmonochromator7_mosaich;
MCNUM mosaicv = mccmonochromator7_mosaicv;
MCNUM r0 = mccmonochromator7_r0;
MCNUM t0 = mccmonochromator7_t0;
MCNUM Q = mccmonochromator7_Q;
MCNUM RV = mccmonochromator7_RV;
MCNUM RH = mccmonochromator7_RH;
MCNUM DM = mccmonochromator7_DM;
MCNUM mosaic = mccmonochromator7_mosaic;
MCNUM width = mccmonochromator7_width;
MCNUM height = mccmonochromator7_height;
MCNUM verbose = mccmonochromator7_verbose;
MCNUM order = mccmonochromator7_order;
#line 464 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Monochromator_curved.comp"
{
  int ih;

  magnify("xy");
  for(ih = 0; ih < NH; ih++)
  {
    int iv;
    for(iv = 0; iv < NV; iv++)
    {
      double zmin,zmax,ymin,ymax;
      double xt, yt;

      zmin = (SlabWidth+gap)*(ih-NH/2.0)+gap/2;
      zmax = zmin+SlabWidth;
      ymin = (SlabHeight+gap)*(iv-NV/2.0)+gap/2;
      ymax = ymin+SlabHeight;

      if (RH) xt = -(zmax*zmax - zmin*zmin)/RH/2;
      else    xt = 0;

      if (RV) yt = -(ymax*ymax - ymin*ymin)/RV/2;
      else    yt = 0;
      multiline(5, xt+yt, (double)ymin, (double)zmin,
                   xt-yt, (double)ymax, (double)zmin,
                  -xt-yt, (double)ymax, (double)zmax,
                  -xt+yt, (double)ymin, (double)zmax,
                   xt+yt, (double)ymin, (double)zmin);
     }
   }
}
#line 87520 "BIFROST.c"
}   /* End of monochromator7=Monochromator_curved() SETTING parameter declarations. */
#undef tiltV
#undef tiltH
#undef col
#undef row
#undef tTable
#undef rTable
#undef SlabHeight
#undef SlabWidth
#undef mono_Q
#undef mos_rms_max
#undef mos_rms_z
#undef mos_rms_y
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Mono_Out'. */
  SIG_MESSAGE("Mono_Out (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Mono_Out");
#define mccompcurname  Mono_Out
#define mccompcurtype  Arm
#define mccompcurindex 123
#line 40 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\optics\\Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 87552 "BIFROST.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'psd_monitor'. */
  SIG_MESSAGE("psd_monitor (McDisplay)");
  printf("MCDISPLAY: component %s\n", "psd_monitor");
#define mccompcurname  psd_monitor
#define mccompcurtype  PSD_monitor
#define mccompcurindex 124
#define nx mccpsd_monitor_nx
#define ny mccpsd_monitor_ny
#define PSD_N mccpsd_monitor_PSD_N
#define PSD_p mccpsd_monitor_PSD_p
#define PSD_p2 mccpsd_monitor_PSD_p2
{   /* Declarations of psd_monitor=PSD_monitor() SETTING parameters. */
char* filename = mccpsd_monitor_filename;
MCNUM xmin = mccpsd_monitor_xmin;
MCNUM xmax = mccpsd_monitor_xmax;
MCNUM ymin = mccpsd_monitor_ymin;
MCNUM ymax = mccpsd_monitor_ymax;
MCNUM xwidth = mccpsd_monitor_xwidth;
MCNUM yheight = mccpsd_monitor_yheight;
MCNUM restore_neutron = mccpsd_monitor_restore_neutron;
#line 112 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\PSD_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87586 "BIFROST.c"
}   /* End of psd_monitor=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef ny
#undef nx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'e_monitor'. */
  SIG_MESSAGE("e_monitor (McDisplay)");
  printf("MCDISPLAY: component %s\n", "e_monitor");
#define mccompcurname  e_monitor
#define mccompcurtype  E_monitor
#define mccompcurindex 125
#define nE mcce_monitor_nE
#define E_N mcce_monitor_E_N
#define E_p mcce_monitor_E_p
#define E_p2 mcce_monitor_E_p2
#define S_p mcce_monitor_S_p
#define S_pE mcce_monitor_S_pE
#define S_pE2 mcce_monitor_S_pE2
{   /* Declarations of e_monitor=E_monitor() SETTING parameters. */
char* filename = mcce_monitor_filename;
MCNUM xmin = mcce_monitor_xmin;
MCNUM xmax = mcce_monitor_xmax;
MCNUM ymin = mcce_monitor_ymin;
MCNUM ymax = mcce_monitor_ymax;
MCNUM xwidth = mcce_monitor_xwidth;
MCNUM yheight = mcce_monitor_yheight;
MCNUM Emin = mcce_monitor_Emin;
MCNUM Emax = mcce_monitor_Emax;
MCNUM restore_neutron = mcce_monitor_restore_neutron;
#line 129 "C:\\mcstas-2.4.1\\lib\\tools\\Python\\mcrun\\..\\mccodelib\\..\\..\\..\\monitors\\E_monitor.comp"
{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87630 "BIFROST.c"
}   /* End of e_monitor=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  printf("MCDISPLAY: end\n");
} /* end display */
#undef magnify
#undef line
#undef dashed_line
#undef multiline
#undef rectangle
#undef box
#undef circle
/* end of generated C code BIFROST.c */
